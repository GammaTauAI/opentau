{"name":"arrify","size":305,"content":"function arrify(value) {\n\tif (value === null || value === undefined) {\n\t\treturn [];\n\t}\n\n\tif (Array.isArray(value)) {\n\t\treturn value;\n\t}\n\n\tif (typeof value === 'string') {\n\t\treturn [value];\n\t}\n\n\tif (typeof value[Symbol.iterator] === 'function') {\n\t\treturn [...value];\n\t}\n\n\treturn [value];\n}\n","loc":20,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":100}
{"name":"astral-regex","size":201,"content":"'use strict';\nconst regex = '[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]';\n\nconst astralRegex = options => options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, 'g');\n\n\n","loc":7,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":62}
{"name":"camelcase","size":3214,"content":"const UPPERCASE = \/[\\p{Lu}]\/u;\nconst LOWERCASE = \/[\\p{Ll}]\/u;\nconst LEADING_CAPITAL = \/^[\\p{Lu}](?![\\p{Lu}])\/gu;\nconst IDENTIFIER = \/([\\p{Alpha}\\p{N}_]|$)\/u;\nconst SEPARATORS = \/[_.\\- ]+\/;\n\nconst LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);\nconst SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');\nconst NUMBERS_AND_IDENTIFIER = new RegExp('\\\\d+' + IDENTIFIER.source, 'gu');\n\nconst preserveCamelCase = (string, toLowerCase, toUpperCase) => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\n\tfor (let index = 0; index < string.length; index++) {\n\t\tconst character = string[index];\n\n\t\tif (isLastCharLower && UPPERCASE.test(character)) {\n\t\t\tstring = string.slice(0, index) + '-' + string.slice(index);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\tindex++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {\n\t\t\tstring = string.slice(0, index - 1) + '-' + string.slice(index - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst preserveConsecutiveUppercase = (input, toLowerCase) => {\n\tLEADING_CAPITAL.lastIndex = 0;\n\n\treturn input.replace(LEADING_CAPITAL, m1 => toLowerCase(m1));\n};\n\nconst postProcess = (input, toUpperCase) => {\n\tSEPARATORS_AND_IDENTIFIER.lastIndex = 0;\n\tNUMBERS_AND_IDENTIFIER.lastIndex = 0;\n\n\treturn input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier))\n\t\t.replace(NUMBERS_AND_IDENTIFIER, m => toUpperCase(m));\n};\n\nfunction camelCase(input, options) {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = {\n\t\tpascalCase: false,\n\t\tpreserveConsecutiveUppercase: false,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tconst toLowerCase = options.locale === false\n\t\t? string => string.toLowerCase()\n\t\t: string => string.toLocaleLowerCase(options.locale);\n\n\tconst toUpperCase = options.locale === false\n\t\t? string => string.toUpperCase()\n\t\t: string => string.toLocaleUpperCase(options.locale);\n\n\tif (input.length === 1) {\n\t\tif (SEPARATORS.test(input)) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn options.pascalCase ? toUpperCase(input) : toLowerCase(input);\n\t}\n\n\tconst hasUpperCase = input !== toLowerCase(input);\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input, toLowerCase, toUpperCase);\n\t}\n\n\tinput = input.replace(LEADING_SEPARATORS, '');\n\tinput = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);\n\n\tif (options.pascalCase) {\n\t\tinput = toUpperCase(input.charAt(0)) + input.slice(1);\n\t}\n\n\treturn postProcess(input, toUpperCase);\n}\n","loc":108,"functions":13,"function_signatures":0,"function_parameters":19,"variable_declarations":19,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":999}
{"name":"decamelize","size":1901,"content":"const handlePreserveConsecutiveUppercase = (decamelized, separator) => {\n\t\/\/ Lowercase all single uppercase characters. As we\n\t\/\/ want to preserve uppercase sequences, we cannot\n\t\/\/ simply lowercase the separated string at the end.\n\t\/\/ `data_For_USACounties` \u2192 `data_for_USACounties`\n\tdecamelized = decamelized.replace(\n\t\t\/((?<![\\p{Uppercase_Letter}\\d])[\\p{Uppercase_Letter}\\d](?![\\p{Uppercase_Letter}\\d]))\/gu,\n\t\t$0 => $0.toLowerCase(),\n\t);\n\n\t\/\/ Remaining uppercase sequences will be separated from lowercase sequences.\n\t\/\/ `data_For_USACounties` \u2192 `data_for_USA_counties`\n\treturn decamelized.replace(\n\t\t\/(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)\/gu,\n\t\t(_, $1, $2) => $1 + separator + $2.toLowerCase(),\n\t);\n};\n\nfunction decamelize(\n\ttext,\n\t{\n\t\tseparator = '_',\n\t\tpreserveConsecutiveUppercase = false,\n\t} = {},\n) {\n\tif (!(typeof text === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError(\n\t\t\t'The `text` and `separator` arguments should be of type `string`',\n\t\t);\n\t}\n\n\t\/\/ Checking the second character is done later on. Therefore process shorter strings here.\n\tif (text.length < 2) {\n\t\treturn preserveConsecutiveUppercase ? text : text.toLowerCase();\n\t}\n\n\tconst replacement = `$1${separator}$2`;\n\n\t\/\/ Split lowercase sequences followed by uppercase character.\n\t\/\/ `dataForUSACounties` \u2192 `data_For_USACounties`\n\t\/\/ `myURLstring \u2192 `my_URLstring`\n\tconst decamelized = text.replace(\n\t\t\/([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})\/gu,\n\t\treplacement,\n\t);\n\n\tif (preserveConsecutiveUppercase) {\n\t\treturn handlePreserveConsecutiveUppercase(decamelized, separator);\n\t}\n\n\t\/\/ Split multiple uppercase characters followed by one or more lowercase characters.\n\t\/\/ `my_URLstring` \u2192 `my_ur_lstring`\n\treturn decamelized\n\t\t.replace(\n\t\t\t\/(\\p{Uppercase_Letter})(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)\/gu,\n\t\t\treplacement,\n\t\t)\n\t\t.toLowerCase();\n}\n","loc":60,"functions":4,"function_signatures":0,"function_parameters":8,"variable_declarations":3,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":598}
{"name":"define-lazy-prop","size":429,"content":"function defineLazyProperty(object, propertyName, valueGetter) {\n\tconst define = value => Object.defineProperty(object, propertyName, {value, enumerable: true, writable: true});\n\n\tObject.defineProperty(object, propertyName, {\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\tget() {\n\t\t\tconst result = valueGetter();\n\t\t\tdefine(result);\n\t\t\treturn result;\n\t\t},\n\t\tset(value) {\n\t\t\tdefine(value);\n\t\t}\n\t});\n\n\treturn object;\n}\n","loc":19,"functions":4,"function_signatures":0,"function_parameters":5,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":116}
{"name":"detect-newline","size":485,"content":"function detectNewline(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tconst newlines = string.match(\/(?:\\r?\\n)\/g) || [];\n\n\tif (newlines.length === 0) {\n\t\treturn;\n\t}\n\n\tconst crlf = newlines.filter(newline => newline === '\\r\\n').length;\n\tconst lf = newlines.length - crlf;\n\n\treturn crlf > lf ? '\\r\\n' : '\\n';\n}\n\nfunction detectNewlineGraceful(string) {\n\treturn (typeof string === 'string' && detectNewline(string)) || '\\n';\n}\n","loc":21,"functions":3,"function_signatures":0,"function_parameters":3,"variable_declarations":3,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":157}
{"name":"ee-first","size":1702,"content":"\/*!\n * ee-first\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n *\/\n\n'use strict'\n\n\/**\n * Module exports.\n * @public\n *\/\n\n\n\n\/**\n * Get the first event in a set of event emitters and event pairs.\n *\n * @param {array} stuff\n * @param {function} done\n * @public\n *\/\n\nfunction first (stuff, done) {\n  if (!Array.isArray(stuff)) {\n    throw new TypeError('arg must be an array of [ee, events...] arrays')\n  }\n\n  var cleanups = []\n\n  for (var i = 0; i < stuff.length; i++) {\n    var arr = stuff[i]\n\n    if (!Array.isArray(arr) || arr.length < 2) {\n      throw new TypeError('each array member must be [ee, events...]')\n    }\n\n    var ee = arr[0]\n\n    for (var j = 1; j < arr.length; j++) {\n      var event = arr[j]\n      var fn = listener(event, callback)\n\n      \/\/ listen to the event\n      ee.on(event, fn)\n      \/\/ push this listener to the list of cleanups\n      cleanups.push({\n        ee: ee,\n        event: event,\n        fn: fn\n      })\n    }\n  }\n\n  function callback () {\n    cleanup()\n    done.apply(null, arguments)\n  }\n\n  function cleanup () {\n    var x\n    for (var i = 0; i < cleanups.length; i++) {\n      x = cleanups[i]\n      x.ee.removeListener(x.event, x.fn)\n    }\n  }\n\n  function thunk (fn) {\n    done = fn\n  }\n\n  thunk.cancel = cleanup\n\n  return thunk\n}\n\n\/**\n * Create the event listener.\n * @private\n *\/\n\nfunction listener (event, done) {\n  return function onevent (arg1) {\n    var args = new Array(arguments.length)\n    var ee = this\n    var err = event === 'error'\n      ? arg1\n      : null\n\n    \/\/ copy args to prevent arguments escaping scope\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    done(err, ee, event, args)\n  }\n}\n","loc":98,"functions":6,"function_signatures":0,"function_parameters":6,"variable_declarations":13,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":516}
{"name":"encodeurl","size":1585,"content":"\/*!\n * encodeurl\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n *\/\n\n'use strict'\n\n\/**\n * Module exports.\n * @public\n *\/\n\n\n\n\/**\n * RegExp to match non-URL code points, *after* encoding (i.e. not including \"%\")\n * and including invalid escape sequences.\n * @private\n *\/\n\nvar ENCODE_CHARS_REGEXP = \/(?:[^\\x21\\x25\\x26-\\x3B\\x3D\\x3F-\\x5B\\x5D\\x5F\\x61-\\x7A\\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+\/g\n\n\/**\n * RegExp to match unmatched surrogate pair.\n * @private\n *\/\n\nvar UNMATCHED_SURROGATE_PAIR_REGEXP = \/(^|[^\\uD800-\\uDBFF])[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF]([^\\uDC00-\\uDFFF]|$)\/g\n\n\/**\n * String to replace unmatched surrogate pair with.\n * @private\n *\/\n\nvar UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\\uFFFD$2'\n\n\/**\n * Encode a URL to a percent-encoded form, excluding already-encoded sequences.\n *\n * This function will take an already-encoded URL and encode all the non-URL\n * code points. This function will not encode the \"%\" character unless it is\n * not part of a valid sequence (`%20` will be left as-is, but `%foo` will\n * be encoded as `%25foo`).\n *\n * This encode is meant to be \"safe\" and does not throw errors. It will try as\n * hard as it can to properly encode the given URL, including replacing any raw,\n * unpaired surrogate pairs with the Unicode replacement character prior to\n * encoding.\n *\n * @param {string} url\n * @return {string}\n * @public\n *\/\n\nfunction encodeUrl (url) {\n  return String(url)\n    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)\n    .replace(ENCODE_CHARS_REGEXP, encodeURI)\n}\n","loc":61,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":3,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":539}
{"name":"escape-string-regexp","size":469,"content":"function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t\/\/ Escape characters with special meaning either inside or outside character sets.\n\t\/\/ Use a simple backslash escape when it\u2019s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns\u2019 stricter grammar.\n\treturn string\n\t\t.replace(\/[|\\\\{}()[\\]^$+*?.]\/g, '\\\\$&')\n\t\t.replace(\/-\/g, '\\\\x2d');\n}\n","loc":12,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":130}
{"name":"function-bind","size":1551,"content":"'use strict';\n\n\/* eslint no-invalid-this: 1 *\/\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nfunction bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            args.concat(slice.call(arguments))\n        );\n\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n'use strict';\n\n\n\n\n","loc":59,"functions":3,"function_signatures":0,"function_parameters":1,"variable_declarations":13,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":358}
{"name":"functional-red-black-tree","size":22323,"content":"\"use strict\"\n\n\n\nvar RED   = 0\nvar BLACK = 1\n\nfunction RBNode(color, key, value, left, right, count) {\n  this._color = color\n  this.key = key\n  this.value = value\n  this.left = left\n  this.right = right\n  this._count = count\n}\n\nfunction cloneNode(node) {\n  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)\n}\n\nfunction repaint(color, node) {\n  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)\n}\n\nfunction recount(node) {\n  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)\n}\n\nfunction RedBlackTree(compare, root) {\n  this._compare = compare\n  this.root = root\n}\n\nvar proto = RedBlackTree.prototype\n\nObject.defineProperty(proto, \"keys\", {\n  get: function() {\n    var result = []\n    this.forEach(function(k,v) {\n      result.push(k)\n    })\n    return result\n  }\n})\n\nObject.defineProperty(proto, \"values\", {\n  get: function() {\n    var result = []\n    this.forEach(function(k,v) {\n      result.push(v)\n    })\n    return result\n  }\n})\n\n\/\/Returns the number of nodes in the tree\nObject.defineProperty(proto, \"length\", {\n  get: function() {\n    if(this.root) {\n      return this.root._count\n    }\n    return 0\n  }\n})\n\n\/\/Insert a new item into the tree\nproto.insert = function(key, value) {\n  var cmp = this._compare\n  \/\/Find point to insert new node at\n  var n = this.root\n  var n_stack = []\n  var d_stack = []\n  while(n) {\n    var d = cmp(key, n.key)\n    n_stack.push(n)\n    d_stack.push(d)\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  \/\/Rebuild path to leaf node\n  n_stack.push(new RBNode(RED, key, value, null, null, 1))\n  for(var s=n_stack.length-2; s>=0; --s) {\n    var n = n_stack[s]\n    if(d_stack[s] <= 0) {\n      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)\n    } else {\n      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)\n    }\n  }\n  \/\/Rebalance tree using rotations\n  \/\/console.log(\"start insert\", key, d_stack)\n  for(var s=n_stack.length-1; s>1; --s) {\n    var p = n_stack[s-1]\n    var n = n_stack[s]\n    if(p._color === BLACK || n._color === BLACK) {\n      break\n    }\n    var pp = n_stack[s-2]\n    if(pp.left === p) {\n      if(p.left === n) {\n        var y = pp.right\n        if(y && y._color === RED) {\n          \/\/console.log(\"LLr\")\n          p._color = BLACK\n          pp.right = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          \/\/console.log(\"LLb\")\n          pp._color = RED\n          pp.left = p.right\n          p._color = BLACK\n          p.right = pp\n          n_stack[s-2] = p\n          n_stack[s-1] = n\n          recount(pp)\n          recount(p)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.left === pp) {\n              ppp.left = p\n            } else {\n              ppp.right = p\n            }\n          }\n          break\n        }\n      } else {\n        var y = pp.right\n        if(y && y._color === RED) {\n          \/\/console.log(\"LRr\")\n          p._color = BLACK\n          pp.right = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          \/\/console.log(\"LRb\")\n          p.right = n.left\n          pp._color = RED\n          pp.left = n.right\n          n._color = BLACK\n          n.left = p\n          n.right = pp\n          n_stack[s-2] = n\n          n_stack[s-1] = p\n          recount(pp)\n          recount(p)\n          recount(n)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.left === pp) {\n              ppp.left = n\n            } else {\n              ppp.right = n\n            }\n          }\n          break\n        }\n      }\n    } else {\n      if(p.right === n) {\n        var y = pp.left\n        if(y && y._color === RED) {\n          \/\/console.log(\"RRr\", y.key)\n          p._color = BLACK\n          pp.left = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          \/\/console.log(\"RRb\")\n          pp._color = RED\n          pp.right = p.left\n          p._color = BLACK\n          p.left = pp\n          n_stack[s-2] = p\n          n_stack[s-1] = n\n          recount(pp)\n          recount(p)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.right === pp) {\n              ppp.right = p\n            } else {\n              ppp.left = p\n            }\n          }\n          break\n        }\n      } else {\n        var y = pp.left\n        if(y && y._color === RED) {\n          \/\/console.log(\"RLr\")\n          p._color = BLACK\n          pp.left = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          \/\/console.log(\"RLb\")\n          p.left = n.right\n          pp._color = RED\n          pp.right = n.left\n          n._color = BLACK\n          n.right = p\n          n.left = pp\n          n_stack[s-2] = n\n          n_stack[s-1] = p\n          recount(pp)\n          recount(p)\n          recount(n)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.right === pp) {\n              ppp.right = n\n            } else {\n              ppp.left = n\n            }\n          }\n          break\n        }\n      }\n    }\n  }\n  \/\/Return new tree\n  n_stack[0]._color = BLACK\n  return new RedBlackTree(cmp, n_stack[0])\n}\n\n\n\/\/Visit all nodes inorder\nfunction doVisitFull(visit, node) {\n  if(node.left) {\n    var v = doVisitFull(visit, node.left)\n    if(v) { return v }\n  }\n  var v = visit(node.key, node.value)\n  if(v) { return v }\n  if(node.right) {\n    return doVisitFull(visit, node.right)\n  }\n}\n\n\/\/Visit half nodes in order\nfunction doVisitHalf(lo, compare, visit, node) {\n  var l = compare(lo, node.key)\n  if(l <= 0) {\n    if(node.left) {\n      var v = doVisitHalf(lo, compare, visit, node.left)\n      if(v) { return v }\n    }\n    var v = visit(node.key, node.value)\n    if(v) { return v }\n  }\n  if(node.right) {\n    return doVisitHalf(lo, compare, visit, node.right)\n  }\n}\n\n\/\/Visit all nodes within a range\nfunction doVisit(lo, hi, compare, visit, node) {\n  var l = compare(lo, node.key)\n  var h = compare(hi, node.key)\n  var v\n  if(l <= 0) {\n    if(node.left) {\n      v = doVisit(lo, hi, compare, visit, node.left)\n      if(v) { return v }\n    }\n    if(h > 0) {\n      v = visit(node.key, node.value)\n      if(v) { return v }\n    }\n  }\n  if(h > 0 && node.right) {\n    return doVisit(lo, hi, compare, visit, node.right)\n  }\n}\n\n\nproto.forEach = function rbTreeForEach(visit, lo, hi) {\n  if(!this.root) {\n    return\n  }\n  switch(arguments.length) {\n    case 1:\n      return doVisitFull(visit, this.root)\n    break\n\n    case 2:\n      return doVisitHalf(lo, this._compare, visit, this.root)\n    break\n\n    case 3:\n      if(this._compare(lo, hi) >= 0) {\n        return\n      }\n      return doVisit(lo, hi, this._compare, visit, this.root)\n    break\n  }\n}\n\n\/\/First item in list\nObject.defineProperty(proto, \"begin\", {\n  get: function() {\n    var stack = []\n    var n = this.root\n    while(n) {\n      stack.push(n)\n      n = n.left\n    }\n    return new RedBlackTreeIterator(this, stack)\n  }\n})\n\n\/\/Last item in list\nObject.defineProperty(proto, \"end\", {\n  get: function() {\n    var stack = []\n    var n = this.root\n    while(n) {\n      stack.push(n)\n      n = n.right\n    }\n    return new RedBlackTreeIterator(this, stack)\n  }\n})\n\n\/\/Find the ith item in the tree\nproto.at = function(idx) {\n  if(idx < 0) {\n    return new RedBlackTreeIterator(this, [])\n  }\n  var n = this.root\n  var stack = []\n  while(true) {\n    stack.push(n)\n    if(n.left) {\n      if(idx < n.left._count) {\n        n = n.left\n        continue\n      }\n      idx -= n.left._count\n    }\n    if(!idx) {\n      return new RedBlackTreeIterator(this, stack)\n    }\n    idx -= 1\n    if(n.right) {\n      if(idx >= n.right._count) {\n        break\n      }\n      n = n.right\n    } else {\n      break\n    }\n  }\n  return new RedBlackTreeIterator(this, [])\n}\n\nproto.ge = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d <= 0) {\n      last_ptr = stack.length\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.gt = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d < 0) {\n      last_ptr = stack.length\n    }\n    if(d < 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.lt = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d > 0) {\n      last_ptr = stack.length\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.le = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d >= 0) {\n      last_ptr = stack.length\n    }\n    if(d < 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\n\/\/Finds the item with key if it exists\nproto.find = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d === 0) {\n      return new RedBlackTreeIterator(this, stack)\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  return new RedBlackTreeIterator(this, [])\n}\n\n\/\/Removes item with key from tree\nproto.remove = function(key) {\n  var iter = this.find(key)\n  if(iter) {\n    return iter.remove()\n  }\n  return this\n}\n\n\/\/Returns the item at `key`\nproto.get = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  while(n) {\n    var d = cmp(key, n.key)\n    if(d === 0) {\n      return n.value\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  return\n}\n\n\/\/Iterator for red black tree\nfunction RedBlackTreeIterator(tree, stack) {\n  this.tree = tree\n  this._stack = stack\n}\n\nvar iproto = RedBlackTreeIterator.prototype\n\n\/\/Test if iterator is valid\nObject.defineProperty(iproto, \"valid\", {\n  get: function() {\n    return this._stack.length > 0\n  }\n})\n\n\/\/Node of the iterator\nObject.defineProperty(iproto, \"node\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1]\n    }\n    return null\n  },\n  enumerable: true\n})\n\n\/\/Makes a copy of an iterator\niproto.clone = function() {\n  return new RedBlackTreeIterator(this.tree, this._stack.slice())\n}\n\n\/\/Swaps two nodes\nfunction swapNode(n, v) {\n  n.key = v.key\n  n.value = v.value\n  n.left = v.left\n  n.right = v.right\n  n._color = v._color\n  n._count = v._count\n}\n\n\/\/Fix up a double black node in a tree\nfunction fixDoubleBlack(stack) {\n  var n, p, s, z\n  for(var i=stack.length-1; i>=0; --i) {\n    n = stack[i]\n    if(i === 0) {\n      n._color = BLACK\n      return\n    }\n    \/\/console.log(\"visit node:\", n.key, i, stack[i].key, stack[i-1].key)\n    p = stack[i-1]\n    if(p.left === n) {\n      \/\/console.log(\"left child\")\n      s = p.right\n      if(s.right && s.right._color === RED) {\n        \/\/console.log(\"case 1: right sibling child red\")\n        s = p.right = cloneNode(s)\n        z = s.right = cloneNode(s.right)\n        p.right = s.left\n        s.left = p\n        s.right = z\n        s._color = p._color\n        n._color = BLACK\n        p._color = BLACK\n        z._color = BLACK\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = s\n          } else {\n            pp.right = s\n          }\n        }\n        stack[i-1] = s\n        return\n      } else if(s.left && s.left._color === RED) {\n        \/\/console.log(\"case 1: left sibling child red\")\n        s = p.right = cloneNode(s)\n        z = s.left = cloneNode(s.left)\n        p.right = z.left\n        s.left = z.right\n        z.left = p\n        z.right = s\n        z._color = p._color\n        p._color = BLACK\n        s._color = BLACK\n        n._color = BLACK\n        recount(p)\n        recount(s)\n        recount(z)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = z\n          } else {\n            pp.right = z\n          }\n        }\n        stack[i-1] = z\n        return\n      }\n      if(s._color === BLACK) {\n        if(p._color === RED) {\n          \/\/console.log(\"case 2: black sibling, red parent\", p.right.value)\n          p._color = BLACK\n          p.right = repaint(RED, s)\n          return\n        } else {\n          \/\/console.log(\"case 2: black sibling, black parent\", p.right.value)\n          p.right = repaint(RED, s)\n          continue  \n        }\n      } else {\n        \/\/console.log(\"case 3: red sibling\")\n        s = cloneNode(s)\n        p.right = s.left\n        s.left = p\n        s._color = p._color\n        p._color = RED\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = s\n          } else {\n            pp.right = s\n          }\n        }\n        stack[i-1] = s\n        stack[i] = p\n        if(i+1 < stack.length) {\n          stack[i+1] = n\n        } else {\n          stack.push(n)\n        }\n        i = i+2\n      }\n    } else {\n      \/\/console.log(\"right child\")\n      s = p.left\n      if(s.left && s.left._color === RED) {\n        \/\/console.log(\"case 1: left sibling child red\", p.value, p._color)\n        s = p.left = cloneNode(s)\n        z = s.left = cloneNode(s.left)\n        p.left = s.right\n        s.right = p\n        s.left = z\n        s._color = p._color\n        n._color = BLACK\n        p._color = BLACK\n        z._color = BLACK\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = s\n          } else {\n            pp.left = s\n          }\n        }\n        stack[i-1] = s\n        return\n      } else if(s.right && s.right._color === RED) {\n        \/\/console.log(\"case 1: right sibling child red\")\n        s = p.left = cloneNode(s)\n        z = s.right = cloneNode(s.right)\n        p.left = z.right\n        s.right = z.left\n        z.right = p\n        z.left = s\n        z._color = p._color\n        p._color = BLACK\n        s._color = BLACK\n        n._color = BLACK\n        recount(p)\n        recount(s)\n        recount(z)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = z\n          } else {\n            pp.left = z\n          }\n        }\n        stack[i-1] = z\n        return\n      }\n      if(s._color === BLACK) {\n        if(p._color === RED) {\n          \/\/console.log(\"case 2: black sibling, red parent\")\n          p._color = BLACK\n          p.left = repaint(RED, s)\n          return\n        } else {\n          \/\/console.log(\"case 2: black sibling, black parent\")\n          p.left = repaint(RED, s)\n          continue  \n        }\n      } else {\n        \/\/console.log(\"case 3: red sibling\")\n        s = cloneNode(s)\n        p.left = s.right\n        s.right = p\n        s._color = p._color\n        p._color = RED\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = s\n          } else {\n            pp.left = s\n          }\n        }\n        stack[i-1] = s\n        stack[i] = p\n        if(i+1 < stack.length) {\n          stack[i+1] = n\n        } else {\n          stack.push(n)\n        }\n        i = i+2\n      }\n    }\n  }\n}\n\n\/\/Removes item at iterator from tree\niproto.remove = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return this.tree\n  }\n  \/\/First copy path to node\n  var cstack = new Array(stack.length)\n  var n = stack[stack.length-1]\n  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)\n  for(var i=stack.length-2; i>=0; --i) {\n    var n = stack[i]\n    if(n.left === stack[i+1]) {\n      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)\n    } else {\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n  }\n\n  \/\/Get node\n  n = cstack[cstack.length-1]\n  \/\/console.log(\"start remove: \", n.value)\n\n  \/\/If not leaf, then swap with previous node\n  if(n.left && n.right) {\n    \/\/console.log(\"moving to leaf\")\n\n    \/\/First walk to previous leaf\n    var split = cstack.length\n    n = n.left\n    while(n.right) {\n      cstack.push(n)\n      n = n.right\n    }\n    \/\/Copy path to leaf\n    var v = cstack[split-1]\n    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))\n    cstack[split-1].key = n.key\n    cstack[split-1].value = n.value\n\n    \/\/Fix up stack\n    for(var i=cstack.length-2; i>=split; --i) {\n      n = cstack[i]\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n    cstack[split-1].left = cstack[split]\n  }\n  \/\/console.log(\"stack=\", cstack.map(function(v) { return v.value }))\n\n  \/\/Remove leaf node\n  n = cstack[cstack.length-1]\n  if(n._color === RED) {\n    \/\/Easy case: removing red leaf\n    \/\/console.log(\"RED leaf\")\n    var p = cstack[cstack.length-2]\n    if(p.left === n) {\n      p.left = null\n    } else if(p.right === n) {\n      p.right = null\n    }\n    cstack.pop()\n    for(var i=0; i<cstack.length; ++i) {\n      cstack[i]._count--\n    }\n    return new RedBlackTree(this.tree._compare, cstack[0])\n  } else {\n    if(n.left || n.right) {\n      \/\/Second easy case:  Single child black parent\n      \/\/console.log(\"BLACK single child\")\n      if(n.left) {\n        swapNode(n, n.left)\n      } else if(n.right) {\n        swapNode(n, n.right)\n      }\n      \/\/Child must be red, so repaint it black to balance color\n      n._color = BLACK\n      for(var i=0; i<cstack.length-1; ++i) {\n        cstack[i]._count--\n      }\n      return new RedBlackTree(this.tree._compare, cstack[0])\n    } else if(cstack.length === 1) {\n      \/\/Third easy case: root\n      \/\/console.log(\"ROOT\")\n      return new RedBlackTree(this.tree._compare, null)\n    } else {\n      \/\/Hard case: Repaint n, and then do some nasty stuff\n      \/\/console.log(\"BLACK leaf no children\")\n      for(var i=0; i<cstack.length; ++i) {\n        cstack[i]._count--\n      }\n      var parent = cstack[cstack.length-2]\n      fixDoubleBlack(cstack)\n      \/\/Fix up links\n      if(parent.left === n) {\n        parent.left = null\n      } else {\n        parent.right = null\n      }\n    }\n  }\n  return new RedBlackTree(this.tree._compare, cstack[0])\n}\n\n\/\/Returns key\nObject.defineProperty(iproto, \"key\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1].key\n    }\n    return\n  },\n  enumerable: true\n})\n\n\/\/Returns value\nObject.defineProperty(iproto, \"value\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1].value\n    }\n    return\n  },\n  enumerable: true\n})\n\n\n\/\/Returns the position of this iterator in the sorted list\nObject.defineProperty(iproto, \"index\", {\n  get: function() {\n    var idx = 0\n    var stack = this._stack\n    if(stack.length === 0) {\n      var r = this.tree.root\n      if(r) {\n        return r._count\n      }\n      return 0\n    } else if(stack[stack.length-1].left) {\n      idx = stack[stack.length-1].left._count\n    }\n    for(var s=stack.length-2; s>=0; --s) {\n      if(stack[s+1] === stack[s].right) {\n        ++idx\n        if(stack[s].left) {\n          idx += stack[s].left._count\n        }\n      }\n    }\n    return idx\n  },\n  enumerable: true\n})\n\n\/\/Advances iterator to next element in list\niproto.next = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return\n  }\n  var n = stack[stack.length-1]\n  if(n.right) {\n    n = n.right\n    while(n) {\n      stack.push(n)\n      n = n.left\n    }\n  } else {\n    stack.pop()\n    while(stack.length > 0 && stack[stack.length-1].right === n) {\n      n = stack[stack.length-1]\n      stack.pop()\n    }\n  }\n}\n\n\/\/Checks if iterator is at end of tree\nObject.defineProperty(iproto, \"hasNext\", {\n  get: function() {\n    var stack = this._stack\n    if(stack.length === 0) {\n      return false\n    }\n    if(stack[stack.length-1].right) {\n      return true\n    }\n    for(var s=stack.length-1; s>0; --s) {\n      if(stack[s-1].left === stack[s]) {\n        return true\n      }\n    }\n    return false\n  }\n})\n\n\/\/Update value\niproto.update = function(value) {\n  var stack = this._stack\n  if(stack.length === 0) {\n    throw new Error(\"Can't update empty node!\")\n  }\n  var cstack = new Array(stack.length)\n  var n = stack[stack.length-1]\n  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)\n  for(var i=stack.length-2; i>=0; --i) {\n    n = stack[i]\n    if(n.left === stack[i+1]) {\n      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)\n    } else {\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n  }\n  return new RedBlackTree(this.tree._compare, cstack[0])\n}\n\n\/\/Moves iterator backward one element\niproto.prev = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return\n  }\n  var n = stack[stack.length-1]\n  if(n.left) {\n    n = n.left\n    while(n) {\n      stack.push(n)\n      n = n.right\n    }\n  } else {\n    stack.pop()\n    while(stack.length > 0 && stack[stack.length-1].left === n) {\n      n = stack[stack.length-1]\n      stack.pop()\n    }\n  }\n}\n\n\/\/Checks if iterator is at start of tree\nObject.defineProperty(iproto, \"hasPrev\", {\n  get: function() {\n    var stack = this._stack\n    if(stack.length === 0) {\n      return false\n    }\n    if(stack[stack.length-1].left) {\n      return true\n    }\n    for(var s=stack.length-1; s>0; --s) {\n      if(stack[s-1].right === stack[s]) {\n        return true\n      }\n    }\n    return false\n  }\n})\n\n\/\/Default comparison function\nfunction defaultCompare(a, b) {\n  if(a < b) {\n    return -1\n  }\n  if(a > b) {\n    return 1\n  }\n  return 0\n}\n\n\/\/Build a tree\nfunction createRBTree(compare) {\n  return new RedBlackTree(compare || defaultCompare, null)\n}","loc":996,"functions":42,"function_signatures":0,"function_parameters":49,"variable_declarations":107,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":7238}
{"name":"icss-utils","size":4873,"content":"\n\n\n\nconst createImports = (imports, postcss, mode = \"rule\") => {\n  return Object.keys(imports).map((path) => {\n    const aliases = imports[path];\n    const declarations = Object.keys(aliases).map((key) =>\n      postcss.decl({\n        prop: key,\n        value: aliases[key],\n        raws: { before: \"\\n  \" },\n      })\n    );\n\n    const hasDeclarations = declarations.length > 0;\n\n    const rule =\n      mode === \"rule\"\n        ? postcss.rule({\n            selector: `:import('${path}')`,\n            raws: { after: hasDeclarations ? \"\\n\" : \"\" },\n          })\n        : postcss.atRule({\n            name: \"icss-import\",\n            params: `'${path}'`,\n            raws: { after: hasDeclarations ? \"\\n\" : \"\" },\n          });\n\n    if (hasDeclarations) {\n      rule.append(declarations);\n    }\n\n    return rule;\n  });\n};\n\nconst createExports = (exports, postcss, mode = \"rule\") => {\n  const declarations = Object.keys(exports).map((key) =>\n    postcss.decl({\n      prop: key,\n      value: exports[key],\n      raws: { before: \"\\n  \" },\n    })\n  );\n\n  if (declarations.length === 0) {\n    return [];\n  }\n  const rule =\n    mode === \"rule\"\n      ? postcss.rule({\n          selector: `:export`,\n          raws: { after: \"\\n\" },\n        })\n      : postcss.atRule({\n          name: \"icss-export\",\n          raws: { after: \"\\n\" },\n        });\n\n  rule.append(declarations);\n\n  return [rule];\n};\n\nconst createICSSRules = (imports, exports, postcss, mode) => [\n  ...createImports(imports, postcss, mode),\n  ...createExports(exports, postcss, mode),\n];\n\n\n\nconst importPattern = \/^:import\\((\"[^\"]*\"|'[^']*'|[^\"']+)\\)$\/;\nconst balancedQuotes = \/^(\"[^\"]*\"|'[^']*'|[^\"']+)$\/;\n\nconst getDeclsObject = (rule) => {\n  const object = {};\n\n  rule.walkDecls((decl) => {\n    const before = decl.raws.before ? decl.raws.before.trim() : \"\";\n\n    object[before + decl.prop] = decl.value;\n  });\n\n  return object;\n};\n\/**\n *\n * @param {string} css\n * @param {boolean} removeRules\n * @param {'auto' | 'rule' | 'at-rule'} mode\n *\/\nconst extractICSS = (css, removeRules = true, mode = \"auto\") => {\n  const icssImports = {};\n  const icssExports = {};\n\n  function addImports(node, path) {\n    const unquoted = path.replace(\/'|\"\/g, \"\");\n    icssImports[unquoted] = Object.assign(\n      icssImports[unquoted] || {},\n      getDeclsObject(node)\n    );\n\n    if (removeRules) {\n      node.remove();\n    }\n  }\n\n  function addExports(node) {\n    Object.assign(icssExports, getDeclsObject(node));\n    if (removeRules) {\n      node.remove();\n    }\n  }\n\n  css.each((node) => {\n    if (node.type === \"rule\" && mode !== \"at-rule\") {\n      if (node.selector.slice(0, 7) === \":import\") {\n        const matches = importPattern.exec(node.selector);\n\n        if (matches) {\n          addImports(node, matches[1]);\n        }\n      }\n\n      if (node.selector === \":export\") {\n        addExports(node);\n      }\n    }\n\n    if (node.type === \"atrule\" && mode !== \"rule\") {\n      if (node.name === \"icss-import\") {\n        const matches = balancedQuotes.exec(node.params);\n\n        if (matches) {\n          addImports(node, matches[1]);\n        }\n      }\n      if (node.name === \"icss-export\") {\n        addExports(node);\n      }\n    }\n  });\n\n  return { icssImports, icssExports };\n};\n\n\n\n\n\n\n\n\n\n\n\n\nconst replaceSymbols = (css, replacements) => {\n  css.walk((node) => {\n    if (node.type === \"decl\" && node.value) {\n      node.value = replaceValueSymbols(node.value.toString(), replacements);\n    } else if (node.type === \"rule\" && node.selector) {\n      node.selector = replaceValueSymbols(\n        node.selector.toString(),\n        replacements\n      );\n    } else if (node.type === \"atrule\" && node.params) {\n      node.params = replaceValueSymbols(node.params.toString(), replacements);\n    }\n  });\n};\n\n\n\nconst matchValueName = \/[$]?[\\w-]+\/g;\n\nconst replaceValueSymbols = (value, replacements) => {\n  let matches;\n\n  while ((matches = matchValueName.exec(value))) {\n    const replacement = replacements[matches[0]];\n\n    if (replacement) {\n      value =\n        value.slice(0, matches.index) +\n        replacement +\n        value.slice(matchValueName.lastIndex);\n\n      matchValueName.lastIndex -= matches[0].length - replacement.length;\n    }\n  }\n\n  return value;\n};\n\n\n","loc":198,"functions":15,"function_signatures":0,"function_parameters":27,"variable_declarations":25,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":1185}
{"name":"ieee754","size":2238,"content":"\/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https:\/\/feross.org\/opensource> *\/\nconst read = function (buffer, offset, isLE, mLen, nBytes) {\n  let e, m\n  const eLen = (nBytes * 8) - mLen - 1\n  const eMax = (1 << eLen) - 1\n  const eBias = eMax >> 1\n  let nBits = -7\n  let i = isLE ? (nBytes - 1) : 0\n  const d = isLE ? -1 : 1\n  let s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  while (nBits > 0) {\n    e = (e * 256) + buffer[offset + i]\n    i += d\n    nBits -= 8\n  }\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  while (nBits > 0) {\n    m = (m * 256) + buffer[offset + i]\n    i += d\n    nBits -= 8\n  }\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n};\n\nconst write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  let e, m, c\n  let eLen = (nBytes * 8) - mLen - 1\n  const eMax = (1 << eLen) - 1\n  const eBias = eMax >> 1\n  const rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  let i = isLE ? 0 : (nBytes - 1)\n  const d = isLE ? 1 : -1\n  const s = value < 0 || (value === 0 && 1 \/ value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) \/ Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt \/ c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c \/= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  while (mLen >= 8) {\n    buffer[offset + i] = m & 0xff\n    i += d\n    m \/= 256\n    mLen -= 8\n  }\n\n  e = (e << mLen) | m\n  eLen += mLen\n  while (eLen > 0) {\n    buffer[offset + i] = e & 0xff\n    i += d\n    e \/= 256\n    eLen -= 8\n  }\n\n  buffer[offset + i - d] |= s * 128\n};\n","loc":104,"functions":2,"function_signatures":0,"function_parameters":11,"variable_declarations":21,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":941}
{"name":"ip-regex","size":2311,"content":"const word = '[a-fA-F\\\\d:]';\n\nconst boundry = options => options && options.includeBoundaries\n\t? `(?:(?<=\\\\s|^)(?=${word})|(?<=${word})(?=\\\\s|$))`\n\t: '';\n\nconst v4 = '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n\nconst v6segment = '[a-fA-F\\\\d]{1,4}';\n\nconst v6 = `\n(?:\n(?:${v6segment}:){7}(?:${v6segment}|:)|                                    \/\/ 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             \/\/ 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   \/\/ 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| \/\/ 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| \/\/ 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| \/\/ 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| \/\/ 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             \/\/ ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             \/\/ %eth0            %1\n`.replace(\/\\s*\\\/\\\/.*$\/gm, '').replace(\/\\n\/g, '').trim();\n\n\/\/ Pre-compile only the exact regexes because adding a global flag make regexes stateful\nconst v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);\nconst v4exact = new RegExp(`^${v4}$`);\nconst v6exact = new RegExp(`^${v6}$`);\n\nconst ipRegex = options => options && options.exact\n\t? v46Exact\n\t: new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, 'g');\n\nipRegex.v4 = options => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, 'g');\nipRegex.v6 = options => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, 'g');\n\n\n","loc":37,"functions":4,"function_signatures":0,"function_parameters":4,"variable_declarations":9,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":1064}
{"name":"is-absolute-url","size":503,"content":"\/\/ Scheme: https:\/\/tools.ietf.org\/html\/rfc3986#section-3.1\n\/\/ Absolute URL: https:\/\/tools.ietf.org\/html\/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = \/^[a-zA-Z][a-zA-Z\\d+\\-.]*?:\/;\n\n\/\/ Windows paths like `c:\\`\nconst WINDOWS_PATH_REGEX = \/^[a-zA-Z]:\\\\\/;\n\nfunction isAbsoluteUrl(url) {\n\tif (typeof url !== 'string') {\n\t\tthrow new TypeError(`Expected a \\`string\\`, got \\`${typeof url}\\``);\n\t}\n\n\tif (WINDOWS_PATH_REGEX.test(url)) {\n\t\treturn false;\n\t}\n\n\treturn ABSOLUTE_URL_REGEX.test(url);\n}\n","loc":19,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":193}
{"name":"is-buffer","size":300,"content":"\/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https:\/\/feross.org>\n * @license  MIT\n *\/\n\nfunction isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n};\n","loc":12,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":87}
{"name":"is-fullwidth-code-point","size":1606,"content":"\/* eslint-disable yoda *\/\n\nfunction isFullwidthCodePoint(codePoint) {\n\tif (!Number.isInteger(codePoint)) {\n\t\treturn false;\n\t}\n\n\t\/\/ Code points are derived from:\n\t\/\/ https:\/\/unicode.org\/Public\/UNIDATA\/EastAsianWidth.txt\n\treturn codePoint >= 0x1100 && (\n\t\tcodePoint <= 0x115F || \/\/ Hangul Jamo\n\t\tcodePoint === 0x2329 || \/\/ LEFT-POINTING ANGLE BRACKET\n\t\tcodePoint === 0x232A || \/\/ RIGHT-POINTING ANGLE BRACKET\n\t\t\/\/ CJK Radicals Supplement .. Enclosed CJK Letters and Months\n\t\t(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||\n\t\t\/\/ Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n\t\t(0x3250 <= codePoint && codePoint <= 0x4DBF) ||\n\t\t\/\/ CJK Unified Ideographs .. Yi Radicals\n\t\t(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||\n\t\t\/\/ Hangul Jamo Extended-A\n\t\t(0xA960 <= codePoint && codePoint <= 0xA97C) ||\n\t\t\/\/ Hangul Syllables\n\t\t(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||\n\t\t\/\/ CJK Compatibility Ideographs\n\t\t(0xF900 <= codePoint && codePoint <= 0xFAFF) ||\n\t\t\/\/ Vertical Forms\n\t\t(0xFE10 <= codePoint && codePoint <= 0xFE19) ||\n\t\t\/\/ CJK Compatibility Forms .. Small Form Variants\n\t\t(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||\n\t\t\/\/ Halfwidth and Fullwidth Forms\n\t\t(0xFF01 <= codePoint && codePoint <= 0xFF60) ||\n\t\t(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||\n\t\t\/\/ Kana Supplement\n\t\t(0x1B000 <= codePoint && codePoint <= 0x1B001) ||\n\t\t\/\/ Enclosed Ideographic Supplement\n\t\t(0x1F200 <= codePoint && codePoint <= 0x1F251) ||\n\t\t\/\/ CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n\t\t(0x20000 <= codePoint && codePoint <= 0x3FFFD)\n\t);\n}\n","loc":41,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":621}
{"name":"is-generator-fn","size":287,"content":"const {toString} = Object.prototype;\n\nfunction isGeneratorFunction(value) {\n\tif (typeof value !== 'function') {\n\t\treturn false;\n\t}\n\n\treturn (value.constructor && value.constructor.name === 'GeneratorFunction')\n\t\t|| toString.call(value) === '[object GeneratorFunction]';\n}\n","loc":11,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":1,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":74}
{"name":"is-obj","size":142,"content":"function isObject(value) {\n\tconst type = typeof value;\n\treturn value !== null && (type === 'object' || type === 'function');\n}\n","loc":5,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":1,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":36}
{"name":"is-plain-object","size":1053,"content":"\/*!\n * is-plain-object <https:\/\/github.com\/jonschlinkert\/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n *\/\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  \/\/ If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  \/\/ If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  \/\/ If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  \/\/ Most likely a plain Object\n  return true;\n};\n\n\n","loc":35,"functions":2,"function_signatures":0,"function_parameters":2,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":211}
{"name":"is-stream","size":746,"content":"function isStream(stream) {\n\treturn stream !== null\n\t\t&& typeof stream === 'object'\n\t\t&& typeof stream.pipe === 'function';\n}\n\nfunction isWritableStream(stream) {\n\treturn isStream(stream)\n\t\t&& stream.writable !== false\n\t\t&& typeof stream._write === 'function'\n\t\t&& typeof stream._writableState === 'object';\n}\n\nfunction isReadableStream(stream) {\n\treturn isStream(stream)\n\t\t&& stream.readable !== false\n\t\t&& typeof stream._read === 'function'\n\t\t&& typeof stream._readableState === 'object';\n}\n\nfunction isDuplexStream(stream) {\n\treturn isWritableStream(stream)\n\t\t&& isReadableStream(stream);\n}\n\nfunction isTransformStream(stream) {\n\treturn isDuplexStream(stream)\n\t\t&& typeof stream._transform === 'function';\n}\n","loc":30,"functions":5,"function_signatures":0,"function_parameters":5,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":7,"estimated_tokens":202}
{"name":"is-typedarray","size":1010,"content":"\nisTypedArray.strict = isStrictTypedArray\nisTypedArray.loose  = isLooseTypedArray\n\nvar toString = Object.prototype.toString\nvar names = {\n    '[object Int8Array]': true\n  , '[object Int16Array]': true\n  , '[object Int32Array]': true\n  , '[object Uint8Array]': true\n  , '[object Uint8ClampedArray]': true\n  , '[object Uint16Array]': true\n  , '[object Uint32Array]': true\n  , '[object Float32Array]': true\n  , '[object Float64Array]': true\n}\n\nfunction isTypedArray(arr) {\n  return (\n       isStrictTypedArray(arr)\n    || isLooseTypedArray(arr)\n  )\n}\n\nfunction isStrictTypedArray(arr) {\n  return (\n       arr instanceof Int8Array\n    || arr instanceof Int16Array\n    || arr instanceof Int32Array\n    || arr instanceof Uint8Array\n    || arr instanceof Uint8ClampedArray\n    || arr instanceof Uint16Array\n    || arr instanceof Uint32Array\n    || arr instanceof Float32Array\n    || arr instanceof Float64Array\n  )\n}\n\nfunction isLooseTypedArray(arr) {\n  return names[toString.call(arr)]\n}\n","loc":42,"functions":3,"function_signatures":0,"function_parameters":3,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":9,"estimated_tokens":265}
{"name":"isobject","size":271,"content":"\/*!\n * isobject <https:\/\/github.com\/jonschlinkert\/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n *\/\n\nfunction isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","loc":11,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":88}
{"name":"json-parse-better-errors","size":1085,"content":"'use strict'\n\n\nfunction parseJson (txt, reviver, context) {\n  context = context || 20\n  try {\n    return JSON.parse(txt, reviver)\n  } catch (e) {\n    if (typeof txt !== 'string') {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\n      const errorMessage = 'Cannot parse ' +\n      (isEmptyArray ? 'an empty array' : String(txt))\n      throw new TypeError(errorMessage)\n    }\n    const syntaxErr = e.message.match(\/^Unexpected token.*position\\s+(\\d+)\/i)\n    const errIdx = syntaxErr\n    ? +syntaxErr[1]\n    : e.message.match(\/^Unexpected end of JSON.*\/i)\n    ? txt.length - 1\n    : null\n    if (errIdx != null) {\n      const start = errIdx <= context\n      ? 0\n      : errIdx - context\n      const end = errIdx + context >= txt.length\n      ? txt.length\n      : errIdx + context\n      e.message += ` while parsing near '${\n        start === 0 ? '' : '...'\n      }${txt.slice(start, end)}${\n        end === txt.length ? '' : '...'\n      }'`\n    } else {\n      e.message += ` while parsing '${txt.slice(0, context * 2)}'`\n    }\n    throw e\n  }\n}\n","loc":39,"functions":1,"function_signatures":0,"function_parameters":3,"variable_declarations":6,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":302}
{"name":"json-stringify-safe","size":902,"content":"\nconst getSerialize = serializer;\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n","loc":28,"functions":4,"function_signatures":0,"function_parameters":10,"variable_declarations":4,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":254}
{"name":"lowercase-keys","size":152,"content":"function lowercaseKeys(object) {\n\treturn Object.fromEntries(Object.entries(object).map(([key, value]) => [key.toLowerCase(), value]));\n}\n","loc":4,"functions":2,"function_signatures":0,"function_parameters":2,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":38}
{"name":"map-obj","size":1695,"content":"const isObject = value => typeof value === 'object' && value !== null;\n\n\/\/ Customized for this use-case\nconst isObjectCustom = value =>\n\tisObject(value)\n\t&& !(value instanceof RegExp)\n\t&& !(value instanceof Error)\n\t&& !(value instanceof Date)\n\t&& !(globalThis.Blob && value instanceof globalThis.Blob);\n\nconst mapObjectSkip = Symbol('mapObjectSkip');\n\nconst _mapObject = (object, mapper, options, isSeen = new WeakMap()) => {\n\toptions = {\n\t\tdeep: false,\n\t\ttarget: {},\n\t\t...options,\n\t};\n\n\tif (isSeen.has(object)) {\n\t\treturn isSeen.get(object);\n\t}\n\n\tisSeen.set(object, options.target);\n\n\tconst {target} = options;\n\tdelete options.target;\n\n\tconst mapArray = array => array.map(element => isObjectCustom(element) ? _mapObject(element, mapper, options, isSeen) : element);\n\tif (Array.isArray(object)) {\n\t\treturn mapArray(object);\n\t}\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tconst mapResult = mapper(key, value, object);\n\n\t\tif (mapResult === mapObjectSkip) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [newKey, newValue, {shouldRecurse = true} = {}] = mapResult;\n\n\t\t\/\/ Drop `__proto__` keys.\n\t\tif (newKey === '__proto__') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (options.deep && shouldRecurse && isObjectCustom(newValue)) {\n\t\t\tnewValue = Array.isArray(newValue)\n\t\t\t\t? mapArray(newValue)\n\t\t\t\t: _mapObject(newValue, mapper, options, isSeen);\n\t\t}\n\n\t\ttarget[newKey] = newValue;\n\t}\n\n\treturn target;\n};\n\nfunction mapObject(object, mapper, options) {\n\tif (!isObject(object)) {\n\t\tthrow new TypeError(`Expected an object, got \\`${object}\\` (${typeof object})`);\n\t}\n\n\tif (Array.isArray(object)) {\n\t\tthrow new TypeError('Expected an object, got an array');\n\t}\n\n\treturn _mapObject(object, mapper, options);\n}\n","loc":71,"functions":6,"function_signatures":0,"function_parameters":11,"variable_declarations":8,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":6,"estimated_tokens":517}
{"name":"merge-descriptors","size":1217,"content":"\/*!\n * merge-descriptors\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n *\/\n\n'use strict'\n\n\/**\n * Module exports.\n * @public\n *\/\n\n\n\n\/**\n * Module variables.\n * @private\n *\/\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\n\/**\n * Merge the property descriptors of `src` into `dest`\n *\n * @param {object} dest Object to add descriptors to\n * @param {object} src Object to clone descriptors from\n * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties\n * @returns {object} Reference to dest\n * @public\n *\/\n\nfunction merge (dest, src, redefine) {\n  if (!dest) {\n    throw new TypeError('argument dest is required')\n  }\n\n  if (!src) {\n    throw new TypeError('argument src is required')\n  }\n\n  if (redefine === undefined) {\n    \/\/ Default to true\n    redefine = true\n  }\n\n  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName (name) {\n    if (!redefine && hasOwnProperty.call(dest, name)) {\n      \/\/ Skip descriptor\n      return\n    }\n\n    \/\/ Copy descriptor\n    var descriptor = Object.getOwnPropertyDescriptor(src, name)\n    Object.defineProperty(dest, name, descriptor)\n  })\n\n  return dest\n}\n","loc":61,"functions":2,"function_signatures":0,"function_parameters":4,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":320}
{"name":"mimic-fn","size":2903,"content":"const copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t\/\/ `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t\/\/ `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t\/\/ `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n\/\/ `Object.defineProperty()` throws if the property exists, is not configurable and either:\n\/\/ - one its descriptors is changed\n\/\/ - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `\/* Wrapped ${withName}*\/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n\/\/ We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n\/\/ We use `bind()` instead of a closure for the same reason.\n\/\/ Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t\/\/ Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nfunction mimicFunction(to, from, {ignoreNonConfigurable = false} = {}) {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n}\n","loc":72,"functions":6,"function_signatures":0,"function_parameters":16,"variable_declarations":13,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":750}
{"name":"minimalistic-assert","size":250,"content":"\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","loc":12,"functions":2,"function_signatures":0,"function_parameters":5,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":75}
{"name":"p-each-series","size":368,"content":"const pEachSeries = async (iterable, iterator) => {\n\tlet index = 0;\n\n\tfor (const value of iterable) {\n\t\t\/\/ eslint-disable-next-line no-await-in-loop\n\t\tconst returnValue = await iterator(await value, index++);\n\n\t\tif (returnValue === pEachSeries.stop) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn iterable;\n};\n\npEachSeries.stop = Symbol('pEachSeries.stop');\n\n\n","loc":19,"functions":1,"function_signatures":0,"function_parameters":2,"variable_declarations":3,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":108}
{"name":"p-try","size":140,"content":"async function pTry(function_, ...arguments_) {\n\treturn new Promise(resolve => {\n\t\tresolve(function_(...arguments_));\n\t});\n}\n","loc":6,"functions":2,"function_signatures":0,"function_parameters":3,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":36}
{"name":"pify","size":2852,"content":"const processFunction = (function_, options, proxy, unwrapped) => (function(...arguments_) {\n\tconst P = options.promiseModule;\n\n\treturn new P((resolve, reject) => {\n\t\tif (options.multiArgs) {\n\t\t\targuments_.push((...result) => {\n\t\t\t\tif (options.errorFirst) {\n\t\t\t\t\tif (result[0]) {\n\t\t\t\t\t\treject(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.shift();\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (options.errorFirst) {\n\t\t\targuments_.push((error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\targuments_.push(resolve);\n\t\t}\n\n\t\tconst self = this === proxy ? unwrapped : this;\n\t\tReflect.apply(function_, self, arguments_);\n\t});\n});\n\nconst filterCache = new WeakMap();\n\nfunction pify(input, options) {\n\toptions = {\n\t\texclude: [\/.+(?:Sync|Stream)$\/],\n\t\terrorFirst: true,\n\t\tpromiseModule: Promise,\n\t\t...options,\n\t};\n\n\tconst objectType = typeof input;\n\tif (!(input !== null && (objectType === 'object' || objectType === 'function'))) {\n\t\tthrow new TypeError(`Expected \\`input\\` to be a \\`Function\\` or \\`Object\\`, got \\`${input === null ? 'null' : objectType}\\``);\n\t}\n\n\tconst filter = (target, key) => {\n\t\tlet cached = filterCache.get(target);\n\n\t\tif (!cached) {\n\t\t\tcached = {};\n\t\t\tfilterCache.set(target, cached);\n\t\t}\n\n\t\tif (key in cached) {\n\t\t\treturn cached[key];\n\t\t}\n\n\t\tconst match = pattern => (typeof pattern === 'string' || typeof key === 'symbol') ? key === pattern : pattern.test(key);\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n\t\tconst writableOrConfigurableOwn = (descriptor === undefined || descriptor.writable || descriptor.configurable);\n\t\tconst included = options.include ? options.include.some(element => match(element)) : !options.exclude.some(element => match(element));\n\t\tconst shouldFilter = included && writableOrConfigurableOwn;\n\t\tcached[key] = shouldFilter;\n\t\treturn shouldFilter;\n\t};\n\n\tconst cache = new WeakMap();\n\n\tconst proxy = new Proxy(input, {\n\t\tapply(target, thisArg, args) {\n\t\t\tconst cached = cache.get(target);\n\n\t\t\tif (cached) {\n\t\t\t\treturn Reflect.apply(cached, thisArg, args);\n\t\t\t}\n\n\t\t\tconst pified = options.excludeMain ? target : processFunction(target, options, proxy, target);\n\t\t\tcache.set(target, pified);\n\t\t\treturn Reflect.apply(pified, thisArg, args);\n\t\t},\n\n\t\tget(target, key) {\n\t\t\tconst property = target[key];\n\n\t\t\t\/\/ eslint-disable-next-line no-use-extend-native\/no-use-extend-native\n\t\t\tif (!filter(target, key) || property === Function.prototype[key]) {\n\t\t\t\treturn property;\n\t\t\t}\n\n\t\t\tconst cached = cache.get(property);\n\n\t\t\tif (cached) {\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tif (typeof property === 'function') {\n\t\t\t\tconst pified = processFunction(property, options, proxy, target);\n\t\t\t\tcache.set(property, pified);\n\t\t\t\treturn pified;\n\t\t\t}\n\n\t\t\treturn property;\n\t\t},\n\t});\n\n\treturn proxy;\n}\n","loc":112,"functions":12,"function_signatures":0,"function_parameters":22,"variable_declarations":19,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":4,"estimated_tokens":836}
{"name":"prepend-http","size":354,"content":"function prependHttp(url, {https = true} = {}) {\n\tif (typeof url !== 'string') {\n\t\tthrow new TypeError(`Expected \\`url\\` to be of type \\`string\\`, got \\`${typeof url}\\``);\n\t}\n\n\turl = url.trim();\n\n\tif (\/^\\.*\\\/|^(?!localhost)\\w+?:\/.test(url)) {\n\t\treturn url;\n\t}\n\n\treturn url.replace(\/^(?!(?:\\w+?:)?\\\/\\\/)\/, https ? 'https:\/\/' : 'http:\/\/');\n}\n","loc":14,"functions":1,"function_signatures":0,"function_parameters":2,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":117}
{"name":"querystringify","size":2575,"content":"'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n\/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n *\/\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(\/\\+\/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n\/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n *\/\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n\/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n *\/\nfunction querystring(query) {\n  var parser = \/([^=?#&]+)=?([^&]*)\/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    \/\/\n    \/\/ Prevent overriding of existing properties. This ensures that build-in\n    \/\/ methods like `toString` or __proto__ are not overriden by malicious\n    \/\/ querystrings.\n    \/\/\n    \/\/ In the case if failed decoding, we want to omit the key\/value pairs\n    \/\/ from the result.\n    \/\/\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n\/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n *\/\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  \/\/\n  \/\/ Optionally prefix with a '?' if needed\n  \/\/\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      \/\/\n      \/\/ Edge cases where we actually want to encode the value to an empty\n      \/\/ string instead of the stringified value.\n      \/\/\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      \/\/\n      \/\/ If we failed to encode the strings, we should bail out as we don't\n      \/\/ want to add invalid strings to the query.\n      \/\/\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n\/\/\n\/\/ Expose the module.\n\/\/\nconst stringify = querystringify;\n\nconst parse = querystring;\n","loc":120,"functions":4,"function_signatures":0,"function_parameters":5,"variable_declarations":12,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":701}
{"name":"requires-port","size":751,"content":"'use strict';\n\n\/**\n * Check if we're required to add a port number.\n *\n * @see https:\/\/url.spec.whatwg.org\/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n *\/\nfunction required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n","loc":39,"functions":1,"function_signatures":0,"function_parameters":2,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":218}
{"name":"setprototypeof","size":407,"content":"'use strict'\n\n\/* eslint no-proto: 0 *\/\n\n\nfunction setProtoOf (obj, proto) {\n  obj.__proto__ = proto\n  return obj\n}\n\nfunction mixinProperties (obj, proto) {\n  for (var prop in proto) {\n    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {\n      obj[prop] = proto[prop]\n    }\n  }\n  return obj\n}\n","loc":19,"functions":2,"function_signatures":0,"function_parameters":4,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":95}
{"name":"slash","size":285,"content":"function slash(path) {\n\tconst isExtendedLengthPath = \/^\\\\\\\\\\?\\\\\/.test(path);\n\tconst hasNonAscii = \/[^\\u0000-\\u0080]+\/.test(path); \/\/ eslint-disable-line no-control-regex\n\n\tif (isExtendedLengthPath || hasNonAscii) {\n\t\treturn path;\n\t}\n\n\treturn path.replace(\/\\\\\/g, '\/');\n}\n","loc":11,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":97}
{"name":"split-on-first","size":464,"content":"function splitOnFirst(string, separator) {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (string === '' || separator === '') {\n\t\treturn [];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n}\n","loc":21,"functions":1,"function_signatures":0,"function_parameters":2,"variable_declarations":1,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":131}
{"name":"stream-shift","size":497,"content":"\n\nfunction shift (stream) {\n  var rs = stream._readableState\n  if (!rs) return null\n  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))\n}\n\nfunction getStateLength (state) {\n  if (state.buffer.length) {\n    \/\/ Since node 6.3.0 state.buffer is a BufferList not an array\n    if (state.buffer.head) {\n      return state.buffer.head.data.length\n    }\n\n    return state.buffer[0].length\n  }\n\n  return state.length\n}\n","loc":21,"functions":2,"function_signatures":0,"function_parameters":2,"variable_declarations":1,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":139}
{"name":"strip-bom","size":347,"content":"function stripBom(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof string}`);\n\t}\n\n\t\/\/ Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n\t\/\/ conversion translates it to FEFF (UTF-16 BOM).\n\tif (string.charCodeAt(0) === 0xFEFF) {\n\t\treturn string.slice(1);\n\t}\n\n\treturn string;\n}\n","loc":14,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":114}
{"name":"trim-newlines","size":800,"content":"function trimNewlines(string) {\n\tlet start = 0;\n\tlet end = string.length;\n\n\twhile (start < end && (string[start] === '\\r' || string[start] === '\\n')) {\n\t\tstart++;\n\t}\n\n\twhile (end > start && (string[end - 1] === '\\r' || string[end - 1] === '\\n')) {\n\t\tend--;\n\t}\n\n\treturn (start > 0 || end < string.length) ? string.slice(start, end) : string;\n}\n\ntrimNewlines.start = string => {\n\tconst end = string.length;\n\tlet start = 0;\n\n\twhile (start < end && (string[start] === '\\r' || string[start] === '\\n')) {\n\t\tstart++;\n\t}\n\n\treturn start > 0 ? string.slice(start, end) : string;\n};\n\ntrimNewlines.end = string => {\n\tlet end = string.length;\n\n\twhile (end > 0 && (string[end - 1] === '\\r' || string[end - 1] === '\\n')) {\n\t\tend--;\n\t}\n\n\treturn end < string.length ? string.slice(0, end) : string;\n};\n","loc":36,"functions":3,"function_signatures":0,"function_parameters":3,"variable_declarations":5,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":295}
{"name":"universalify","size":724,"content":"'use strict'\n\nconst fromCallback = function (fn) {\n  return Object.defineProperty(function (...args) {\n    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)\n    else {\n      return new Promise((resolve, reject) => {\n        fn.call(\n          this,\n          ...args,\n          (err, res) => (err != null) ? reject(err) : resolve(res)\n        )\n      })\n    }\n  }, 'name', { value: fn.name })\n};\n\nconst fromPromise = function (fn) {\n  return Object.defineProperty(function (...args) {\n    const cb = args[args.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, args)\n    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n};\n","loc":25,"functions":7,"function_signatures":0,"function_parameters":9,"variable_declarations":3,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":216}
{"name":"console-control-strings","size":2429,"content":"'use strict'\n\n\/\/ These tables borrowed from `ansi`\n\nvar prefix = '\\x1b['\n\nconst up = function up (num) {\n  return prefix + (num || '') + 'A'\n};\n\nconst down = function down (num) {\n  return prefix + (num || '') + 'B'\n};\n\nconst forward = function forward (num) {\n  return prefix + (num || '') + 'C'\n};\n\nconst back = function back (num) {\n  return prefix + (num || '') + 'D'\n};\n\nconst nextLine = function nextLine (num) {\n  return prefix + (num || '') + 'E'\n};\n\nconst previousLine = function previousLine (num) {\n  return prefix + (num || '') + 'F'\n};\n\nconst horizontalAbsolute = function horizontalAbsolute (num) {\n  if (num == null) throw new Error('horizontalAboslute requires a column to position to')\n  return prefix + num + 'G'\n};\n\nconst eraseData = function eraseData () {\n  return prefix + 'J'\n};\n\nconst eraseLine = function eraseLine () {\n  return prefix + 'K'\n};\n\nconst goto = function (x, y) {\n  return prefix + y + ';' + x + 'H'\n};\n\nconst gotoSOL = function () {\n  return '\\r'\n};\n\nconst beep = function () {\n  return '\\x07'\n};\n\nconst hideCursor = function hideCursor () {\n  return prefix + '?25l'\n};\n\nconst showCursor = function showCursor () {\n  return prefix + '?25h'\n};\n\nvar colors = {\n  reset: 0,\n\/\/ styles\n  bold: 1,\n  italic: 3,\n  underline: 4,\n  inverse: 7,\n\/\/ resets\n  stopBold: 22,\n  stopItalic: 23,\n  stopUnderline: 24,\n  stopInverse: 27,\n\/\/ colors\n  white: 37,\n  black: 30,\n  blue: 34,\n  cyan: 36,\n  green: 32,\n  magenta: 35,\n  red: 31,\n  yellow: 33,\n  bgWhite: 47,\n  bgBlack: 40,\n  bgBlue: 44,\n  bgCyan: 46,\n  bgGreen: 42,\n  bgMagenta: 45,\n  bgRed: 41,\n  bgYellow: 43,\n\n  grey: 90,\n  brightBlack: 90,\n  brightRed: 91,\n  brightGreen: 92,\n  brightYellow: 93,\n  brightBlue: 94,\n  brightMagenta: 95,\n  brightCyan: 96,\n  brightWhite: 97,\n\n  bgGrey: 100,\n  bgBrightBlack: 100,\n  bgBrightRed: 101,\n  bgBrightGreen: 102,\n  bgBrightYellow: 103,\n  bgBrightBlue: 104,\n  bgBrightMagenta: 105,\n  bgBrightCyan: 106,\n  bgBrightWhite: 107\n}\n\nconst color = function color (colorWith) {\n  if (arguments.length !== 1 || !Array.isArray(colorWith)) {\n    colorWith = Array.prototype.slice.call(arguments)\n  }\n  return prefix + colorWith.map(colorNameToCode).join(';') + 'm'\n};\n\nfunction colorNameToCode (color) {\n  if (colors[color] != null) return colors[color]\n  throw new Error('Unknown color or style name: ' + color)\n}\n","loc":126,"functions":16,"function_signatures":0,"function_parameters":11,"variable_declarations":17,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":851}
{"name":"for-in","size":317,"content":"\/*!\n * for-in <https:\/\/github.com\/jonschlinkert\/for-in>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n *\/\n\n'use strict';\n\nfunction forIn(obj, fn, thisArg) {\n  for (var key in obj) {\n    if (fn.call(thisArg, obj[key], key, obj) === false) {\n      break;\n    }\n  }\n};\n","loc":17,"functions":1,"function_signatures":0,"function_parameters":3,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":116}
{"name":"is-accessor-descriptor","size":1280,"content":"\/*!\n * is-accessor-descriptor <https:\/\/github.com\/jonschlinkert\/is-accessor-descriptor>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n *\/\n\n'use strict';\n\nconst isObject = val => {\n  return val !== null && typeof val === 'object' && !Array.isArray(val);\n};\n\n\n","loc":15,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":1,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":95}
{"name":"is-arrayish","size":316,"content":"function isArrayish(obj) {\n\tif (!obj || typeof obj === 'string') {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && (obj.splice instanceof Function ||\n\t\t\t(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));\n};\n","loc":10,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":3,"estimated_tokens":89}
{"name":"is-descriptor","size":1158,"content":"'use strict';\n\nconst isObject = val => val !== null && typeof val === 'object';\nconst dataDesc = new Set(['configurable', 'enumerable', 'get', 'set']);\nconst accDesc = new Set(['configurable', 'enumerable', 'writable', 'value']);\n\n\n\nfunction isDataDesc(keys) {\n  return keys.every(k => dataDesc.has(k));\n}\n\nfunction isAccessorDesc(keys) {\n  return keys.every(k => accDesc.has(k));\n}\n","loc":16,"functions":5,"function_signatures":0,"function_parameters":5,"variable_declarations":3,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":114}
{"name":"is-extglob","size":458,"content":"\/*!\n * is-extglob <https:\/\/github.com\/jonschlinkert\/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n *\/\n\nvar regex = \/(\\\\).|([@?!+*]\\(.*\\))\/;\n\nfunction isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n","loc":23,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":161}
{"name":"is-map","size":902,"content":"'use strict';\n\nvar $Map = typeof Map === 'function' && Map.prototype ? Map : null;\nvar $Set = typeof Set === 'function' && Set.prototype ? Set : null;\n\nvar exported;\n\nif (!$Map) {\n\t\/\/ eslint-disable-next-line no-unused-vars\n\texported = function isMap(x) {\n\t\t\/\/ `Map` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $Map ? Map.prototype.has : null;\nvar $setHas = $Set ? Set.prototype.has : null;\nif (!exported && !$mapHas) {\n\t\/\/ eslint-disable-next-line no-unused-vars\n\texported = function isMap(x) {\n\t\t\/\/ `Map` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\n\n","loc":27,"functions":2,"function_signatures":0,"function_parameters":2,"variable_declarations":5,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":201}
{"name":"is-negative-zero","size":120,"content":"'use strict';\n\nfunction isNegativeZero(number) {\n\treturn number === 0 && (1 \/ number) === -Infinity;\n};\n\n","loc":7,"functions":1,"function_signatures":0,"function_parameters":1,"variable_declarations":0,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":34}
{"name":"is-set","size":902,"content":"'use strict';\n\nvar $Map = typeof Map === 'function' && Map.prototype ? Map : null;\nvar $Set = typeof Set === 'function' && Set.prototype ? Set : null;\n\nvar exported;\n\nif (!$Set) {\n\t\/\/ eslint-disable-next-line no-unused-vars\n\texported = function isSet(x) {\n\t\t\/\/ `Set` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $Map ? Map.prototype.has : null;\nvar $setHas = $Set ? Set.prototype.has : null;\nif (!exported && !$setHas) {\n\t\/\/ eslint-disable-next-line no-unused-vars\n\texported = function isSet(x) {\n\t\t\/\/ `Set` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\n\n","loc":27,"functions":2,"function_signatures":0,"function_parameters":2,"variable_declarations":5,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":198}
{"name":"is-weakmap","size":994,"content":"'use strict';\n\nvar $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;\nvar $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;\n\nvar exported;\n\nif (!$WeakMap) {\n\t\/\/ eslint-disable-next-line no-unused-vars\n\texported = function isWeakMap(x) {\n\t\t\/\/ `WeakMap` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $WeakMap ? $WeakMap.prototype.has : null;\nvar $setHas = $WeakSet ? $WeakSet.prototype.has : null;\nif (!exported && !$mapHas) {\n\t\/\/ eslint-disable-next-line no-unused-vars\n\texported = function isWeakMap(x) {\n\t\t\/\/ `WeakMap` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\n\n","loc":27,"functions":2,"function_signatures":0,"function_parameters":2,"variable_declarations":5,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":217}
{"name":"map-cache","size":1950,"content":"\/*!\n * map-cache <https:\/\/github.com\/jonschlinkert\/map-cache>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n *\/\n\n'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n\/**\n * Expose `MapCache`\n *\/\n\n\n\n\/**\n * Creates a cache object to store key\/value pairs.\n *\n * ```js\n * var cache = new MapCache();\n * ```\n *\n * @api public\n *\/\n\nfunction MapCache(data) {\n  this.__data__ = data || {};\n}\n\n\/**\n * Adds `value` to `key` on the cache.\n *\n * ```js\n * cache.set('foo', 'bar');\n * ```\n *\n * @param {String} `key` The key of the value to cache.\n * @param {*} `value` The value to cache.\n * @returns {Object} Returns the `Cache` object for chaining.\n * @api public\n *\/\n\nMapCache.prototype.set = function mapSet(key, value) {\n  if (key !== '__proto__') {\n    this.__data__[key] = value;\n  }\n  return this;\n};\n\n\/**\n * Gets the cached value for `key`.\n *\n * ```js\n * cache.get('foo');\n * \/\/=> 'bar'\n * ```\n *\n * @param {String} `key` The key of the value to get.\n * @returns {*} Returns the cached value.\n * @api public\n *\/\n\nMapCache.prototype.get = function mapGet(key) {\n  return key === '__proto__' ? undefined : this.__data__[key];\n};\n\n\/**\n * Checks if a cached value for `key` exists.\n *\n * ```js\n * cache.has('foo');\n * \/\/=> true\n * ```\n *\n * @param {String} `key` The key of the entry to check.\n * @returns {Boolean} Returns `true` if an entry for `key` exists, else `false`.\n * @api public\n *\/\n\nMapCache.prototype.has = function mapHas(key) {\n  return key !== '__proto__' && hasOwn.call(this.__data__, key);\n};\n\n\/**\n * Removes `key` and its value from the cache.\n *\n * ```js\n * cache.del('foo');\n * ```\n * @title .del\n * @param {String} `key` The key of the value to remove.\n * @returns {Boolean} Returns `true` if the entry was removed successfully, else `false`.\n * @api public\n *\/\n\nMapCache.prototype.del = function mapDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n};\n","loc":101,"functions":5,"function_signatures":0,"function_parameters":6,"variable_declarations":1,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":639}
{"name":"mixin-deep","size":741,"content":"'use strict';\n\nconst isObject = val => {\n  return typeof val === 'function' || (typeof val === 'object' && val !== null && !Array.isArray(val));\n};\n\nconst isValidKey = key => {\n  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';\n};\n\nconst mixinDeep = (target, ...rest) => {\n  for (let obj of rest) {\n    if (isObject(obj)) {\n      for (let key in obj) {\n        if (isValidKey(key)) {\n          mixin(target, obj[key], key);\n        }\n      }\n    }\n  }\n  return target;\n};\n\nfunction mixin(target, val, key) {\n  let obj = target[key];\n  if (isObject(val) && isObject(obj)) {\n    mixinDeep(obj, val);\n  } else {\n    target[key] = val;\n  }\n}\n\n\/**\n * Expose mixinDeep\n * @type {Function}\n *\/\n\n\n","loc":39,"functions":4,"function_signatures":0,"function_parameters":7,"variable_declarations":4,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":2,"estimated_tokens":222}
{"name":"normalize-range","size":1453,"content":"'use strict';\n\n\n\nfunction wrapRange(min, max, value) {\n  var maxLessMin = max - min;\n  return ((value - min) % maxLessMin + maxLessMin) % maxLessMin + min;\n}\n\nfunction limitRange(min, max, value) {\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction validateRange(min, max, value, minExclusive, maxExclusive) {\n  if (!testRange(min, max, value, minExclusive, maxExclusive)) {\n    throw new Error(value + ' is outside of range [' + min + ',' + max + ')');\n  }\n  return value;\n}\n\nfunction testRange(min, max, value, minExclusive, maxExclusive) {\n  return !(\n       value < min ||\n       value > max ||\n       (maxExclusive && (value === max)) ||\n       (minExclusive && (value === min))\n  );\n}\n\nfunction name(min, max, minExcl, maxExcl) {\n  return (minExcl ? '(' : '[') + min + ',' + max + (maxExcl ? ')' : ']');\n}\n\nfunction curry(min, max, minExclusive, maxExclusive) {\n  var boundNameFn = name.bind(null, min, max, minExclusive, maxExclusive);\n  return {\n    wrap: wrapRange.bind(null, min, max),\n    limit: limitRange.bind(null, min, max),\n    validate: function(value) {\n      return validateRange(min, max, value, minExclusive, maxExclusive);\n    },\n    test: function(value) {\n      return testRange(min, max, value, minExclusive, maxExclusive);\n    },\n    toString: boundNameFn,\n    name: boundNameFn\n  };\n}\n","loc":49,"functions":8,"function_signatures":0,"function_parameters":26,"variable_declarations":2,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":395}
{"name":"p-finally","size":218,"content":"async function pFinally(\n\tpromise,\n\tonFinally = (() => {})\n) {\n\tlet value;\n\ttry {\n\t\tvalue = await promise;\n\t} catch (error) {\n\t\tawait onFinally();\n\t\tthrow error;\n\t}\n\n\tawait onFinally();\n\treturn value;\n}\n","loc":16,"functions":2,"function_signatures":0,"function_parameters":2,"variable_declarations":1,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":0,"estimated_tokens":72}
{"name":"unpipe","size":1119,"content":"\/*!\n * unpipe\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n *\/\n\n'use strict'\n\n\/**\n * Module exports.\n * @public\n *\/\n\n\n\n\/**\n * Determine if there are Node.js pipe-like data listeners.\n * @private\n *\/\n\nfunction hasPipeDataListeners (stream) {\n  var listeners = stream.listeners('data')\n\n  for (var i = 0; i < listeners.length; i++) {\n    if (listeners[i].name === 'ondata') {\n      return true\n    }\n  }\n\n  return false\n}\n\n\/**\n * Unpipe a stream from all destinations.\n *\n * @param {object} stream\n * @public\n *\/\n\nfunction unpipe (stream) {\n  if (!stream) {\n    throw new TypeError('argument stream is required')\n  }\n\n  if (typeof stream.unpipe === 'function') {\n    \/\/ new-style\n    stream.unpipe()\n    return\n  }\n\n  \/\/ Node.js 0.8 hack\n  if (!hasPipeDataListeners(stream)) {\n    return\n  }\n\n  var listener\n  var listeners = stream.listeners('close')\n\n  for (var i = 0; i < listeners.length; i++) {\n    listener = listeners[i]\n\n    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {\n      continue\n    }\n\n    \/\/ invoke the listener\n    listener.call(stream)\n  }\n}\n","loc":70,"functions":2,"function_signatures":0,"function_parameters":2,"variable_declarations":5,"property_declarations":0,"trivial_types":0,"predefined_types":0,"type_definitions":0,"dynamism_heuristic":1,"estimated_tokens":328}
