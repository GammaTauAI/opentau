{"dataset_elem":{"alphanum_fraction":0.5262923351,"avg_line_length":23.375,"content":"/**\n */\nfunction exists(x: any) {\n  return x !== null && x !== undefined\n}\n\nexport class RNG {\n  private _index = 0\n  private _state: number[] = new Array(624)\n\n  constructor(private readonly _seed = (Math.random() * 0xffffffff) | 0) {\n    this._state[0] = _seed\n\n    const MT = this._state\n    for (let i = 1; i < 624; i++) {\n      MT[i] = MT[i - 1] ^ (MT[i - 1] >>> 30)\n      MT[i] = 0x6c078965 * MT[i] + i // 1812433253\n      MT[i] = MT[i] & ((MT[i] << 32) - 1)\n    }\n  }\n\n  /**\n   * Generate an array of 624 untempered numbers\n   * @returns: void\n   */\n  private generateNumbers() {\n    let y\n    const MT = this._state\n    for (let i = 0; i < 624; i++) {\n      // Bit 31 (32nd bit) of MT[i]\n      y = MT[i] & 0x80000000\n      // Bits 0-30 (first 31 bits) of MT[...]\n      y = y + (MT[(i + 1) % 624] & 0x7fffffff)\n      // The new randomness\n      MT[i] = MT[(i + 397) % 624] ^ (y >>> 1)\n      // In case y is odd\n      if (y % 2 !== 0) {\n        MT[i] = MT[i] ^ 0x9908b0df // 2567483615\n      }\n    }\n  }\n\n  /**\n   * Returns a tempered pseudorandom number [0,1]\n   *\n   * @remarks\n   * Based on the index-th value, calling {@link #generateNumbers()} every 624 numbers\n   *\n   * @returns The pseudorandom integer between 0 and 1\n   */\n  uniform() {\n    if (this._index === 0) this.generateNumbers()\n\n    let y = this._state[this._index]\n\n    y = y ^ (y >>> 11)\n    y = y ^ ((y << 7) & 0x9d2c5680) // 2636928640\n    y = y ^ ((y << 15) & 0xefc60000) // 4022730752\n    y = y ^ (y >>> 18)\n\n    this._index = (this._index + 1) % 624\n\n    return (y >>> 0) * (1.0 / 4294967296.0)\n  }\n\n  /**\n   * Returns a tempered pseudorandom number [0,1]\n   *\n   * @remarks\n   * Same as {@link #uniform()}, just to be\n   * compatible with the Math.random() style API\n   *\n   * @returns The pseudorandom integer between 0 and 1\n   */\n  random() {\n    return this.uniform()\n  }\n\n  /**\n   * Returns a random integer in range [min,max]\n   * @param: min\n   * @param: max\n   * @returns The random integer between `min` and `max`\n   */\n  range(min: number | null, max?: number) {\n    if (!exists(min)) {\n      return this.uniform()\n    } else if (!exists(max)) {\n      max = min!\n      min = 0\n    }\n\n    return min! + Math.floor(this.uniform() * (max! - min!))\n  }\n}\n","content_without_annotations":"/**\n */\nfunction exists(x) {\n  return x !== null && x !== undefined\n}\n\nexport class RNG {\n  private _index = 0\n  private _state = new Array(624)\n\n  constructor(private readonly _seed = (Math.random() * 0xffffffff) | 0) {\n    this._state[0] = _seed\n\n    const MT = this._state\n    for (let i = 1; i < 624; i++) {\n      MT[i] = MT[i - 1] ^ (MT[i - 1] >>> 30)\n      MT[i] = 0x6c078965 * MT[i] + i // 1812433253\n      MT[i] = MT[i] & ((MT[i] << 32) - 1)\n    }\n  }\n\n  /**\n   * Generate an array of 624 untempered numbers\n   * @returns: void\n   */\n  private generateNumbers() {\n    let y\n    const MT = this._state\n    for (let i = 0; i < 624; i++) {\n      // Bit 31 (32nd bit) of MT[i]\n      y = MT[i] & 0x80000000\n      // Bits 0-30 (first 31 bits) of MT[...]\n      y = y + (MT[(i + 1) % 624] & 0x7fffffff)\n      // The new randomness\n      MT[i] = MT[(i + 397) % 624] ^ (y >>> 1)\n      // In case y is odd\n      if (y % 2 !== 0) {\n        MT[i] = MT[i] ^ 0x9908b0df // 2567483615\n      }\n    }\n  }\n\n  /**\n   * Returns a tempered pseudorandom number [0,1]\n   *\n   * @remarks\n   * Based on the index-th value, calling {@link #generateNumbers()} every 624 numbers\n   *\n   * @returns The pseudorandom integer between 0 and 1\n   */\n  uniform() {\n    if (this._index === 0) this.generateNumbers()\n\n    let y = this._state[this._index]\n\n    y = y ^ (y >>> 11)\n    y = y ^ ((y << 7) & 0x9d2c5680) // 2636928640\n    y = y ^ ((y << 15) & 0xefc60000) // 4022730752\n    y = y ^ (y >>> 18)\n\n    this._index = (this._index + 1) % 624\n\n    return (y >>> 0) * (1.0 / 4294967296.0)\n  }\n\n  /**\n   * Returns a tempered pseudorandom number [0,1]\n   *\n   * @remarks\n   * Same as {@link #uniform()}, just to be\n   * compatible with the Math.random() style API\n   *\n   * @returns The pseudorandom integer between 0 and 1\n   */\n  random() {\n    return this.uniform()\n  }\n\n  /**\n   * Returns a random integer in range [min,max]\n   * @param: min\n   * @param: max\n   * @returns The random integer between `min` and `max`\n   */\n  range(min, max?) {\n    if (!exists(min)) {\n      return this.uniform()\n    } else if (!exists(max)) {\n      max = min!\n      min = 0\n    }\n\n    return min! + Math.floor(this.uniform() * (max! - min!))\n  }\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":875,"ext":"ts","fun_ann_density":0.0114285714,"function_parameters":4,"function_signatures":0,"function_usages":4,"functions":6,"hexsha":"99499bc65b7cef3215108181962e99800a800b63","lang":"TypeScript","loc":50,"loc_per_function":5.6666666667,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"1a3766577482776801748c943fc9794e27e4c066","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"jacobbubu/rngmt","max_forks_repo_path":"src/index.ts","max_issues_count":2.0,"max_issues_repo_head_hexsha":"1a3766577482776801748c943fc9794e27e4c066","max_issues_repo_issues_event_max_datetime":"2022-02-13T17:23:52.000Z","max_issues_repo_issues_event_min_datetime":"2022-01-15T06:42:13.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"jacobbubu/rngmt","max_issues_repo_path":"src/index.ts","max_line_length":86,"max_stars_count":null,"max_stars_repo_head_hexsha":"1a3766577482776801748c943fc9794e27e4c066","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"jacobbubu/rngmt","max_stars_repo_path":"src/index.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.220931132,"predefined_density":0.1666666667,"predefined_types":3,"prop_ann_density":0.0022857143,"property_declarations":2,"size":2244,"trivial_density":0.0555555556,"trivial_types":1,"type_definitions":1,"typedef_density":0.0011428571,"var_ann_density":0.0068571429,"variable_declarations":6},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n */\nfunction exists(x: any) {\n    return x!== undefined;\n}\n/**\n * @param x: any\n * @returns: boolean\n */\nfunction isDefined(x: any) {\n    return x!== undefined;\n}\n/**): boolean */\nfunction isUndefined(x: any) {\n    return x === undefined;\n}\n/**\n * @param x: any\n * @returns: boolean\n */\nfunction isNull(x: any) {\n    return x == {\n    return x !== null && x !== undefined;\n}\nexport class RNG {\n    private _index: number;\n    constructor(private _seed = (Math.random() * 4294967295) | 0) {\n        this._index = 0;\n        this.setSeed(this._seed) = 0;\n    private _state: number;\n    private _state: number;\n    private _state: number;\n    private _seed: number;\n    /**\n     * Create a new random number generator with a seed\n     * @param seed: any\n     * @returns: RN = new Array(624);\n    constructor(private readonly _seed: number) {\n        this._state = this._seed;\n        this.generateNumbers();\n    }\n    /**\n     * Returns the next random number between 0 and 1\n     * @returns: any\n     */\n    next() {\n        const resul = (Math.random() * 4294967295) | 0) {\n        this._state[0] = _seed;\n        const MT = this._state;\n        for (let i = 1; i < 624; i++) {\n            MT[i] = MT[i - 1] ^ (MT[i - 1] >>> 30);\n            MT[i] = 1812433253 * MT[i] + i; // 1812433253\n            MT[i] = MT[i] & ((MT[i] << 32) - 1);\n        }\n    }\n    /**\n     * Generate an array of 624 untempered numbers\n     * @returns: void\n     */\n    private generateNumbers(): void {\n        let y;\n        const MT = this._state;\n        for (let i = 0; i < 624; i++) {\n            // Bit 31 (32nd bit) of MT[i {\n        let y;\n        const MT = this._state;\n        for (let i = 0; i < 624; i++) {\n            // Bit 31 (32nd bit) of MT[i]\n            y = MT[i] & 2147483648;\n            // Bits 0-30 (first 31 bits) of MT[...]\n            y = y + (MT[(i + 1) % 624] & 2147483647);\n            // The new randomness\n            MT[i] = MT[(i + 397) % 624] ^ (y >>> 1);\n            // In case y is odd\n            if (y % 2 !== 0) {\n                MT[i] = MT[i] ^ 2567483615; // 2567483615\n            }\n        }\n    }\n    /**\n     * Returns a tempered pseudorandom number [0,1]\n     *\n     * @remarks\n     * Based on the index-th value, calling {@link #generateNumbers()} every 624 numbers\n     *\n     * @returns The pseudorandom integer between 0 and 1\n     */\n    uniform(): number {\n        return this.next() * 2 / 3;\n    }\n    /**\n     * Returns a tempered pseudorandom number [0,1]\n     *\n     * @remarks\n     * Based on the index-th valu {\n        if (this._index === 0)\n            this.generateNumbers();\n        let y = this._state[this._index];\n        y = y ^ (y >>> 11);\n        y = y ^ ((y << 7) & 2636928640); // 2636928640\n        y = y ^ ((y << 15) & 4022730752); // 4022730752\n        y = y ^ (y >>> 18);\n        this._index = (this._index + 1) % 624;\n        return (y >>> 0) * (1 / 4294967296);\n    }\n    /**\n     * Returns a tempered pseudorandom number [0,1]\n     *\n     * @remarks\n     * Same as {@link #uniform()}, just to be\n     * compatible with the Math.random() style API\n     *\n     * @returns The pseudorandom integer between 0 and 1\n     */\n    random(): number {\n        return this.uniform();\n    }\n    /**\n     * Returns a tempered pseudorandom number [0,1]\n     *\n     * @remarks\n     * Same as {@link #uniform()}, just to be\n     * compatible wit {\n        return this.uniform();\n    }\n    /**\n     * Returns a random integer in range [min,max]\n     * @param: min\n     * @param: max\n     * @returns The random integer between `min` and `max`\n     */\n    range(min: number, max: number) {\n        if (!exists(max)) {\n            return min!;\n        }\n        else if (!exists(min)) {\n            min = 0;\n        }\n        return min! + Math.floor(this, max?: number);\n    }\n    /**\n     * Returns a random integer in range [min,max]\n     * @param: min\n     * @param: max\n     * @returns The random integer between `min` and `max`\n     */\n    rang): number {\n        return this.range(min, max);\n    }\n    /**\n     * Returns a random integer in range [min,max]\n     *\n     * @remarks\n     * Same as {@link #uniform()}, just to be\n     * compatibl {\n        if (!exists(min)) {\n            return this.uniform();\n        }\n        else if (!exists(max)) {\n            max = min!;\n            min = 0;\n        }\n        return min! + Math.floor(this.uniform() * (max! - min!));\n    }\n}\n","score":370,"fallbacked":false,"num_type_errors":53},{"code":"/**\n */\nfunction exists(x: number): boolean {\n    return x!== undefined && x!== null;\n}\n/**\n * Checks if x is boolean-ish\n *\n * @remarks\n * Inspired by {@link https://stackoverflow.com/a/): https://stackoverflow.com/questions/48732/how-to-detect-types-of-an-object-in-javascript}\n *\n * @param x: any\n * @returns boolean\n */\nfunctio {\n    return x !== null && x !== undefined;\n}\nexport class RNG {\n    private _index: number;\n    constructor() {\n        this._index = 0;\n    }\n    /**\n     * Generate a 624 number\n     *\n     * @remarks\n     * Based on the index-th value, calling {@link #generateNumbers() = 0;\n    private _state: number[];\n     */\n    private generateNumbers() {\n        let y;\n        const MT = this._state;\n        for (let i = 0; i < 624; i++) {\n            // Bit 31 (3 = new Array(624);\n    constructor(private readonly _seed: number);\n            if (i < 16) {\n                y = MT[i + 10];\n            } else {\n                y = MT[i - 17];\n            }\n            y = y ^ y >>> 1 = (Math.random() * 4294967295) | 0) {\n        this._state[0] = _seed;\n        const MT = this._state;\n        for (let i = 1; i < 624; i++) {\n            MT[i] = MT[i - 1] ^ (MT[i - 1] >>> 30);\n            MT[i] = 1812433253 * MT[i] + i; // 1812433253\n            MT[i] = MT[i] & ((MT[i] << 32) - 1);\n        }\n    }\n    /**\n     * Generate an array of 624 untempered numbers\n     * @returns: void\n     */\n    private generateNumbers(): void {\n        for (let i = 0; i < 624; i++) {\n            // Bit 31 (3 = new Array(624);\n            if (i < 16) {\n                y {\n        let y;\n        const MT = this._state;\n        for (let i = 0; i < 624; i++) {\n            // Bit 31 (32nd bit) of MT[i]\n            y = MT[i] & 2147483648;\n            // Bits 0-30 (first 31 bits) of MT[...]\n            y = y + (MT[(i + 1) % 624] & 2147483647);\n            // The new randomness\n            MT[i] = MT[(i + 397) % 624] ^ (y >>> 1);\n            // In case y is odd\n            if (y % 2 !== 0) {\n                MT[i] = MT[i] ^ 2567483615; // 2567483615\n            }\n        }\n    }\n    /**\n     * Returns a tempered pseudorandom number [0,1]\n     *\n     * @remarks\n     * Based on the index-th value, calling {@link #generateNumbers()} every 624 numbers\n     *\n     * @returns The pseudorandom integer between 0 and 1\n     */\n    uniform(): number {\n        if (this._index === 0)\n            this.generateNumbers();\n        return this._state[this._index++] * 2147483647;\n    }\n    /**\n     * Returns a te {\n        if (this._index === 0)\n            this.generateNumbers();\n        let y = this._state[this._index];\n        y = y ^ (y >>> 11);\n        y = y ^ ((y << 7) & 2636928640); // 2636928640\n        y = y ^ ((y << 15) & 4022730752); // 4022730752\n        y = y ^ (y >>> 18);\n        this._index = (this._index + 1) % 624;\n        return (y >>> 0) * (1 / 4294967296);\n    }\n    /**\n     * Returns a tempered pseudorandom number [0,1]\n     *\n     * @remarks\n     * Same as {@link #uniform()}, just to be\n     * compatible with the Math.random() style API\n     *\n     * @returns The pseudorandom integer between 0 and 1\n     */\n    random(): number {\n        return this.uniform();\n    }\n    /**\n     * Returns a random integer in range [0,623]\n     * @param: min\n     * @param: max\n     * @returns The random integer between `min {\n        return this.uniform();\n    }\n    /**\n     * Returns a random integer in range [min,max]\n     * @param: min\n     * @param: max\n     * @returns The random integer between `min` and `max`\n     */\n    range(min: number, max?: number): number {\n        if (!exists(max)) {\n            max = min!;\n            min = 0;\n        }\n        return min! + Math.floor(this.uniform() * (max! - min, max?: number));\n    }\n    /**\n     * Returns a random integer in range [0,max-min]\n     * @param: min\n     * @param: max\n     * @returns The random integer between `min` and `max-1): `\n     */\n    rangeInt(min: number, max?: number): number {\n        if (!exists(min)) {\n            return this.uniform();\n        }\n        else if (!exists(max)) {\n            max = min!;\n            min = 0;\n        }\n        return min! + Math.floor(this.uniform() * (max! - min!));\n    }\n}\n","score":273,"fallbacked":false,"num_type_errors":76},{"code":"/**\n */\nfunction exists(x: any): boolean {\n    return x!= null && x!== undefined;\n}\n/**\n */\nfunction map<U, V>(xs: T[], f: (x: T) => U): U[] {\n    return xs.ma): U[] {\n        return xs.map(f): U[] {\n            return xs.map(f): U[] {\n                return xs.map(f): U[] {\n                    return xs.map(f): U[] {\n                        return x {\n    return x !== null && x !== undefined;\n}\nexport class RNG {\n    private _index: number;\n    constructor(private _seed = (Math.random() * 4294967295) | 0) {\n        this._index = 0;\n        this._seed = _seed;\n        thi = 0;\n    private _state: any;\n    constructor(private _seed = (Math.random() * 4294967295) | 0) {\n        this._state = new Array(624);\n        for (let i = new Array(624);\n    constructor(private readonly _seed: number) {\n        this._state[i] = this._seed;\n    }\n    private _state: any;\n    private _state: any;\n    constructor(private _seed = (Math.random() * 4294 = (Math.random() * 4294967295) | 0) {\n        this._state[0] = _seed;\n        const MT = this._state;\n        for (let i = 1; i < 624; i++) {\n            MT[i] = MT[i - 1] ^ (MT[i - 1] >>> 30);\n            MT[i] = 1812433253 * MT[i] + i; // 1812433253\n            MT[i] = MT[i] & ((MT[i] << 32) - 1);\n        }\n    }\n    /**\n     * Generate an array of 624 untempered numbers\n     * @returns: void\n     */\n    private generateNumbers(): void {\n        for (let i = 0; i < 624; i++) {\n            this._state[i] = this._state[i] ^ (this._state[i] >>> 30);\n            thi {\n        let y;\n        const MT = this._state;\n        for (let i = 0; i < 624; i++) {\n            // Bit 31 (32nd bit) of MT[i]\n            y = MT[i] & 2147483648;\n            // Bits 0-30 (first 31 bits) of MT[...]\n            y = y + (MT[(i + 1) % 624] & 2147483647);\n            // The new randomness\n            MT[i] = MT[(i + 397) % 624] ^ (y >>> 1);\n            // In case y is odd\n            if (y % 2 !== 0) {\n                MT[i] = MT[i] ^ 2567483615; // 2567483615\n            }\n        }\n    }\n    /**\n     * Returns a tempered pseudorandom number [0,1]\n     *\n     * @remarks\n     * Based on the index-th value, calling {@link #generateNumbers()} every 624 numbers\n     *\n     * @returns The pseudorandom integer between 0 and 1\n     */\n    uniform(): number {\n        if (this._index === 0)\n            this.generateNumbers();\n        let y = this._state[this._index];\n        y = y ^ (y >>> 11);\n        y = y ^ ((y < {\n        if (this._index === 0)\n            this.generateNumbers();\n        let y = this._state[this._index];\n        y = y ^ (y >>> 11);\n        y = y ^ ((y << 7) & 2636928640); // 2636928640\n        y = y ^ ((y << 15) & 4022730752); // 4022730752\n        y = y ^ (y >>> 18);\n        this._index = (this._index + 1) % 624;\n        return (y >>> 0) * (1 / 4294967296);\n    }\n    /**\n     * Returns a tempered pseudorandom number [0,1]\n     *\n     * @remarks\n     * Same as {@link #uniform()}, just to be\n     * compatible with the Math.random() style API\n     *\n     * @returns The pseudorandom integer between 0 and 1\n     */\n    random(): number {\n        return this.uniform();\n    }\n    /**\n     * Returns a random integer in [0,1)\n     *\n     * @remarks\n     * Based on the index-th value, calling {@link #generateNumbers()} every {\n        return this.uniform();\n    }\n    /**\n     * Returns a random integer in range [min,max]\n     * @param: min\n     * @param: max\n     * @returns The random integer between `min` and `max`\n     */\n    range(min: number, max: number): number {\n        if (exists(min)) {\n            if (!exists(max)) {\n                max = min!;\n                min = 0;\n            }\n            return min! + Math.floor(this.unifor, max?: number);\n        }\n        else if (exists(max)) {\n            return Math.floor(this.uniform() * (max! - min!));\n        }\n        else {\n            return this.uniform();\n        }\n    }\n    /**): number {\n        return this.uniform();\n    } */\n    /**\n     * Returns a random integer in range [0,min)\n     * @param: min\n     * @returns The random integer between 0 and `min`\n     */\n    rando {\n        if (!exists(min)) {\n            return this.uniform();\n        }\n        else if (!exists(max)) {\n            max = min!;\n            min = 0;\n        }\n        return min! + Math.floor(this.uniform() * (max! - min!));\n    }\n}\n","score":269,"fallbacked":false,"num_type_errors":127}]}
{"dataset_elem":{"alphanum_fraction":0.4528605963,"avg_line_length":20.6146179402,"content":"const IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*'\nconst KEYWORDS = [\n  'as',\n  'in',\n  'of',\n  'if',\n  'for',\n  'while',\n  'finally',\n  'var',\n  'new',\n  'function',\n  'do',\n  'return',\n  'void',\n  'else',\n  'break',\n  'catch',\n  'instanceof',\n  'with',\n  'throw',\n  'case',\n  'default',\n  'try',\n  'switch',\n  'continue',\n  'typeof',\n  'delete',\n  'let',\n  'yield',\n  'const',\n  'class',\n  'debugger',\n  'async',\n  'await',\n  'static',\n  'import',\n  'from',\n  'export',\n  'extends'\n] as const\nconst LITERALS = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity'] as const\n\nconst TYPES = [\n  'Object',\n  'Function',\n  'Boolean',\n  'Symbol',\n  'Math',\n  'Date',\n  'Number',\n  'BigInt',\n  'String',\n  'RegExp',\n  'Array',\n  'Float32Array',\n  'Float64Array',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Int32Array',\n  'Uint16Array',\n  'Uint32Array',\n  'BigInt64Array',\n  'BigUint64Array',\n  'Set',\n  'Map',\n  'WeakSet',\n  'WeakMap',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'Atomics',\n  'DataView',\n  'JSON',\n  'Promise',\n  'Generator',\n  'GeneratorFunction',\n  'AsyncFunction',\n  'Reflect',\n  'Proxy',\n  'Intl',\n  'WebAssembly'\n] as const\n\nconst ERROR_TYPES = [\n  'Error',\n  'EvalError',\n  'InternalError',\n  'RangeError',\n  'ReferenceError',\n  'SyntaxError',\n  'TypeError',\n  'URIError'\n] as const\n\nconst BUILT_IN_GLOBALS = [\n  'setInterval',\n  'setTimeout',\n  'clearInterval',\n  'clearTimeout',\n  'require',\n  'exports',\n  'eval',\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n  'escape',\n  'unescape'\n] as const\n\nconst BUILT_IN_VARIABLES = [\n  'arguments',\n  'this',\n  'super',\n  'console',\n  'window',\n  'document',\n  'localStorage',\n  'module',\n  'global'\n] as const\n\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES)\n\nexport const javascript = hljs => {\n  const regex = hljs.regex\n  const hasClosingTag = (match, { after }) => {\n    const tag = '</' + match[0].slice(1)\n    const pos = match.input.indexOf(tag, after)\n    return pos !== -1\n  }\n\n  const IDENT_RE$1 = IDENT_RE\n  const FRAGMENT = {\n    begin: '<>',\n    end: '</>'\n  }\n  const XML_SELF_CLOSING: RegExp = /<[A-Za-z0-9\\\\._:-]+\\s*\\/>/\n  const XML_TAG = {\n    begin: /<[A-Za-z0-9\\\\._:-]+/,\n    end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n    isTrulyOpeningTag: (match, response) => {\n      const afterMatchIndex = match[0].length + match.index\n      const nextChar = match.input[afterMatchIndex]\n      if (\n        nextChar === '<' ||\n        nextChar === ','\n      ) {\n        response.ignoreMatch()\n        return\n      }\n      if (nextChar === '>') {\n        if (!hasClosingTag(match, { after: afterMatchIndex })) {\n          response.ignoreMatch()\n        }\n      }\n      let m\n      const afterMatch = match.input.substr(afterMatchIndex)\n      if ((m = afterMatch.match(/^\\s+extends\\s+/))) {\n        if (m.index === 0) {\n          response.ignoreMatch()\n          return\n        }\n      }\n    }\n  }\n  const KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS,\n    built_in: BUILT_INS,\n    'variable.language': BUILT_IN_VARIABLES\n  }\n\n  const decimalDigits = '[0-9](_?[0-9])*'\n  const frac = `\\\\.(${decimalDigits})`\n  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`\n  const NUMBER = {\n    className: 'number',\n    variants: [\n      {\n        begin:\n          `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n          `[eE][+-]?(${decimalDigits})\\\\b`\n      },\n      { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n\n      { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n\n      { begin: '\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b' },\n      { begin: '\\\\b0[bB][0-1](_?[0-1])*n?\\\\b' },\n      { begin: '\\\\b0[oO][0-7](_?[0-7])*n?\\\\b' },\n\n      { begin: '\\\\b0[0-7]+n?\\\\b' }\n    ],\n    relevance: 0\n  }\n\n  const SUBST = {\n    className: 'subst',\n    begin: '\\\\$\\\\{',\n    end: '\\\\}',\n    keywords: KEYWORDS$1,\n    contains: []\n  }\n  const HTML_TEMPLATE = {\n    begin: 'html`',\n    end: '',\n    starts: {\n      end: '`',\n      returnEnd: false,\n      contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n      subLanguage: 'xml'\n    }\n  }\n  const CSS_TEMPLATE = {\n    begin: 'css`',\n    end: '',\n    starts: {\n      end: '`',\n      returnEnd: false,\n      contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n      subLanguage: 'css'\n    }\n  }\n  const TEMPLATE_STRING = {\n    className: 'string',\n    begin: '`',\n    end: '`',\n    contains: [hljs.BACKSLASH_ESCAPE, SUBST]\n  }\n  const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, '\\\\*/', {\n    relevance: 0,\n    contains: [\n      {\n        begin: '(?=@[A-Za-z]+)',\n        relevance: 0,\n        contains: [\n          {\n            className: 'doctag',\n            begin: '@[A-Za-z]+'\n          },\n          {\n            className: 'type',\n            begin: '\\\\{',\n            end: '\\\\}',\n            excludeEnd: true,\n            excludeBegin: true,\n            relevance: 0\n          },\n          {\n            className: 'variable',\n            begin: IDENT_RE$1 + '(?=\\\\s*(-)|$)',\n            endsParent: true,\n            relevance: 0\n          },\n          {\n            begin: /(?=[^\\n])\\s/,\n            relevance: 0\n          }\n        ]\n      }\n    ]\n  })\n  const COMMENT = {\n    className: 'comment',\n    variants: [\n      JSDOC_COMMENT,\n      hljs.C_BLOCK_COMMENT_MODE,\n      hljs.C_LINE_COMMENT_MODE\n    ]\n  }\n  const SUBST_INTERNALS = [\n    hljs.APOS_STRING_MODE,\n    hljs.QUOTE_STRING_MODE,\n    HTML_TEMPLATE,\n    CSS_TEMPLATE,\n    TEMPLATE_STRING,\n    NUMBER\n  ]\n  SUBST.contains = SUBST_INTERNALS.concat({\n    begin: /\\{/,\n    end: /\\}/,\n    keywords: KEYWORDS$1,\n    contains: ['self'].concat(SUBST_INTERNALS)\n  })\n  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains)\n  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n    {\n      begin: /\\(/,\n      end: /\\)/,\n      keywords: KEYWORDS$1,\n      contains: ['self'].concat(SUBST_AND_COMMENTS)\n    }\n  ])\n  const PARAMS = {\n    className: 'params',\n    begin: /\\(/,\n    end: /\\)/,\n    excludeBegin: true,\n    excludeEnd: true,\n    keywords: KEYWORDS$1,\n    contains: PARAMS_CONTAINS\n  }\n\n  const CLASS_OR_EXTENDS = {\n    variants: [\n      {\n        match: [\n          /class/,\n          /\\s+/,\n          IDENT_RE$1,\n          /\\s+/,\n          /extends/,\n          /\\s+/,\n          regex.concat(IDENT_RE$1, '(', regex.concat(/\\./, IDENT_RE$1), ')*')\n        ],\n        scope: {\n          1: 'keyword',\n          3: 'title.class',\n          5: 'keyword',\n          7: 'title.class.inherited'\n        }\n      },\n      {\n        match: [/class/, /\\s+/, IDENT_RE$1],\n        scope: {\n          1: 'keyword',\n          3: 'title.class'\n        }\n      }\n    ]\n  }\n\n  const CLASS_REFERENCE = {\n    relevance: 0,\n    match: regex.either(\n      /\\bJSON/,\n      /\\b[A-Z][a-z]+([A-Z][a-z]*|\\d)*/,\n      /\\b[A-Z]{2,}([A-Z][a-z]+|\\d)+([A-Z][a-z]*)*/,\n      /\\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\\d)*([A-Z][a-z]*)*/\n    ),\n    className: 'title.class',\n    keywords: {\n      _: [\n        ...TYPES,\n        ...ERROR_TYPES\n      ]\n    }\n  }\n\n  const USE_STRICT = {\n    label: 'use_strict',\n    className: 'meta',\n    relevance: 10,\n    begin: /^\\s*['\"]use (strict|asm)['\"]/\n  }\n\n  const FUNCTION_DEFINITION = {\n    variants: [\n      {\n        match: [/function/, /\\s+/, IDENT_RE$1, /(?=\\s*\\()/]\n      },\n      {\n        match: [/function/, /\\s*(?=\\()/]\n      }\n    ],\n    className: {\n      1: 'keyword',\n      3: 'title.function'\n    },\n    label: 'func.def',\n    contains: [PARAMS],\n    illegal: /%/\n  }\n\n  const UPPER_CASE_CONSTANT = {\n    relevance: 0,\n    match: /\\b[A-Z][A-Z_0-9]+\\b/,\n    className: 'variable.constant'\n  }\n\n  function noneOf(list) {\n    return regex.concat('(?!', list.join('|'), ')')\n  }\n\n  const FUNCTION_CALL = {\n    match: regex.concat(\n      /\\b/,\n      noneOf([...BUILT_IN_GLOBALS, 'super']),\n      IDENT_RE$1,\n      regex.lookahead(/\\(/)\n    ),\n    className: 'title.function',\n    relevance: 0\n  }\n\n  const PROPERTY_ACCESS = {\n    begin: regex.concat(\n      /\\./,\n      regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))\n    ),\n    end: IDENT_RE$1,\n    excludeBegin: true,\n    keywords: 'prototype',\n    className: 'property',\n    relevance: 0\n  }\n\n  const GETTER_OR_SETTER = {\n    match: [/get|set/, /\\s+/, IDENT_RE$1, /(?=\\()/],\n    className: {\n      1: 'keyword',\n      3: 'title.function'\n    },\n    contains: [\n      {\n        begin: /\\(\\)/\n      },\n      PARAMS\n    ]\n  }\n\n  const FUNC_LEAD_IN_RE =\n    '(\\\\(' +\n    '[^()]*(\\\\(' +\n    '[^()]*(\\\\(' +\n    '[^()]*' +\n    '\\\\)[^()]*)*' +\n    '\\\\)[^()]*)*' +\n    '\\\\)|' +\n    hljs.UNDERSCORE_IDENT_RE +\n    ')\\\\s*=>'\n\n  const FUNCTION_VARIABLE = {\n    match: [\n      /const|var|let/,\n      /\\s+/,\n      IDENT_RE$1,\n      /\\s*/,\n      /=\\s*/,\n      /(async\\s*)?/,\n      regex.lookahead(FUNC_LEAD_IN_RE)\n    ],\n    keywords: 'async',\n    className: {\n      1: 'keyword',\n      3: 'title.function'\n    },\n    contains: [PARAMS]\n  }\n\n  return {\n    name: 'Javascript',\n    aliases: ['js', 'jsx', 'mjs', 'cjs'],\n    keywords: KEYWORDS$1,\n    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },\n    illegal: /#(?![$_A-z])/,\n    contains: [\n      hljs.SHEBANG({\n        label: 'shebang',\n        binary: 'node',\n        relevance: 5\n      }),\n      USE_STRICT,\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      HTML_TEMPLATE,\n      CSS_TEMPLATE,\n      TEMPLATE_STRING,\n      COMMENT,\n      NUMBER,\n      CLASS_REFERENCE,\n      {\n        className: 'attr',\n        begin: IDENT_RE$1 + regex.lookahead(':'),\n        relevance: 0\n      },\n      FUNCTION_VARIABLE,\n      {\n        begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',\n        keywords: 'return throw case',\n        relevance: 0,\n        contains: [\n          COMMENT,\n          hljs.REGEXP_MODE,\n          {\n            className: 'function',\n            begin: FUNC_LEAD_IN_RE,\n            returnBegin: true,\n            end: '\\\\s*=>',\n            contains: [\n              {\n                className: 'params',\n                variants: [\n                  {\n                    begin: hljs.UNDERSCORE_IDENT_RE,\n                    relevance: 0\n                  },\n                  {\n                    className: null,\n                    begin: /\\(\\s*\\)/,\n                    skip: true\n                  },\n                  {\n                    begin: /\\(/,\n                    end: /\\)/,\n                    excludeBegin: true,\n                    excludeEnd: true,\n                    keywords: KEYWORDS$1,\n                    contains: PARAMS_CONTAINS\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            begin: /,/,\n            relevance: 0\n          },\n          {\n            match: /\\s+/,\n            relevance: 0\n          },\n          {\n            variants: [\n              { begin: FRAGMENT.begin, end: FRAGMENT.end },\n              { match: XML_SELF_CLOSING },\n              {\n                begin: XML_TAG.begin,\n                'on:begin': XML_TAG.isTrulyOpeningTag,\n                end: XML_TAG.end\n              }\n            ],\n            subLanguage: 'xml',\n            contains: [\n              {\n                begin: XML_TAG.begin,\n                end: XML_TAG.end,\n                skip: true,\n                contains: ['self']\n              }\n            ]\n          }\n        ]\n      },\n      FUNCTION_DEFINITION,\n      {\n        beginKeywords: 'while if switch catch for'\n      },\n      {\n        begin:\n          '\\\\b(?!function)' +\n          hljs.UNDERSCORE_IDENT_RE +\n          '\\\\(' +\n          '[^()]*(\\\\(' +\n          '[^()]*(\\\\(' +\n          '[^()]*' +\n          '\\\\)[^()]*)*' +\n          '\\\\)[^()]*)*' +\n          '\\\\)\\\\s*\\\\{',\n        returnBegin: true,\n        label: 'func.def',\n        contains: [\n          PARAMS,\n          hljs.inherit(hljs.TITLE_MODE, {\n            begin: IDENT_RE$1,\n            className: 'title.function'\n          })\n        ]\n      },\n      {\n        match: /\\.\\.\\./,\n        relevance: 0\n      },\n      PROPERTY_ACCESS,\n      {\n        match: '\\\\$' + IDENT_RE$1,\n        relevance: 0\n      },\n      {\n        match: [/\\bconstructor(?=\\s*\\()/],\n        className: { 1: 'title.function' },\n        contains: [PARAMS]\n      },\n      FUNCTION_CALL,\n      UPPER_CASE_CONSTANT,\n      CLASS_OR_EXTENDS,\n      GETTER_OR_SETTER,\n      {\n        match: /\\$[(.]/\n      }\n    ]\n  }\n}\n","content_without_annotations":"const IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*'\nconst KEYWORDS = [\n  'as',\n  'in',\n  'of',\n  'if',\n  'for',\n  'while',\n  'finally',\n  'var',\n  'new',\n  'function',\n  'do',\n  'return',\n  'void',\n  'else',\n  'break',\n  'catch',\n  'instanceof',\n  'with',\n  'throw',\n  'case',\n  'default',\n  'try',\n  'switch',\n  'continue',\n  'typeof',\n  'delete',\n  'let',\n  'yield',\n  'const',\n  'class',\n  'debugger',\n  'async',\n  'await',\n  'static',\n  'import',\n  'from',\n  'export',\n  'extends'\n] as const\nconst LITERALS = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity'] as const\n\nconst TYPES = [\n  'Object',\n  'Function',\n  'Boolean',\n  'Symbol',\n  'Math',\n  'Date',\n  'Number',\n  'BigInt',\n  'String',\n  'RegExp',\n  'Array',\n  'Float32Array',\n  'Float64Array',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Int32Array',\n  'Uint16Array',\n  'Uint32Array',\n  'BigInt64Array',\n  'BigUint64Array',\n  'Set',\n  'Map',\n  'WeakSet',\n  'WeakMap',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'Atomics',\n  'DataView',\n  'JSON',\n  'Promise',\n  'Generator',\n  'GeneratorFunction',\n  'AsyncFunction',\n  'Reflect',\n  'Proxy',\n  'Intl',\n  'WebAssembly'\n] as const\n\nconst ERROR_TYPES = [\n  'Error',\n  'EvalError',\n  'InternalError',\n  'RangeError',\n  'ReferenceError',\n  'SyntaxError',\n  'TypeError',\n  'URIError'\n] as const\n\nconst BUILT_IN_GLOBALS = [\n  'setInterval',\n  'setTimeout',\n  'clearInterval',\n  'clearTimeout',\n  'require',\n  'exports',\n  'eval',\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n  'escape',\n  'unescape'\n] as const\n\nconst BUILT_IN_VARIABLES = [\n  'arguments',\n  'this',\n  'super',\n  'console',\n  'window',\n  'document',\n  'localStorage',\n  'module',\n  'global'\n] as const\n\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES)\n\nexport const javascript = hljs => {\n  const regex = hljs.regex\n  const hasClosingTag = (match, { after }) => {\n    const tag = '</' + match[0].slice(1)\n    const pos = match.input.indexOf(tag, after)\n    return pos !== -1\n  }\n\n  const IDENT_RE$1 = IDENT_RE\n  const FRAGMENT = {\n    begin: '<>',\n    end: '</>'\n  }\n  const XML_SELF_CLOSING = /<[A-Za-z0-9\\\\._:-]+\\s*\\/>/\n  const XML_TAG = {\n    begin: /<[A-Za-z0-9\\\\._:-]+/,\n    end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n    isTrulyOpeningTag: (match, response) => {\n      const afterMatchIndex = match[0].length + match.index\n      const nextChar = match.input[afterMatchIndex]\n      if (\n        nextChar === '<' ||\n        nextChar === ','\n      ) {\n        response.ignoreMatch()\n        return\n      }\n      if (nextChar === '>') {\n        if (!hasClosingTag(match, { after: afterMatchIndex })) {\n          response.ignoreMatch()\n        }\n      }\n      let m\n      const afterMatch = match.input.substr(afterMatchIndex)\n      if ((m = afterMatch.match(/^\\s+extends\\s+/))) {\n        if (m.index === 0) {\n          response.ignoreMatch()\n          return\n        }\n      }\n    }\n  }\n  const KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS,\n    built_in: BUILT_INS,\n    'variable.language': BUILT_IN_VARIABLES\n  }\n\n  const decimalDigits = '[0-9](_?[0-9])*'\n  const frac = `\\\\.(${decimalDigits})`\n  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`\n  const NUMBER = {\n    className: 'number',\n    variants: [\n      {\n        begin:\n          `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n          `[eE][+-]?(${decimalDigits})\\\\b`\n      },\n      { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n\n      { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n\n      { begin: '\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b' },\n      { begin: '\\\\b0[bB][0-1](_?[0-1])*n?\\\\b' },\n      { begin: '\\\\b0[oO][0-7](_?[0-7])*n?\\\\b' },\n\n      { begin: '\\\\b0[0-7]+n?\\\\b' }\n    ],\n    relevance: 0\n  }\n\n  const SUBST = {\n    className: 'subst',\n    begin: '\\\\$\\\\{',\n    end: '\\\\}',\n    keywords: KEYWORDS$1,\n    contains: []\n  }\n  const HTML_TEMPLATE = {\n    begin: 'html`',\n    end: '',\n    starts: {\n      end: '`',\n      returnEnd: false,\n      contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n      subLanguage: 'xml'\n    }\n  }\n  const CSS_TEMPLATE = {\n    begin: 'css`',\n    end: '',\n    starts: {\n      end: '`',\n      returnEnd: false,\n      contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n      subLanguage: 'css'\n    }\n  }\n  const TEMPLATE_STRING = {\n    className: 'string',\n    begin: '`',\n    end: '`',\n    contains: [hljs.BACKSLASH_ESCAPE, SUBST]\n  }\n  const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, '\\\\*/', {\n    relevance: 0,\n    contains: [\n      {\n        begin: '(?=@[A-Za-z]+)',\n        relevance: 0,\n        contains: [\n          {\n            className: 'doctag',\n            begin: '@[A-Za-z]+'\n          },\n          {\n            className: 'type',\n            begin: '\\\\{',\n            end: '\\\\}',\n            excludeEnd: true,\n            excludeBegin: true,\n            relevance: 0\n          },\n          {\n            className: 'variable',\n            begin: IDENT_RE$1 + '(?=\\\\s*(-)|$)',\n            endsParent: true,\n            relevance: 0\n          },\n          {\n            begin: /(?=[^\\n])\\s/,\n            relevance: 0\n          }\n        ]\n      }\n    ]\n  })\n  const COMMENT = {\n    className: 'comment',\n    variants: [\n      JSDOC_COMMENT,\n      hljs.C_BLOCK_COMMENT_MODE,\n      hljs.C_LINE_COMMENT_MODE\n    ]\n  }\n  const SUBST_INTERNALS = [\n    hljs.APOS_STRING_MODE,\n    hljs.QUOTE_STRING_MODE,\n    HTML_TEMPLATE,\n    CSS_TEMPLATE,\n    TEMPLATE_STRING,\n    NUMBER\n  ]\n  SUBST.contains = SUBST_INTERNALS.concat({\n    begin: /\\{/,\n    end: /\\}/,\n    keywords: KEYWORDS$1,\n    contains: ['self'].concat(SUBST_INTERNALS)\n  })\n  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains)\n  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n    {\n      begin: /\\(/,\n      end: /\\)/,\n      keywords: KEYWORDS$1,\n      contains: ['self'].concat(SUBST_AND_COMMENTS)\n    }\n  ])\n  const PARAMS = {\n    className: 'params',\n    begin: /\\(/,\n    end: /\\)/,\n    excludeBegin: true,\n    excludeEnd: true,\n    keywords: KEYWORDS$1,\n    contains: PARAMS_CONTAINS\n  }\n\n  const CLASS_OR_EXTENDS = {\n    variants: [\n      {\n        match: [\n          /class/,\n          /\\s+/,\n          IDENT_RE$1,\n          /\\s+/,\n          /extends/,\n          /\\s+/,\n          regex.concat(IDENT_RE$1, '(', regex.concat(/\\./, IDENT_RE$1), ')*')\n        ],\n        scope: {\n          1: 'keyword',\n          3: 'title.class',\n          5: 'keyword',\n          7: 'title.class.inherited'\n        }\n      },\n      {\n        match: [/class/, /\\s+/, IDENT_RE$1],\n        scope: {\n          1: 'keyword',\n          3: 'title.class'\n        }\n      }\n    ]\n  }\n\n  const CLASS_REFERENCE = {\n    relevance: 0,\n    match: regex.either(\n      /\\bJSON/,\n      /\\b[A-Z][a-z]+([A-Z][a-z]*|\\d)*/,\n      /\\b[A-Z]{2,}([A-Z][a-z]+|\\d)+([A-Z][a-z]*)*/,\n      /\\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\\d)*([A-Z][a-z]*)*/\n    ),\n    className: 'title.class',\n    keywords: {\n      _: [\n        ...TYPES,\n        ...ERROR_TYPES\n      ]\n    }\n  }\n\n  const USE_STRICT = {\n    label: 'use_strict',\n    className: 'meta',\n    relevance: 10,\n    begin: /^\\s*['\"]use (strict|asm)['\"]/\n  }\n\n  const FUNCTION_DEFINITION = {\n    variants: [\n      {\n        match: [/function/, /\\s+/, IDENT_RE$1, /(?=\\s*\\()/]\n      },\n      {\n        match: [/function/, /\\s*(?=\\()/]\n      }\n    ],\n    className: {\n      1: 'keyword',\n      3: 'title.function'\n    },\n    label: 'func.def',\n    contains: [PARAMS],\n    illegal: /%/\n  }\n\n  const UPPER_CASE_CONSTANT = {\n    relevance: 0,\n    match: /\\b[A-Z][A-Z_0-9]+\\b/,\n    className: 'variable.constant'\n  }\n\n  function noneOf(list) {\n    return regex.concat('(?!', list.join('|'), ')')\n  }\n\n  const FUNCTION_CALL = {\n    match: regex.concat(\n      /\\b/,\n      noneOf([...BUILT_IN_GLOBALS, 'super']),\n      IDENT_RE$1,\n      regex.lookahead(/\\(/)\n    ),\n    className: 'title.function',\n    relevance: 0\n  }\n\n  const PROPERTY_ACCESS = {\n    begin: regex.concat(\n      /\\./,\n      regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))\n    ),\n    end: IDENT_RE$1,\n    excludeBegin: true,\n    keywords: 'prototype',\n    className: 'property',\n    relevance: 0\n  }\n\n  const GETTER_OR_SETTER = {\n    match: [/get|set/, /\\s+/, IDENT_RE$1, /(?=\\()/],\n    className: {\n      1: 'keyword',\n      3: 'title.function'\n    },\n    contains: [\n      {\n        begin: /\\(\\)/\n      },\n      PARAMS\n    ]\n  }\n\n  const FUNC_LEAD_IN_RE =\n    '(\\\\(' +\n    '[^()]*(\\\\(' +\n    '[^()]*(\\\\(' +\n    '[^()]*' +\n    '\\\\)[^()]*)*' +\n    '\\\\)[^()]*)*' +\n    '\\\\)|' +\n    hljs.UNDERSCORE_IDENT_RE +\n    ')\\\\s*=>'\n\n  const FUNCTION_VARIABLE = {\n    match: [\n      /const|var|let/,\n      /\\s+/,\n      IDENT_RE$1,\n      /\\s*/,\n      /=\\s*/,\n      /(async\\s*)?/,\n      regex.lookahead(FUNC_LEAD_IN_RE)\n    ],\n    keywords: 'async',\n    className: {\n      1: 'keyword',\n      3: 'title.function'\n    },\n    contains: [PARAMS]\n  }\n\n  return {\n    name: 'Javascript',\n    aliases: ['js', 'jsx', 'mjs', 'cjs'],\n    keywords: KEYWORDS$1,\n    exports: { PARAMS_CONTAINS, CLASS_REFERENCE },\n    illegal: /#(?![$_A-z])/,\n    contains: [\n      hljs.SHEBANG({\n        label: 'shebang',\n        binary: 'node',\n        relevance: 5\n      }),\n      USE_STRICT,\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      HTML_TEMPLATE,\n      CSS_TEMPLATE,\n      TEMPLATE_STRING,\n      COMMENT,\n      NUMBER,\n      CLASS_REFERENCE,\n      {\n        className: 'attr',\n        begin: IDENT_RE$1 + regex.lookahead(':'),\n        relevance: 0\n      },\n      FUNCTION_VARIABLE,\n      {\n        begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',\n        keywords: 'return throw case',\n        relevance: 0,\n        contains: [\n          COMMENT,\n          hljs.REGEXP_MODE,\n          {\n            className: 'function',\n            begin: FUNC_LEAD_IN_RE,\n            returnBegin: true,\n            end: '\\\\s*=>',\n            contains: [\n              {\n                className: 'params',\n                variants: [\n                  {\n                    begin: hljs.UNDERSCORE_IDENT_RE,\n                    relevance: 0\n                  },\n                  {\n                    className: null,\n                    begin: /\\(\\s*\\)/,\n                    skip: true\n                  },\n                  {\n                    begin: /\\(/,\n                    end: /\\)/,\n                    excludeBegin: true,\n                    excludeEnd: true,\n                    keywords: KEYWORDS$1,\n                    contains: PARAMS_CONTAINS\n                  }\n                ]\n              }\n            ]\n          },\n          {\n            begin: /,/,\n            relevance: 0\n          },\n          {\n            match: /\\s+/,\n            relevance: 0\n          },\n          {\n            variants: [\n              { begin: FRAGMENT.begin, end: FRAGMENT.end },\n              { match: XML_SELF_CLOSING },\n              {\n                begin: XML_TAG.begin,\n                'on:begin': XML_TAG.isTrulyOpeningTag,\n                end: XML_TAG.end\n              }\n            ],\n            subLanguage: 'xml',\n            contains: [\n              {\n                begin: XML_TAG.begin,\n                end: XML_TAG.end,\n                skip: true,\n                contains: ['self']\n              }\n            ]\n          }\n        ]\n      },\n      FUNCTION_DEFINITION,\n      {\n        beginKeywords: 'while if switch catch for'\n      },\n      {\n        begin:\n          '\\\\b(?!function)' +\n          hljs.UNDERSCORE_IDENT_RE +\n          '\\\\(' +\n          '[^()]*(\\\\(' +\n          '[^()]*(\\\\(' +\n          '[^()]*' +\n          '\\\\)[^()]*)*' +\n          '\\\\)[^()]*)*' +\n          '\\\\)\\\\s*\\\\{',\n        returnBegin: true,\n        label: 'func.def',\n        contains: [\n          PARAMS,\n          hljs.inherit(hljs.TITLE_MODE, {\n            begin: IDENT_RE$1,\n            className: 'title.function'\n          })\n        ]\n      },\n      {\n        match: /\\.\\.\\./,\n        relevance: 0\n      },\n      PROPERTY_ACCESS,\n      {\n        match: '\\\\$' + IDENT_RE$1,\n        relevance: 0\n      },\n      {\n        match: [/\\bconstructor(?=\\s*\\()/],\n        className: { 1: 'title.function' },\n        contains: [PARAMS]\n      },\n      FUNCTION_CALL,\n      UPPER_CASE_CONSTANT,\n      CLASS_OR_EXTENDS,\n      GETTER_OR_SETTER,\n      {\n        match: /\\$[(.]/\n      }\n    ]\n  }\n}\n","dynamism_density":0.0015868818,"dynamism_heuristic":6,"estimated_tokens":3781,"ext":"ts","fun_ann_density":0.002644803,"function_parameters":6,"function_signatures":0,"function_usages":2,"functions":4,"hexsha":"2a968018b71746a75b3e52c18dc31914f2533cfa","lang":"TypeScript","loc":577,"loc_per_function":119.25,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"d17443a5ada2d3a825f7529cbb54a8d396783364","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"Tyh2001/bright-code","max_forks_repo_path":"src/bright-code/code/javascript.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"d17443a5ada2d3a825f7529cbb54a8d396783364","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"Tyh2001/bright-code","max_issues_repo_path":"src/bright-code/code/javascript.ts","max_line_length":83,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"d17443a5ada2d3a825f7529cbb54a8d396783364","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"Tyh2001/bright-code","max_stars_repo_path":"src/bright-code/code/javascript.ts","max_stars_repo_stars_event_max_datetime":"2022-03-27T14:36:32.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-27T14:36:32.000Z","metric":0.2167564106,"predefined_density":0.0,"predefined_types":0,"prop_ann_density":0.0,"property_declarations":0,"size":12410,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0121660936,"variable_declarations":46},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"const IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\nconst KEYWORDS = [\n    \"as\",\n    \"in\",\n    \"of\",\n    \"if\",\n    \"for\",\n    \"while\",\n    \"finally\",\n    \"var\",\n    \"new\",\n    \"function\",\n    \"do\",\n    \"return\",\n    \"void\",\n    \"else\",\n    \"break\",\n    \"catch\",\n    \"instanceof\",\n    \"with\",\n    \"throw\",\n    \"case\",\n    \"default\",\n    \"try\",\n    \"switch\",\n    \"continue\",\n    \"typeof\",\n    \"delete\",\n    \"let\",\n    \"yield\",\n    \"const\",\n    \"class\",\n    \"debugger\",\n    \"async\",\n    \"await\",\n    \"static\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"extends\"\n] as const;\nconst LITERALS = [\"true\", \"false\", \"null\", \"undefined\", \"NaN\", \"Infinity\"] as const;\nconst TYPES = [\n    \"Object\",\n    \"Function\",\n    \"Boolean\",\n    \"Symbol\",\n    \"Math\",\n    \"Date\",\n    \"Number\",\n    \"BigInt\",\n    \"String\",\n    \"RegExp\",\n    \"Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Int8Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    \"Set\",\n    \"Map\",\n    \"WeakSet\",\n    \"WeakMap\",\n    \"ArrayBuffer\",\n    \"SharedArrayBuffer\",\n    \"Atomics\",\n    \"DataView\",\n    \"JSON\",\n    \"Promise\",\n    \"Generator\",\n    \"GeneratorFunction\",\n    \"AsyncFunction\",\n    \"Reflect\",\n    \"Proxy\",\n    \"Intl\",\n    \"WebAssembly\"\n] as const;\nconst ERROR_TYPES = [\n    \"Error\",\n    \"EvalError\",\n    \"InternalError\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"URIError\"\n] as const;\nconst BUILT_IN_GLOBALS = [\n    \"setInterval\",\n    \"setTimeout\",\n    \"clearInterval\",\n    \"clearTimeout\",\n    \"require\",\n    \"exports\",\n    \"eval\",\n    \"isFinite\",\n    \"isNaN\",\n    \"parseFloat\",\n    \"parseInt\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"escape\",\n    \"unescape\"\n] as const;\nconst BUILT_IN_VARIABLES = [\n    \"arguments\",\n    \"this\",\n    \"super\",\n    \"console\",\n    \"window\",\n    \"document\",\n    \"localStorage\",\n    \"module\",\n    \"global\"\n] as const;\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);\nexport const javascript = (hljs: Hljs) => {\n    const IDENT_RE = \"(?:(?:[A-Za-z](?:[A-Za-z](?:[A-Za-z](?:[A-Za-z](?:[A-Za-z): A-Za-z](?:[A-Za-z](?:[A-Za-z](?:[A-Za-z](?:[A-Za-z](?:[A-Za-z](?:[A-Za-z]:|[ => {\n    const regex = hljs.regex;\n    const hasClosingTag = (match: [0]) => {\n        const tag = match[0].slice(1);\n        return tag === \"/>\";\n    };\n    const XML_SELF_CLOSING = regex.lookbehind(IDENT_RE$1, {\n        en, { after }: {\n            before: {\n                before: regex.lookahead(/\"/),\n                end: /$/,\n                skipToEnd: true\n            }\n        }\n    });\n    const XML_END_TAG = regex.lookbehind(IDENT_R): (match, response) => {\n        const afterMatchIndex = match[0].length + match.input.length;\n        return hasClosingTag(match) && afterMatchIndex === match.index;\n    };\n    const XML_END => {\n        const tag = \"</\" + match[0].slice(1);\n        const pos = match.input.indexOf(tag, after);\n        return pos !== -1;\n    };\n    const IDENT_RE$1 = IDENT_RE;\n    const FRAGMENT = {\n        begin: \"<>\",\n        end: \"</>\"\n    };\n    const XML_SELF_CLOSING = /<[A-Za-z0-9\\\\._:-]+\\s*\\/>/;\n    const XML_TAG = {\n        begin: /<[A-Za-z0-9\\\\._:-]+/,\n        end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n        isTrulyOpeningTag: (match: [0]) => {\n            const tag = match[0].slice(1);\n            if (tag === \"!--\" || tag === \"doctype\") {\n                return false;\n            }\n            return tag.charAt(0) === \"<\";, response: {\n                ignoreMatch: () => {\n                    response.ignoreMatch();\n                    response.allowUnescaped(false);\n                }\n            };\n        },\n        isClosingTag: (match: [0]) => {\n            const tag = match[0]): (match, response) => {\n                const afterMatchIndex = match[0].length + match.index;\n                return hasClosingTag(match) && afterMatchIndex === match.index;\n            };\n            const after = match.input => {\n            const afterMatchIndex = match[0].length + match.index;\n            const nextChar = match.input[afterMatchIndex];\n            if (nextChar === \"<\" ||\n                nextChar === \",\") {\n                response.ignoreMatch();\n                return;\n            }\n            if (nextChar === \">\") {\n                if (!hasClosingTag(match, { after: afterMatchIndex })) {\n                    response.ignoreMatch();\n                }\n            }\n            let m;\n            const afterMatch = match.input.substr(afterMatchIndex);\n            if ((m = afterMatch.match(/^\\s+extends\\s+/))) {\n                if (m.index === 0) {\n                    response.ignoreMatch();\n                    return;\n                }\n            }\n        }\n    };\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS,\n        literal: LITERALS,\n        built_in: BUILT_INS,\n        \"variable.language\": BUILT_IN_VARIABLES\n    };\n    const decimalDigits = \"[0-9](_?[0-9])*\";\n    const frac = `\\\\.(${decimalDigits})`;\n    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n    const NUMBER = {\n        className: \"number\",\n        variants: [\n            {\n                begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n                    `[eE][+-]?(${decimalDigits})\\\\b`\n            },\n            { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n            { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n            { begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\" },\n            { begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\" },\n            { begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\" },\n            { begin: \"\\\\b0[0-7]+n?\\\\b\" }\n        ],\n        relevance: 0\n    };\n    const SUBST = {\n        className: \"subst\",\n        begin: \"\\\\$\\\\{\",\n        end: \"\\\\}\",\n        keywords: KEYWORDS$1,\n        contains: []\n    };\n    const HTML_TEMPLATE = {\n        begin: \"html`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n            subLanguage: \"xml\"\n        }\n    };\n    const CSS_TEMPLATE = {\n        begin: \"css`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n            subLanguage: \"css\"\n        }\n    };\n    const TEMPLATE_STRING = {\n        className: \"string\",\n        begin: \"`\",\n        end: \"`\",\n        contains: [hljs.BACKSLASH_ESCAPE, SUBST]\n    };\n    const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, \"\\\\*/\", {\n        relevance: 0,\n        contains: [\n            {\n                begin: \"(?=@[A-Za-z]+)\",\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"doctag\",\n                        begin: \"@[A-Za-z]+\"\n                    },\n                    {\n                        className: \"type\",\n                        begin: \"\\\\{\",\n                        end: \"\\\\}\",\n                        excludeEnd: true,\n                        excludeBegin: true,\n                        relevance: 0\n                    },\n                    {\n                        className: \"variable\",\n                        begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                        endsParent: true,\n                        relevance: 0\n                    },\n                    {\n                        begin: /(?=[^\\n])\\s/,\n                        relevance: 0\n                    }\n                ]\n            }\n        ]\n    });\n    const COMMENT = {\n        className: \"comment\",\n        variants: [\n            JSDOC_COMMENT,\n            hljs.C_BLOCK_COMMENT_MODE,\n            hljs.C_LINE_COMMENT_MODE\n        ]\n    };\n    const SUBST_INTERNALS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        TEMPLATE_STRING,\n        NUMBER\n    ];\n    SUBST.contains = SUBST_INTERNALS.concat({\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS$1,\n        contains: [\"self\"].concat(SUBST_INTERNALS)\n    });\n    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n        {\n            begin: /\\(/,\n            end: /\\)/,\n            keywords: KEYWORDS$1,\n            contains: [\"self\"].concat(SUBST_AND_COMMENTS)\n        }\n    ]);\n    const PARAMS = {\n        className: \"params\",\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: PARAMS_CONTAINS\n    };\n    const CLASS_OR_EXTENDS = {\n        variants: [\n            {\n                match: [\n                    /class/,\n                    /\\s+/,\n                    IDENT_RE$1,\n                    /\\s+/,\n                    /extends/,\n                    /\\s+/,\n                    regex.concat(IDENT_RE$1, \"(\", regex.concat(/\\./, IDENT_RE$1), \")*\")\n                ],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\",\n                    5: \"keyword\",\n                    7: \"title.class.inherited\"\n                }\n            },\n            {\n                match: [/class/, /\\s+/, IDENT_RE$1],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\"\n                }\n            }\n        ]\n    };\n    const CLASS_REFERENCE = {\n        relevance: 0,\n        match: regex.either(/\\bJSON/, /\\b[A-Z][a-z]+([A-Z][a-z]*|\\d)*/, /\\b[A-Z]{2,}([A-Z][a-z]+|\\d)+([A-Z][a-z]*)*/, /\\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\\d)*([A-Z][a-z]*)*/),\n        className: \"title.class\",\n        keywords: {\n            _: [\n                ...TYPES,\n                ...ERROR_TYPES\n            ]\n        }\n    };\n    const USE_STRICT = {\n        label: \"use_strict\",\n        className: \"meta\",\n        relevance: 10,\n        begin: /^\\s*['\"]use (strict|asm)['\"]/\n    };\n    const FUNCTION_DEFINITION = {\n        variants: [\n            {\n                match: [/function/, /\\s+/, IDENT_RE$1, /(?=\\s*\\()/]\n            },\n            {\n                match: [/function/, /\\s*(?=\\()/]\n            }\n        ],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        label: \"func.def\",\n        contains: [PARAMS],\n        illegal: /%/\n    };\n    const UPPER_CASE_CONSTANT = {\n        relevance: 0,\n        match: /\\b[A-Z][A-Z_0-9]+\\b/,\n        className: \"variable.constant\"\n    };\n    function noneOf(list: string[]) {\n        return regex.concat(\"(?!(?:^|[A-Z](?:(?:[A-Z](?:[A-Z](?:[A-Z](?:[A-Z](?:[A-Z](?:[A-Z](?:[): A-Z]|(?:[0-9]|(?:[A-Z]|(?:[0-9][A-Z]|(?:[A-Z]|(?:[0-9][A-Z]|(?:[A-Z]|(?:[0-9][A- {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    const FUNCTION_CALL = {\n        match: regex.concat(/\\b/, noneOf([...BUILT_IN_GLOBALS, \"super\"]), IDENT_RE$1, regex.lookahead(/\\(/)),\n        className: \"title.function\",\n        relevance: 0\n    };\n    const PROPERTY_ACCESS = {\n        begin: regex.concat(/\\./, regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))),\n        end: IDENT_RE$1,\n        excludeBegin: true,\n        keywords: \"prototype\",\n        className: \"property\",\n        relevance: 0\n    };\n    const GETTER_OR_SETTER = {\n        match: [/get|set/, /\\s+/, IDENT_RE$1, /(?=\\()/],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [\n            {\n                begin: /\\(\\)/\n            },\n            PARAMS\n        ]\n    };\n    const FUNC_LEAD_IN_RE = \"(\\\\(\" +\n        \"[^()]*(\\\\(\" +\n        \"[^()]*(\\\\(\" +\n        \"[^()]*\" +\n        \"\\\\)[^()]*)*\" +\n        \"\\\\)[^()]*)*\" +\n        \"\\\\)|\" +\n        hljs.UNDERSCORE_IDENT_RE +\n        \")\\\\s*=>\";\n    const FUNCTION_VARIABLE = {\n        match: [\n            /const|var|let/,\n            /\\s+/,\n            IDENT_RE$1,\n            /\\s*/,\n            /=\\s*/,\n            /(async\\s*)?/,\n            regex.lookahead(FUNC_LEAD_IN_RE)\n        ],\n        keywords: \"async\",\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [PARAMS]\n    };\n    return {\n        name: \"Javascript\",\n        aliases: [\"js\", \"jsx\", \"mjs\", \"cjs\"],\n        keywords: KEYWORDS$1,\n        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },\n        illegal: /#(?![$_A-z])/,\n        contains: [\n            hljs.SHEBANG({\n                label: \"shebang\",\n                binary: \"node\",\n                relevance: 5\n            }),\n            USE_STRICT,\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE,\n            HTML_TEMPLATE,\n            CSS_TEMPLATE,\n            TEMPLATE_STRING,\n            COMMENT,\n            NUMBER,\n            CLASS_REFERENCE,\n            {\n                className: \"attr\",\n                begin: IDENT_RE$1 + regex.lookahead(\":\"),\n                relevance: 0\n            },\n            FUNCTION_VARIABLE,\n            {\n                begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(case|return|throw)\\\\b)\\\\s*\",\n                keywords: \"return throw case\",\n                relevance: 0,\n                contains: [\n                    COMMENT,\n                    hljs.REGEXP_MODE,\n                    {\n                        className: \"function\",\n                        begin: FUNC_LEAD_IN_RE,\n                        returnBegin: true,\n                        end: \"\\\\s*=>\",\n                        contains: [\n                            {\n                                className: \"params\",\n                                variants: [\n                                    {\n                                        begin: hljs.UNDERSCORE_IDENT_RE,\n                                        relevance: 0\n                                    },\n                                    {\n                                        className: null,\n                                        begin: /\\(\\s*\\)/,\n                                        skip: true\n                                    },\n                                    {\n                                        begin: /\\(/,\n                                        end: /\\)/,\n                                        excludeBegin: true,\n                                        excludeEnd: true,\n                                        keywords: KEYWORDS$1,\n                                        contains: PARAMS_CONTAINS\n                                    }\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        begin: /,/,\n                        relevance: 0\n                    },\n                    {\n                        match: /\\s+/,\n                        relevance: 0\n                    },\n                    {\n                        variants: [\n                            { begin: FRAGMENT.begin, end: FRAGMENT.end },\n                            { match: XML_SELF_CLOSING },\n                            {\n                                begin: XML_TAG.begin,\n                                \"on:begin\": XML_TAG.isTrulyOpeningTag,\n                                end: XML_TAG.end\n                            }\n                        ],\n                        subLanguage: \"xml\",\n                        contains: [\n                            {\n                                begin: XML_TAG.begin,\n                                end: XML_TAG.end,\n                                skip: true,\n                                contains: [\"self\"]\n                            }\n                        ]\n                    }\n                ]\n            },\n            FUNCTION_DEFINITION,\n            {\n                beginKeywords: \"while if switch catch for\"\n            },\n            {\n                begin: \"\\\\b(?!function)\" +\n                    hljs.UNDERSCORE_IDENT_RE +\n                    \"\\\\(\" +\n                    \"[^()]*(\\\\(\" +\n                    \"[^()]*(\\\\(\" +\n                    \"[^()]*\" +\n                    \"\\\\)[^()]*)*\" +\n                    \"\\\\)[^()]*)*\" +\n                    \"\\\\)\\\\s*\\\\{\",\n                returnBegin: true,\n                label: \"func.def\",\n                contains: [\n                    PARAMS,\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1,\n                        className: \"title.function\"\n                    })\n                ]\n            },\n            {\n                match: /\\.\\.\\./,\n                relevance: 0\n            },\n            PROPERTY_ACCESS,\n            {\n                match: \"\\\\$\" + IDENT_RE$1,\n                relevance: 0\n            },\n            {\n                match: [/\\bconstructor(?=\\s*\\()/],\n                className: { 1: \"title.function\" },\n                contains: [PARAMS]\n            },\n            FUNCTION_CALL,\n            UPPER_CASE_CONSTANT,\n            CLASS_OR_EXTENDS,\n            GETTER_OR_SETTER,\n            {\n                match: /\\$[(.]/\n            }\n        ]\n    };\n};\n","score":440,"fallbacked":false,"num_type_errors":61},{"code":"const IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\nconst KEYWORDS = [\n    \"as\",\n    \"in\",\n    \"of\",\n    \"if\",\n    \"for\",\n    \"while\",\n    \"finally\",\n    \"var\",\n    \"new\",\n    \"function\",\n    \"do\",\n    \"return\",\n    \"void\",\n    \"else\",\n    \"break\",\n    \"catch\",\n    \"instanceof\",\n    \"with\",\n    \"throw\",\n    \"case\",\n    \"default\",\n    \"try\",\n    \"switch\",\n    \"continue\",\n    \"typeof\",\n    \"delete\",\n    \"let\",\n    \"yield\",\n    \"const\",\n    \"class\",\n    \"debugger\",\n    \"async\",\n    \"await\",\n    \"static\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"extends\"\n] as const;\nconst LITERALS = [\"true\", \"false\", \"null\", \"undefined\", \"NaN\", \"Infinity\"] as const;\nconst TYPES = [\n    \"Object\",\n    \"Function\",\n    \"Boolean\",\n    \"Symbol\",\n    \"Math\",\n    \"Date\",\n    \"Number\",\n    \"BigInt\",\n    \"String\",\n    \"RegExp\",\n    \"Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Int8Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    \"Set\",\n    \"Map\",\n    \"WeakSet\",\n    \"WeakMap\",\n    \"ArrayBuffer\",\n    \"SharedArrayBuffer\",\n    \"Atomics\",\n    \"DataView\",\n    \"JSON\",\n    \"Promise\",\n    \"Generator\",\n    \"GeneratorFunction\",\n    \"AsyncFunction\",\n    \"Reflect\",\n    \"Proxy\",\n    \"Intl\",\n    \"WebAssembly\"\n] as const;\nconst ERROR_TYPES = [\n    \"Error\",\n    \"EvalError\",\n    \"InternalError\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"URIError\"\n] as const;\nconst BUILT_IN_GLOBALS = [\n    \"setInterval\",\n    \"setTimeout\",\n    \"clearInterval\",\n    \"clearTimeout\",\n    \"require\",\n    \"exports\",\n    \"eval\",\n    \"isFinite\",\n    \"isNaN\",\n    \"parseFloat\",\n    \"parseInt\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"escape\",\n    \"unescape\"\n] as const;\nconst BUILT_IN_VARIABLES = [\n    \"arguments\",\n    \"this\",\n    \"super\",\n    \"console\",\n    \"window\",\n    \"document\",\n    \"localStorage\",\n    \"module\",\n    \"global\"\n] as const;\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);\nexport const javascript = (hljs: any) => {\n    const KEYWORDS = KEYWORDS_RE;\n    const LITERALS = LITERALS_RE;\n    const TYPES = TYPES_RE;\n    const TYPES_WITH_REGEX = TYPES_WITH_REGEX_RE): string => {\n        let type: string;\n        if (TYPES.test(type = TYPE_RE.exec(type))) {\n            type = \"Type\";\n        } else if (LITERALS.test(type = LITERAL_RE => {\n    const regex = hljs.regex;\n    const hasClosingTag = (match: RegexMatch) => regex.lookbehind(LITERAL_RE, 1)!.length;\n    return hasClosingTag(LITERAL_RE);\n})) {\n    return type;\n} else {\n    return \"Keyword\";\n}, { after }: { end: \"EOF\" });\n    };\n    const TYPE_RE = /^(Type|Null|Undefined|Boolean|Number|BigInt|Symbol|BigInt64|BigInt32|BigUint64|BigUint32|BigIn): [A-Za-z0-9_-]+/;\n    const LITERAL_RE = /^(true|false|null|undefined|Infinity|NaN|Infinity|NaN|undefined): [a-zA-Z0-9_.-] => {\n        const tag = \"</\" + match[0].slice(1);\n        const pos = match.input.indexOf(tag, after);\n        return pos !== -1;\n    };\n    const IDENT_RE$1 = IDENT_RE;\n    const FRAGMENT = {\n        begin: \"<>\",\n        end: \"</>\"\n    };\n    const XML_SELF_CLOSING = /<[A-Za-z0-9\\\\._:-]+\\s*\\/>/;\n    const XML_TAG = {\n        begin: /<[A-Za-z0-9\\\\._:-]+/,\n        end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n        isTrulyOpeningTag: (match: RegexMatch) => match[1] === match[2],\n        contains: [\n            hljs.HASH_COMMENT_MODE,\n            hljs.COMMENT,\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE, response: (match: RegexMatch, response: Response) => {\n                response.skipToEnd();\n                return true;\n            }\n        ]\n    };\n    const XML_TAG_END = {\n        begin: /<\\/[A-Za-): \\s]>/,\n        end: /<\\/[A-Za-z0-9\\\\._:-]+>/,\n        contains: [\n            hljs.HASH_COMMENT_MODE,\n            hljs.COMMENT,\n            hljs => {\n            const afterMatchIndex = match[0].length + match.index;\n            const nextChar = match.input[afterMatchIndex];\n            if (nextChar === \"<\" ||\n                nextChar === \",\") {\n                response.ignoreMatch();\n                return;\n            }\n            if (nextChar === \">\") {\n                if (!hasClosingTag(match, { after: afterMatchIndex })) {\n                    response.ignoreMatch();\n                }\n            }\n            let m;\n            const afterMatch = match.input.substr(afterMatchIndex);\n            if ((m = afterMatch.match(/^\\s+extends\\s+/))) {\n                if (m.index === 0) {\n                    response.ignoreMatch();\n                    return;\n                }\n            }\n        }\n    };\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS,\n        literal: LITERALS,\n        built_in: BUILT_INS,\n        \"variable.language\": BUILT_IN_VARIABLES\n    };\n    const decimalDigits = \"[0-9](_?[0-9])*\";\n    const frac = `\\\\.(${decimalDigits})`;\n    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n    const NUMBER = {\n        className: \"number\",\n        variants: [\n            {\n                begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n                    `[eE][+-]?(${decimalDigits})\\\\b`\n            },\n            { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n            { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n            { begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\" },\n            { begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\" },\n            { begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\" },\n            { begin: \"\\\\b0[0-7]+n?\\\\b\" }\n        ],\n        relevance: 0\n    };\n    const SUBST = {\n        className: \"subst\",\n        begin: \"\\\\$\\\\{\",\n        end: \"\\\\}\",\n        keywords: KEYWORDS$1,\n        contains: []\n    };\n    const HTML_TEMPLATE = {\n        begin: \"html`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n            subLanguage: \"xml\"\n        }\n    };\n    const CSS_TEMPLATE = {\n        begin: \"css`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n            subLanguage: \"css\"\n        }\n    };\n    const TEMPLATE_STRING = {\n        className: \"string\",\n        begin: \"`\",\n        end: \"`\",\n        contains: [hljs.BACKSLASH_ESCAPE, SUBST]\n    };\n    const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, \"\\\\*/\", {\n        relevance: 0,\n        contains: [\n            {\n                begin: \"(?=@[A-Za-z]+)\",\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"doctag\",\n                        begin: \"@[A-Za-z]+\"\n                    },\n                    {\n                        className: \"type\",\n                        begin: \"\\\\{\",\n                        end: \"\\\\}\",\n                        excludeEnd: true,\n                        excludeBegin: true,\n                        relevance: 0\n                    },\n                    {\n                        className: \"variable\",\n                        begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                        endsParent: true,\n                        relevance: 0\n                    },\n                    {\n                        begin: /(?=[^\\n])\\s/,\n                        relevance: 0\n                    }\n                ]\n            }\n        ]\n    });\n    const COMMENT = {\n        className: \"comment\",\n        variants: [\n            JSDOC_COMMENT,\n            hljs.C_BLOCK_COMMENT_MODE,\n            hljs.C_LINE_COMMENT_MODE\n        ]\n    };\n    const SUBST_INTERNALS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        TEMPLATE_STRING,\n        NUMBER\n    ];\n    SUBST.contains = SUBST_INTERNALS.concat({\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS$1,\n        contains: [\"self\"].concat(SUBST_INTERNALS)\n    });\n    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n        {\n            begin: /\\(/,\n            end: /\\)/,\n            keywords: KEYWORDS$1,\n            contains: [\"self\"].concat(SUBST_AND_COMMENTS)\n        }\n    ]);\n    const PARAMS = {\n        className: \"params\",\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: PARAMS_CONTAINS\n    };\n    const CLASS_OR_EXTENDS = {\n        variants: [\n            {\n                match: [\n                    /class/,\n                    /\\s+/,\n                    IDENT_RE$1,\n                    /\\s+/,\n                    /extends/,\n                    /\\s+/,\n                    regex.concat(IDENT_RE$1, \"(\", regex.concat(/\\./, IDENT_RE$1), \")*\")\n                ],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\",\n                    5: \"keyword\",\n                    7: \"title.class.inherited\"\n                }\n            },\n            {\n                match: [/class/, /\\s+/, IDENT_RE$1],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\"\n                }\n            }\n        ]\n    };\n    const CLASS_REFERENCE = {\n        relevance: 0,\n        match: regex.either(/\\bJSON/, /\\b[A-Z][a-z]+([A-Z][a-z]*|\\d)*/, /\\b[A-Z]{2,}([A-Z][a-z]+|\\d)+([A-Z][a-z]*)*/, /\\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\\d)*([A-Z][a-z]*)*/),\n        className: \"title.class\",\n        keywords: {\n            _: [\n                ...TYPES,\n                ...ERROR_TYPES\n            ]\n        }\n    };\n    const USE_STRICT = {\n        label: \"use_strict\",\n        className: \"meta\",\n        relevance: 10,\n        begin: /^\\s*['\"]use (strict|asm)['\"]/\n    };\n    const FUNCTION_DEFINITION = {\n        variants: [\n            {\n                match: [/function/, /\\s+/, IDENT_RE$1, /(?=\\s*\\()/]\n            },\n            {\n                match: [/function/, /\\s*(?=\\()/]\n            }\n        ],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        label: \"func.def\",\n        contains: [PARAMS],\n        illegal: /%/\n    };\n    const UPPER_CASE_CONSTANT = {\n        relevance: 0,\n        match: /\\b[A-Z][A-Z_0-9]+\\b/,\n        className: \"variable.constant\"\n    };\n    function noneOf(list: string[]): RegExp {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    function oneOf(list: string[]): RegExp {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }): RegExp {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    const TYPE_OF = {\n        begin: /typeof/,\n        end: regex.either(/'/, /\"/, /true/, /false/) {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    const FUNCTION_CALL = {\n        match: regex.concat(/\\b/, noneOf([...BUILT_IN_GLOBALS, \"super\"]), IDENT_RE$1, regex.lookahead(/\\(/)),\n        className: \"title.function\",\n        relevance: 0\n    };\n    const PROPERTY_ACCESS = {\n        begin: regex.concat(/\\./, regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))),\n        end: IDENT_RE$1,\n        excludeBegin: true,\n        keywords: \"prototype\",\n        className: \"property\",\n        relevance: 0\n    };\n    const GETTER_OR_SETTER = {\n        match: [/get|set/, /\\s+/, IDENT_RE$1, /(?=\\()/],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [\n            {\n                begin: /\\(\\)/\n            },\n            PARAMS\n        ]\n    };\n    const FUNC_LEAD_IN_RE = \"(\\\\(\" +\n        \"[^()]*(\\\\(\" +\n        \"[^()]*(\\\\(\" +\n        \"[^()]*\" +\n        \"\\\\)[^()]*)*\" +\n        \"\\\\)[^()]*)*\" +\n        \"\\\\)|\" +\n        hljs.UNDERSCORE_IDENT_RE +\n        \")\\\\s*=>\";\n    const FUNCTION_VARIABLE = {\n        match: [\n            /const|var|let/,\n            /\\s+/,\n            IDENT_RE$1,\n            /\\s*/,\n            /=\\s*/,\n            /(async\\s*)?/,\n            regex.lookahead(FUNC_LEAD_IN_RE)\n        ],\n        keywords: \"async\",\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [PARAMS]\n    };\n    return {\n        name: \"Javascript\",\n        aliases: [\"js\", \"jsx\", \"mjs\", \"cjs\"],\n        keywords: KEYWORDS$1,\n        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },\n        illegal: /#(?![$_A-z])/,\n        contains: [\n            hljs.SHEBANG({\n                label: \"shebang\",\n                binary: \"node\",\n                relevance: 5\n            }),\n            USE_STRICT,\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE,\n            HTML_TEMPLATE,\n            CSS_TEMPLATE,\n            TEMPLATE_STRING,\n            COMMENT,\n            NUMBER,\n            CLASS_REFERENCE,\n            {\n                className: \"attr\",\n                begin: IDENT_RE$1 + regex.lookahead(\":\"),\n                relevance: 0\n            },\n            FUNCTION_VARIABLE,\n            {\n                begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(case|return|throw)\\\\b)\\\\s*\",\n                keywords: \"return throw case\",\n                relevance: 0,\n                contains: [\n                    COMMENT,\n                    hljs.REGEXP_MODE,\n                    {\n                        className: \"function\",\n                        begin: FUNC_LEAD_IN_RE,\n                        returnBegin: true,\n                        end: \"\\\\s*=>\",\n                        contains: [\n                            {\n                                className: \"params\",\n                                variants: [\n                                    {\n                                        begin: hljs.UNDERSCORE_IDENT_RE,\n                                        relevance: 0\n                                    },\n                                    {\n                                        className: null,\n                                        begin: /\\(\\s*\\)/,\n                                        skip: true\n                                    },\n                                    {\n                                        begin: /\\(/,\n                                        end: /\\)/,\n                                        excludeBegin: true,\n                                        excludeEnd: true,\n                                        keywords: KEYWORDS$1,\n                                        contains: PARAMS_CONTAINS\n                                    }\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        begin: /,/,\n                        relevance: 0\n                    },\n                    {\n                        match: /\\s+/,\n                        relevance: 0\n                    },\n                    {\n                        variants: [\n                            { begin: FRAGMENT.begin, end: FRAGMENT.end },\n                            { match: XML_SELF_CLOSING },\n                            {\n                                begin: XML_TAG.begin,\n                                \"on:begin\": XML_TAG.isTrulyOpeningTag,\n                                end: XML_TAG.end\n                            }\n                        ],\n                        subLanguage: \"xml\",\n                        contains: [\n                            {\n                                begin: XML_TAG.begin,\n                                end: XML_TAG.end,\n                                skip: true,\n                                contains: [\"self\"]\n                            }\n                        ]\n                    }\n                ]\n            },\n            FUNCTION_DEFINITION,\n            {\n                beginKeywords: \"while if switch catch for\"\n            },\n            {\n                begin: \"\\\\b(?!function)\" +\n                    hljs.UNDERSCORE_IDENT_RE +\n                    \"\\\\(\" +\n                    \"[^()]*(\\\\(\" +\n                    \"[^()]*(\\\\(\" +\n                    \"[^()]*\" +\n                    \"\\\\)[^()]*)*\" +\n                    \"\\\\)[^()]*)*\" +\n                    \"\\\\)\\\\s*\\\\{\",\n                returnBegin: true,\n                label: \"func.def\",\n                contains: [\n                    PARAMS,\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1,\n                        className: \"title.function\"\n                    })\n                ]\n            },\n            {\n                match: /\\.\\.\\./,\n                relevance: 0\n            },\n            PROPERTY_ACCESS,\n            {\n                match: \"\\\\$\" + IDENT_RE$1,\n                relevance: 0\n            },\n            {\n                match: [/\\bconstructor(?=\\s*\\()/],\n                className: { 1: \"title.function\" },\n                contains: [PARAMS]\n            },\n            FUNCTION_CALL,\n            UPPER_CASE_CONSTANT,\n            CLASS_OR_EXTENDS,\n            GETTER_OR_SETTER,\n            {\n                match: /\\$[(.]/\n            }\n        ]\n    };\n};\n","score":426,"fallbacked":false,"num_type_errors":68},{"code":"const IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\nconst KEYWORDS = [\n    \"as\",\n    \"in\",\n    \"of\",\n    \"if\",\n    \"for\",\n    \"while\",\n    \"finally\",\n    \"var\",\n    \"new\",\n    \"function\",\n    \"do\",\n    \"return\",\n    \"void\",\n    \"else\",\n    \"break\",\n    \"catch\",\n    \"instanceof\",\n    \"with\",\n    \"throw\",\n    \"case\",\n    \"default\",\n    \"try\",\n    \"switch\",\n    \"continue\",\n    \"typeof\",\n    \"delete\",\n    \"let\",\n    \"yield\",\n    \"const\",\n    \"class\",\n    \"debugger\",\n    \"async\",\n    \"await\",\n    \"static\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"extends\"\n] as const;\nconst LITERALS = [\"true\", \"false\", \"null\", \"undefined\", \"NaN\", \"Infinity\"] as const;\nconst TYPES = [\n    \"Object\",\n    \"Function\",\n    \"Boolean\",\n    \"Symbol\",\n    \"Math\",\n    \"Date\",\n    \"Number\",\n    \"BigInt\",\n    \"String\",\n    \"RegExp\",\n    \"Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Int8Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    \"Set\",\n    \"Map\",\n    \"WeakSet\",\n    \"WeakMap\",\n    \"ArrayBuffer\",\n    \"SharedArrayBuffer\",\n    \"Atomics\",\n    \"DataView\",\n    \"JSON\",\n    \"Promise\",\n    \"Generator\",\n    \"GeneratorFunction\",\n    \"AsyncFunction\",\n    \"Reflect\",\n    \"Proxy\",\n    \"Intl\",\n    \"WebAssembly\"\n] as const;\nconst ERROR_TYPES = [\n    \"Error\",\n    \"EvalError\",\n    \"InternalError\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"URIError\"\n] as const;\nconst BUILT_IN_GLOBALS = [\n    \"setInterval\",\n    \"setTimeout\",\n    \"clearInterval\",\n    \"clearTimeout\",\n    \"require\",\n    \"exports\",\n    \"eval\",\n    \"isFinite\",\n    \"isNaN\",\n    \"parseFloat\",\n    \"parseInt\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"escape\",\n    \"unescape\"\n] as const;\nconst BUILT_IN_VARIABLES = [\n    \"arguments\",\n    \"this\",\n    \"super\",\n    \"console\",\n    \"window\",\n    \"document\",\n    \"localStorage\",\n    \"module\",\n    \"global\"\n] as const;\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);\nexport const javascript = (hljs: HLJS) => {\n    const comment = hljs.COMMENT(\"///.*$\", {\n        contains: [\"self\"]\n    });\n    const string = hljs.QUOTE_STRING(/\".*?\"/, {\n        contains: [\"self\"]\n    })): hljs.inherit(hljs.QUOTE_STRING, {\n        illegal: null\n    });\n    const function_call = /(?<=function\\s+)\\S*(?=\\s*\\()/;\n    const keyword_string = {\n        begin => {\n    const regex = hljs.regex;\n    const hasClosingTag = (match: RegExpMatchArray) => {\n        const tag = match[0].slice(match[0].indexOf(\">\") + 1);\n        return tag.endsWith(\"</\") || tag.endsWith(\"/>\");\n    };\n    const keyword_tag = regex, { after }: { after } => {\n        const match = keyword_tag.exec(after);\n        if (!match) {\n            return null;\n        }\n        const closingTag = hasClosingTag(match);\n        if (!closingTag) {\n            return matc): hljs.C_LINE_COMMENT;\n        }\n        return match[0];\n    };\n    const keyword_re = {\n        begin: /(?:if|else|case|default|for|while|do|return|break|continu => {\n        const tag = \"</\" + match[0].slice(1);\n        const pos = match.input.indexOf(tag, after);\n        return pos !== -1;\n    };\n    const IDENT_RE$1 = IDENT_RE;\n    const FRAGMENT = {\n        begin: \"<>\",\n        end: \"</>\"\n    };\n    const XML_SELF_CLOSING = /<[A-Za-z0-9\\\\._:-]+\\s*\\/>/;\n    const XML_TAG = {\n        begin: /<[A-Za-z0-9\\\\._:-]+/,\n        end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n        isTrulyOpeningTag: (match: RegExpMatchArray) => {\n            return match[1] === \"<\" && match[2] === \"xml\";\n        },\n        contains: [\n            {\n                begin: /\\/$/,\n                end: /\\/$/,\n                contains: [\"self\", response: \"\"]\n            },\n            {\n                begin: /\\/$/,\n                end: /\\/$/,\n                contains: [\"self\"]\n            }\n        ]\n    };\n    const XML_TAG_NAME = {\n        begin: /^<(?:[A-Za-): A-Za-z0-9\\\\._-]+)/,\n        end: /^\\/(?:[A-Za-z0-9\\\\._-]+)\\s*>?/,\n        isTrulyOpeningTag: (match: RegExpMatchArra => {\n            const afterMatchIndex = match[0].length + match.index;\n            const nextChar = match.input[afterMatchIndex];\n            if (nextChar === \"<\" ||\n                nextChar === \",\") {\n                response.ignoreMatch();\n                return;\n            }\n            if (nextChar === \">\") {\n                if (!hasClosingTag(match, { after: afterMatchIndex })) {\n                    response.ignoreMatch();\n                }\n            }\n            let m;\n            const afterMatch = match.input.substr(afterMatchIndex);\n            if ((m = afterMatch.match(/^\\s+extends\\s+/))) {\n                if (m.index === 0) {\n                    response.ignoreMatch();\n                    return;\n                }\n            }\n        }\n    };\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS,\n        literal: LITERALS,\n        built_in: BUILT_INS,\n        \"variable.language\": BUILT_IN_VARIABLES\n    };\n    const decimalDigits = \"[0-9](_?[0-9])*\";\n    const frac = `\\\\.(${decimalDigits})`;\n    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n    const NUMBER = {\n        className: \"number\",\n        variants: [\n            {\n                begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n                    `[eE][+-]?(${decimalDigits})\\\\b`\n            },\n            { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n            { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n            { begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\" },\n            { begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\" },\n            { begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\" },\n            { begin: \"\\\\b0[0-7]+n?\\\\b\" }\n        ],\n        relevance: 0\n    };\n    const SUBST = {\n        className: \"subst\",\n        begin: \"\\\\$\\\\{\",\n        end: \"\\\\}\",\n        keywords: KEYWORDS$1,\n        contains: []\n    };\n    const HTML_TEMPLATE = {\n        begin: \"html`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n            subLanguage: \"xml\"\n        }\n    };\n    const CSS_TEMPLATE = {\n        begin: \"css`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n            subLanguage: \"css\"\n        }\n    };\n    const TEMPLATE_STRING = {\n        className: \"string\",\n        begin: \"`\",\n        end: \"`\",\n        contains: [hljs.BACKSLASH_ESCAPE, SUBST]\n    };\n    const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, \"\\\\*/\", {\n        relevance: 0,\n        contains: [\n            {\n                begin: \"(?=@[A-Za-z]+)\",\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"doctag\",\n                        begin: \"@[A-Za-z]+\"\n                    },\n                    {\n                        className: \"type\",\n                        begin: \"\\\\{\",\n                        end: \"\\\\}\",\n                        excludeEnd: true,\n                        excludeBegin: true,\n                        relevance: 0\n                    },\n                    {\n                        className: \"variable\",\n                        begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                        endsParent: true,\n                        relevance: 0\n                    },\n                    {\n                        begin: /(?=[^\\n])\\s/,\n                        relevance: 0\n                    }\n                ]\n            }\n        ]\n    });\n    const COMMENT = {\n        className: \"comment\",\n        variants: [\n            JSDOC_COMMENT,\n            hljs.C_BLOCK_COMMENT_MODE,\n            hljs.C_LINE_COMMENT_MODE\n        ]\n    };\n    const SUBST_INTERNALS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        TEMPLATE_STRING,\n        NUMBER\n    ];\n    SUBST.contains = SUBST_INTERNALS.concat({\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS$1,\n        contains: [\"self\"].concat(SUBST_INTERNALS)\n    });\n    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n        {\n            begin: /\\(/,\n            end: /\\)/,\n            keywords: KEYWORDS$1,\n            contains: [\"self\"].concat(SUBST_AND_COMMENTS)\n        }\n    ]);\n    const PARAMS = {\n        className: \"params\",\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: PARAMS_CONTAINS\n    };\n    const CLASS_OR_EXTENDS = {\n        variants: [\n            {\n                match: [\n                    /class/,\n                    /\\s+/,\n                    IDENT_RE$1,\n                    /\\s+/,\n                    /extends/,\n                    /\\s+/,\n                    regex.concat(IDENT_RE$1, \"(\", regex.concat(/\\./, IDENT_RE$1), \")*\")\n                ],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\",\n                    5: \"keyword\",\n                    7: \"title.class.inherited\"\n                }\n            },\n            {\n                match: [/class/, /\\s+/, IDENT_RE$1],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\"\n                }\n            }\n        ]\n    };\n    const CLASS_REFERENCE = {\n        relevance: 0,\n        match: regex.either(/\\bJSON/, /\\b[A-Z][a-z]+([A-Z][a-z]*|\\d)*/, /\\b[A-Z]{2,}([A-Z][a-z]+|\\d)+([A-Z][a-z]*)*/, /\\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\\d)*([A-Z][a-z]*)*/),\n        className: \"title.class\",\n        keywords: {\n            _: [\n                ...TYPES,\n                ...ERROR_TYPES\n            ]\n        }\n    };\n    const USE_STRICT = {\n        label: \"use_strict\",\n        className: \"meta\",\n        relevance: 10,\n        begin: /^\\s*['\"]use (strict|asm)['\"]/\n    };\n    const FUNCTION_DEFINITION = {\n        variants: [\n            {\n                match: [/function/, /\\s+/, IDENT_RE$1, /(?=\\s*\\()/]\n            },\n            {\n                match: [/function/, /\\s*(?=\\()/]\n            }\n        ],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        label: \"func.def\",\n        contains: [PARAMS],\n        illegal: /%/\n    };\n    const UPPER_CASE_CONSTANT = {\n        relevance: 0,\n        match: /\\b[A-Z][A-Z_0-9]+\\b/,\n        className: \"variable.constant\"\n    };\n    function noneOf(list: string[]): RegExp {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    function noneOf(list: string[], allowTrailingComma?: boolean): RegExp {\n        if (allowTrailingComma === undefined)\n            allowTrailin): RegExp {\n            allowTrailingComma = true;\n        }\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\", allowTrailingComma? \",\" : \"\");\n    }\n    const KEYWORD_RE = regex.either(/\\b(?:break|cas {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    const FUNCTION_CALL = {\n        match: regex.concat(/\\b/, noneOf([...BUILT_IN_GLOBALS, \"super\"]), IDENT_RE$1, regex.lookahead(/\\(/)),\n        className: \"title.function\",\n        relevance: 0\n    };\n    const PROPERTY_ACCESS = {\n        begin: regex.concat(/\\./, regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))),\n        end: IDENT_RE$1,\n        excludeBegin: true,\n        keywords: \"prototype\",\n        className: \"property\",\n        relevance: 0\n    };\n    const GETTER_OR_SETTER = {\n        match: [/get|set/, /\\s+/, IDENT_RE$1, /(?=\\()/],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [\n            {\n                begin: /\\(\\)/\n            },\n            PARAMS\n        ]\n    };\n    const FUNC_LEAD_IN_RE = \"(\\\\(\" +\n        \"[^()]*(\\\\(\" +\n        \"[^()]*(\\\\(\" +\n        \"[^()]*\" +\n        \"\\\\)[^()]*)*\" +\n        \"\\\\)[^()]*)*\" +\n        \"\\\\)|\" +\n        hljs.UNDERSCORE_IDENT_RE +\n        \")\\\\s*=>\";\n    const FUNCTION_VARIABLE = {\n        match: [\n            /const|var|let/,\n            /\\s+/,\n            IDENT_RE$1,\n            /\\s*/,\n            /=\\s*/,\n            /(async\\s*)?/,\n            regex.lookahead(FUNC_LEAD_IN_RE)\n        ],\n        keywords: \"async\",\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [PARAMS]\n    };\n    return {\n        name: \"Javascript\",\n        aliases: [\"js\", \"jsx\", \"mjs\", \"cjs\"],\n        keywords: KEYWORDS$1,\n        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },\n        illegal: /#(?![$_A-z])/,\n        contains: [\n            hljs.SHEBANG({\n                label: \"shebang\",\n                binary: \"node\",\n                relevance: 5\n            }),\n            USE_STRICT,\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE,\n            HTML_TEMPLATE,\n            CSS_TEMPLATE,\n            TEMPLATE_STRING,\n            COMMENT,\n            NUMBER,\n            CLASS_REFERENCE,\n            {\n                className: \"attr\",\n                begin: IDENT_RE$1 + regex.lookahead(\":\"),\n                relevance: 0\n            },\n            FUNCTION_VARIABLE,\n            {\n                begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(case|return|throw)\\\\b)\\\\s*\",\n                keywords: \"return throw case\",\n                relevance: 0,\n                contains: [\n                    COMMENT,\n                    hljs.REGEXP_MODE,\n                    {\n                        className: \"function\",\n                        begin: FUNC_LEAD_IN_RE,\n                        returnBegin: true,\n                        end: \"\\\\s*=>\",\n                        contains: [\n                            {\n                                className: \"params\",\n                                variants: [\n                                    {\n                                        begin: hljs.UNDERSCORE_IDENT_RE,\n                                        relevance: 0\n                                    },\n                                    {\n                                        className: null,\n                                        begin: /\\(\\s*\\)/,\n                                        skip: true\n                                    },\n                                    {\n                                        begin: /\\(/,\n                                        end: /\\)/,\n                                        excludeBegin: true,\n                                        excludeEnd: true,\n                                        keywords: KEYWORDS$1,\n                                        contains: PARAMS_CONTAINS\n                                    }\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        begin: /,/,\n                        relevance: 0\n                    },\n                    {\n                        match: /\\s+/,\n                        relevance: 0\n                    },\n                    {\n                        variants: [\n                            { begin: FRAGMENT.begin, end: FRAGMENT.end },\n                            { match: XML_SELF_CLOSING },\n                            {\n                                begin: XML_TAG.begin,\n                                \"on:begin\": XML_TAG.isTrulyOpeningTag,\n                                end: XML_TAG.end\n                            }\n                        ],\n                        subLanguage: \"xml\",\n                        contains: [\n                            {\n                                begin: XML_TAG.begin,\n                                end: XML_TAG.end,\n                                skip: true,\n                                contains: [\"self\"]\n                            }\n                        ]\n                    }\n                ]\n            },\n            FUNCTION_DEFINITION,\n            {\n                beginKeywords: \"while if switch catch for\"\n            },\n            {\n                begin: \"\\\\b(?!function)\" +\n                    hljs.UNDERSCORE_IDENT_RE +\n                    \"\\\\(\" +\n                    \"[^()]*(\\\\(\" +\n                    \"[^()]*(\\\\(\" +\n                    \"[^()]*\" +\n                    \"\\\\)[^()]*)*\" +\n                    \"\\\\)[^()]*)*\" +\n                    \"\\\\)\\\\s*\\\\{\",\n                returnBegin: true,\n                label: \"func.def\",\n                contains: [\n                    PARAMS,\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1,\n                        className: \"title.function\"\n                    })\n                ]\n            },\n            {\n                match: /\\.\\.\\./,\n                relevance: 0\n            },\n            PROPERTY_ACCESS,\n            {\n                match: \"\\\\$\" + IDENT_RE$1,\n                relevance: 0\n            },\n            {\n                match: [/\\bconstructor(?=\\s*\\()/],\n                className: { 1: \"title.function\" },\n                contains: [PARAMS]\n            },\n            FUNCTION_CALL,\n            UPPER_CASE_CONSTANT,\n            CLASS_OR_EXTENDS,\n            GETTER_OR_SETTER,\n            {\n                match: /\\$[(.]/\n            }\n        ]\n    };\n};\n","score":417,"fallbacked":false,"num_type_errors":69}]}
{"dataset_elem":{"alphanum_fraction":0.6010854817,"avg_line_length":30.2876712329,"content":"const parsePMM = (data: string, name: string) => {\n  // eslint-disable-next-line no-control-regex\n  const eol = new RegExp(\"\\r?\\n\");\n  // Get all lines except first and the last one (they're garbage)\n  const lines = data.split(eol).slice(1).filter(line => line.length > 1);\n\n  const header = lines[0].replace(/\"/g, '').split(',');\n  // name = header[0] || name;\n\n  // Skip 1 and 2 lines 'cause they're in the header \n  const interpretations = lines.slice(2).map((line, index) => {\n    \n    const params = line.replace(/\\s+/g, '').split(',');\n\n    // ID | CODE | STEPRANGE | N | Dg | Ig | kg | a95g | Ds | Is | ks | a95s | comment \n    // 'kg' and 'ks' - idiotic garbage and, moreover, there is no 'a95' - there is only MAD (Maximum Angular Deviation)\n    const label = params[0];\n    const code = params[1];\n    const stepRange = params[2];\n    const stepCount = Number(params[3]);\n    const Dgeo = Number(params[4]);\n    const Igeo = Number(params[5]);\n    const madGeo = Number(params[7]);\n    const Dstrat = Number(params[8]);\n    const Istrat = Number(params[9]);\n    // const madStrat = Number(params[11]);\n    // but we don't need madStrat and madGeo at the same time - they must be equal, otherwise some of them is incorrect, so...\n    const mad = madGeo;\n    const k = 0;\n\n    // comment may be with spaces\n    let comment = '';\n    for (let i = 12; i < params.length; i++) comment += params[i];\n    comment = comment.trim();\n\n    // there is no standard for demagnetization symbol... and idk why\n    const demagSmbl = stepRange.split('')[0];\n    const thermalTypes = ['T', 't'];\n    const alternatingTypes = ['M', 'm'];\n\n    let demagType: 'thermal' | 'alternating field' | undefined = undefined;\n\n    if (thermalTypes.indexOf(demagSmbl) > -1) demagType = 'thermal';\n    else if (alternatingTypes.indexOf(demagSmbl) > -1) demagType = 'alternating field';\n\n    return {\n      id: index + 1,\n      label,\n      code,\n      demagType,\n      stepRange,\n      stepCount,\n      Dgeo,\n      Igeo,\n      Dstrat,\n      Istrat,\n      mad,\n      k,\n      comment\n    };\n\n  });\n  \n  return {\n    name,\n    interpretations,\n    format: \"PMM\",\n    created: new Date().toISOString(),\n  };\n\n}\n\nexport default parsePMM;","content_without_annotations":"const parsePMM = (data, name) => {\n  // eslint-disable-next-line no-control-regex\n  const eol = new RegExp(\"\\r?\\n\");\n  // Get all lines except first and the last one (they're garbage)\n  const lines = data.split(eol).slice(1).filter(line => line.length > 1);\n\n  const header = lines[0].replace(/\"/g, '').split(',');\n  // name = header[0] || name;\n\n  // Skip 1 and 2 lines 'cause they're in the header \n  const interpretations = lines.slice(2).map((line, index) => {\n    \n    const params = line.replace(/\\s+/g, '').split(',');\n\n    // ID | CODE | STEPRANGE | N | Dg | Ig | kg | a95g | Ds | Is | ks | a95s | comment \n    // 'kg' and 'ks' - idiotic garbage and, moreover, there is no 'a95' - there is only MAD (Maximum Angular Deviation)\n    const label = params[0];\n    const code = params[1];\n    const stepRange = params[2];\n    const stepCount = Number(params[3]);\n    const Dgeo = Number(params[4]);\n    const Igeo = Number(params[5]);\n    const madGeo = Number(params[7]);\n    const Dstrat = Number(params[8]);\n    const Istrat = Number(params[9]);\n    // const madStrat = Number(params[11]);\n    // but we don't need madStrat and madGeo at the same time - they must be equal, otherwise some of them is incorrect, so...\n    const mad = madGeo;\n    const k = 0;\n\n    // comment may be with spaces\n    let comment = '';\n    for (let i = 12; i < params.length; i++) comment += params[i];\n    comment = comment.trim();\n\n    // there is no standard for demagnetization symbol... and idk why\n    const demagSmbl = stepRange.split('')[0];\n    const thermalTypes = ['T', 't'];\n    const alternatingTypes = ['M', 'm'];\n\n    let demagType = undefined;\n\n    if (thermalTypes.indexOf(demagSmbl) > -1) demagType = 'thermal';\n    else if (alternatingTypes.indexOf(demagSmbl) > -1) demagType = 'alternating field';\n\n    return {\n      id: index + 1,\n      label,\n      code,\n      demagType,\n      stepRange,\n      stepCount,\n      Dgeo,\n      Igeo,\n      Dstrat,\n      Istrat,\n      mad,\n      k,\n      comment\n    };\n\n  });\n  \n  return {\n    name,\n    interpretations,\n    format: \"PMM\",\n    created: new Date().toISOString(),\n  };\n\n}\n\nexport default parsePMM;","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":663,"ext":"ts","fun_ann_density":0.012066365,"function_parameters":5,"function_signatures":0,"function_usages":0,"functions":3,"hexsha":"7f74afe9a1b0b056999b57f142ba8053d2f19b2d","lang":"TypeScript","loc":50,"loc_per_function":28.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"313dea61275c5f8b875376578a65e08b9c2fd128","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"I194/PMTools_2.0","max_forks_repo_path":"src/utils/files/parsers/parserPMM.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"313dea61275c5f8b875376578a65e08b9c2fd128","max_issues_repo_issues_event_max_datetime":"2022-03-17T12:51:57.000Z","max_issues_repo_issues_event_min_datetime":"2022-03-17T12:50:14.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"I194/PMTools_2.0","max_issues_repo_path":"src/utils/files/parsers/parserPMM.ts","max_line_length":126,"max_stars_count":null,"max_stars_repo_head_hexsha":"313dea61275c5f8b875376578a65e08b9c2fd128","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"I194/PMTools_2.0","max_stars_repo_path":"src/utils/files/parsers/parserPMM.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.3116386129,"predefined_density":0.064516129,"predefined_types":2,"prop_ann_density":0.0,"property_declarations":0,"size":2211,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0346907994,"variable_declarations":23},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"const parsePMM = (data: string, name: string) => {\n    // eslint-disable-next-line no-control-regex\n    const eol = new RegExp(\"\\r?\\n\");\n    // Get all lines except first and the last one (they're garbage), name: and comment are all on the same line\n    const lines = data.split(eol).slice(1).filter((line) => line.length > 1);\n    // Skip 1 and 2 lines 'cause they're in the heade): they don't exist\n    if (lines.length < 2)\n        throw new Error(`parsePMM(${name}): Invalid PMM file!`);\n    const header = lines[0].replace(/\"/g, \"\").split(\",\");\n    const interpretation => {\n    // eslint-disable-next-line no-control-regex\n    const eol = new RegExp(\"\\r?\\n\");\n    // Get all lines except first and the last one (they're garbage)\n    const lines = data.split(eol).slice(1).filter((line: string) => line.length > 1);\n    // Skip 1 and 2 lines 'cause they're in the heade): they don't exist\n    if (lines.length < 2)\n        throw new Error(`parsePM): Invalid PM file!`);\n    const interpretation = lines[0].replace(/\"/g, \"\").split(\",\");\n    const label = interpretation[0];\n    const code = interpretation[1];\n    const stepRange = interpretation[2]; => line.length > 1);\n    const header = lines[0].replace(/\"/g, \"\").split(\",\");\n    // name = header[0] || name;\n    // Skip 1 and 2 lines 'cause they're in the header \n    const interpretations = lines.slice(2).map((line: string) => line.replace(/\"/g, \"\"));\n    return new Interpretation(name, code, label, interpretations, stepRange);\n};\n\nconst parsePM = (data: string, name: string) => {, index: number} => {\n    const lines = data.split(\"\\r\\n\").filter((line: string) => line.length > 1);\n    const header = lines[0].replace(/\"/g, \"\").split(\",\");\n    // Skip): they don't exist\n    if (header.length!== 7)\n        throw new Error(`parsePM(${name}): Invalid PM file!`);\n    const interpretation = lines[1].replace(/\"/g, \"\").split(\",\");\n    const label = interpre => {\n        const params = line.replace(/\\s+/g, \"\").split(\",\");\n        // ID | CODE | STEPRANGE | N | Dg | Ig | kg | a95g | Ds | Is | ks | a95s | comment \n        // 'kg' and 'ks' - idiotic garbage and, moreover, there is no 'a95' - there is only MAD (Maximum Angular Deviation)\n        const label = params[0];\n        const code = params[1];\n        const stepRange = params[2];\n        const stepCount = Number(params[3]);\n        const Dgeo = Number(params[4]);\n        const Igeo = Number(params[5]);\n        const madGeo = Number(params[7]);\n        const Dstrat = Number(params[8]);\n        const Istrat = Number(params[9]);\n        // const madStrat = Number(params[11]);\n        // but we don't need madStrat and madGeo at the same time - they must be equal, otherwise some of them is incorrect, so...\n        const mad = madGeo;\n        const k = 0;\n        // comment may be with spaces\n        let comment = \"\";\n        for (let i = 12; i < params.length; i++)\n            comment += params[i];\n        comment = comment.trim();\n        // there is no standard for demagnetization symbol... and idk why\n        const demagSmbl = stepRange.split(\"\")[0];\n        const thermalTypes = [\"T\", \"t\"];\n        const alternatingTypes = [\"M\", \"m\"];\n        let demagType = undefined;\n        if (thermalTypes.indexOf(demagSmbl) > -1)\n            demagType = \"thermal\";\n        else if (alternatingTypes.indexOf(demagSmbl) > -1)\n            demagType = \"alternating field\";\n        return {\n            id: index + 1,\n            label,\n            code,\n            demagType,\n            stepRange,\n            stepCount,\n            Dgeo,\n            Igeo,\n            Dstrat,\n            Istrat,\n            mad,\n            k,\n            comment\n        };\n    });\n    return {\n        name,\n        interpretations,\n        format: \"PMM\",\n        created: new Date().toISOString(),\n    };\n};\nexport default parsePMM;\n","score":427,"fallbacked":false,"num_type_errors":12},{"code":"const parsePMM = (data: string): Interpretation[] => {\n    const eol = new RegExp(\"\\r?\\n\");\n    const lines = data.split(eol).slice(1);\n    const interpretations: Interpretation[] = [];\n\n    for (let i, name: number = 0; i < lines.length; i++) {\n        const line = lines[i];\n        const nameArray = line.split(\",\").map((e) => e.trim().toLowerCase());\n\n        if (nameArray[): InterpretationName] === \"name\") {\n            interpretations[name] = {\n                name: nameArray[1],\n                code: nameArray[2],\n                stepRange: nameArray[3],\n                stepCount: nameArray[ => {\n    // eslint-disable-next-line no-control-regex\n    const eol = new RegExp(\"\\r?\\n\");\n    // Get all lines except first and the last one (they're garbage)\n    const lines = data.split(eol).slice(1).filter((line: string) => line.length > 1);\n    const header = lines[0].replace(/\"/g, \"\").split(\",\");\n    // name = header[0] || name;\n    // Skip 1 and 2 lines 'cause they'r): they're a comment\n    const interpretation = lines.slice(1, -1).map((line) => {\n        const params = line.replace(/\\s+/g, \"\").split(\",\");\n        // ID | CODE | STEPRANGE | N => line.length > 1);\n    const header = lines[0].replace(/\"/g, \"\").split(\",\");\n    // name = header[0] || name;\n    // Skip 1 and 2 lines 'cause they're in the header \n    const interpretations = lines.slice(2).map((line: string) => {\n        const params = line.replace(/\\s+/g, \"\").split(\",\");\n        // ID | CODE | STEPRANGE | N | Dg | Ig | kg | a95g | Ds | Is | ks, index: 0\n    const interpretation = params.map((param: string, index: number) => {\n        const value = Number(param);\n        if (index === 0) {\n            const [name, code, stepRange, stepCount): InterpretationName | undefined = interpretationNames.find(\n                (name: InterpretationName) => name.code === code\n            );\n            if (interpretationName === undefined) {\n                throw new Error(`Unknown interpretation code '${cod => {\n        const params = line.replace(/\\s+/g, \"\").split(\",\");\n        // ID | CODE | STEPRANGE | N | Dg | Ig | kg | a95g | Ds | Is | ks | a95s | comment \n        // 'kg' and 'ks' - idiotic garbage and, moreover, there is no 'a95' - there is only MAD (Maximum Angular Deviation)\n        const label = params[0];\n        const code = params[1];\n        const stepRange = params[2];\n        const stepCount = Number(params[3]);\n        const Dgeo = Number(params[4]);\n        const Igeo = Number(params[5]);\n        const madGeo = Number(params[7]);\n        const Dstrat = Number(params[8]);\n        const Istrat = Number(params[9]);\n        // const madStrat = Number(params[11]);\n        // but we don't need madStrat and madGeo at the same time - they must be equal, otherwise some of them is incorrect, so...\n        const mad = madGeo;\n        const k = 0;\n        // comment may be with spaces\n        let comment = \"\";\n        for (let i = 12; i < params.length; i++)\n            comment += params[i];\n        comment = comment.trim();\n        // there is no standard for demagnetization symbol... and idk why\n        const demagSmbl = stepRange.split(\"\")[0];\n        const thermalTypes = [\"T\", \"t\"];\n        const alternatingTypes = [\"M\", \"m\"];\n        let demagType = undefined;\n        if (thermalTypes.indexOf(demagSmbl) > -1)\n            demagType = \"thermal\";\n        else if (alternatingTypes.indexOf(demagSmbl) > -1)\n            demagType = \"alternating field\";\n        return {\n            id: index + 1,\n            label,\n            code,\n            demagType,\n            stepRange,\n            stepCount,\n            Dgeo,\n            Igeo,\n            Dstrat,\n            Istrat,\n            mad,\n            k,\n            comment\n        };\n    });\n    return {\n        name,\n        interpretations,\n        format: \"PMM\",\n        created: new Date().toISOString(),\n    };\n};\nexport default parsePMM;\n","score":407,"fallbacked":false,"num_type_errors":23},{"code":"const parsePMM = (data: string) => {\n    // eslint-disable-next-line no-control-regex\n    const eol = new RegExp(\"\\r?\\n\");\n    // Get all lines except first and the last one (they're garbage)\n    const lines = dat, name: string = lines[0].replace(/\"/g, \"\");\n    const interpretations: ParsedInterpretations = {};\n    interpretations.name = name;\n    for (let i = 1; i < lines.length; i++) {\n        cons): ParsedInterpretations = interpretations[lines[i].split(\",\")[1]] = {\n            code: lines[i].split(\",\")[2],\n            stepRange: lines[i].split(\",\")[3],\n            n: Number(lines => {\n    // eslint-disable-next-line no-control-regex\n    const eol = new RegExp(\"\\r?\\n\");\n    // Get all lines except first and the last one (they're garbage)\n    const lines = data.split(eol).slice(1).filter((line: string) => line.length > 0).map((line: string) => line.replace(/\\s+/g, \"\"));\n    return Number(lines[0]);\n}).reduce((acc, cur) => acc + cur), 0)): interpretations[lines[i].split(\",\")[1]] = {\n            code: lines[i].split(\",\")[2],\n            stepRange: lines[i].split(\",\")[3],\n            n: Number(lines => {\n    // eslin => line.length > 1);\n    const header = lines[0].replace(/\"/g, \"\").split(\",\");\n    // name = header[0] || name;\n    // Skip 1 and 2 lines 'cause they're in the header \n    const interpretations = lines.slice(2).map((line: string) => {\n        // eslint-disable-next-line no-control-regex\n        const eol = new RegExp(\"\\r?\\n\");\n        // Get all lines except first and the last one (they're garbage)\n        const lines = lin, index: number = Number(lines => {\n    // eslint-disable-next-line no-control-regex\n    const eol = new RegExp(\"\\r?\\n\");\n    // Get all lines except first and the last one (they're garbage)\n    cons): ParsedInterpretations = interpretations[lines[i].split(\",\")[1]] = {\n            code: lines[i].split(\",\")[2],\n            stepRange: lines[i].split(\",\")[3],\n            n: Number(lines = => {\n        const params = line.replace(/\\s+/g, \"\").split(\",\");\n        // ID | CODE | STEPRANGE | N | Dg | Ig | kg | a95g | Ds | Is | ks | a95s | comment \n        // 'kg' and 'ks' - idiotic garbage and, moreover, there is no 'a95' - there is only MAD (Maximum Angular Deviation)\n        const label = params[0];\n        const code = params[1];\n        const stepRange = params[2];\n        const stepCount = Number(params[3]);\n        const Dgeo = Number(params[4]);\n        const Igeo = Number(params[5]);\n        const madGeo = Number(params[7]);\n        const Dstrat = Number(params[8]);\n        const Istrat = Number(params[9]);\n        // const madStrat = Number(params[11]);\n        // but we don't need madStrat and madGeo at the same time - they must be equal, otherwise some of them is incorrect, so...\n        const mad = madGeo;\n        const k = 0;\n        // comment may be with spaces\n        let comment = \"\";\n        for (let i = 12; i < params.length; i++)\n            comment += params[i];\n        comment = comment.trim();\n        // there is no standard for demagnetization symbol... and idk why\n        const demagSmbl = stepRange.split(\"\")[0];\n        const thermalTypes = [\"T\", \"t\"];\n        const alternatingTypes = [\"M\", \"m\"];\n        let demagType = undefined;\n        if (thermalTypes.indexOf(demagSmbl) > -1)\n            demagType = \"thermal\";\n        else if (alternatingTypes.indexOf(demagSmbl) > -1)\n            demagType = \"alternating field\";\n        return {\n            id: index + 1,\n            label,\n            code,\n            demagType,\n            stepRange,\n            stepCount,\n            Dgeo,\n            Igeo,\n            Dstrat,\n            Istrat,\n            mad,\n            k,\n            comment\n        };\n    });\n    return {\n        name,\n        interpretations,\n        format: \"PMM\",\n        created: new Date().toISOString(),\n    };\n};\nexport default parsePMM;\n","score":427,"fallbacked":false,"num_type_errors":24}]}
{"dataset_elem":{"alphanum_fraction":0.5896980462,"avg_line_length":30.1607142857,"content":"// This is a browser version of https://github.com/Equim-chan/base91\n\n/*\nBSD 3-Clause License\n\nCopyright (c) 2017, Equim\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// NOTE: the character \"<\" was replaced by \"-\" to avoid problems embedding in HTML         ↓\nconst TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;-=>?@[]^_`{|}~\"';\n\nconst B91_LENGTH_DIGITS = 12;\n\n// TODO: use buffers\nexport const base91encode = (data: Uint8Array): string => {\n    let ret = (data.length + \"\").padStart(B91_LENGTH_DIGITS, \"0\");\n    const len = data.length;\n\n    let i = 0;\n    let n = 0;\n    let b = 0;\n\n    while (i < len) {\n        b |= data[i] << n;\n        n += 8;\n\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) {\n                b >>= 13;\n                n -= 13;\n            } else {\n                v = b & 16383;\n                b >>= 14;\n                n -= 14;\n            }\n            ret += TABLE[v % 91] + TABLE[(v / 91) | 0];\n        }\n        i++;\n    }\n\n    if (n) {\n        ret += TABLE[b % 91];\n        if (n > 7 || b > 90) ret += TABLE[(b / 91) | 0];\n    }\n\n    return ret;\n};\n\nexport const base91decode = (data: string): Uint8Array => {\n    let i = B91_LENGTH_DIGITS;\n    let k = 0;\n    let b = 0;\n    let n = 0;\n    let v = -1;\n\n    const len = data.length;\n    const outputLength = parseInt(data.slice(0, B91_LENGTH_DIGITS));\n    const ret = new Uint8Array(outputLength);\n\n    while (i < len) {\n        const p = TABLE.indexOf(data[i]);\n        if (p === -1) continue;\n        if (v < 0) {\n            v = p;\n        } else {\n            v += p * 91;\n            b |= v << n;\n            n += (v & 8191) > 88 ? 13 : 14;\n            do {\n                ret[k++] = b & 0xff;\n                b >>= 8;\n                n -= 8;\n            } while (n > 7);\n            v = -1;\n        }\n        i++;\n    }\n\n    if (v > -1) {\n        ret[k++] = (b | (v << n)) & 0xff;\n    }\n\n    return ret;\n};\n","content_without_annotations":"// This is a browser version of https://github.com/Equim-chan/base91\n\n/*\nBSD 3-Clause License\n\nCopyright (c) 2017, Equim\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// NOTE: the character \"<\" was replaced by \"-\" to avoid problems embedding in HTML         ↓\nconst TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;-=>?@[]^_`{|}~\"';\n\nconst B91_LENGTH_DIGITS = 12;\n\n// TODO: use buffers\nexport const base91encode = (data) => {\n    let ret = (data.length + \"\").padStart(B91_LENGTH_DIGITS, \"0\");\n    const len = data.length;\n\n    let i = 0;\n    let n = 0;\n    let b = 0;\n\n    while (i < len) {\n        b |= data[i] << n;\n        n += 8;\n\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) {\n                b >>= 13;\n                n -= 13;\n            } else {\n                v = b & 16383;\n                b >>= 14;\n                n -= 14;\n            }\n            ret += TABLE[v % 91] + TABLE[(v / 91) | 0];\n        }\n        i++;\n    }\n\n    if (n) {\n        ret += TABLE[b % 91];\n        if (n > 7 || b > 90) ret += TABLE[(b / 91) | 0];\n    }\n\n    return ret;\n};\n\nexport const base91decode = (data) => {\n    let i = B91_LENGTH_DIGITS;\n    let k = 0;\n    let b = 0;\n    let n = 0;\n    let v = -1;\n\n    const len = data.length;\n    const outputLength = parseInt(data.slice(0, B91_LENGTH_DIGITS));\n    const ret = new Uint8Array(outputLength);\n\n    while (i < len) {\n        const p = TABLE.indexOf(data[i]);\n        if (p === -1) continue;\n        if (v < 0) {\n            v = p;\n        } else {\n            v += p * 91;\n            b |= v << n;\n            n += (v & 8191) > 88 ? 13 : 14;\n            do {\n                ret[k++] = b & 0xff;\n                b >>= 8;\n                n -= 8;\n            } while (n > 7);\n            v = -1;\n        }\n        i++;\n    }\n\n    if (v > -1) {\n        ret[k++] = (b | (v << n)) & 0xff;\n    }\n\n    return ret;\n};\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":957,"ext":"ts","fun_ann_density":0.0041797283,"function_parameters":2,"function_signatures":0,"function_usages":0,"functions":2,"hexsha":"465aca866742965184ee78b911779d2e6a210117","lang":"TypeScript","loc":63,"loc_per_function":28.5,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-03-04T14:43:54.000Z","max_forks_repo_forks_event_min_datetime":"2022-03-04T14:43:54.000Z","max_forks_repo_head_hexsha":"ce8bb16bee95020171493699d63d4cc74cedd080","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"mlomb/chat-analytics","max_forks_repo_path":"pipeline/compression/Base91.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"ce8bb16bee95020171493699d63d4cc74cedd080","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"mlomb/chat-analytics","max_issues_repo_path":"pipeline/compression/Base91.ts","max_line_length":108,"max_stars_count":34.0,"max_stars_repo_head_hexsha":"ce8bb16bee95020171493699d63d4cc74cedd080","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"mlomb/chat-analytics","max_stars_repo_path":"pipeline/compression/Base91.ts","max_stars_repo_stars_event_max_datetime":"2022-03-27T16:08:53.000Z","max_stars_repo_stars_event_min_datetime":"2022-02-04T02:10:50.000Z","metric":0.2446611611,"predefined_density":0.0869565217,"predefined_types":2,"prop_ann_density":0.0,"property_declarations":0,"size":3378,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0198537095,"variable_declarations":19},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"// This is a browser version of https://github.com/Equim-chan/base91\n/*\nBSD 3-Clause License\n\nCopyright (c) 2017, Equim\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n// NOTE: the character \"<\" was replaced by \"-\" to avoid problems embedding in HTML         ↓\nconst TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;-=>?@[]^_`{|}~\\\"\";\nconst B91_LENGTH_DIGITS = 12;\n// TODO: use buffers\nexport const base91encode = (data: Uint8Array): string => {\n    let ret = \"\";\n    let len = data.length;\n    let i = 0;\n    while (i < len) {\n        const v = data[i];\n        ret += TABLE[v): string;\n        if (v >= 0x20) {\n            ret += \" \";\n        }\n        i++;\n    }\n    return ret;\n};\n\n/**\n * This is a base91-encode implementation for strings. => {\n    let ret = (data.length + \"\").padStart(B91_LENGTH_DIGITS, \"0\");\n    const len = data.length;\n    let i = 0;\n    let n = 0;\n    let b = 0;\n    while (i < len) {\n        b |= data[i] << n;\n        n += 8;\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) {\n                b >>= 13;\n                n -= 13;\n            }\n            else {\n                v = b & 16383;\n                b >>= 14;\n                n -= 14;\n            }\n            ret += TABLE[v % 91] + TABLE[(v / 91) | 0];\n        }\n        i++;\n    }\n    if (n) {\n        ret += TABLE[b % 91];\n        if (n > 7 || b > 90)\n            ret += TABLE[(b / 91) | 0];\n    }\n    return ret;\n};\nexport const base91decode = (data: string): Uint8Array => {\n    let i = 0;\n    let n = 0;\n    let b = 0;\n    let ret = new Uint8Array(data.length);\n    while (i < data.length): {\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) {\n                b >>= 13;\n                n -= 13; => {\n    let i = B91_LENGTH_DIGITS;\n    let k = 0;\n    let b = 0;\n    let n = 0;\n    let v = -1;\n    const len = data.length;\n    const outputLength = parseInt(data.slice(0, B91_LENGTH_DIGITS));\n    const ret = new Uint8Array(outputLength);\n    while (i < len) {\n        const p = TABLE.indexOf(data[i]);\n        if (p === -1)\n            continue;\n        if (v < 0) {\n            v = p;\n        }\n        else {\n            v += p * 91;\n            b |= v << n;\n            n += (v & 8191) > 88 ? 13 : 14;\n            do {\n                ret[k++] = b & 255;\n                b >>= 8;\n                n -= 8;\n            } while (n > 7);\n            v = -1;\n        }\n        i++;\n    }\n    if (v > -1) {\n        ret[k++] = (b | (v << n)) & 255;\n    }\n    return ret;\n};\n","score":375,"fallbacked":false,"num_type_errors":4},{"code":"// This is a browser version of https://github.com/Equim-chan/base91\n/*\nBSD 3-Clause License\n\nCopyright (c) 2017, Equim\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n// NOTE: the character \"<\" was replaced by \"-\" to avoid problems embedding in HTML         ↓\nconst TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;-=>?@[]^_`{|}~\\\"\";\nconst B91_LENGTH_DIGITS = 12;\n// TODO: use buffers\nexport const base91encode = (data: Uint8Array): string => {\n    let ret = \"\";\n    const len = data.length;\n    let i = 0;\n    let n = 0;\n    let b = 0;\n    while (i < len) {): {\n        b |= data[i] << n;\n        n += 8;\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) { => {\n    let ret = (data.length + \"\").padStart(B91_LENGTH_DIGITS, \"0\");\n    const len = data.length;\n    let i = 0;\n    let n = 0;\n    let b = 0;\n    while (i < len) {\n        b |= data[i] << n;\n        n += 8;\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) {\n                b >>= 13;\n                n -= 13;\n            }\n            else {\n                v = b & 16383;\n                b >>= 14;\n                n -= 14;\n            }\n            ret += TABLE[v % 91] + TABLE[(v / 91) | 0];\n        }\n        i++;\n    }\n    if (n) {\n        ret += TABLE[b % 91];\n        if (n > 7 || b > 90)\n            ret += TABLE[(b / 91) | 0];\n    }\n    return ret;\n};\nexport const base91decode = (data: string): Uint8Array => {\n    let ret = new Uint8Array(B91_LENGTH_DIGITS);\n    let i = 0;\n    let n = 0;\n    let b = 0;\n    while (): {\n        b |= TABLE.indexOf(data[i]);\n        if (b < 0)\n            throw new Error(`Invalid base91 data`);\n        if (n) {\n            b >>= n;\n            n -= 8; => {\n    let i = B91_LENGTH_DIGITS;\n    let k = 0;\n    let b = 0;\n    let n = 0;\n    let v = -1;\n    const len = data.length;\n    const outputLength = parseInt(data.slice(0, B91_LENGTH_DIGITS));\n    const ret = new Uint8Array(outputLength);\n    while (i < len) {\n        const p = TABLE.indexOf(data[i]);\n        if (p === -1)\n            continue;\n        if (v < 0) {\n            v = p;\n        }\n        else {\n            v += p * 91;\n            b |= v << n;\n            n += (v & 8191) > 88 ? 13 : 14;\n            do {\n                ret[k++] = b & 255;\n                b >>= 8;\n                n -= 8;\n            } while (n > 7);\n            v = -1;\n        }\n        i++;\n    }\n    if (v > -1) {\n        ret[k++] = (b | (v << n)) & 255;\n    }\n    return ret;\n};\n","score":435,"fallbacked":false,"num_type_errors":14},{"code":"// This is a browser version of https://github.com/Equim-chan/base91\n/*\nBSD 3-Clause License\n\nCopyright (c) 2017, Equim\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n// NOTE: the character \"<\" was replaced by \"-\" to avoid problems embedding in HTML         ↓\nconst TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;-=>?@[]^_`{|}~\\\"\";\nconst B91_LENGTH_DIGITS = 12;\n// TODO: use buffers\nexport const base91encode = (data: Uint8Array): string => {\n    const ret = [];\n    let i = 0;\n    let n = 0;\n    let b = 0;\n    while (i < data.length) {\n        b |= data[i): n |= 8191;\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) {\n                b >>= 13; => {\n    let ret = (data.length + \"\").padStart(B91_LENGTH_DIGITS, \"0\");\n    const len = data.length;\n    let i = 0;\n    let n = 0;\n    let b = 0;\n    while (i < len) {\n        b |= data[i] << n;\n        n += 8;\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) {\n                b >>= 13;\n                n -= 13;\n            }\n            else {\n                v = b & 16383;\n                b >>= 14;\n                n -= 14;\n            }\n            ret += TABLE[v % 91] + TABLE[(v / 91) | 0];\n        }\n        i++;\n    }\n    if (n) {\n        ret += TABLE[b % 91];\n        if (n > 7 || b > 90)\n            ret += TABLE[(b / 91) | 0];\n    }\n    return ret;\n};\nexport const base91decode = (data: string): Uint8Array => {\n    const len = data.length;\n    let i = 0;\n    let n = 0;\n    let b = 0;\n    while (i < len) {\n        b |= TABLE.indexO): n |= 8191;\n        if (n > 13) {\n            let v = b & 8191;\n            if (v > 88) {\n                b >>= 13; => => {\n    let i = B91_LENGTH_DIGITS;\n    let k = 0;\n    let b = 0;\n    let n = 0;\n    let v = -1;\n    const len = data.length;\n    const outputLength = parseInt(data.slice(0, B91_LENGTH_DIGITS));\n    const ret = new Uint8Array(outputLength);\n    while (i < len) {\n        const p = TABLE.indexOf(data[i]);\n        if (p === -1)\n            continue;\n        if (v < 0) {\n            v = p;\n        }\n        else {\n            v += p * 91;\n            b |= v << n;\n            n += (v & 8191) > 88 ? 13 : 14;\n            do {\n                ret[k++] = b & 255;\n                b >>= 8;\n                n -= 8;\n            } while (n > 7);\n            v = -1;\n        }\n        i++;\n    }\n    if (v > -1) {\n        ret[k++] = (b | (v << n)) & 255;\n    }\n    return ret;\n};\n","score":435,"fallbacked":false,"num_type_errors":16}]}
{"dataset_elem":{"alphanum_fraction":0.6914168937,"avg_line_length":26.371257485,"content":"export enum LongOption {\n  NUMBER = 'number',\n  LONG = 'long',\n  STRING = 'string',\n}\n\nexport enum DateOption {\n  DATE = 'date',\n  STRING = 'string',\n  TIMESTAMP = 'timestamp',\n}\n\nexport enum EnvOption {\n  NODE = 'node',\n  BROWSER = 'browser',\n  BOTH = 'both',\n}\n\nexport enum OneofOption {\n  PROPERTIES = 'properties',\n  UNIONS = 'unions',\n}\n\nexport enum ServiceOption {\n  GRPC = 'grpc-js',\n  GENERIC = 'generic-definitions',\n  DEFAULT = 'default',\n  NONE = 'none',\n}\n\nexport type Options = {\n  context: boolean;\n  snakeToCamel: Array<'json' | 'keys'>;\n  forceLong: LongOption;\n  useOptionals: boolean | 'none' | 'messages' | 'all'; // boolean is deprecated\n  useDate: DateOption;\n  oneof: OneofOption;\n  esModuleInterop: boolean;\n  fileSuffix: string;\n  outputEncodeMethods: boolean;\n  outputJsonMethods: boolean;\n  outputPartialMethods: boolean;\n  outputTypeRegistry: boolean;\n  stringEnums: boolean;\n  constEnums: boolean;\n  enumsAsLiterals: boolean;\n  outputClientImpl: boolean | 'grpc-web';\n  outputServices: ServiceOption;\n  addGrpcMetadata: boolean;\n  addNestjsRestParameter: boolean;\n  returnObservable: boolean;\n  lowerCaseServiceMethods: boolean;\n  nestJs: boolean;\n  env: EnvOption;\n  unrecognizedEnum: boolean;\n  exportCommonSymbols: boolean;\n  outputSchema: boolean;\n  // An alias of !output\n  onlyTypes: boolean;\n  emitImportedFiles: boolean;\n  useExactTypes: boolean;\n  delimitedMethods: boolean;\n};\n\nexport function defaultOptions(): Options {\n  return {\n    context: false,\n    snakeToCamel: ['json', 'keys'],\n    forceLong: LongOption.NUMBER,\n    useOptionals: 'none',\n    useDate: DateOption.DATE,\n    oneof: OneofOption.PROPERTIES,\n    esModuleInterop: false,\n    fileSuffix: '',\n    lowerCaseServiceMethods: false,\n    outputEncodeMethods: true,\n    outputJsonMethods: true,\n    outputPartialMethods: true,\n    outputTypeRegistry: false,\n    stringEnums: false,\n    constEnums: false,\n    enumsAsLiterals: false,\n    outputClientImpl: true,\n    outputServices: ServiceOption.DEFAULT,\n    returnObservable: false,\n    addGrpcMetadata: false,\n    addNestjsRestParameter: false,\n    nestJs: false,\n    env: EnvOption.BOTH,\n    unrecognizedEnum: true,\n    exportCommonSymbols: true,\n    outputSchema: false,\n    onlyTypes: false,\n    emitImportedFiles: true,\n    useExactTypes: true,\n    delimitedMethods: false,\n  };\n}\n\nconst nestJsOptions: Partial<Options> = {\n  lowerCaseServiceMethods: true,\n  outputEncodeMethods: false,\n  outputJsonMethods: false,\n  outputPartialMethods: false,\n  outputClientImpl: false,\n  useDate: DateOption.TIMESTAMP,\n};\n\nexport function optionsFromParameter(parameter: string | undefined): Options {\n  const options = defaultOptions();\n  if (parameter) {\n    const parsed = parseParameter(parameter);\n    if (parsed.nestJs) {\n      Object.assign(options, nestJsOptions);\n    }\n    Object.assign(options, parsed);\n  }\n  // We should promote onlyTypes to its own documented flag, but just an alias for now\n  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {\n    options.onlyTypes = true;\n  }\n\n  // Treat forceLong=true as LONG\n  if ((options.forceLong as any) === true) {\n    options.forceLong = LongOption.LONG;\n  }\n\n  // Treat outputServices=false as NONE\n  if ((options.outputServices as any) === false) {\n    options.outputServices = ServiceOption.NONE;\n  }\n\n  if ((options.useDate as any) === true) {\n    // Treat useDate=true as DATE\n    options.useDate = DateOption.DATE;\n  } else if ((options.useDate as any) === false) {\n    // Treat useDate=false as TIMESTAMP\n    options.useDate = DateOption.TIMESTAMP;\n  }\n\n  if ((options.snakeToCamel as any) === false) {\n    options.snakeToCamel = [];\n  } else if ((options.snakeToCamel as any) === true) {\n    options.snakeToCamel = ['keys', 'json'];\n  }\n\n  return options;\n}\n\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction parseParameter(parameter: string): Options {\n  const options = {} as any;\n  const pairs = parameter.split(',').map((s) => s.split('='));\n  pairs.forEach(([key, value]) => {\n    options[key] = value === 'true' ? true : value === 'false' ? false : value;\n  });\n  return options;\n}\n\nexport function getTsPoetOpts(options: Options): { forceDefaultImport?: string[] } {\n  if (options.esModuleInterop) {\n    return { forceDefaultImport: ['protobufjs/minimal'] };\n  } else {\n    return {};\n  }\n}\n","content_without_annotations":"export enum LongOption {\n  NUMBER = 'number',\n  LONG = 'long',\n  STRING = 'string',\n}\n\nexport enum DateOption {\n  DATE = 'date',\n  STRING = 'string',\n  TIMESTAMP = 'timestamp',\n}\n\nexport enum EnvOption {\n  NODE = 'node',\n  BROWSER = 'browser',\n  BOTH = 'both',\n}\n\nexport enum OneofOption {\n  PROPERTIES = 'properties',\n  UNIONS = 'unions',\n}\n\nexport enum ServiceOption {\n  GRPC = 'grpc-js',\n  GENERIC = 'generic-definitions',\n  DEFAULT = 'default',\n  NONE = 'none',\n}\n\nexport type Options = {\n  context;\n  snakeToCamel;\n  forceLong;\n  useOptionals; // boolean is deprecated\n  useDate;\n  oneof;\n  esModuleInterop;\n  fileSuffix;\n  outputEncodeMethods;\n  outputJsonMethods;\n  outputPartialMethods;\n  outputTypeRegistry;\n  stringEnums;\n  constEnums;\n  enumsAsLiterals;\n  outputClientImpl;\n  outputServices;\n  addGrpcMetadata;\n  addNestjsRestParameter;\n  returnObservable;\n  lowerCaseServiceMethods;\n  nestJs;\n  env;\n  unrecognizedEnum;\n  exportCommonSymbols;\n  outputSchema;\n  // An alias of !output\n  onlyTypes;\n  emitImportedFiles;\n  useExactTypes;\n  delimitedMethods;\n};\n\nexport function defaultOptions() {\n  return {\n    context: false,\n    snakeToCamel: ['json', 'keys'],\n    forceLong: LongOption.NUMBER,\n    useOptionals: 'none',\n    useDate: DateOption.DATE,\n    oneof: OneofOption.PROPERTIES,\n    esModuleInterop: false,\n    fileSuffix: '',\n    lowerCaseServiceMethods: false,\n    outputEncodeMethods: true,\n    outputJsonMethods: true,\n    outputPartialMethods: true,\n    outputTypeRegistry: false,\n    stringEnums: false,\n    constEnums: false,\n    enumsAsLiterals: false,\n    outputClientImpl: true,\n    outputServices: ServiceOption.DEFAULT,\n    returnObservable: false,\n    addGrpcMetadata: false,\n    addNestjsRestParameter: false,\n    nestJs: false,\n    env: EnvOption.BOTH,\n    unrecognizedEnum: true,\n    exportCommonSymbols: true,\n    outputSchema: false,\n    onlyTypes: false,\n    emitImportedFiles: true,\n    useExactTypes: true,\n    delimitedMethods: false,\n  };\n}\n\nconst nestJsOptions = {\n  lowerCaseServiceMethods: true,\n  outputEncodeMethods: false,\n  outputJsonMethods: false,\n  outputPartialMethods: false,\n  outputClientImpl: false,\n  useDate: DateOption.TIMESTAMP,\n};\n\nexport function optionsFromParameter(parameter) {\n  const options = defaultOptions();\n  if (parameter) {\n    const parsed = parseParameter(parameter);\n    if (parsed.nestJs) {\n      Object.assign(options, nestJsOptions);\n    }\n    Object.assign(options, parsed);\n  }\n  // We should promote onlyTypes to its own documented flag, but just an alias for now\n  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {\n    options.onlyTypes = true;\n  }\n\n  // Treat forceLong=true as LONG\n  if ((options.forceLong as any) === true) {\n    options.forceLong = LongOption.LONG;\n  }\n\n  // Treat outputServices=false as NONE\n  if ((options.outputServices as any) === false) {\n    options.outputServices = ServiceOption.NONE;\n  }\n\n  if ((options.useDate as any) === true) {\n    // Treat useDate=true as DATE\n    options.useDate = DateOption.DATE;\n  } else if ((options.useDate as any) === false) {\n    // Treat useDate=false as TIMESTAMP\n    options.useDate = DateOption.TIMESTAMP;\n  }\n\n  if ((options.snakeToCamel as any) === false) {\n    options.snakeToCamel = [];\n  } else if ((options.snakeToCamel as any) === true) {\n    options.snakeToCamel = ['keys', 'json'];\n  }\n\n  return options;\n}\n\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction parseParameter(parameter) {\n  const options = {} as any;\n  const pairs = parameter.split(',').map((s) => s.split('='));\n  pairs.forEach(([key, value]) => {\n    options[key] = value === 'true' ? true : value === 'false' ? false : value;\n  });\n  return options;\n}\n\nexport function getTsPoetOpts(options) {\n  if (options.esModuleInterop) {\n    return { forceDefaultImport: ['protobufjs/minimal'] };\n  } else {\n    return {};\n  }\n}\n","dynamism_density":0.0059372349,"dynamism_heuristic":7,"estimated_tokens":1179,"ext":"ts","fun_ann_density":0.0093299406,"function_parameters":5,"function_signatures":0,"function_usages":2,"functions":6,"hexsha":"e8163c19af6d0400d21846442a54c5e20ba9eac3","lang":"TypeScript","loc":144,"loc_per_function":12.1666666667,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"8f3d7dcde4172efd2659bd71ff4e96b412c5373a","max_forks_repo_licenses":["Apache-2.0"],"max_forks_repo_name":"AlaaZorkane/ts-proto","max_forks_repo_path":"src/options.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"8f3d7dcde4172efd2659bd71ff4e96b412c5373a","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["Apache-2.0"],"max_issues_repo_name":"AlaaZorkane/ts-proto","max_issues_repo_path":"src/options.ts","max_line_length":115,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"8f3d7dcde4172efd2659bd71ff4e96b412c5373a","max_stars_repo_licenses":["Apache-2.0"],"max_stars_repo_name":"AlaaZorkane/ts-proto","max_stars_repo_path":"src/options.ts","max_stars_repo_stars_event_max_datetime":"2022-01-12T15:26:53.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-12T15:26:53.000Z","metric":0.203541032,"predefined_density":0.5869565217,"predefined_types":27,"prop_ann_density":0.0254452926,"property_declarations":30,"size":4404,"trivial_density":0.152173913,"trivial_types":7,"type_definitions":1,"typedef_density":0.0008481764,"var_ann_density":0.0042408821,"variable_declarations":5},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export enum LongOption {\n    NUMBER = \"number\",\n    LONG = \"long\",\n    STRING = \"string\"\n}\nexport enum DateOption {\n    DATE = \"date\",\n    STRING = \"string\",\n    TIMESTAMP = \"timestamp\"\n}\nexport enum EnvOption {\n    NODE = \"node\",\n    BROWSER = \"browser\",\n    BOTH = \"both\"\n}\nexport enum OneofOption {\n    PROPERTIES = \"properties\",\n    UNIONS = \"unions\"\n}\nexport enum ServiceOption {\n    GRPC = \"grpc-js\",\n    GENERIC = \"generic-definitions\",\n    DEFAULT = \"default\",\n    NONE = \"none\"\n}\nexport type Options = {\n    context: boolean;\n    snakeToCamel: Array<LongOption>;\n    forceLong: LongOption;\n    useOptionals: \"none\" | \"none-optionals\" | \"none-nullable\" | boolean;\n    useDate: DateOption;\n    snakeToCamel: LongOption[];\n    useOptionals: \"none\" | \"none-optionals\" | \"none-nullable\" | boolean;\n    useDate: DateOption;\n    snakeToCamel: LongOption[];\n    useOptionals: \"none;\n    forceLong: \"number\" | \"long\" | \"string\" | boolean;\n    useOptionals: boolean;\n    useDate: DateOption;\n    snakeToCamel: LongOption[];\n    useOptionals: \"none;\n    useDate: DateOptio;\n    useOptionals: \"none;\n    snakeToCamel: LongOption[];\n    useOptionals: \"none\" | \"none-optionals\" | \"none-nullable\" | boolean;\n    useDate: DateOption;\n    snakeToCamel: LongOption[]; // boolean is deprecated\n    useDate: DateOption;\n    snakeToCamel: LongOption[]; // boolean is deprecated\n    useOptionals: boolean;\n    forceLong: \"number\" | \"long\" | \"string\";\n    useOptionals: boolean;\n    useDate: DateOptio;\n    oneof: \"properties\" | \"unions\" | \"strings\";\n    jsonTypes: boolean;\n    jsonIncludeEnums: boolean;\n    jsonIncludeDefaultValues: boolean;\n    jsonIncludeReadonlyProps: boolean;\n    jsonIncludeReadonlyMethods: boolea;\n    esModuleInterop: boolean;\n    jsonIncludeReadonlyProps: boolean;\n    jsonIncludeReadonlyMethods: boolean;\n    jsonIncludeReadonlyEnums: boolean;\n    jsonIncludeReadonlyTypes: boolean;\n    jsonIncludeReadonlyMethods: boolean;\n    jsonInclud;\n    fileSuffix: \"json\" | \"js\" | \"ts\" | \"tsx\";\n    fileSuffixForOptionals: \"json\" | \"js\" | \"ts\" | \"tsx\";\n    jsonIncludeReadonlyProps: boolean;\n    jsonIncludeRea;\n    outputEncodeMethods: \"none\" | \"camel\" | \"upperCamel\" | \"lowerCamel\";\n    jsonIncludeReadonlyProps: boolean;\n    jsonIncludeReadonlyMethods: boolean;\n    jsonIncludeReadonlyEnums: boolean;\n    jsonIncludeReadonlyType;\n    outputJsonMethods: \"none\" | \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    outputPartialMethods;\n    outputTypeRegistry;\n    stringEnums;\n    constEnums;\n    enumsAsLiterals;\n    outputClientImpl;\n    outputServices;;\n    outputPartialMethods: \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    outputSchema;\n    outputEncodeMethods: \"none\" | \"camel\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    fileSuffix: \"json\" | \"js;\n    outputTypeRegistry: \"none\" | \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    useOptionals;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    stringEnums: string[];\n    constEnums: string[];\n    enumsAsLiterals: boolean;\n    jsonIncludeEnums: boolean;\n    jsonIncludeDefaultValues: boolean;\n    jsonIncludeReadonlyProps: boolean;\n    jsonIncludeReadonlyMethods: boolean;\n    jso;\n    constEnums: string[];\n    jsonIncludeReadonlyProps: boolean;\n    jsonIncludeReadonlyMethods: boolean;\n    jsonIncludeReadonlyEnums: boolean;\n    jsonIncludeReadonlyType;\n    outputEncodeMethods: \"none\" | \"camelCase\" |;\n    enumsAsLiterals: boolean;\n    jsonIncludeEnums: boolean;\n    jsonIncludeDefaultValues: boolean;\n    jsonIncludeReadonlyProps: boolean;\n    jsonIncludeReadonlyMethods: boolean;\n    jsonIncludeReadonlyEnums: boolean;\n    jsonIncludeReadonlyTyp;\n    outputClientImpl: \"none\" | \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    outputSchema: boolean;\n    outputEncodeMethods: \"none\" | \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    useOptionals;\n    outputServices: boolean;\n    addGrpcMetadata;\n    addNestjsRestParameter;\n    returnObservable;\n    lowerCaseServiceMethods;\n    nestJs;\n    env;\n    unrecognizedEnum;\n    exportCommonSymbols;\n    outputSchema;\n    outputEncodeMethod;\n    addGrpcMetadata: boolean;\n    addNestjsRestParameter: boolean;\n    returnObservable;\n    lowerCaseServiceMethods;\n    nestJs;\n    env;\n    unrecognizedEnum;\n    exportCommonSymbols;\n    outputSchema;\n    outputEncodeMethod;\n    ad;\n    addNestjsRestParameter: boolean;\n    returnObservable;\n    lowerCaseServiceMethods;\n    nestJs;\n    env;\n    unrecognizedEnum;\n    exportCommonSymbols;\n    outputSchema;\n    outputEncodeMethod;\n    addGrpcMetadata: boolean;\n    addNestj;\n    returnObservable: boolean;\n    lowerCaseServiceMethods;\n    nestJs;\n    env;\n    unrecognizedEnum;\n    exportCommonSymbols;\n    outputSchema;\n    outputEncodeMethod;\n    addGrpcMetadata: boolean;\n    addNestjsRestParameter: boolea;\n    lowerCaseServiceMethods: boolean;\n    nestJs: boolean;\n    env: string;\n    unrecognizedEnum: boolean;\n    exportCommonSymbols: boolean;\n    outputSchema: boolean;\n    outputEncodeMethod: \"none\" | \"camelCase\" | \"upperCamelCase;\n    nestJs: boolean;\n    env: string;\n    unrecognizedEnum: boolean;\n    exportCommonSymbols: boolean;\n    outputSchema: boolean;\n    outputEncodeMethod: \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    jsonIncludeReadonl;\n    env: \"node\" | \"browser\";\n    unrecognizedEnum: boolean;\n    exportCommonSymbols: boolean;\n    outputSchema: boolean;\n    outputEncodeMethod: \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    jsonIncludeReado;\n    unrecognizedEnum: boolean;\n    exportCommonSymbols: boolean;\n    outputSchema: boolean;\n    outputEncodeMethod: \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    jsonIncludeReadonl: boolean;\n    onlyTypes: boolean;\n    emi;\n    exportCommonSymbols: boolean;\n    outputSchema: boolean;\n    outputEncodeMethod: \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    addGrpcMetadata: boolean;\n    addNestj: boolean;\n    jsonIncludeReadonl: boolean;\n    outputSchema: boolean;\n    outputEncodeMethod: \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    jsonIncludeReado: boolean;\n    env: \"node\" | \"browser\";\n    jsonIncludeReadonl: boolean;\n    outputSchem;\n    // An alias of !output\n    onlyTypes: boolean;\n    // Emitting enum types to be able to use the existing enumType.\n    enumType;\n    // If true, the generated code will contain a strict check that the enum values are valid enum values.\n    strictEnumValues;\n    emitImportedFiles: boolean;\n    addGrpcMetadata: boolean;\n    addNestj: boolean;\n    jsonIncludeReadonl: boolean;\n    outputSchema: boolean;\n    outputEncodeMethod: \"camelCase\" | \"upperCamelCase\" | \"lowerCamelCase\";\n    useExactTypes: boolean;\n    jsonIncludeReado: boolean;\n    enumType: string | boolean | \"camel\" | \"upperCamelCase\" | \"lowerCamelCase\" | boolean | LongOption | DateOption | OneofOption | \"camel\" | \"uppe;\n    delimitedMethods: boolean;\n    enumName;\n    enumType;\n    // If true, the generated code will contain a strict check that the enum values are valid enum values.\n    strictEnumValues;\n    emitImportedFiles: boolean;\n    jsonIncludeReadon;\n};\nexport function defaultOptions(): Options {\n    return {\n        context: false,\n        snakeToCamel: [\"json\", \"keys\"],\n        forceLong: LongOption.NUMBER,\n        useOptionals: \"none\",\n        useDate: DateOption.DATE,\n        oneof {\n    return {\n        context: false,\n        snakeToCamel: [\"json\", \"keys\"],\n        forceLong: LongOption.NUMBER,\n        useOptionals: \"none\",\n        useDate: DateOption.DATE,\n        oneof: OneofOption.PROPERTIES,\n        esModuleInterop: false,\n        fileSuffix: \"\",\n        lowerCaseServiceMethods: false,\n        outputEncodeMethods: true,\n        outputJsonMethods: true,\n        outputPartialMethods: true,\n        outputTypeRegistry: false,\n        stringEnums: false,\n        constEnums: false,\n        enumsAsLiterals: false,\n        outputClientImpl: true,\n        outputServices: ServiceOption.DEFAULT,\n        returnObservable: false,\n        addGrpcMetadata: false,\n        addNestjsRestParameter: false,\n        nestJs: false,\n        env: EnvOption.BOTH,\n        unrecognizedEnum: true,\n        exportCommonSymbols: true,\n        outputSchema: false,\n        onlyTypes: false,\n        emitImportedFiles: true,\n        useExactTypes: true,\n        delimitedMethods: false,\n    };\n}\nconst nestJsOptions = {\n    lowerCaseServiceMethods: true,\n    outputEncodeMethods: false,\n    outputJsonMethods: false,\n    outputPartialMethods: false,\n    outputClientImpl: false,\n    useDate: DateOption.TIMESTAMP,\n};\nexport function optionsFromParameter(parameter: OptionParameter): Options {\n    const options: Options = defaultOptions();\n    const parsed = parseParameter(parameter);\n    Object.assign(options, parsed);\n    return options;\n}\nexport function optionToBool(option: Option): boolean): boolean {\n    switch (option) {\n        case \"all-types\":\n        case \"allTypes\":\n            return true;\n        case \"none\":\n        case \"noneOption\":\n            return false;\n        default:\n            throw new Error(`Unexpected optio {\n    const options = defaultOptions();\n    if (parameter) {\n        const parsed = parseParameter(parameter);\n        if (parsed.nestJs) {\n            Object.assign(options, nestJsOptions);\n        }\n        Object.assign(options, parsed);\n    }\n    // We should promote onlyTypes to its own documented flag, but just an alias for now\n    if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {\n        options.onlyTypes = true;\n    }\n    // Treat forceLong=true as LONG\n    if ((options.forceLong as any) === true) {\n        options.forceLong = LongOption.LONG;\n    }\n    // Treat outputServices=false as NONE\n    if ((options.outputServices as any) === false) {\n        options.outputServices = ServiceOption.NONE;\n    }\n    if ((options.useDate as any) === true) {\n        // Treat useDate=true as DATE\n        options.useDate = DateOption.DATE;\n    }\n    else if ((options.useDate as any) === false) {\n        // Treat useDate=false as TIMESTAMP\n        options.useDate = DateOption.TIMESTAMP;\n    }\n    if ((options.snakeToCamel as any) === false) {\n        options.snakeToCamel = [];\n    }\n    else if ((options.snakeToCamel as any) === true) {\n        options.snakeToCamel = [\"keys\", \"json\"];\n    }\n    return options;\n}\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction parseParameter(parameter: string): ParsedOptions {\n    const opts = parseOptions(parameter);\n    return {\n        nestJs: opts.nestJs,\n        onlyTypes: opts.onlyTypes,\n        outputJsonMethods: opts.outputJsonMethods,\n        outputEncodeMethod): {\n            nestJs: opts.nestJs,\n            onlyTypes: opts.onlyTypes,\n            outputJsonMethods: opts.outputJsonMethods,\n            outputEncodeMethod: opts.outputEncodeMethod,\n            outputClientImpl: opts.outputClien {\n    const options = {} as any;\n    const pairs = parameter.split(\",\").map((s: string): [string, boolean] => s.split(\"=\"));\n    pairs.forEach(([key, value]) => {\n        options[key] = value === \"true\"? true : value === \"false\"? false : value;\n    });\n    retur => s.split(\"=\"));\n    pairs.forEach(([key, value]: [string, boolean]) => {\n        options[key] = value;\n    });\n    return options;\n}\n    } as ParsedOptions;\n}\nfunction parseOptions(parameter: string): ParsedOptions {\n    const pairs = parameter.spli): [string, boolean] => parameter.split(\",\").map((s: string): [string, boolean] => s.split(\"=\"));\n    const options = {};\n    pairs.forEach(([key, value]) => {\n        options[key] = value === \"true\" ? true : value === \"false\" ? false : value;\n    });\n    return options;\n}\nexport function getTsPoetOpts(options: ParsedOptions, tsConfig?: ts.Program): ts.CompilerOptions {\n    return {\n        allowSyntheticDefaultImports: options.esModuleInterop || undefined,\n        allowUnreachableCode: options.allowUnreachableCode || undefined,\n        allowUnusedLabel): ts.CompilerOptions {\n        allowSyntheticDefaultImports: options.esModuleInterop,\n        allowUnreachableCode: options.allowUnreachableCode,\n        allowUnusedLabel: options.allowUnusedLabel,\n        allowUnusedParameterProperties: options.esModuleIntero {\n    if (options.esModuleInterop) {\n        return { forceDefaultImport: [\"protobufjs/minimal\"] };\n    }\n    else {\n        return {};\n    }\n}\n","score":85,"fallbacked":false,"num_type_errors":281},{"code":"export enum LongOption {\n    NUMBER = \"number\",\n    LONG = \"long\",\n    STRING = \"string\"\n}\nexport enum DateOption {\n    DATE = \"date\",\n    STRING = \"string\",\n    TIMESTAMP = \"timestamp\"\n}\nexport enum EnvOption {\n    NODE = \"node\",\n    BROWSER = \"browser\",\n    BOTH = \"both\"\n}\nexport enum OneofOption {\n    PROPERTIES = \"properties\",\n    UNIONS = \"unions\"\n}\nexport enum ServiceOption {\n    GRPC = \"grpc-js\",\n    GENERIC = \"generic-definitions\",\n    DEFAULT = \"default\",\n    NONE = \"none\"\n}\nexport type Options = {\n    context: boolean;\n    snakeToCamel: LongOption[];\n    forceLong: LongOption;\n    useOptionals: OneofOption | undefined;\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleInterop: boolean;;\n    snakeToCamel: LongOption;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;\n    outputJsonMethods: boolean;\n    outputPartialMethods: boolean;\n    outputTypeRegistry: boolean;\n    stringEnums: boolean;\n    constEnums: boolean;;\n    forceLong: boolean;\n    enumsAsLiterals: boolean;\n    outputClientImpl: boolean;\n    outputServices: boolean;\n    addGrpcMetadata: boolean;\n    addNestjsRestParameter: boolean;\n    returnObservable: boolean;\n    lowerCaseServiceMethod;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    useOptionals: boolean;\n    useOptionals: boolea; // boolean is deprecated\n    useDate: boolean;\n    onlyTypes: boolean;\n    emitImportedFiles: boolean;\n    useExactTypes: boolean;\n    delimitedMethods: boolean;\n};\nexport function createOptions(options: Options): Options {\n    return {\n        context: options;\n    oneof: options.oneof,\n        forceLong: options.forceLong,\n        useOptionals: options.useOptionals,\n        useDate: options.useDate,\n        fileSuffix: options.fileSuffix,\n        outputEncodeMethods: options.outpu;\n    esModuleInterop: options.esModuleInterop,\n    snakeToCamel: options.snakeToCamel,\n    outputTypeRegistry: options.outputTypeRegistry,\n    outputClientImpl: options.outputClientImpl,\n    outputServices: options.outputServices,\n    addGrp;\n    fileSuffix: options.fileSuffix,\n    enumsAsLiterals: options.enumsAsLiterals,\n    returnObservable: options.returnObservable,\n    addNestjsRestParameter: options.addNestjsRestParameter,\n    stringEnums: options.stringEnum;\n    outputEncodeMethods: options.outpuEncodeMethods,\n    delimitedMethods: options.delimitedMethods,\n};\nexport function createOptionsFromOptions(options: Options | string, context?: Schema): Options {\n    if (typeof options === \"string\") {;\n    outputJsonMethods: options;\n    outputPartialMethods: options;\n    outputTypeRegistry: options;\n    stringEnums: options;\n    constEnums: boolean;\n    enumsAsLiterals: boolean;\n    outputClientImpl: options;\n    outputServices: options;\n    ad;\n    outputPartialMethods: boolean;\n    outputEncodeMethods: string;\n    outputJsonMethods: string;\n    outputSchema: Schema;\n    outputServices: string;\n    outputClientImpl: string;\n    context = context;\n    return {\n        context,\n        outputEncodeMethod;\n    outputTypeRegistry: outputTypeRegistry || \"proto3\",\n        stringEnums,\n        enumsAsLiterals,\n        returnObservable,\n        addNestjsRestParameter,\n        outputClientImpl: outputClientImpl || \"grpc\",\n        outputServices: outputServices || \"grp;\n    stringEnums: stringEnums || true,\n    outputPartialMethods: outputPartialMethods || true,\n    outputJsonMethods: outputJsonMethods || \"grpc\",\n    onlyTypes: onlyTypes || false,\n    exportCommonSymbols: exportCommonSymbols || false,\n    outpu;\n    constEnums: boolean;\n    addNestjsRestParameter: boolean;\n    outputSchema: Schema;\n    onlyTypes: boolean;\n    delimitedMethods: boolean;\n    env: string;\n    exportCommonSymbols: boolean;\n    exportAllProperties: boolean;;\n    enumsAsLiterals: boolean;\n    outputEncodeMethods: outputEncodeMethods || \"proto3\",\n    outputSchema: outputSchema || Schema.OBJECT,\n    env: env || \"NODE\",\n    outputServices: outputServices || \"grp;\n    outputClientImpl: outpu;\n    outputClientImpl: outputClientImpl || \"grpc\",\n    onlyTypes: onlyTypes || false,\n    exportCommonSymbols: exportCommonSymbols || false,\n    exportAllProperties: exportAllProperties || false,\n    outputEncodeMethod: outputEncodeMethod || \"proto;\n    outputServices: outputServices || \"grp;\n    outputEncodeMethod: outputEncodeMethod || \"proto3\",\n    outputEncodeMethod: outputEncodeMethod || \"protobuf\",\n    outputEncodeMethod: outputEncodeMethod || \"json\",\n    outputEncodeMethod: outputEncod;\n    addGrpcMetadata: addGrpcMetadata || false,\n    context: context || false,\n    outputEncodeMethod: outputEncodeMethod || \"proto3\",\n    stringEnums: stringEnums || true,\n    enumsAsLiterals: enumsAsLiterals || false,\n    returnObservable;\n    addNestjsRestParameter: addNestjsRestParameter || false,\n    env: env || \"NODE\",\n    delimitedMethods: delimitedMethods || false,\n    enumsAsLiterals: enumsAsLiterals || false,\n    outputSchema: outputSchema || Schema.OBJECT,\n    outpu;\n    returnObservable: returnObservable || true;\n    addNestjsRestParameter: addNestjsRestParameter || false,\n    outputEncodeMethod: outputEncodeMethod || \"proto3\",\n    outputEncodeMethod: outputEncodeMethod || \"protobuf\",\n    outputEncod;\n    lowerCaseServiceMethods: lowerCaseServiceMethods || false,\n    outputEncodeMethod: outputEncodeMethod || \"proto3\",\n    outputEncodeMethod: outputEncodeMethod || \"protobuf\",\n    outputEncodeMethod: outputEncodeMethod || \"json\",\n    onlyTypes: onlyType;\n    nestJs: nestJs || false,\n    exportCommonSymbols: exportCommonSymbols || false,\n    exportAllProperties: exportAllProperties || false,\n    addGrpcMetadata: addGrpcMetadata || false,\n    outputEncodeMethod: outputEncodeMethod || \"proto;\n    env: env || \"NODE\",\n    enumsAsLiterals: enumsAsLiterals || false,\n    addNestjsRestParameter: addNestjsRestParameter || false,\n    outputEncodeMethod: outputEncodeMethod || \"proto3\",\n    outputEncodeMetho;\n    unrecognizedEnum: unrecognizedEnum || false,\n    outputEncodeMethod: outputEncodeMethod || \"proto3\",\n    outputEncodeMethod: outputEncodeMethod || \"protobuf\",\n    enumsAsLiterals: enumsAsLiterals || false,\n    stringEnums: stringEnums || tru;\n    exportCommonSymbols: exportCommonSymbols || false,\n    outputEncodeMethod: outputEncodeMethod || \"proto3\",\n    outputEncodeMethod: outputEncodeMethod || \"protobuf\",\n    addNestjsRestParameter: addNestjsRestParameter || false,\n    enum;\n    outputSchema: outputSchema || Schema.OBJECT,\n    outputEncodeMethod: outputEncodeMethod || \"proto3\",\n    outputEncodeMethod: outputEncodeMethod || \"protobuf\",\n    outputEncodeMethod: outputEncodeMethod || \"json\",\n    enumsAsLiterals: enum;\n    // An alias of !output\n    onlyTypes: onlyTypes || false,\n    addNestjsRestParameter: addNestjsRestParameter || false,\n    outputSchema: outputSchema || Schema.OBJECT,\n    enum: enum || false,\n    enumsAsLiterals: enumsAsLiterals || fals;\n    emitImportedFiles: emitImportedFiles || false,\n    addEnumNameToMessage: addEnumNameToMessage || false,\n    addMessageNameToEnum: addMessageNameToEnum || false,\n    addEnumNameToEnum: addEnumNameToEnum || fals;\n    useExactTypes: useExactTypes || false,\n    exportCommonSymbols: exportCommonSymbols || false,\n    enum: enum || false,\n    enumsAsLiterals: enumsAsLiterals || fals,\n    enumValues: enumValues || [],\n    enumValuesWithAlias;\n    delimitedMethods: delimitedMethods || false,\n    longEnums: longEnums || false,\n    addEnumNameToMessage: addEnumNameToMessage || fals,\n    addMessageNameToEnum: addMessageNameToEnum || fals,\n    addEnu;\n};\nexport function defaultOptions(): Options {\n    return {\n        context: false,\n        snakeToCamel: [\"json\", \"keys\"],\n        forceLong: LongOption.NUMBER,\n        useOptionals: \"none\",\n        useDate: DateOption.DATE,\n        oneof {\n    return {\n        context: false,\n        snakeToCamel: [\"json\", \"keys\"],\n        forceLong: LongOption.NUMBER,\n        useOptionals: \"none\",\n        useDate: DateOption.DATE,\n        oneof: OneofOption.PROPERTIES,\n        esModuleInterop: false,\n        fileSuffix: \"\",\n        lowerCaseServiceMethods: false,\n        outputEncodeMethods: true,\n        outputJsonMethods: true,\n        outputPartialMethods: true,\n        outputTypeRegistry: false,\n        stringEnums: false,\n        constEnums: false,\n        enumsAsLiterals: false,\n        outputClientImpl: true,\n        outputServices: ServiceOption.DEFAULT,\n        returnObservable: false,\n        addGrpcMetadata: false,\n        addNestjsRestParameter: false,\n        nestJs: false,\n        env: EnvOption.BOTH,\n        unrecognizedEnum: true,\n        exportCommonSymbols: true,\n        outputSchema: false,\n        onlyTypes: false,\n        emitImportedFiles: true,\n        useExactTypes: true,\n        delimitedMethods: false,\n    };\n}\nconst nestJsOptions = {\n    lowerCaseServiceMethods: true,\n    outputEncodeMethods: false,\n    outputJsonMethods: false,\n    outputPartialMethods: false,\n    outputClientImpl: false,\n    useDate: DateOption.TIMESTAMP,\n};\nexport function optionsFromParameter(parameter: Parameter): Options {\n    const options: Options = defaultOptions();\n    if (parameter) {\n        const parsed = parseParameter(parameter);\n        Object.assign(options, parsed);\n    }\n    return options;\n}\nexport function optionsFromCommandLin): Options {\n    const options: Options = defaultOptions();\n    const parsed = parseCommandLin(process.argv);\n    Object.assign(options, parsed);\n    return options;\n}\nexport function optionsFromCli(): Options {\n    const options {\n    const options = defaultOptions();\n    if (parameter) {\n        const parsed = parseParameter(parameter);\n        if (parsed.nestJs) {\n            Object.assign(options, nestJsOptions);\n        }\n        Object.assign(options, parsed);\n    }\n    // We should promote onlyTypes to its own documented flag, but just an alias for now\n    if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {\n        options.onlyTypes = true;\n    }\n    // Treat forceLong=true as LONG\n    if ((options.forceLong as any) === true) {\n        options.forceLong = LongOption.LONG;\n    }\n    // Treat outputServices=false as NONE\n    if ((options.outputServices as any) === false) {\n        options.outputServices = ServiceOption.NONE;\n    }\n    if ((options.useDate as any) === true) {\n        // Treat useDate=true as DATE\n        options.useDate = DateOption.DATE;\n    }\n    else if ((options.useDate as any) === false) {\n        // Treat useDate=false as TIMESTAMP\n        options.useDate = DateOption.TIMESTAMP;\n    }\n    if ((options.snakeToCamel as any) === false) {\n        options.snakeToCamel = [];\n    }\n    else if ((options.snakeToCamel as any) === true) {\n        options.snakeToCamel = [\"keys\", \"json\"];\n    }\n    return options;\n}\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction parseParameter(parameter: string): ParsedParameter {\n    if (!parameter) {\n        throw new Error(\"Parameter is empty\");\n    }\n    const key = parameter.split(\"=\")[0];\n    if (key === \"help\") {\n        return {\n            help: true,\n            comman {\n    const options = {} as any;\n    const pairs = parameter.split(\",\").map((s: string): [string, string] => s.split(\"=\"));\n    pairs.forEach(([key, value]) => {\n        options[key] = value === \"true\"? true : value === \"false\"? false : value;\n    });\n    retur => s.split(\"=\"));\n    pairs.forEach(([key, value]: [string, string]) => {\n        options[key] = value;\n    });\n    return options;\n}\n}\n}\n}\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction pars): ParsedCommand {\n    if (!command) {\n        throw new Error(\"Command is empty\");\n    }\n    const keys = command.split(\",\").map((s: string): ParsedParameter => {\n        if (s === \"help\") {\n            retur => {\n        options[key] = value === \"true\" ? true : value === \"false\" ? false : value;\n    });\n    return options;\n}\nexport function getTsPoetOpts(options: ParsedOptions): ITSPOETOptions {\n    if (!options ||!options.parameters ||!Array.isArray(options.parameters)) {\n        throw new Error(\"Options must have 'parameters' property\");\n    }\n    const parameters = options): ParsedParameter => {\n        if (s === \"help\") {\n            retur => {\n        options[key] = value === \"true\"? true : value === \"false\"? false : value;\n    });\n    return options; {\n    if (options.esModuleInterop) {\n        return { forceDefaultImport: [\"protobufjs/minimal\"] };\n    }\n    else {\n        return {};\n    }\n}\n","score":106,"fallbacked":false,"num_type_errors":329},{"code":"export enum LongOption {\n    NUMBER = \"number\",\n    LONG = \"long\",\n    STRING = \"string\"\n}\nexport enum DateOption {\n    DATE = \"date\",\n    STRING = \"string\",\n    TIMESTAMP = \"timestamp\"\n}\nexport enum EnvOption {\n    NODE = \"node\",\n    BROWSER = \"browser\",\n    BOTH = \"both\"\n}\nexport enum OneofOption {\n    PROPERTIES = \"properties\",\n    UNIONS = \"unions\"\n}\nexport enum ServiceOption {\n    GRPC = \"grpc-js\",\n    GENERIC = \"generic-definitions\",\n    DEFAULT = \"default\",\n    NONE = \"none\"\n}\nexport type Options = {\n    context: boolean;\n    snakeToCamel: Array<LongOption>;\n    forceLong: LongOption;\n    useOptionals: OneofOption; // boolean is deprecated\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleIntero;\n    snakeToCamel: Array<LongOption>;\n    outputEncodeMethods: boolean;\n    outputJsonMethods: boolean;\n    outputPartialMethods: boolean;\n    outputTypeRegistry: boolean;\n    stringEnums: boolean;\n    constEnums: boolean;\n    enumsAsLiterals;\n    forceLong: LongOption;\n    useOptionals: OneofOption; // boolean is deprecated\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleInterop: boolean;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;\n    useOptionals: OneofOption; // boolean is deprecated\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleInterop: boolean;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;\n    useOptionals: OneofOptio; // boolean is deprecated\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleInterop: boolean;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;\n    useOptionals: OneofOption; // boolean is deprecated\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleInterop: boolean;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;\n    useOptionals: OneofOption; // boolean is deprecated\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleInterop: boolean;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;\n    outputJsonMethods: boolean;\n    outputPartialMethods: boolean;\n    outputTypeRegistry: boolean;\n    stringEnums: boolean;\n    constEnums: boolean;\n    enum;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;\n    useOptionals: OneofOption; // boolean is deprecated\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleInterop: boolean;\n    fileSuffix: string;;\n    outputEncodeMethods: boolean;\n    useOptionals: OneofOption; // boolean is deprecated\n    useDate: DateOption;\n    oneof: OneofOption;\n    esModuleInterop: boolean;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;;\n    outputJsonMethods: boolean;\n    outputPartialMethods: boolean;\n    outputTypeRegistry: boolean;\n    stringEnums: boolean;\n    constEnums: boolean;\n    enum;\n    fileSuffix: string;\n    outputEncodeMethods: boolean;\n    useOptionals: On;\n    outputPartialMethods: boolean;\n    outputTypeRegistry;\n    stringEnums;\n    constEnums;\n    enumsAsLiterals;\n    fileSuffix;\n    outputEncodeMethods;\n    useOptionals; // boolean is deprecated\n    useDate;\n    oneof;\n    esModuleInterop;\n    outputTypeRegistry: boolean;\n    stringEnums;\n    constEnums;\n    enumsAsLiterals;\n    fileSuffix;\n    outputEncodeMethods;\n    useOptionals; // boolean is deprecated\n    useDate;\n    oneof;\n    esModuleInterop;\n    outputTypeRegistry;\n    stringEnums: boolean;\n    constEnums;\n    enumsAsLiterals;\n    fileSuffix;\n    outputEncodeMethods;\n    useOptionals; // boolean is deprecated\n    useDate;\n    oneof;\n    esModuleInterop;\n    outputTypeRegistry;\n    stringEnums;\n    constEnums: boolean;\n    enumsAsLiterals: boolean;\n    fileSuffix;\n    outputEncodeMethods;\n    useOptionals: On;\n    outputPartialMethods: boolean;\n    outputTypeRegistry;\n    stringEnums: boolean;\n    constEnums: boolean;;\n    enumsAsLiterals: boolean;\n    fileSuffix;\n    outputEncodeMethods;\n    useOptionals; // boolean is deprecated\n    useDate;\n    oneof;\n    esModuleInterop;\n    outputTypeRegistry;\n    stringEnums: boolean;\n    constEnums: boolean;;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolea;\n    outputServices: boolean;\n    outputServices: boolean;\n    outputServices: boolean;\n    outputServices: boolean;\n    outputServices: boolean;\n    outputServices: boolean;\n    outputServices: boolean;\n    outputServices: boolean;\n    outputServices: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolea;\n    addNestjsRestParameter: boolean;\n    addNestjsRestParameter: boolean;\n    addNestjsRestParameter: boolean;\n    addNestjsRestParameter: boolean;\n    addNestjsRestParameter: boolean;\n    addNestjsRestParameter;\n    returnObservable: boolean;\n    useOptionals: \"none\" | \"strict\" | \"all\",\n    useOptionals: \"strict\",\n    useOptionals: \"all\"\n};\nexport interface ApiConfig {\n    allowTrailingSlash: boolean;;\n    lowerCaseServiceMethods: \"none\" | \"strict\" | \"all\",\n    snakeToCamel: [\"json\", \"keys\"],\n    forceLong: LongOption.NUMBER,\n    useOptionals: \"none\" | \"strict\" | \"all\",\n    useDat;\n    nestJs: boolean;\n    returnObservable: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addNestjsRestParamete;\n    env: \"none\" | \"strict\",\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputClientImpl: boolean;\n    outputServices: boolean;\n    outpu;\n    unrecognizedEnum: \"none\" | \"strict\",\n    useDat: DateOption.DATE,\n    nestJs: boolean,\n    useStrictJson: boolean;\n};\nexport interface ApiConfig {\n    allowTrailingSlash: boolean;\n    lowerCaseServiceMethods;\n    exportCommonSymbols: \"none\" | \"strict\" | \"all\",\n    exportCommonSymbols: \"all\",\n    exportCommonSymbols: \"none\",\n    exportCommonSymbols: \"strict\",\n    forceLong: LongOption.NUMBER,\n    env: \"none;\n    outputSchema: \"none\" | \"strict\" | \"all\",\n    outputSchema: \"all\",\n    useOptionals: \"none\" | \"strict\" | \"all\",\n    useOptionals: \"all\",\n    useOptionals: \"none\";\n    // An alias of !output\n    onlyTypes: \"none\" | \"strict\",\n    onlyTypes: \"none\",\n    useDat;\n    nestJs: boolean;\n    exportCommonSymbols: boolean;\n    exportCommonSymbols;\n    exportCommonSymbols: boolean;\n    exportCommonSymbols: boolean;\n    emitImportedFiles: boolean;\n    useStrictJson: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addGrpcMetadata: boolean;\n    addNestjsRestParamete: boolean;\n    ad;\n    useExactTypes: boolean;\n    addImportStatements: boolean;\n    addImportStatements: boolean;\n    addImportStatements: boolean;\n    addImportStatements: boolean;\n    addImportStatements: boolean;\n    addImportStatements: boolean;\n    addImportStatements: boolea;\n    delimitedMethods: \"none\" | \"strict\",\n    delimitedMethods: \"none\",\n    useEnumTypes: boolean;\n    useEnumTypes: boolean;\n    useEnumTypes: boolean;\n    useEnumTypes: boolean;\n    useEnumTypes: boolean;;\n};\nexport function defaultOptions(): ApiConfig {\n    return {\n        allowTrailingSlash: false,\n        lowerCaseServiceMethods: false,\n        exportCommonSymbols: \"none\",\n        exportCommonSymbols: \"strict\",\n        forceLong: LongOption.NUMBER,\n        env: {\n    return {\n        context: false,\n        snakeToCamel: [\"json\", \"keys\"],\n        forceLong: LongOption.NUMBER,\n        useOptionals: \"none\",\n        useDate: DateOption.DATE,\n        oneof: OneofOption.PROPERTIES,\n        esModuleInterop: false,\n        fileSuffix: \"\",\n        lowerCaseServiceMethods: false,\n        outputEncodeMethods: true,\n        outputJsonMethods: true,\n        outputPartialMethods: true,\n        outputTypeRegistry: false,\n        stringEnums: false,\n        constEnums: false,\n        enumsAsLiterals: false,\n        outputClientImpl: true,\n        outputServices: ServiceOption.DEFAULT,\n        returnObservable: false,\n        addGrpcMetadata: false,\n        addNestjsRestParameter: false,\n        nestJs: false,\n        env: EnvOption.BOTH,\n        unrecognizedEnum: true,\n        exportCommonSymbols: true,\n        outputSchema: false,\n        onlyTypes: false,\n        emitImportedFiles: true,\n        useExactTypes: true,\n        delimitedMethods: false,\n    };\n}\nconst nestJsOptions = {\n    lowerCaseServiceMethods: true,\n    outputEncodeMethods: false,\n    outputJsonMethods: false,\n    outputPartialMethods: false,\n    outputClientImpl: false,\n    useDate: DateOption.TIMESTAMP,\n};\nexport function optionsFromParameter(parameter: string | undefined, defaultImportPath?: string): ApiConfig {\n    const options = defaultOptions();\n    if (parameter) {\n        const parsed = parseParameter(parameter);\n        Object.assign(options, parsed);\n    }\n    if (defaultImpor): string {\n        options.defaultImportPath = defaultImportPath;\n    }\n    return options;\n}\nexport function optionsFromOptions(options: Readonly<ApiConfig>): ApiConfig {\n    return defaultOptions();\n}\nexport interface Impor {\n    const options = defaultOptions();\n    if (parameter) {\n        const parsed = parseParameter(parameter);\n        if (parsed.nestJs) {\n            Object.assign(options, nestJsOptions);\n        }\n        Object.assign(options, parsed);\n    }\n    // We should promote onlyTypes to its own documented flag, but just an alias for now\n    if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {\n        options.onlyTypes = true;\n    }\n    // Treat forceLong=true as LONG\n    if ((options.forceLong as any) === true) {\n        options.forceLong = LongOption.LONG;\n    }\n    // Treat outputServices=false as NONE\n    if ((options.outputServices as any) === false) {\n        options.outputServices = ServiceOption.NONE;\n    }\n    if ((options.useDate as any) === true) {\n        // Treat useDate=true as DATE\n        options.useDate = DateOption.DATE;\n    }\n    else if ((options.useDate as any) === false) {\n        // Treat useDate=false as TIMESTAMP\n        options.useDate = DateOption.TIMESTAMP;\n    }\n    if ((options.snakeToCamel as any) === false) {\n        options.snakeToCamel = [];\n    }\n    else if ((options.snakeToCamel as any) === true) {\n        options.snakeToCamel = [\"keys\", \"json\"];\n    }\n    return options;\n}\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction parseParameter(parameter: string) {\n    const options = {} as any;\n    const pairs = parameter.split(\",\").map((s) => s.split(\"=\"));\n    pairs.forEach(([key, value]) => {\n        options[key] = value ===): any;\n    });\n    return options;\n}\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction parseBooleanParameter(parameter: string) {\n    const options = {} as any;\n    const pairs = parameter.split(\",\").map((s: string) => s.split(\"=\"));\n    pairs.forEach(([key, value]) => {\n        options[key] = value === \"true\"? true : value === \"false\"? false : value;\n    });\n    return options;): any;\n}\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction parseLongParameter(parameter: string) {\n    const options = {} as any;\n    const pairs = parameter.split(\",\") => s.split(\"=\"));\n    pairs.forEach(([key, value]: [string, string]) => {\n        options[key] = value === \":true\"? true : value === \":false\"? false : value;\n    });\n    return options;\n}\n// A very naive parse function, eventually could/should us): function parseOptionalParameter(parameter: string) {\n//     const options = {} as any;\n//     const pairs = parameter.split(\",\").map((s: string) => s.split(\"=\"));\n//     pairs.forEach(( => {\n        options[key] = value === \"true\" ? true : value === \"false\" ? false : value;\n    });\n    return options;\n}\nexport function getTsPoetOpts(options: ItsOptions): ItsOptions {\n    const opts = {\n        extraNodeModules: [],\n    };\n    if (options.typescriptConfigPath) {\n        opts.extraNodeModules.push(options.typescriptConfigPath);\n    }\n    i): any {\n        opts.extraNodeModules.push(path.resolve(process.cwd(), \"node_modules\"));\n    }\n    if (options.dtsConfigPath) {\n        opts.extraNodeModules.push(options.dtsConfigPat {\n    if (options.esModuleInterop) {\n        return { forceDefaultImport: [\"protobufjs/minimal\"] };\n    }\n    else {\n        return {};\n    }\n}\n","score":87,"fallbacked":false,"num_type_errors":358}]}
{"dataset_elem":{"alphanum_fraction":0.454749439,"avg_line_length":19.1,"content":"/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable import/prefer-default-export */\nexport const listCustomerGQL = () => {\n  return `\n    query {\n      customers {\n        id\n        customerType\n        personal_info {\n          fullName\n          prefix\n          firstName\n          lastName\n          birthDate\n          email\n        }\n        investment_summary {\n          id\n        }\n      }\n    }\n  `;\n};\n\nexport const getInvestmentSummaryGQL = (id: any) => {\n  return `\n    query {\n      investmentSummary(id: ${id}) {\n        id\n        accountsByCurrency {\n          currency\n          asOf\n          items {\n            acctNo\n            acctName\n            totalInvestmentAmt\n            currentFundValue\n            gainOrLossAmt\n            gainOrLossPercent\n          }\n        }\n        fundsByCurrency {\n          currency\n          items {\n            tag\n            currentValue\n            totalInitial\n            allocation\n          }\n        }\n        transactionHistory {\n          acctName\n          acctNo\n          status\n          transactionDetails{\n            trxnType\n          }\n          currentFundValue{\n            fundName\n            totalInitial\n            totalShares\n            currentNavpu\n            currentFundValue\n          }\n        }\n      }\n    }\n  `;\n};\n","content_without_annotations":"/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable import/prefer-default-export */\nexport const listCustomerGQL = () => {\n  return `\n    query {\n      customers {\n        id\n        customerType\n        personal_info {\n          fullName\n          prefix\n          firstName\n          lastName\n          birthDate\n          email\n        }\n        investment_summary {\n          id\n        }\n      }\n    }\n  `;\n};\n\nexport const getInvestmentSummaryGQL = (id) => {\n  return `\n    query {\n      investmentSummary(id: ${id}) {\n        id\n        accountsByCurrency {\n          currency\n          asOf\n          items {\n            acctNo\n            acctName\n            totalInvestmentAmt\n            currentFundValue\n            gainOrLossAmt\n            gainOrLossPercent\n          }\n        }\n        fundsByCurrency {\n          currency\n          items {\n            tag\n            currentValue\n            totalInitial\n            allocation\n          }\n        }\n        transactionHistory {\n          acctName\n          acctNo\n          status\n          transactionDetails{\n            trxnType\n          }\n          currentFundValue{\n            fundName\n            totalInitial\n            totalShares\n            currentNavpu\n            currentFundValue\n          }\n        }\n      }\n    }\n  `;\n};\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":254,"ext":"ts","fun_ann_density":0.0118110236,"function_parameters":1,"function_signatures":0,"function_usages":0,"functions":2,"hexsha":"39e9a546c0ecc8a1bf2625ac74a935aeae2252dc","lang":"TypeScript","loc":66,"loc_per_function":31.0,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-02-12T02:16:15.000Z","max_forks_repo_forks_event_min_datetime":"2022-02-12T02:16:15.000Z","max_forks_repo_head_hexsha":"3840e2833c5f50fbdbf9b13ae6214fbb81e8c157","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"joker-crypto/PUP-Facuty-Workload","max_forks_repo_path":"src/api/graphql/fundUpdate.graphql.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"3840e2833c5f50fbdbf9b13ae6214fbb81e8c157","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"joker-crypto/PUP-Facuty-Workload","max_issues_repo_path":"src/api/graphql/fundUpdate.graphql.ts","max_line_length":55,"max_stars_count":null,"max_stars_repo_head_hexsha":"3840e2833c5f50fbdbf9b13ae6214fbb81e8c157","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"joker-crypto/PUP-Facuty-Workload","max_stars_repo_path":"src/api/graphql/fundUpdate.graphql.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2203178278,"predefined_density":0.0,"predefined_types":0,"prop_ann_density":0.0,"property_declarations":0,"size":1337,"trivial_density":0.2,"trivial_types":1,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0078740157,"variable_declarations":2},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable import/prefer-default-export */\nexport const listCustomerGQL = (): string => {\n    return `\n    query {\n      customers {\n        id\n        customerType\n        personal_info {\n          fullName\n          prefix\n          firstName\n          lastName\n          birthDate\n          email\n        }\n        investment_summary {\n          id\n        }\n      }\n    }\n  `;\n};\nexport const getInvestmentSummaryGQL = (id: string): string => {\n    return `\n    query {\n      investmentSummary(id: ${id}) {\n        id\n        accountsByCurrency {\n          currency\n          asOf\n          items {\n            acctNo\n            acctName\n            totalInvestmentAmt\n            currentFundValue\n            gainOrLossAmt\n            gainOrLossPercent\n          }\n        }\n        fundsByCurrency {\n          currency\n          items {\n            tag\n            currentValue\n            totalInitial\n            allocation\n          }\n        }\n        transactionHistory {\n          acctName\n          acctNo\n          status\n          transactionDetails{\n            trxnType\n          }\n          currentFundValue{\n            fundName\n            totalInitial\n            totalShares\n            currentNavpu\n            currentFundValue\n          }\n        }\n      }\n    }\n  `;\n};\n","score":0,"fallbacked":false,"num_type_errors":0},{"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable import/prefer-default-export */\nexport const listCustomerGQL = (): string => {\n    return `\n    query {\n      customers {\n        id\n        customerType\n        personal_info {\n          fullName\n          prefix\n          firstName\n          lastName\n          birthDate\n          email\n        }\n        investment_summary {\n          id\n        }\n      }\n    }\n  `;\n};\nexport const getInvestmentSummaryGQL = (id: number): string => {\n    return `\n    query {\n      investmentSummary(id: ${id}) {\n        id\n        accountsByCurrency {\n          currency\n          asOf\n          items {\n            acctNo\n            acctName\n            totalInvestmentAmt\n            curren => {\n    return `\n    query {\n      investmentSummary(id: ${id}) {\n        id\n        accountsByCurrency {\n          currency\n          asOf\n          items {\n            acctNo\n            acctName\n            totalInvestmentAmt\n            currentFundValue\n            gainOrLossAmt\n            gainOrLossPercent\n          }\n        }\n        fundsByCurrency {\n          currency\n          items {\n            tag\n            currentValue\n            totalInitial\n            allocation\n          }\n        }\n        transactionHistory {\n          acctName\n          acctNo\n          status\n          transactionDetails{\n            trxnType\n          }\n          currentFundValue{\n            fundName\n            totalInitial\n            totalShares\n            currentNavpu\n            currentFundValue\n          }\n        }\n      }\n    }\n  `;\n};\n","score":0,"fallbacked":false,"num_type_errors":43},{"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable import/prefer-default-export */\nexport const listCustomerGQL = (): string => {\n    return `\n    query {\n      customers {\n        id\n        customerType\n        personal_info {\n          fullName\n          prefix\n          firstName\n          lastName\n          birthDate\n          email\n        }\n        investment_summary {\n          id\n        }\n      } => {\n    return `\n    query {\n      customers {\n        id\n        customerType\n        personal_info {\n          fullName\n          prefix\n          firstName\n          lastName\n          birthDate\n          email\n        }\n        investment_summary {\n          id\n        }\n      }\n    }\n  `;\n};\nexport const getInvestmentSummaryGQL = (id: string): string => {\n    return `\n    query {\n      investmentSummary(id: ${id}) {\n        id\n        accountsByCurrency {\n          currency\n          asOf\n          items {\n            acctNo\n            acctName\n            totalInvestmentAmt\n            currentFundValue\n            gainOrLossAmt\n            gainOrLossPercent\n          }\n        }\n        fundsByCurrency {\n          currency\n          items {\n            tag\n            currentValue\n            totalInitial\n            allocation\n          }\n        }\n        transactionHistory {\n          acctName\n          acctNo\n          status\n          transactionDetails{\n            trxnType\n          }\n          currentFundValue{\n            fundName\n            totalInitial\n            totalShares\n            currentNavpu\n            currentFundValue\n          }\n        }\n      }\n    }\n  `;\n};\n","score":0,"fallbacked":false,"num_type_errors":63}]}
{"dataset_elem":{"alphanum_fraction":0.1438202247,"avg_line_length":24.1847826087,"content":"export default function generateParenthesis(n: number): string[] {\n    if (n === 1) {\n        return [\"()\"];\n    }\n    if (n === 5) {\n        return [\n            \"((((()))))\",\n            \"(((()())))\",\n            \"(((())()))\",\n            \"(((()))())\",\n            \"(((())))()\",\n            \"((()(())))\",\n            \"((()()()))\",\n            \"((()())())\",\n            \"((()()))()\",\n            \"((())(()))\",\n            \"((())()())\",\n            \"((())())()\",\n            \"((()))(())\",\n            \"((()))()()\",\n            \"(()((())))\",\n            \"(()(()()))\",\n            \"(()(())())\",\n            \"(()(()))()\",\n            \"(()()(()))\",\n            \"(()()()())\",\n            \"(()()())()\",\n            \"(()())(())\",\n            \"(()())()()\",\n            \"(())((()))\",\n            \"(())(()())\",\n            \"(())(())()\",\n            \"(())()(())\",\n            \"(())()()()\",\n            \"()(((())))\",\n            \"()((()()))\",\n            \"()((())())\",\n            \"()((()))()\",\n            \"()(()(()))\",\n            \"()(()()())\",\n            \"()(()())()\",\n            \"()(())(())\",\n            \"()(())()()\",\n            \"()()((()))\",\n            \"()()(()())\",\n            \"()()(())()\",\n            \"()()()(())\",\n            \"()()()()()\",\n        ];\n    }\n    if (n === 2) {\n        return [\"(())\", \"()()\"];\n    }\n\n    if (n === 3) {\n        return [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"];\n    }\n    if (n === 4) {\n        return [\n            \"(((())))\",\n            \"((()()))\",\n            \"((())())\",\n            \"((()))()\",\n            \"(()(()))\",\n            \"(()()())\",\n            \"(()())()\",\n            \"(())(())\",\n            \"(())()()\",\n            \"()((()))\",\n            \"()(()())\",\n            \"()(())()\",\n            \"()()(())\",\n            \"()()()()\",\n        ];\n    }\n\n    const cached = cache.get(n);\n    if (cached) {\n        return cached;\n    }\n    const set = new Set<string>();\n    for (const str of generateParenthesis(n - 1)) {\n        for (let i = 0; i <= str.length / 2; i++) {\n            set.add(str.slice(0, i) + \"()\" + str.slice(i, str.length));\n        }\n    }\n    const res = Array.from(set);\n    cache.set(n, res);\n    return res;\n}\nconst cache = new Map<number, string[]>();\n","content_without_annotations":"export default function generateParenthesis(n) {\n    if (n === 1) {\n        return [\"()\"];\n    }\n    if (n === 5) {\n        return [\n            \"((((()))))\",\n            \"(((()())))\",\n            \"(((())()))\",\n            \"(((()))())\",\n            \"(((())))()\",\n            \"((()(())))\",\n            \"((()()()))\",\n            \"((()())())\",\n            \"((()()))()\",\n            \"((())(()))\",\n            \"((())()())\",\n            \"((())())()\",\n            \"((()))(())\",\n            \"((()))()()\",\n            \"(()((())))\",\n            \"(()(()()))\",\n            \"(()(())())\",\n            \"(()(()))()\",\n            \"(()()(()))\",\n            \"(()()()())\",\n            \"(()()())()\",\n            \"(()())(())\",\n            \"(()())()()\",\n            \"(())((()))\",\n            \"(())(()())\",\n            \"(())(())()\",\n            \"(())()(())\",\n            \"(())()()()\",\n            \"()(((())))\",\n            \"()((()()))\",\n            \"()((())())\",\n            \"()((()))()\",\n            \"()(()(()))\",\n            \"()(()()())\",\n            \"()(()())()\",\n            \"()(())(())\",\n            \"()(())()()\",\n            \"()()((()))\",\n            \"()()(()())\",\n            \"()()(())()\",\n            \"()()()(())\",\n            \"()()()()()\",\n        ];\n    }\n    if (n === 2) {\n        return [\"(())\", \"()()\"];\n    }\n\n    if (n === 3) {\n        return [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"];\n    }\n    if (n === 4) {\n        return [\n            \"(((())))\",\n            \"((()()))\",\n            \"((())())\",\n            \"((()))()\",\n            \"(()(()))\",\n            \"(()()())\",\n            \"(()())()\",\n            \"(())(())\",\n            \"(())()()\",\n            \"()((()))\",\n            \"()(()())\",\n            \"()(())()\",\n            \"()()(())\",\n            \"()()()()\",\n        ];\n    }\n\n    const cached = cache.get(n);\n    if (cached) {\n        return cached;\n    }\n    const set = new Set<string>();\n    for (const str of generateParenthesis(n - 1)) {\n        for (let i = 0; i <= str.length / 2; i++) {\n            set.add(str.slice(0, i) + \"()\" + str.slice(i, str.length));\n        }\n    }\n    const res = Array.from(set);\n    cache.set(n, res);\n    return res;\n}\nconst cache = new Map<number, string[]>();\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":602,"ext":"ts","fun_ann_density":0.0033222591,"function_parameters":1,"function_signatures":0,"function_usages":1,"functions":1,"hexsha":"7b6a001e2836a3661f9ceba920b7c88bd5a6252f","lang":"TypeScript","loc":89,"loc_per_function":86.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"bec83c7bc30fe3387a19bf8ae0c8685ed0aba2f4","max_forks_repo_licenses":["MulanPSL-1.0"],"max_forks_repo_name":"masx200/leetcode-test","max_forks_repo_path":"generate-parentheses/index.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"bec83c7bc30fe3387a19bf8ae0c8685ed0aba2f4","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MulanPSL-1.0"],"max_issues_repo_name":"masx200/leetcode-test","max_issues_repo_path":"generate-parentheses/index.ts","max_line_length":71,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"bec83c7bc30fe3387a19bf8ae0c8685ed0aba2f4","max_stars_repo_licenses":["MulanPSL-1.0"],"max_stars_repo_name":"masx200/leetcode-test","max_stars_repo_path":"generate-parentheses/index.ts","max_stars_repo_stars_event_max_datetime":"2022-03-30T11:10:14.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-30T11:10:14.000Z","metric":0.2046368652,"predefined_density":0.7142857143,"predefined_types":5,"prop_ann_density":0.0,"property_declarations":0,"size":2225,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0083056478,"variable_declarations":5},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export default function generateParenthesis(n: number): string[] {\n    if (n === 1) {\n        return [\"()\"];\n    }\n    if (n === 5) {\n        return [\n            \"((((()))))\",\n            \"(((()())))\",\n            \"(((())())): ((()()))\",\n            \"(((())()))\",\n            \"((()))())\",\n            \"(()((()))\",\n            \"(()())()\",\n            \"(()())()()\",\n            \"(()())()\",\n            \"(()())()()\",\n            \"((())((()) {\n    if (n === 1) {\n        return [\"()\"];\n    }\n    if (n === 5) {\n        return [\n            \"((((()))))\",\n            \"(((()())))\",\n            \"(((())()))\",\n            \"(((()))())\",\n            \"(((())))()\",\n            \"((()(())))\",\n            \"((()()()))\",\n            \"((()())())\",\n            \"((()()))()\",\n            \"((())(()))\",\n            \"((())()())\",\n            \"((())())()\",\n            \"((()))(())\",\n            \"((()))()()\",\n            \"(()((())))\",\n            \"(()(()()))\",\n            \"(()(())())\",\n            \"(()(()))()\",\n            \"(()()(()))\",\n            \"(()()()())\",\n            \"(()()())()\",\n            \"(()())(())\",\n            \"(()())()()\",\n            \"(())((()))\",\n            \"(())(()())\",\n            \"(())(())()\",\n            \"(())()(())\",\n            \"(())()()()\",\n            \"()(((())))\",\n            \"()((()()))\",\n            \"()((())())\",\n            \"()((()))()\",\n            \"()(()(()))\",\n            \"()(()()())\",\n            \"()(()())()\",\n            \"()(())(())\",\n            \"()(())()()\",\n            \"()()((()))\",\n            \"()()(()())\",\n            \"()()(())()\",\n            \"()()()(())\",\n            \"()()()()()\",\n        ];\n    }\n    if (n === 2) {\n        return [\"(())\", \"()()\"];\n    }\n    if (n === 3) {\n        return [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"];\n    }\n    if (n === 4) {\n        return [\n            \"(((())))\",\n            \"((()()))\",\n            \"((())())\",\n            \"((()))()\",\n            \"(()(()))\",\n            \"(()()())\",\n            \"(()())()\",\n            \"(())(())\",\n            \"(())()()\",\n            \"()((()))\",\n            \"()(()())\",\n            \"()(())()\",\n            \"()()(())\",\n            \"()()()()\",\n        ];\n    }\n    const cached = cache.get(n);\n    if (cached) {\n        return cached;\n    }\n    const set = new Set<string>();\n    for (const str of generateParenthesis(n - 1)) {\n        for (let i = 0; i <= str.length / 2; i++) {\n            set.add(str.slice(0, i) + \"()\" + str.slice(i, str.length));\n        }\n    }\n    const res = Array.from(set);\n    cache.set(n, res);\n    return res;\n}\nconst cache = new Map<number, string[]>();\n","score":286,"fallbacked":false,"num_type_errors":5},{"code":"export default function generateParenthesis(n: number): string[] {\n    if (n <= 0) {\n        return [];\n    }\n    let res = generateParenthesis(n - 1);\n    for (let i = 0; i < res.length; i++) {): any {\n        res[i] = \"(\" + res[i] + \")\";\n    }\n    return res;\n}\n\nconst cache = new Map<number, string[]>();\n\n// prettier-ignore\nexport function generateParenthesis {\n    if (n === 1) {\n        return [\"()\"];\n    }\n    if (n === 5) {\n        return [\n            \"((((()))))\",\n            \"(((()())))\",\n            \"(((())()))\",\n            \"(((()))())\",\n            \"(((())))()\",\n            \"((()(())))\",\n            \"((()()()))\",\n            \"((()())())\",\n            \"((()()))()\",\n            \"((())(()))\",\n            \"((())()())\",\n            \"((())())()\",\n            \"((()))(())\",\n            \"((()))()()\",\n            \"(()((())))\",\n            \"(()(()()))\",\n            \"(()(())())\",\n            \"(()(()))()\",\n            \"(()()(()))\",\n            \"(()()()())\",\n            \"(()()())()\",\n            \"(()())(())\",\n            \"(()())()()\",\n            \"(())((()))\",\n            \"(())(()())\",\n            \"(())(())()\",\n            \"(())()(())\",\n            \"(())()()()\",\n            \"()(((())))\",\n            \"()((()()))\",\n            \"()((())())\",\n            \"()((()))()\",\n            \"()(()(()))\",\n            \"()(()()())\",\n            \"()(()())()\",\n            \"()(())(())\",\n            \"()(())()()\",\n            \"()()((()))\",\n            \"()()(()())\",\n            \"()()(())()\",\n            \"()()()(())\",\n            \"()()()()()\",\n        ];\n    }\n    if (n === 2) {\n        return [\"(())\", \"()()\"];\n    }\n    if (n === 3) {\n        return [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"];\n    }\n    if (n === 4) {\n        return [\n            \"(((())))\",\n            \"((()()))\",\n            \"((())())\",\n            \"((()))()\",\n            \"(()(()))\",\n            \"(()()())\",\n            \"(()())()\",\n            \"(())(())\",\n            \"(())()()\",\n            \"()((()))\",\n            \"()(()())\",\n            \"()(())()\",\n            \"()()(())\",\n            \"()()()()\",\n        ];\n    }\n    const cached = cache.get(n);\n    if (cached) {\n        return cached;\n    }\n    const set = new Set<string>();\n    for (const str of generateParenthesis(n - 1)) {\n        for (let i = 0; i <= str.length / 2; i++) {\n            set.add(str.slice(0, i) + \"()\" + str.slice(i, str.length));\n        }\n    }\n    const res = Array.from(set);\n    cache.set(n, res);\n    return res;\n}\nconst cache = new Map<number, string[]>();\n","score":350,"fallbacked":false,"num_type_errors":10},{"code":"export default function generateParenthesis(n: number): string[] {\n    if (n <= 1) {\n        return [\"\"];\n    }\n    const set = new Set<string>();\n    for (let str of generateParenthesis(n - 1)) {\n        for (let): string[] => string[]\n        const left = str.slice(0, str.length - 1);\n        const right = str.slice(1);\n        set.add(`${left}${right}`);\n    }\n    return Array.from(se {\n    if (n === 1) {\n        return [\"()\"];\n    }\n    if (n === 5) {\n        return [\n            \"((((()))))\",\n            \"(((()())))\",\n            \"(((())()))\",\n            \"(((()))())\",\n            \"(((())))()\",\n            \"((()(())))\",\n            \"((()()()))\",\n            \"((()())())\",\n            \"((()()))()\",\n            \"((())(()))\",\n            \"((())()())\",\n            \"((())())()\",\n            \"((()))(())\",\n            \"((()))()()\",\n            \"(()((())))\",\n            \"(()(()()))\",\n            \"(()(())())\",\n            \"(()(()))()\",\n            \"(()()(()))\",\n            \"(()()()())\",\n            \"(()()())()\",\n            \"(()())(())\",\n            \"(()())()()\",\n            \"(())((()))\",\n            \"(())(()())\",\n            \"(())(())()\",\n            \"(())()(())\",\n            \"(())()()()\",\n            \"()(((())))\",\n            \"()((()()))\",\n            \"()((())())\",\n            \"()((()))()\",\n            \"()(()(()))\",\n            \"()(()()())\",\n            \"()(()())()\",\n            \"()(())(())\",\n            \"()(())()()\",\n            \"()()((()))\",\n            \"()()(()())\",\n            \"()()(())()\",\n            \"()()()(())\",\n            \"()()()()()\",\n        ];\n    }\n    if (n === 2) {\n        return [\"(())\", \"()()\"];\n    }\n    if (n === 3) {\n        return [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"];\n    }\n    if (n === 4) {\n        return [\n            \"(((())))\",\n            \"((()()))\",\n            \"((())())\",\n            \"((()))()\",\n            \"(()(()))\",\n            \"(()()())\",\n            \"(()())()\",\n            \"(())(())\",\n            \"(())()()\",\n            \"()((()))\",\n            \"()(()())\",\n            \"()(())()\",\n            \"()()(())\",\n            \"()()()()\",\n        ];\n    }\n    const cached = cache.get(n);\n    if (cached) {\n        return cached;\n    }\n    const set = new Set<string>();\n    for (const str of generateParenthesis(n - 1)) {\n        for (let i = 0; i <= str.length / 2; i++) {\n            set.add(str.slice(0, i) + \"()\" + str.slice(i, str.length));\n        }\n    }\n    const res = Array.from(set);\n    cache.set(n, res);\n    return res;\n}\nconst cache = new Map<number, string[]>();\n","score":385,"fallbacked":false,"num_type_errors":16}]}
{"dataset_elem":{"alphanum_fraction":0.530155642,"avg_line_length":18.3571428571,"content":"/* Defines the board entity */\nexport interface Board {\n    address1: string;\n    address2: string;\n    city: string;\n    contact: string;\n    coordId: string;\n    email: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicenses: boolean;\n  }\n  \n  export interface BoardResolved {\n    authority: Board;\n    error?: any;\n  }\n\n  export function newBoard(): Board{\n    const a: Board={\n      address1: '',\n      address2: '',\n      city: '',\n      contact: '',\n      coordId: null,\n      email: '',\n      fax: '',\n      id: 0,\n      multipleLocation: false,\n      department: '',\n      division: '',\n      board: '',\n      officeHours: '',\n      st: 'NC',\n      teleExt: '',\n      telephone: '',\n      url: '',\n      zip: '',\n      zipExt: '',\n      haslicenses: false\n    };\n    return a;\n  }\n\n  ","content_without_annotations":"/* Defines the board entity */\nexport interface Board {\n    address1;\n    address2;\n    city;\n    contact;\n    coordId;\n    email;\n    fax;\n    id;\n    multipleLocation;\n    department;\n    division;\n    board;\n    officeHours;\n    st;\n    teleExt;\n    telephone;\n    url;\n    zip;\n    zipExt;\n    haslicenses;\n  }\n  \n  export interface BoardResolved {\n    authority;\n    error?;\n  }\n\n  export function newBoard(){\n    const a={\n      address1: '',\n      address2: '',\n      city: '',\n      contact: '',\n      coordId: null,\n      email: '',\n      fax: '',\n      id: 0,\n      multipleLocation: false,\n      department: '',\n      division: '',\n      board: '',\n      officeHours: '',\n      st: 'NC',\n      teleExt: '',\n      telephone: '',\n      url: '',\n      zip: '',\n      zipExt: '',\n      haslicenses: false\n    };\n    return a;\n  }\n\n  ","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":260,"ext":"ts","fun_ann_density":0.0038461538,"function_parameters":0,"function_signatures":0,"function_usages":0,"functions":1,"hexsha":"c2dc8f4b06b04cbfe8c66ae83924e18992baa024","lang":"TypeScript","loc":51,"loc_per_function":23.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"1b4d95c1bb2a136b9aa5615ecbd4dd073bbbfa8d","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"TomPrice0/FLG-Client","max_forks_repo_path":"FLG-Client/src/app/boards/board.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"1b4d95c1bb2a136b9aa5615ecbd4dd073bbbfa8d","max_issues_repo_issues_event_max_datetime":"2022-03-02T07:47:51.000Z","max_issues_repo_issues_event_min_datetime":"2022-03-02T07:47:51.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"TomPrice0/FLG-Client","max_issues_repo_path":"FLG-Client/src/app/boards/board.ts","max_line_length":36,"max_stars_count":null,"max_stars_repo_head_hexsha":"1b4d95c1bb2a136b9aa5615ecbd4dd073bbbfa8d","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"TomPrice0/FLG-Client","max_stars_repo_path":"FLG-Client/src/app/boards/board.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2023366048,"predefined_density":0.8333333333,"predefined_types":20,"prop_ann_density":0.0846153846,"property_declarations":22,"size":1028,"trivial_density":0.0416666667,"trivial_types":1,"type_definitions":2,"typedef_density":0.0076923077,"var_ann_density":0.0038461538,"variable_declarations":1},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/* Defines the board entity */\nexport interface Board {\n    address1: string;\n    address2: string;\n    city: string;\n    contact: string;\n    coordId: number;\n    email: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: strin;\n    address2: string;\n    division: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    city: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    teleExt: strin;\n    contact: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicenses: boolean;\n}\nexport interface BoardInput {\n    address1: string;\n    address2: string;\n    city: string;;\n    coordId: number;\n    email: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    email: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicenses: boolean;\n}\nexport interface BoardOutput {\n    address1;\n    address2;\n    city;\n    contact;\n    fax: string;\n    id;\n    multipleLocation;\n    department;\n    division;\n    board;\n    officeHours;\n    st;\n    url;\n    zip: string;\n    zipExt: string;\n}\nexport interface BoardArgs {\n    address;\n    id: number;\n    multipleLocation: boolean;\n    department;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    ha;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    email: string;\n    url: string;\n    zip: string;\n    zipExt: string;;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    email: string;\n    url: string;\n    zip: string;\n    zipExt: string;;\n    department: string;;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    email: string;\n    url: string;\n    zip: string;\n    zipExt: string;;\n}\nexport interface BoardDeleteInput {\n    i;\n    board: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    email: string;\n    url: string;;\n    officeHours: string;\n    url: string;\n    zip: string;\n    zipExt: string;;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    email: string;;\n    st: string;\n    zip: string;\n    zipExt: string;;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    email: string;\n    url: string;;\n    teleExt: string;\n}\nexport interface BoardDeleteOutput {\n    i;\n    error: string;\n}\nexport interface BoardDeleteArgs {\n    board: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;;\n    telephone: string;;\n    st: string;;\n    email: string;;\n    url: string;;\n    officeHours: string;;\n    url: string;;\n    zip: string;;\n    zipExt: string;;\n    department: string;;\n    division: string;;;\n    url: string;;\n    zip: string;;\n    zipExt: string;;\n    department: string;;\n    division: string;;\n    board: string;;\n    officeHours: string;;\n    st: string;;\n    email: string;;\n}\nexport interface Boar;\n    zip: string;\n    zipExt: string;\n    haslicenses;\n}\nexport interface BoardResolveInput {\n    id: number;\n    board: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division;\n    zipExt: string;\n}\nexport interface BoardResolveOutput {\n    board: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    zip: string;\n}\nexport interface BoardResolveArg;\n    haslicenses: boolean;\nexport interface BoardListInput {\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    zipExt: string;\n}\nexport interface BoardListOutput {\n    board: string[];\n}\nexport interface BoardResolved {\n    authority: string;\n    board?: Board;\n    error?: string;\n}\nexport interface BoardCreateInput {\n    address1: string;\n    address2: string;\n    city: string;\n    contact: string;\n    coordId: number;;\n    error?: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone;\n}\nexport function newBoard(): BoardCreateInput {\n    const a = {\n        address1: \"\",\n        address2: \"\",\n        city: \"\",\n        contact: \"\",\n        coordId: null,\n        email: \"\",\n        fax: \"\",\n        id: 0,\n        multipl {\n    const a = {\n        address1: \"\",\n        address2: \"\",\n        city: \"\",\n        contact: \"\",\n        coordId: null,\n        email: \"\",\n        fax: \"\",\n        id: 0,\n        multipleLocation: false,\n        department: \"\",\n        division: \"\",\n        board: \"\",\n        officeHours: \"\",\n        st: \"NC\",\n        teleExt: \"\",\n        telephone: \"\",\n        url: \"\",\n        zip: \"\",\n        zipExt: \"\",\n        haslicenses: false\n    };\n    return a;\n}\n","score":48,"fallbacked":false,"num_type_errors":168},{"code":"/* Defines the board entity */\nexport interface Board {\n    address1: string;\n    address2: string;\n    city: string;\n    contact: string;\n    coordId: number;\n    email: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: strin;\n    address2: string;\n    division: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicenses;\n    city: string;\n    address2: string;\n    contact: string;\n    coordId: number;\n    address2: string;\n    city: string;\n    contact: string;\n    email: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: strin;\n    division: strin;\n    email: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: strin;\n    division: strin;\n    board: strin;\n    officeHours: string;\n    st: string;\n    tel;\n    fax: string;\n    tel: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicenses: boolean;\n}\n/* Defines the board entity */\nexport interface BoardDTO {\n    address1?: string;\n    id: number;\n    address2?: string;\n    city?: string;\n    contact?: string;\n    coordId?: number;\n    email?: string;\n    fax?: string;\n    id?: number;\n    multipleLocation?: boolean;\n    department?: strin;\n    multipleLocation: boolean;\n    officeHours?: string;\n    st?: strin;\n    tel?: string;\n    fax?: string;\n    tel?: string;\n    url?: string;\n    zip?: string;\n    zipExt?: string;\n    haslicenses?;\n    department: strin;\n    division?: strin;\n    board?: strin;\n    officeHours?: string;\n    st?: strin;\n    tel?: string;\n    fax?: string;\n    tel?: string;\n    url?: string;\n    zi;\n    division: strin;\n    address1?: string;\n    address2?: string;\n    city?: string;\n    contact?: string;\n    coordId?: number;\n    email?: string;\n    fax?: string;\n    id?: number;\n    multipleLocatio;\n    board: strin;\n    officeHours?: string;\n    st?: strin;\n    tel?: string;\n    fax?: string;\n    tel?: string;\n    url?: string;\n    zip?: string;\n    zipExt?: string;\n    haslicense;\n    officeHours: string;\n    st: string;\n    tel: string;\n    fax: string;\n    tel: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicenses: boolean;\n}\n/* Define;\n    st: string;\n    tel: string;\n    fax: string;\n    tel: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicense: boolean;\n    officeHours: string;\n    st: strin;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicenses: boolean;\n*/\nexport interface Board {\n    address1: string;\n    id: number;\n    addres;\n    telephone: string;\n    fax: string;\n    email: string;\n    url: string;\n    telephone: string;\n    url: string;\n    city: string;\n    zip: string;\n    city?: string;\n    zipExt: string;\n    url: string;\n    city?: string;\n    address2?: string;\n    city?: string;\n    address2?: string;\n    contact?: string;\n    tel?: string;\n    st?: string;\n    tel?: string;\n    fax?: string;\n    zip: string;\n    zipExt: string;\n    haslicense: boolean;\n    st: string;\n    tel: string;\n    fax: string;\n    tel: string;\n    url: string;\n    city: string;\n    address2: strin;\n    zipExt: string;\n    haslicense: boolean;\n    officeHours: string;\n}\nexport interface BoardResponse {\n    id: number;\n    address1: string;\n    address2?: string;\n    city: string;\n    contact?: string;;\n    haslicenses: boolean;\n    city?: string;\n    city?: string;\n    city?: string;\n    city?: string;\n    city?: string;\n    city?: string;\n    city?: string;\n    city?: string;\n    city?: string;\n    city?;\n}\nexport interface BoardResolved {\n    authority: string;\n    address1: string;\n    address2?: string;\n    city: string;\n    contact?: string;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    haslicense: boolea;\n    error?: any;\n    multipleLocation: boolean;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n};\n}\nexport function newBoard(): Board {\n    const a = {\n        address1: \"\",\n        address2: \"\",\n        city: \"\",\n        contact: \"\",\n        coordId: null,\n        email: \"\",\n        fax: \"\",\n        id: 0,\n        multipleLocation {\n    const a = {\n        address1: \"\",\n        address2: \"\",\n        city: \"\",\n        contact: \"\",\n        coordId: null,\n        email: \"\",\n        fax: \"\",\n        id: 0,\n        multipleLocation: false,\n        department: \"\",\n        division: \"\",\n        board: \"\",\n        officeHours: \"\",\n        st: \"NC\",\n        teleExt: \"\",\n        telephone: \"\",\n        url: \"\",\n        zip: \"\",\n        zipExt: \"\",\n        haslicenses: false\n    };\n    return a;\n}\n","score":28,"fallbacked":false,"num_type_errors":226},{"code":"/* Defines the board entity */\nexport interface Board {\n    address1: string;\n    address2: string;\n    city: string;\n    contact: string;\n    coordId: string;\n    email: string;\n    fax: string;\n    id: number;\n    multipleLocation: boolean;\n    department: strin;\n    address2: string;\n    division: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    zipExt: string;\n    haslicenses;\n    city: string;\n    address2: string;\n    division: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    zipExt;\n    contact: string;\n    id;\n    coordId: string;\n    city;\n    email: string;\n    address2;\n    division;\n    officeHours;\n    st;\n    teleExt;\n    telephone;\n    url;\n    zip;\n    zipExt;\n    contact;\n    id;\n    coordId;\n    city;\n    email;\n    fax: string;\n    address1: string;\n    contact: string;\n    address2: string;\n    city: string;\n    division: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone;\n    id: number;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: strin;\n    multipleLocation: boolean;\n    department: string;\n    division: string;\n    board: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    department: string;\n    id: number;\n    address1: string;\n    address2: string;\n    city: string;\n    contact: string;\n    coordId: string;\n    email: string;\n    fax: string;\n    id: numbe;\n    division: string;\n    address2: string;\n    division: string;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    address3;\n    board: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    address3: string;\n    id: number;\n    multipleLocation: boolean;\n    division: strin;\n    officeHours: string;\n    st: string;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    zip: string;\n    contact: string;\n    zipExt: string;\n    id: number;\n    city: string;\n    st: string;\n    email: string;\n    teleExt: string;\n    telephone: string;\n    address1: string;\n    address2: string;\n    city: string;\n    contact: string;\n    address3: string;\n    address;\n    teleExt: string;\n    telephone: string;\n    url: string;\n    id: number;\n    address: string;\n    division: string;\n    name: string;\n    address3: string;\n    st: string;\n    zip: string;;\n    telephone: string;\n    id: number;\n    address: string;\n    telephone: string;\n    officeHours: string;\n    zip: string;\n    id: number;\n    address1: string;\n    address2: string;\n    city: strin;\n    url: string;\n    teleExt: string;\n    id: number;\n    address: string;\n    address2: string;\n    address3: string;\n    fax: string;\n    teleExt: string;\n    telephone: string;\n    emai;\n    zip: string;\n    id: number;\n    address: string;\n    fax: string;\n    address2: string;\n    city: string;\n    address3: string;\n    officeHours: string;\n    address4: string;\n    id;\n    zipExt: string;\n    address: string;\n    id: number;\n    address: string;\n    address3: string;\n    st: string;\n    officeHours: string;\n    telephone: string;\n    email: string;\n    id: number;\n    haslicenses: boolean;\n    id: number;\n    address: string;\n    id: number;\n    address: string;\n    id: number;\n    address: string;\n    address: string;\n    address: string;\n    address: string;\n    address;\n}\nexport interface BoardResolved {\n    authority: string;\n    address1: string;\n    address2: string;\n    city: string;\n    contact: string;\n    coordId: number;\n    email: string;\n    fax: string;\n    id: number;\n    multipleLocation;\n    error?: string;\n    address3: string;\n    teleExt: string;\n    telephone: string;\n    name: string;\n    officeHours: string;\n    st: string;\n    url: string;\n    id: number;\n    address: strin;\n}\nexport function newBoard(): BoardResolved {\n    const a = {\n        address1: \"\",\n        address2: \"\",\n        city: \"\",\n        contact: \"\",\n        coordId: null,\n        email: \"\",\n        fax: \"\",\n        id: 0,\n        multipleLocatio {\n    const a = {\n        address1: \"\",\n        address2: \"\",\n        city: \"\",\n        contact: \"\",\n        coordId: null,\n        email: \"\",\n        fax: \"\",\n        id: 0,\n        multipleLocation: false,\n        department: \"\",\n        division: \"\",\n        board: \"\",\n        officeHours: \"\",\n        st: \"NC\",\n        teleExt: \"\",\n        telephone: \"\",\n        url: \"\",\n        zip: \"\",\n        zipExt: \"\",\n        haslicenses: false\n    };\n    return a;\n}\n","score":62,"fallbacked":false,"num_type_errors":241}]}
{"dataset_elem":{"alphanum_fraction":0.5734679666,"avg_line_length":26.8411214953,"content":"/**\n * ```ts\n * import {deepClone} from 'yfang-utils'\n * const data = deepClone<{value:string}>({value: 'name'})\n * ```\n * @export 深拷贝任意类型数据\n *\n * @param data 任意类型数据\n * @returns\n */\nexport function deepClone<T>(data: any): T {\n  if (!data || !(data instanceof Object) || typeof data === 'function') {\n    return data\n  }\n  let constructor = data.constructor\n  let result = new constructor()\n  for (let key in data) {\n    if (data.hasOwnProperty(key)) {\n      result[key] = deepClone(data[key])\n    }\n  }\n  return result\n}\n\n/**\n * @export 判断两个变量值是否完全相同\n * @param a 任何类型变量\n * @param b 任何类型变量\n */\nexport function isEquals(a: any, b: any): boolean {\n  if (a === b) return true\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime()\n  if (!a || !b || (typeof a !== 'object' && typeof b !== 'object')) return a === b\n  if (a.prototype !== b.prototype) return false\n  if (Array.isArray(a) && Array.isArray(b)) a.sort(), b.sort()\n\n  let keys = Object.keys(a)\n  if (keys.length !== Object.keys(b).length) return false\n  return keys.every(k => isEquals(a[k], b[k]))\n}\n\n/**\n * @export 对象序列化\n * @param obj 任意对象\n * @return\n */\nexport function stringfyQueryString(obj: any): string {\n  if (!obj) return ''\n  const pairs = []\n  for (let key in obj) {\n    let value = obj[key]\n    if (value instanceof Array) {\n      for (let i = 0; i < value.length; ++i) {\n        pairs.push(encodeURIComponent(key + '[' + i + ']') + '=' + encodeURIComponent(value[i]))\n      }\n      continue\n    }\n    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]))\n  }\n  return pairs.join('&')\n}\n\n/**\n * @export 生成指定范围随机数\n * @param  {Number} min 最小值\n * @param  {Number} max 最大值\n * @return {Number}\n */\nexport function randomNum(min: number, max: number): number {\n  if (typeof min === 'number' && typeof max === 'number')\n    return Math.floor(min + Math.random() * (max - min))\n  return 0\n}\n\n/**\n * @export 时间格式化\n * @param {*} date Date对象，string 或 number 的毫秒事件数\n * @param {string} fmt 格式类型为：\"yyyy-MM-dd hh:mm:ss\"\n * @returns {string}\n */\nexport function formatDate(date: any, fmt: string = 'yyyy-MM-dd hh:mm:ss'): string {\n  if (!date) {\n    return '--'\n  }\n  if (typeof date === 'string' && !/-/.test(date)) date = Number(date)\n  date = new Date(date)\n  let o: any = {\n    'M+': date.getMonth() + 1, // 月份\n    'd+': date.getDate(), // 日\n    'h+': date.getHours(), // 小时\n    'm+': date.getMinutes(), // 分\n    's+': date.getSeconds(), // 秒\n    'q+': Math.floor((date.getMonth() + 3) / 3), // 季度\n    S: date.getMilliseconds() // 毫秒\n  }\n  if (/(y+)/.test(fmt))\n    fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length))\n  for (let k in o) {\n    if (new RegExp('(' + k + ')').test(fmt))\n      fmt = fmt.replace(\n        RegExp.$1,\n        RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length)\n      )\n  }\n  return fmt\n}\n","content_without_annotations":"/**\n * ```ts\n * import {deepClone} from 'yfang-utils'\n * const data = deepClone<{value:string}>({value: 'name'})\n * ```\n * @export 深拷贝任意类型数据\n *\n * @param data 任意类型数据\n * @returns\n */\nexport function deepClone<T>(data) {\n  if (!data || !(data instanceof Object) || typeof data === 'function') {\n    return data\n  }\n  let constructor = data.constructor\n  let result = new constructor()\n  for (let key in data) {\n    if (data.hasOwnProperty(key)) {\n      result[key] = deepClone(data[key])\n    }\n  }\n  return result\n}\n\n/**\n * @export 判断两个变量值是否完全相同\n * @param a 任何类型变量\n * @param b 任何类型变量\n */\nexport function isEquals(a, b) {\n  if (a === b) return true\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime()\n  if (!a || !b || (typeof a !== 'object' && typeof b !== 'object')) return a === b\n  if (a.prototype !== b.prototype) return false\n  if (Array.isArray(a) && Array.isArray(b)) a.sort(), b.sort()\n\n  let keys = Object.keys(a)\n  if (keys.length !== Object.keys(b).length) return false\n  return keys.every(k => isEquals(a[k], b[k]))\n}\n\n/**\n * @export 对象序列化\n * @param obj 任意对象\n * @return\n */\nexport function stringfyQueryString(obj) {\n  if (!obj) return ''\n  const pairs = []\n  for (let key in obj) {\n    let value = obj[key]\n    if (value instanceof Array) {\n      for (let i = 0; i < value.length; ++i) {\n        pairs.push(encodeURIComponent(key + '[' + i + ']') + '=' + encodeURIComponent(value[i]))\n      }\n      continue\n    }\n    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]))\n  }\n  return pairs.join('&')\n}\n\n/**\n * @export 生成指定范围随机数\n * @param  {Number} min 最小值\n * @param  {Number} max 最大值\n * @return {Number}\n */\nexport function randomNum(min, max) {\n  if (typeof min === 'number' && typeof max === 'number')\n    return Math.floor(min + Math.random() * (max - min))\n  return 0\n}\n\n/**\n * @export 时间格式化\n * @param {*} date Date对象，string 或 number 的毫秒事件数\n * @param {string} fmt 格式类型为：\"yyyy-MM-dd hh:mm:ss\"\n * @returns {string}\n */\nexport function formatDate(date, fmt = 'yyyy-MM-dd hh:mm:ss') {\n  if (!date) {\n    return '--'\n  }\n  if (typeof date === 'string' && !/-/.test(date)) date = Number(date)\n  date = new Date(date)\n  let o = {\n    'M+': date.getMonth() + 1, // 月份\n    'd+': date.getDate(), // 日\n    'h+': date.getHours(), // 小时\n    'm+': date.getMinutes(), // 分\n    's+': date.getSeconds(), // 秒\n    'q+': Math.floor((date.getMonth() + 3) / 3), // 季度\n    S: date.getMilliseconds() // 毫秒\n  }\n  if (/(y+)/.test(fmt))\n    fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length))\n  for (let k in o) {\n    if (new RegExp('(' + k + ')').test(fmt))\n      fmt = fmt.replace(\n        RegExp.$1,\n        RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length)\n      )\n  }\n  return fmt\n}\n","dynamism_density":0.0104058273,"dynamism_heuristic":10,"estimated_tokens":961,"ext":"ts","fun_ann_density":0.0156087409,"function_parameters":9,"function_signatures":0,"function_usages":2,"functions":6,"hexsha":"64595b8249135ee031171343f8ec4f50b2c9a087","lang":"TypeScript","loc":69,"loc_per_function":10.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"6154f8ac335d1d355bd24794713bcd6bb739065e","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"YFang-FE/yfang-utils","max_forks_repo_path":"src/object.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"6154f8ac335d1d355bd24794713bcd6bb739065e","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"YFang-FE/yfang-utils","max_issues_repo_path":"src/object.ts","max_line_length":96,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"6154f8ac335d1d355bd24794713bcd6bb739065e","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"YFang-FE/yfang-utils","max_stars_repo_path":"src/object.ts","max_stars_repo_stars_event_max_datetime":"2022-02-09T11:48:51.000Z","max_stars_repo_stars_event_min_datetime":"2022-02-09T11:48:51.000Z","metric":0.2245592944,"predefined_density":0.3181818182,"predefined_types":7,"prop_ann_density":0.0,"property_declarations":0,"size":2872,"trivial_density":0.2727272727,"trivial_types":6,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0072840791,"variable_declarations":7},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * ```ts\n * import {deepClone} from 'yfang-utils'\n * const data = deepClone<{value:string}>({value: 'name'})\n * ```\n * @export 深拷贝任意类型数据\n *\n * @param data 任意类型数据\n * @returns\n */\nexport function deepClone<T>(data: T): T {\n    return JSON.parse(JSON.stringify(data));\n}\n/**\n * ```ts\n * import {deepClone} from 'yfang-utils'\n * const data = deepClone<Array<string>): Array<string> => deepClone<Array<string>>({value: 'name'})\n * ```\n * @export 深拷贝数组\n *\n * @param data 数组\n * @returns\n */\nexpor {\n    if (!data || !(data instanceof Object) || typeof data === \"function\") {\n        return data;\n    }\n    let constructor = data.constructor;\n    let result = new constructor();\n    for (let key in data) {\n        if (data.hasOwnProperty(key)) {\n            result[key] = deepClone(data[key]);\n        }\n    }\n    return result;\n}\n/**\n * @export 判断两个变量值是否完全相同\n * @param a 任何类型变量\n * @param b 任何类型变量\n */\nexport function isEquals(a: any, b: any) {\n    if (a === b)\n        return true;\n    if (a === null || b === null)\n        return false;\n    if (Array.isArray(a) && Array.isArray(b)), b: any) {\n        if (a.length!== b.length)\n            return false;\n        for (let i = 0; i < a.length; ++i) {\n            if (!isEquals(a[i], b[): any)\n                return false;\n        }\n        return true;\n    }\n    if (a.prototype!== b.prototype)\n        return false;\n    let keys = Object.keys(a);\n    if (keys.length!== Object.keys {\n    if (a === b)\n        return true;\n    if (a instanceof Date && b instanceof Date)\n        return a.getTime() === b.getTime();\n    if (!a || !b || (typeof a !== \"object\" && typeof b !== \"object\"))\n        return a === b;\n    if (a.prototype !== b.prototype)\n        return false;\n    if (Array.isArray(a) && Array.isArray(b))\n        a.sort(), b.sort();\n    let keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n        return false;\n    return keys.every((k: any) => isEquals(a[k], b[k]));\n}\n    return a.equals(b);\n}\n/**\n * @export 克隆对象\n * @param data 任意对象\n */\nexpor): any => {\n    if (!data ||!(data instanceof Object))\n        return data;\n    let constructor = data.constructor;\n    let result = new constructor();\n    for (let key in data) {\n        if (data.hasOwnProperty(ke => isEquals(a[k], b[k]));\n}\n/**\n * @export 对象序列化\n * @param obj 任意对象\n * @return\n */\nexport function stringfyQueryString(obj: any) {\n    if (typeof obj === \"undefined\")\n        return \"\";\n    if (typeof obj === \"string\")\n        return obj;\n    if (Array.isArray(obj)) {\n        return obj.map((item) => stringfyQueryStrin): any;\n    }\n    if (obj instanceof Object) {\n        let pairs = [];\n        for (let key in obj) {\n            if (!obj.hasOwnProperty(key))\n                continue;\n            if (key === \"__type\")\n                continue; {\n    if (!obj)\n        return \"\";\n    const pairs = [];\n    for (let key in obj) {\n        let value = obj[key];\n        if (value instanceof Array) {\n            for (let i = 0; i < value.length; ++i) {\n                pairs.push(encodeURIComponent(key + \"[\" + i + \"]\") + \"=\" + encodeURIComponent(value[i]));\n            }\n            continue;\n        }\n        pairs.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(obj[key]));\n    }\n    return pairs.join(\"&\");\n}\n/**\n * @export 生成指定范围随机数\n * @param  {Number} min 最小值\n * @param  {Number} max 最大值\n * @return {Number}\n */\nexport function randomNum(min: number, max: number) {\n    if (typeof min === \"number\" && typeof max === \"number\")\n        return Math.floor(Math.random() * (max - min)) + min;\n    return 0;\n}, max: 0, min: 0}): number {\n    if (typeof min === \"number\" && typeof max === \"number\")\n        return Math.floor(Math.random() * (max - min)) + min;\n    return 0;\n}\n/**\n * @expor {\n    if (typeof min === \"number\" && typeof max === \"number\")\n        return Math.floor(min + Math.random() * (max - min));\n    return 0;\n}\n/**\n * @export 时间格式化\n * @param {*} date Date对象，string 或 number 的毫秒事件数\n * @param {string} fmt 格式类型为：\"yyyy-MM-dd hh:mm:ss\"\n * @returns {string}\n */\nexport function formatDate(date: number | Date | string | undefined, fmt = \"yyyy-MM-dd hh:mm:ss\") {\n    if (!date) {\n        return \"--\";\n    }\n    if (typeof date === \"string\" &&!/-/.test, fmt: \"yyyy-MM-dd hh:mm:ss\") {\n        let dateStr = date;\n        if (dateStr.indexOf(\"T\") > -1) {\n            dateStr = dateStr.replace(/(.+)(.+)/ = \"yyyy-MM-dd hh:mm:ss\"): dateStr;\n        }\n        let dateArr = dateStr.split(\" \");\n        date = new Date(dateArr[0]);\n        fmt = fmt.replace(/yyyy|YYYY|yy|YY/g, (match) => { {\n    if (!date) {\n        return \"--\";\n    }\n    if (typeof date === \"string\" && !/-/.test(date))\n        date = Number(date);\n    date = new Date(date);\n    let o = {\n        \"M+\": date.getMonth() + 1,\n        \"d+\": date.getDate(),\n        \"h+\": date.getHours(),\n        \"m+\": date.getMinutes(),\n        \"s+\": date.getSeconds(),\n        \"q+\": Math.floor((date.getMonth() + 3) / 3),\n        S: date.getMilliseconds() // 毫秒\n    };\n    if (/(y+)/.test(fmt))\n        fmt = fmt.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    for (let k in o) {\n        if (new RegExp(\"(\" + k + \")\").test(fmt))\n            fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n    }\n    return fmt;\n}\n","score":405,"fallbacked":false,"num_type_errors":59},{"code":"/**\n * ```ts\n * import {deepClone} from 'yfang-utils'\n * const data = deepClone<{value:string}>({value: 'name'})\n * ```\n * @export 深拷贝任意类型数据\n *\n * @param data 任意类型数据\n * @returns\n */\nexport function deepClone<T>(data: T): T {\n    if (!data || typeof data === \"function\") {\n        return data;\n    }\n    let constructor = data.constructor;\n    let result = new constructor();\n    for (let key in data) {\n        if (dat): any {\n            result[key] = deepClone(data[key]);\n        }\n    }\n    return result;\n}\n/**\n * ```ts\n * import {deepClone} from 'yfang-utils'\n * const data {\n    if (!data || !(data instanceof Object) || typeof data === \"function\") {\n        return data;\n    }\n    let constructor = data.constructor;\n    let result = new constructor();\n    for (let key in data) {\n        if (data.hasOwnProperty(key)) {\n            result[key] = deepClone(data[key]);\n        }\n    }\n    return result;\n}\n/**\n * @export 判断两个变量值是否完全相同\n * @param a 任何类型变量\n * @param b 任何类型变量\n */\nexport function isEquals(a: any, b: any): boolean {\n    if (a === b)\n        return true;\n    if (a instanceof Date && b instanceof Date)\n        return a.getTime() === b.getTime();\n    if (a instanceof Array && b instanceo, b: any)\n        return a.length === b.length && a.every((value, i) => isEquals(value, b[i]));\n    if (a instanceof Object && b instanceof Object)\n        return keys(a).every((ke): boolean => isEquals(a[ke], b[ke]));\n    if (a instanceof Set && b instanceof Set)\n        return a.size === b.size && Array.from(a).every((value, i) => isEquals {\n    if (a === b)\n        return true;\n    if (a instanceof Date && b instanceof Date)\n        return a.getTime() === b.getTime();\n    if (!a || !b || (typeof a !== \"object\" && typeof b !== \"object\"))\n        return a === b;\n    if (a.prototype !== b.prototype)\n        return false;\n    if (Array.isArray(a) && Array.isArray(b))\n        a.sort(), b.sort();\n    let keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n        return false;\n    return keys.every((k: keyof a) => isEquals(a[k], b[k]));\n}\n/**\n * ```ts\n * import {deepClone} from 'yfang-utils'\n * const data {\n    if (!data ||!(dat): boolean {\n        return false;\n    }\n    if (typeof data === \"object\") {\n        return JSON.stringify(data) === JSON.stringify(deepClone(data));\n    }\n    return false;\n}\n * ```\n * => isEquals(a[k], b[k]));\n}\n/**\n * @export 对象序列化\n * @param obj 任意对象\n * @return\n */\nexport function stringfyQueryString(obj: any): string {\n    return encodeURI(stringfyObject(obj));\n}\nexport function stringfyObject(obj: any): string {\n    if (!obj)\n        return \"\";\n    const pairs = [];\n    for (let key in ob): boolean {\n        if (!ob.hasOwnProperty(key))\n            continue;\n        let value = ob[key];\n        if (value instanceof Array) {\n            for (let i = 0; i < value.length; ++i) { {\n    if (!obj)\n        return \"\";\n    const pairs = [];\n    for (let key in obj) {\n        let value = obj[key];\n        if (value instanceof Array) {\n            for (let i = 0; i < value.length; ++i) {\n                pairs.push(encodeURIComponent(key + \"[\" + i + \"]\") + \"=\" + encodeURIComponent(value[i]));\n            }\n            continue;\n        }\n        pairs.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(obj[key]));\n    }\n    return pairs.join(\"&\");\n}\n/**\n * @export 生成指定范围随机数\n * @param  {Number} min 最小值\n * @param  {Number} max 最大值\n * @return {Number}\n */\nexport function randomNum(min: number, max: number): number {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n}\n}\n}\n}\n}\n\nexport const obj: {, max: number, min: number} = {\n    max: 2147483647,\n    min: -2147483648\n};\n\nexport class Request {\n    constructor(config): void {\n        this.config = config;\n        this.response = {};\n    }\n\n    get(url: string, data: any, callback: (err: any, res: any) => void): void {\n        let _url = ur {\n    if (typeof min === \"number\" && typeof max === \"number\")\n        return Math.floor(min + Math.random() * (max - min));\n    return 0;\n}\n/**\n * @export 时间格式化\n * @param {*} date Date对象，string 或 number 的毫秒事件数\n * @param {string} fmt 格式类型为：\"yyyy-MM-dd hh:mm:ss\"\n * @returns {string}\n */\nexport function formatDate(date: any, fmt = \"yyyy-MM-dd hh:mm:ss\") {\n    if (!date) {\n        return \"--\";\n    }\n    if (typeof date === \"string\" &&!/-/.test(date))\n        date = Numbe, fmt: \"yyyy-MM-dd hh:mm:ss\";\n    let o = {\n        \"M+\": date.getMonth() + 1, // 月份\n        \"d+\": date.getDate(), // 日\n        \"h+\": date.getHour = \"yyyy-MM-dd hh:mm:ss\"): \"yyyy-MM-dd hh:mm:ss\", // 小时\n        \"m+\": date.getMinutes(), // 分\n        \"s+\": date.getSeconds(), // 秒\n        \"q+\": Math.floor((date.getMonth() {\n    if (!date) {\n        return \"--\";\n    }\n    if (typeof date === \"string\" && !/-/.test(date))\n        date = Number(date);\n    date = new Date(date);\n    let o = {\n        \"M+\": date.getMonth() + 1,\n        \"d+\": date.getDate(),\n        \"h+\": date.getHours(),\n        \"m+\": date.getMinutes(),\n        \"s+\": date.getSeconds(),\n        \"q+\": Math.floor((date.getMonth() + 3) / 3),\n        S: date.getMilliseconds() // 毫秒\n    };\n    if (/(y+)/.test(fmt))\n        fmt = fmt.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    for (let k in o) {\n        if (new RegExp(\"(\" + k + \")\").test(fmt))\n            fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n    }\n    return fmt;\n}\n","score":336,"fallbacked":false,"num_type_errors":68},{"code":"/**\n * ```ts\n * import {deepClone} from 'yfang-utils'\n * const data = deepClone<{value:string}>({value: 'name'})\n * ```\n * @export 深拷贝任意类型数据\n *\n * @param data 任意类型数据\n * @returns\n */\nexport function deepClone<T>(data: T): T {\n    if (!data ||!(data instanceof Object) || typeof data === \"function\") {\n        return data;\n    }\n    let constructor = data.constructor;\n    let result = new constructor();\n    for (let key in data {\n    if (!data || !(data instanceof Object) || typeof data === \"function\") {\n        return data;\n    }\n    let constructor = data.constructor;\n    let result = new constructor();\n    for (let key in data) {\n        if (data.hasOwnProperty(key)) {\n            result[key] = deepClone(data[key]);\n        }\n    }\n    return result;\n}\n/**\n * @export 判断两个变量值是否完全相同\n * @param a 任何类型变量\n * @param b 任何类型变量\n */\nexport function isEquals(a: any, b: any): boolean {\n    if (a === b)\n        return true;\n    if (a instanceof Date && b instanceof Date)\n        return a.getTime() === b.getTime();\n    if (!a ||!b ||, b: any)\n        return false;\n    if (Array.isArray(a) && Array.isArray(b))\n        return a.length === b.length && a.every((v, i) => isEquals(v, b[i]))): false;\n    if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n    }\n    let keys = Object.keys(a);\n    if (keys.length!== Object.keys(b) {\n    if (a === b)\n        return true;\n    if (a instanceof Date && b instanceof Date)\n        return a.getTime() === b.getTime();\n    if (!a || !b || (typeof a !== \"object\" && typeof b !== \"object\"))\n        return a === b;\n    if (a.prototype !== b.prototype)\n        return false;\n    if (Array.isArray(a) && Array.isArray(b))\n        a.sort(), b.sort();\n    let keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n        return false;\n    return keys.every((k: string) => isEquals(a[k], b[k]));\n    }\n    if (a instanceof Date && b instanceof Date)\n        return a.getTime() === b.getTime();\n    let keys = Object.keys(a);\n    i): for (let key of keys) {\n        if (a[key] && b[key]) {\n            if (!isEquals(a[key], b[key])) {\n            return false;\n            }\n        } else if (a[ke => isEquals(a[k], b[k]));\n}\n/**\n * @export 对象序列化\n * @param obj 任意对象\n * @return\n */\nexport function stringfyQueryString(obj: any): string {\n    if (!obj)\n        return \"\";\n    let pairs = [];\n    for (let key in obj) {\n        let value = obj[key];\n        if (value instanceof Array) {\n            for (let i =): for (let value of value) {\n                if (!value)\n                    continue;\n                pairs.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n            }\n            continue;\n        }\n        pairs.push(encodeURIComponent(key) + \"= {\n    if (!obj)\n        return \"\";\n    const pairs = [];\n    for (let key in obj) {\n        let value = obj[key];\n        if (value instanceof Array) {\n            for (let i = 0; i < value.length; ++i) {\n                pairs.push(encodeURIComponent(key + \"[\" + i + \"]\") + \"=\" + encodeURIComponent(value[i]));\n            }\n            continue;\n        }\n        pairs.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(obj[key]));\n    }\n    return pairs.join(\"&\");\n}\n/**\n * @export 生成指定范围随机数\n * @param  {Number} min 最小值\n * @param  {Number} max 最大值\n * @return {Number}\n */\nexport function randomNum(min: number, max: number) {\n    if (typeof min === \"number\" && typeof max === \"number\")\n        return Math.random() * (max - min) + min;\n    return 0;\n}\n/**\n *, max: Number 最大值\n * @param  {Number} min 最小值\n * @param  {Number} max 最大值\n * @param  {Number} step 相隔值\n * @return {Array}\n *): Array\n */\nexport function randomArr(min: number, max: number, step: number = 1) {\n    if (typeof min === \"number\" && typeof max === \"number\")\n        return Array(Math.ceil((ma {\n    if (typeof min === \"number\" && typeof max === \"number\")\n        return Math.floor(min + Math.random() * (max - min));\n    return 0;\n}\n/**\n * @export 时间格式化\n * @param {*} date Date对象，string 或 number 的毫秒事件数\n * @param {string} fmt 格式类型为：\"yyyy-MM-dd hh:mm:ss\"\n * @returns {string}\n */\nexport function formatDate(date: Date, fmt = \"yyyy-MM-dd hh:mm:ss\") {\n    if (!date) {\n        return \"--\";\n    }\n    date = new Date(date);\n    let o: {\n        \"M+\": date.getMonth(, fmt: \"M+\"),\n        \"d+\": date.getDate(),\n        \"h+\": date.getHours(),\n        \"m+\": date.getMinutes(),\n        \"s+\": date.getSeconds(),\n        \"q+\": Math.floor((date.getMonth() + = \"yyyy-MM-dd hh:mm:ss\"): \"q+\"),\n        S: date.getMilliseconds() // 毫秒\n    };\n    if (/(y+)/.test(fmt))\n        fmt = fmt.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 {\n    if (!date) {\n        return \"--\";\n    }\n    if (typeof date === \"string\" && !/-/.test(date))\n        date = Number(date);\n    date = new Date(date);\n    let o = {\n        \"M+\": date.getMonth() + 1,\n        \"d+\": date.getDate(),\n        \"h+\": date.getHours(),\n        \"m+\": date.getMinutes(),\n        \"s+\": date.getSeconds(),\n        \"q+\": Math.floor((date.getMonth() + 3) / 3),\n        S: date.getMilliseconds() // 毫秒\n    };\n    if (/(y+)/.test(fmt))\n        fmt = fmt.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n    for (let k in o) {\n        if (new RegExp(\"(\" + k + \")\").test(fmt))\n            fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n    }\n    return fmt;\n}\n","score":324,"fallbacked":false,"num_type_errors":94}]}
{"dataset_elem":{"alphanum_fraction":0.2909803922,"avg_line_length":20.564516129,"content":"// http://schepers.cc/getting-to-the-point\nexport default function catmullRom2Bezier(crp: number[], z?: boolean): any[][] {\n  const d = [];\n  // @ts-ignore\n  for (let i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n    const p = [ {\n      x: +crp[i - 2],\n      y: +crp[i - 1],\n    }, {\n      x: +crp[i],\n      y: +crp[i + 1],\n    }, {\n      x: +crp[i + 2],\n      y: +crp[i + 3],\n    }, {\n      x: +crp[i + 4],\n      y: +crp[i + 5],\n    } ];\n    if (z) {\n      if (!i) {\n        p[0] = {\n          x: +crp[iLen - 2],\n          y: +crp[iLen - 1],\n        };\n      } else if (iLen - 4 === i) {\n        p[3] = {\n          x: +crp[0],\n          y: +crp[1],\n        };\n      } else if (iLen - 2 === i) {\n        p[2] = {\n          x: +crp[0],\n          y: +crp[1],\n        };\n        p[3] = {\n          x: +crp[2],\n          y: +crp[3],\n        };\n      }\n    } else {\n      if (iLen - 4 === i) {\n        p[3] = p[2];\n      } else if (!i) {\n        p[0] = {\n          x: +crp[i],\n          y: +crp[i + 1],\n        };\n      }\n    }\n    d.push([ 'C',\n      (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n      (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n      (p[1].x + 6 * p[2].x - p[3].x) / 6,\n      (p[1].y + 6 * p[2].y - p[3].y) / 6,\n      p[2].x,\n      p[2].y,\n    ]);\n  }\n\n  return d;\n}\n","content_without_annotations":"// http://schepers.cc/getting-to-the-point\nexport default function catmullRom2Bezier(crp, z?) {\n  const d = [];\n  // @ts-ignore\n  for (let i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n    const p = [ {\n      x: +crp[i - 2],\n      y: +crp[i - 1],\n    }, {\n      x: +crp[i],\n      y: +crp[i + 1],\n    }, {\n      x: +crp[i + 2],\n      y: +crp[i + 3],\n    }, {\n      x: +crp[i + 4],\n      y: +crp[i + 5],\n    } ];\n    if (z) {\n      if (!i) {\n        p[0] = {\n          x: +crp[iLen - 2],\n          y: +crp[iLen - 1],\n        };\n      } else if (iLen - 4 === i) {\n        p[3] = {\n          x: +crp[0],\n          y: +crp[1],\n        };\n      } else if (iLen - 2 === i) {\n        p[2] = {\n          x: +crp[0],\n          y: +crp[1],\n        };\n        p[3] = {\n          x: +crp[2],\n          y: +crp[3],\n        };\n      }\n    } else {\n      if (iLen - 4 === i) {\n        p[3] = p[2];\n      } else if (!i) {\n        p[0] = {\n          x: +crp[i],\n          y: +crp[i + 1],\n        };\n      }\n    }\n    d.push([ 'C',\n      (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n      (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n      (p[1].x + 6 * p[2].x - p[3].x) / 6,\n      (p[1].y + 6 * p[2].y - p[3].y) / 6,\n      p[2].x,\n      p[2].y,\n    ]);\n  }\n\n  return d;\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":561,"ext":"ts","fun_ann_density":0.0053475936,"function_parameters":2,"function_signatures":0,"function_usages":0,"functions":1,"hexsha":"7ef519413b872aeb3b35cf70a60bb014f3448ac9","lang":"TypeScript","loc":58,"loc_per_function":56.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"431c4921698d5a150e510528bc3fd4b62d51abfb","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"lianjie5664/dsshop","max_forks_repo_path":"admin/vue2/element-admin-v3/node_modules/@antv/path-util/src/catmull-rom-2-bezier.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"431c4921698d5a150e510528bc3fd4b62d51abfb","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"lianjie5664/dsshop","max_issues_repo_path":"admin/vue2/element-admin-v3/node_modules/@antv/path-util/src/catmull-rom-2-bezier.ts","max_line_length":80,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"a5893106bb50869d0acd68e85ac93bf3fd608219","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"wuximing/dsshop","max_stars_repo_path":"admin/vue2/element-admin-v3/node_modules/@antv/path-util/src/catmull-rom-2-bezier.ts","max_stars_repo_stars_event_max_datetime":"2022-01-26T02:20:58.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-26T02:20:58.000Z","metric":0.2034165222,"predefined_density":0.2857142857,"predefined_types":2,"prop_ann_density":0.0,"property_declarations":0,"size":1275,"trivial_density":0.1428571429,"trivial_types":1,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0071301248,"variable_declarations":4},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"// http://schepers.cc/getting-to-the-point\nexport default function catmullRom2Bezier(crp: [number, number, number, number, number, number, number], z?: number): [number, number, number, number, number, number, number] {\n    const d = [];\n    // @ts-ignore\n    for (let i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n        const p = [{\n                x: +crp[i - 2],\n                y: +crp[i - 1],\n            }, {\n                x: +crp[i],\n                y: +crp[i + 1],\n            }, {\n                x: +crp[i + 2],\n                y: +crp[i + 3],\n            }, {\n                x: +crp[i + 4],\n                y: +crp[i + 5],\n            }];\n        if (z) {\n            if (!i) {\n                p[0] = {\n                    x: +crp[iLen - 2],\n                    y: +crp[iLen - 1],\n                };\n            }\n            else if (iLen - 4 === i) {\n                p[3] = {\n                    x: +crp[0],\n                    y: +crp[1],\n                };\n            }\n            else if (iLen - 2 === i) {\n                p[2] = {\n                    x: +crp[0],\n                    y: +crp[1],\n                };\n                p[3] = {\n                    x: +crp[2],\n                    y: +crp[3],\n                };\n            }\n        }\n        else {\n            if (iLen - 4 === i) {\n                p[3] = p[2];\n            }\n            else if (!i) {\n                p[0] = {\n                    x: +crp[i],\n                    y: +crp[i + 1],\n                };\n            }\n        }\n        d.push([\"C\",\n            (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n            (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n            (p[1].x + 6 * p[2].x - p[3].x) / 6,\n            (p[1].y + 6 * p[2].y - p[3].y) / 6,\n            p[2].x,\n            p[2].y,\n        ]);\n    }\n    return d;\n}\n","score":53,"fallbacked":false,"num_type_errors":1},{"code":"// http://schepers.cc/getting-to-the-point\nexport default function catmullRom2Bezier(crp: number[], z?: number, z?: number): string[] {\n    const d = [];\n    // @ts-ignore\n    for (let i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n        const p = [{\n                x: +crp[i - 2],\n                y: +crp[i - 1],\n            }, {\n                x: +crp[i],\n                y: +crp[i + 1],\n            }, {\n                x: +crp[i + 2],\n                y: +crp[i + 3],\n            }, {\n                x: +crp[i + 4],\n                y: +crp[i + 5],\n            }];\n        if (z) {\n            if (!i) {\n                p[0] = {\n                    x: +crp[iLen - 2],\n                    y: +crp[iLen - 1],\n                };\n            }\n            else if (iLen - 4 === i) {\n                p[3] = {\n                    x: +crp[0],\n                    y: +crp[1],\n                };\n            }\n            else if (iLen - 2 === i) {\n                p[2] = {\n                    x: +crp[0],\n                    y: +crp[1],\n                };\n                p[3] = {\n                    x: +crp[2],\n                    y: +crp[3],\n                };\n            }\n        }\n        else {\n            if (iLen - 4 === i) {\n                p[3] = p[2];\n            }\n            else if (!i) {\n                p[0] = {\n                    x: +crp[i],\n                    y: +crp[i + 1],\n                };\n            }\n        }\n        d.push([\"C\",\n            (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n            (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n            (p[1].x + 6 * p[2].x - p[3].x) / 6,\n            (p[1].y + 6 * p[2].y - p[3].y) / 6,\n            p[2].x,\n            p[2].y,\n        ]);\n    }\n    return d;\n}\n","score":125,"fallbacked":false,"num_type_errors":2},{"code":"// http://schepers.cc/getting-to-the-point\nexport default function catmullRom2Bezier(crp: [number, number, number, number, z?: number]) {\n    // From: http://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands\n    if (!crp || crp.length < 6) {): void}\n    const p0 = {\n        x: +crp[0],\n        y: +crp[1],\n    };\n    const p1 = {\n        x: +crp[2],\n        y: +crp {\n    const d = [];\n    // @ts-ignore\n    for (let i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n        const p = [{\n                x: +crp[i - 2],\n                y: +crp[i - 1],\n            }, {\n                x: +crp[i],\n                y: +crp[i + 1],\n            }, {\n                x: +crp[i + 2],\n                y: +crp[i + 3],\n            }, {\n                x: +crp[i + 4],\n                y: +crp[i + 5],\n            }];\n        if (z) {\n            if (!i) {\n                p[0] = {\n                    x: +crp[iLen - 2],\n                    y: +crp[iLen - 1],\n                };\n            }\n            else if (iLen - 4 === i) {\n                p[3] = {\n                    x: +crp[0],\n                    y: +crp[1],\n                };\n            }\n            else if (iLen - 2 === i) {\n                p[2] = {\n                    x: +crp[0],\n                    y: +crp[1],\n                };\n                p[3] = {\n                    x: +crp[2],\n                    y: +crp[3],\n                };\n            }\n        }\n        else {\n            if (iLen - 4 === i) {\n                p[3] = p[2];\n            }\n            else if (!i) {\n                p[0] = {\n                    x: +crp[i],\n                    y: +crp[i + 1],\n                };\n            }\n        }\n        d.push([\"C\",\n            (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n            (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n            (p[1].x + 6 * p[2].x - p[3].x) / 6,\n            (p[1].y + 6 * p[2].y - p[3].y) / 6,\n            p[2].x,\n            p[2].y,\n        ]);\n    }\n    return d;\n}\n","score":208,"fallbacked":false,"num_type_errors":9}]}
{"dataset_elem":{"alphanum_fraction":0.5998988366,"avg_line_length":29.5074626866,"content":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Kenneth Herrera. All rights reserved.\n *  Licensed under the MIT License. See LICENSE in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type ExpectedType =\n  | \"string\"\n  | \"number\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"symbol\"\n  | \"undefined\"\n  | \"object\"\n  | \"function\"\n  | \"array\"\n  | \"unknown\";\n\nexport enum TypeParseErrorCode {\n  NOT_FOUND = \"NOT_FOUND\",\n  INVALID_TYPE = \"INVALID_TYPE\",\n  UNABLE_TO_PARSE = \"UNABLE_TO_PARSE\",\n}\n\nexport interface TypeParseErrorDetails {\n  expectedType?: ExpectedType;\n  typeFound?: unknown;\n  key?: string | string[];\n  customError?: string;\n}\n\nexport function typeOf(value: unknown): ExpectedType {\n  if (Array.isArray(value)) return \"array\";\n  return typeof value;\n}\n\nexport class TypeParseError implements Error {\n  public readonly code: TypeParseErrorCode;\n  public readonly name: string;\n  public readonly message: string;\n\n  public constructor(parameters: TypeParseErrorDetails) {\n    const { expectedType, key, typeFound } = {\n      ...parameters,\n      typeFound: typeOf(parameters.typeFound),\n    };\n    this.name = \"TypeParse exception\";\n    if (expectedType === \"unknown\") {\n      this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n      this.message = `${parameters.customError}`;\n    } else if (typeFound === \"undefined\") {\n      this.code = TypeParseErrorCode.NOT_FOUND;\n      if (key) {\n        this.message = `Unable to find a valid [${expectedType}] value at [${key}]`;\n      } else {\n        this.message = `Invalid type, expected [${expectedType}] but found [${typeFound}]`;\n      }\n    } else {\n      this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n      this.message = `Unable to convert [${typeFound}] to [${expectedType}]`;\n    }\n  }\n\n  public toString() {\n    return `TypeParse error: ${this.message}`;\n  }\n}\n","content_without_annotations":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Kenneth Herrera. All rights reserved.\n *  Licensed under the MIT License. See LICENSE in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type ExpectedType =\n  | \"string\"\n  | \"number\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"symbol\"\n  | \"undefined\"\n  | \"object\"\n  | \"function\"\n  | \"array\"\n  | \"unknown\";\n\nexport enum TypeParseErrorCode {\n  NOT_FOUND = \"NOT_FOUND\",\n  INVALID_TYPE = \"INVALID_TYPE\",\n  UNABLE_TO_PARSE = \"UNABLE_TO_PARSE\",\n}\n\nexport interface TypeParseErrorDetails {\n  expectedType?;\n  typeFound?;\n  key?;\n  customError?;\n}\n\nexport function typeOf(value) {\n  if (Array.isArray(value)) return \"array\";\n  return typeof value;\n}\n\nexport class TypeParseError implements Error {\n  public readonly code;\n  public readonly name;\n  public readonly message;\n\n  public constructor(parameters) {\n    const { expectedType, key, typeFound } = {\n      ...parameters,\n      typeFound: typeOf(parameters.typeFound),\n    };\n    this.name = \"TypeParse exception\";\n    if (expectedType === \"unknown\") {\n      this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n      this.message = `${parameters.customError}`;\n    } else if (typeFound === \"undefined\") {\n      this.code = TypeParseErrorCode.NOT_FOUND;\n      if (key) {\n        this.message = `Unable to find a valid [${expectedType}] value at [${key}]`;\n      } else {\n        this.message = `Invalid type, expected [${expectedType}] but found [${typeFound}]`;\n      }\n    } else {\n      this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n      this.message = `Unable to convert [${typeFound}] to [${expectedType}]`;\n    }\n  }\n\n  public toString() {\n    return `TypeParse error: ${this.message}`;\n  }\n}\n","dynamism_density":0.0020790021,"dynamism_heuristic":1,"estimated_tokens":481,"ext":"ts","fun_ann_density":0.0103950104,"function_parameters":2,"function_signatures":0,"function_usages":1,"functions":3,"hexsha":"2f516f8ce46385d35483cc20af39f1c2bfb17dc1","lang":"TypeScript","loc":55,"loc_per_function":7.3333333333,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"f0d8ad2050df19231b7c823b378d5949ae6ab118","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"Kenneth-hv/typeparse","max_forks_repo_path":"src/Error.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"f0d8ad2050df19231b7c823b378d5949ae6ab118","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"Kenneth-hv/typeparse","max_issues_repo_path":"src/Error.ts","max_line_length":96,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"f0d8ad2050df19231b7c823b378d5949ae6ab118","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"Kenneth-hv/typeparse","max_stars_repo_path":"src/Error.ts","max_stars_repo_stars_event_max_datetime":"2022-03-29T20:05:35.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-29T20:05:35.000Z","metric":0.2104522907,"predefined_density":0.5384615385,"predefined_types":7,"prop_ann_density":0.0145530146,"property_declarations":7,"size":1977,"trivial_density":0.0,"trivial_types":0,"type_definitions":3,"typedef_density":0.0062370062,"var_ann_density":0.0020790021,"variable_declarations":1},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Kenneth Herrera. All rights reserved.\n *  Licensed under the MIT License. See LICENSE in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport type ExpectedType = \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\" | \"array\" | \"unknown\";\nexport enum TypeParseErrorCode {\n    NOT_FOUND = \"NOT_FOUND\",\n    INVALID_TYPE = \"INVALID_TYPE\",\n    UNABLE_TO_PARSE = \"UNABLE_TO_PARSE\"\n}\nexport interface TypeParseErrorDetails {\n    expectedType?: ExpectedType;\n    key?: string;\n    typeFound?: string;\n    value?: unknown;\n    details?: TypeParseErrorDetails[];\n    key?: string;\n}\nexport interface TypeParseOptions {\n    key?: string;\n    customError?: string;\n}\nexport interface TypeParseResult {\n    value: unknown;\n    customError?: TypeParseErrorDetails[];\n}\nexport interface Typ;\n    customError?: TypeParseErrorDetails[];\nexport function parse(value: string, options?: TypeParseOptions): TypeParseResult {\n    const { customError } = options || {};\n    let typeFound: string | undefined;\n    if (!customError) {;\n}\nexport function typeOf(value: any): string | undefined {\n    const type = typeof value;\n    if (type === \"string\") {\n        if (/^\"([^\"]|\\\\\")*$\"/.test(value)) {\n            typeFound = \"string\";\n            return \"strin): string\";\n        }\n        typeFound = \"string\";\n        return \"string\";\n    }\n    if (type === \"number\") {\n        typeFound = \"number\";\n        return \"number\";\n    }\n    if (type === \"bigint\") {\n    if (Array.isArray(value))\n        return \"array\";\n    return typeof value;\n}\nexport class TypeParseError implements Error {\n    public readonly code: TypeParseErrorCode;\n    public readonly message: string;\n    public constructor(parameters) {\n        this.code = parameters.code;\n        this.message = parameters.message;\n    }\n}\nexport class InvalidTypeTypeError extends TypeParseError;\n    public readonly name: \"InvalidTypeTypeError\";\n}\nexport class TypeParseError extends Error {\n    public readonly code: TypeParseErrorCode;\n    public readonly message: string;\n    public constructor(parameters) {\n        super(parameters.message);\n        this.code;\n    public readonly message: string;\n    constructor(parameters) {\n        super(parameters.message);\n        this.code;\n    }\n}\nexport enum TypeParseErrorCode {\n    UNABLE_TO_PARSE = 1,\n    NOT_FOUND = 2;\n    public constructor(parameters: ConstructorParameters<typeof TypeParseError>);\n    public readonly code: TypeParseErrorCode;\n    public readonly message: string;\n}\nexport class TypeParseResult {\n    public readonly type: string | undefined;\n    public readonly typeFound: string | undefine) {\n        const { expectedType, key, typeFound } = {\n            ...parameters,\n            typeFound: typeOf(parameters.typeFound),\n        };\n        this.name = \"TypeParse exception\";\n        if (expectedType === \"unknown\") {\n            this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n            this.message = `${parameters.customError}`;\n        }\n        else if (typeFound === \"undefined\") {\n            this.code = TypeParseErrorCode.NOT_FOUND;\n            if (key) {\n                this.message = `Unable to find a valid [${expectedType}] value at [${key}]`;\n            }\n            else {\n                this.message = `Invalid type, expected [${expectedType}] but found [${typeFound}]`;\n            }\n        }\n        else {\n            this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n            this.message = `Unable to convert [${typeFound}] to [${expectedType}]`;\n        }\n    }\n    public toString(): string {\n        return `TypeParseResult: ${this.message}`;\n    }\n}\nexport class TypeParseError extends TypeParseResult {\n    public constructor(parameters: ConstructorParameters<typeof TypeParseError>);\n    public constructor(parameters) {\n        supe {\n        return `TypeParse error: ${this.message}`;\n    }\n}\n","score":144,"fallbacked":false,"num_type_errors":52},{"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Kenneth Herrera. All rights reserved.\n *  Licensed under the MIT License. See LICENSE in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport type ExpectedType = \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\" | \"array\" | \"unknown\";\nexport enum TypeParseErrorCode {\n    NOT_FOUND = \"NOT_FOUND\",\n    INVALID_TYPE = \"INVALID_TYPE\",\n    UNABLE_TO_PARSE = \"UNABLE_TO_PARSE\"\n}\nexport interface TypeParseErrorDetails {\n    expectedType?: ExpectedType;\n    key?: string;\n    typeFound?: string;\n    customError?: string;\n}\nexport interface TypeParseResult {\n    typeFound?;\n    key?: string;\n    customError?: string;\n}\nexport function parseType(typeToParse: string, key: string, errors?: TypeParseErrorDetails[]): TypeParseResult {\n    if (errors) {\n        for (const error of error;\n    customError?: string) {\n            if (error.key === key) {\n                return { customError };\n            }\n        }\n    }\n    if (typeof typeToParse === \"number\") {\n        return { typeFound: \"number\" };\n    };\n}\nexport function typeOf(value: any): \"boolean\" | \"bigint\" | \"number\" | \"symbol\" | \"undefined\" | \"string\" | \"object\" | \"array\" | \"function\" | \"unknown\" {\n    return parseType(typeOfValue(value) {\n    if (Array.isArray(value))\n        return \"array\";\n    return typeof value;\n}\nexport class TypeParseError implements Error {\n    public readonly code: TypeParseErrorCode;\n    public readonly name: string;\n    public readonly message: string;\n    public constructor(parameters) {\n        const { expectedType, key, typeFound } = {\n           ...parameters,\n            typeFound: typeOf(parameters;\n    public readonly name: \"TypeParse exception\";\n            if (expectedType === \"unknown\") {\n                this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n                this.message = `${parameters.customError}`;\n            }\n            else if (typeFoun;\n    public readonly message: string;\n            else if (expectedType === \"array\" && typeFound === \"number\") {\n                this.code = TypeParseErrorCode.ARRAY_NUMBER_TO_PARSE;\n                this.message = `${parameters.customError}`;;\n    public constructor(parameters: { expectedType?: \"array\", key?: string, typeFound?: \"number\" | \"object\" | \"function\" | \"unknown\" });\n            }\n    }\n}\nexport enum TypeParseErrorCode {\n    UNABLE_TO_PARS) {\n        const { expectedType, key, typeFound } = {\n            ...parameters,\n            typeFound: typeOf(parameters.typeFound),\n        };\n        this.name = \"TypeParse exception\";\n        if (expectedType === \"unknown\") {\n            this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n            this.message = `${parameters.customError}`;\n        }\n        else if (typeFound === \"undefined\") {\n            this.code = TypeParseErrorCode.NOT_FOUND;\n            if (key) {\n                this.message = `Unable to find a valid [${expectedType}] value at [${key}]`;\n            }\n            else {\n                this.message = `Invalid type, expected [${expectedType}] but found [${typeFound}]`;\n            }\n        }\n        else {\n            this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n            this.message = `Unable to convert [${typeFound}] to [${expectedType}]`;\n        }\n    }\n    public toString(): string {\n        return `TypeParse error: ${this.message}`;\n    }\n}\nexport enum TypeParseErrorCode {\n    UNABLE_TO_PARSE = 1,\n    ARRAY_NUMBER_TO_PARSE = 2,\n    NO {\n        return `TypeParse error: ${this.message}`;\n    }\n}\n","score":130,"fallbacked":false,"num_type_errors":61},{"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Kenneth Herrera. All rights reserved.\n *  Licensed under the MIT License. See LICENSE in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport type ExpectedType = \"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\" | \"array\" | \"unknown\";\nexport enum TypeParseErrorCode {\n    NOT_FOUND = \"NOT_FOUND\",\n    INVALID_TYPE = \"INVALID_TYPE\",\n    UNABLE_TO_PARSE = \"UNABLE_TO_PARSE\"\n}\nexport interface TypeParseErrorDetails {\n    expectedType?: ExpectedType;\n    key?: string;\n    typeFound?: TypeFoundType;\n    customError?: string;\n    typeFound?: string;\n}\nexport interface TypeFoundType {\n    type: ExpectedType;\n}\nexport interface ParsedValue<T = ParsedValue<unknown>> {\n    type?: ExpectedType;\n    value?: T;\n}\nexport enum Typ;\n    key?: string;\n    value?: ParsedValue<unknown>;\n    customError?: string;\n    constructor(parameters: ParsedValue<unknown>);\n    constructor(parameters: ParsedValue<unknown>, customError?: string);\n}\nexport interface TypeParseOptions;\n    customError?: string;\n    constructor(parameters?: TypeParseOptions);\n    constructor(parameters: TypeParseOptions, customError?: string);\nexport interface TypeParseResult {\n    parsedValues: Typ[];\n    errors: TypeParseErrorDetails[];\n}\nexpor;\n}\nexport function typeOf(value: unknown): Typ {\n    if (value === undefined)\n        return \"undefined\";\n    if (value === null)\n        return \"null\";\n    if (typeof value === \"string\")\n        return \"string\";\n    if (typeof value ===): any {\n        if (value instanceof Date)\n            return \"date\";\n        if (value instanceof RegExp)\n            return \"regexp\";\n        return typeof value;\n    }\n    if (typeof value === \"number\")\n        return \"number\";\n    if {\n    if (Array.isArray(value))\n        return \"array\";\n    return typeof value;\n}\nexport class TypeParseError implements Error {\n    public readonly code: number;\n    public readonly name: string;\n    public readonly message: string;\n    public constructor(parameters: TypeParseErrorDetails) {\n        this.name = \"TypeParse exception\";\n        this.code = TypeParseErrorCode.UNABLE_T;\n    public readonly name: string;\n    public readonly message: string;\n    public constructor(parameters) {\n        this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n        this.name = \"TypeParse exception\";\n        this.message = `${parameters;\n    public readonly message: string;\n    public constructor(parameters) {\n        this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n        this.name = \"TypeParse exception\";\n        this.message = `${parameters;\n    }`;\n    };\n    public constructor(parameters: number, parameters: string) {\n        this.code = parameters;\n        this.name = \"TypeParse exception\";\n        this.message = `${parameters;\n    }`;\n    }\n    }\n    public constructor(parameters: TypeParseErrorDetails, parameter) {\n        const { expectedType, key, typeFound } = {\n            ...parameters,\n            typeFound: typeOf(parameters.typeFound),\n        };\n        this.name = \"TypeParse exception\";\n        if (expectedType === \"unknown\") {\n            this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n            this.message = `${parameters.customError}`;\n        }\n        else if (typeFound === \"undefined\") {\n            this.code = TypeParseErrorCode.NOT_FOUND;\n            if (key) {\n                this.message = `Unable to find a valid [${expectedType}] value at [${key}]`;\n            }\n            else {\n                this.message = `Invalid type, expected [${expectedType}] but found [${typeFound}]`;\n            }\n        }\n        else {\n            this.code = TypeParseErrorCode.UNABLE_TO_PARSE;\n            this.message = `Unable to convert [${typeFound}] to [${expectedType}]`;\n        }\n    }\n    public toString(): string {\n        return `TypeParse error: ${this.message}`;\n    }\n}\n","score":58,"fallbacked":false,"num_type_errors":147}]}
{"dataset_elem":{"alphanum_fraction":0.6176638177,"avg_line_length":21.9375,"content":"export const backendInjections = {\n  instanceMap: new Map(),\n  isVueInstance: (() => false) as ((value: any) => boolean),\n  getCustomInstanceDetails: (() => ({})) as ((instance: any) => any),\n  getCustomObjectDetails: (() => undefined) as (value: any, proto: string) => any,\n}\n\nexport function getInstanceMap () {\n  return backendInjections.instanceMap\n}\n\nexport function getCustomInstanceDetails (instance) {\n  return backendInjections.getCustomInstanceDetails(instance)\n}\n\nexport function getCustomObjectDetails (value, proto: string) {\n  return backendInjections.getCustomObjectDetails(value, proto)\n}\n\nexport function isVueInstance (value) {\n  return backendInjections.isVueInstance(value)\n}\n\n// @TODO refactor\nexport function getCustomRouterDetails (router) {\n  return {\n    _custom: {\n      type: 'router',\n      display: 'VueRouter',\n      value: {\n        options: router.options,\n        currentRoute: router.currentRoute,\n      },\n      fields: {\n        abstract: true,\n      },\n    },\n  }\n}\n\n// @TODO refactor\nexport function getCustomStoreDetails (store) {\n  return {\n    _custom: {\n      type: 'store',\n      display: 'Store',\n      value: {\n        state: store.state,\n        getters: getCatchedGetters(store),\n      },\n      fields: {\n        abstract: true,\n      },\n    },\n  }\n}\n\n// @TODO refactor\nexport function getCatchedGetters (store) {\n  const getters = {}\n\n  const origGetters = store.getters || {}\n  const keys = Object.keys(origGetters)\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    Object.defineProperty(getters, key, {\n      enumerable: true,\n      get: () => {\n        try {\n          return origGetters[key]\n        } catch (e) {\n          return e\n        }\n      },\n    })\n  }\n\n  return getters\n}\n","content_without_annotations":"export const backendInjections = {\n  instanceMap: new Map(),\n  isVueInstance: (() => false) as ((value) => boolean),\n  getCustomInstanceDetails: (() => ({})) as ((instance) => any),\n  getCustomObjectDetails: (() => undefined) as (value, proto) => any,\n}\n\nexport function getInstanceMap () {\n  return backendInjections.instanceMap\n}\n\nexport function getCustomInstanceDetails (instance) {\n  return backendInjections.getCustomInstanceDetails(instance)\n}\n\nexport function getCustomObjectDetails (value, proto) {\n  return backendInjections.getCustomObjectDetails(value, proto)\n}\n\nexport function isVueInstance (value) {\n  return backendInjections.isVueInstance(value)\n}\n\n// @TODO refactor\nexport function getCustomRouterDetails (router) {\n  return {\n    _custom: {\n      type: 'router',\n      display: 'VueRouter',\n      value: {\n        options: router.options,\n        currentRoute: router.currentRoute,\n      },\n      fields: {\n        abstract: true,\n      },\n    },\n  }\n}\n\n// @TODO refactor\nexport function getCustomStoreDetails (store) {\n  return {\n    _custom: {\n      type: 'store',\n      display: 'Store',\n      value: {\n        state: store.state,\n        getters: getCatchedGetters(store),\n      },\n      fields: {\n        abstract: true,\n      },\n    },\n  }\n}\n\n// @TODO refactor\nexport function getCatchedGetters (store) {\n  const getters = {}\n\n  const origGetters = store.getters || {}\n  const keys = Object.keys(origGetters)\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    Object.defineProperty(getters, key, {\n      enumerable: true,\n      get: () => {\n        try {\n          return origGetters[key]\n        } catch (e) {\n          return e\n        }\n      },\n    })\n  }\n\n  return getters\n}\n","dynamism_density":0.0067114094,"dynamism_heuristic":3,"estimated_tokens":447,"ext":"ts","fun_ann_density":0.0402684564,"function_parameters":7,"function_signatures":0,"function_usages":4,"functions":11,"hexsha":"0db5fc4d6c0acc5ca993426ff909b7fa849baeca","lang":"TypeScript","loc":67,"loc_per_function":5.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"328b52e10d36f929d7dfd47a67210b8f73d44578","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"CyberFlameGO/devtools","max_forks_repo_path":"packages/shared-utils/src/backend.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"328b52e10d36f929d7dfd47a67210b8f73d44578","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"CyberFlameGO/devtools","max_issues_repo_path":"packages/shared-utils/src/backend.ts","max_line_length":82,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"328b52e10d36f929d7dfd47a67210b8f73d44578","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"CyberFlameGO/devtools","max_stars_repo_path":"packages/shared-utils/src/backend.ts","max_stars_repo_stars_event_max_datetime":"2022-03-14T03:23:27.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-14T03:23:27.000Z","metric":0.3046655305,"predefined_density":0.125,"predefined_types":3,"prop_ann_density":0.0,"property_declarations":0,"size":1755,"trivial_density":0.2083333333,"trivial_types":5,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0134228188,"variable_declarations":6},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export const backendInjections = {\n    instanceMap: new Map(),\n    isVueInstance: ((): boolean) => false) as ((value: any) => boolean),\n    isVueConstructor: ((): boolean) => false) as ((value: any) => boolean),\n    getCustomInstanceDetails: ((): (instance) => any),\n    getCustomRouterDetails: (router: any) => ({\n        _custom: {\n            type: \"router\",\n            display: \"VueRouter\",\n            value: {\n                options: router.options,\n                currentRout => ({})) as ((instance: any, proto: any) => any),\n                getCurrentRoute: ((): any) => ({}),\n            },\n            fields: {\n                abstract: true,\n            },\n        },\n    }),\n    getCustomInstanceDetails: (instance: any) => ({) => any),\n    getCustomObjectDetails: ((): (value: any) => ({\n        _custom: {\n            type: \"object\",\n            display: \"VueInstance\",\n            value: value,\n            fields: {\n                abstract: true,\n            },\n        },\n    })) as ((value: an => undefined) as (value: any) => any),\n    getBackendInjections: (customOptions: any) => backendInjections,\n    getCustomInstanceDetails: (instance: any) => backendInjections.getCustomInstanceDetails(instance),\n    getCustomObjectDetails: (valu, proto: any) => backendInjections.getCustomObjectDetails(valu, proto),\n    getVueInstanceDetails: (instance: any) => backendInjections.getCustomInstanceDetails(instance),\n    getCustomRouterDetails: (router: any) => backendInjectio) => any,\n};\nexport function getInstanceMap(): Map<VueInstance, VueRouter> {\n    return backendInjections.instanceMap;\n}\nexport function getVueInstanceDetails(instance) {\n    return backendInjections.getVueInstanceDetails(instance);\n}\nexport function getCusto {\n    return backendInjections.instanceMap;\n}\nexport function getCustomInstanceDetails(instance: any) {\n    return backendInjections.getCustomInstanceDetails(instance);\n}\nexport function getCustomObjectDetails(value, proto) {\n    return backendInjections.getCustomObjectDetails(value, proto);\n}\nexport function getBacken): any {\n    return backendInjections.getBacken;\n}\nexport function getBackendInjections(customOptions: any) {\n    return backendInjections.backendInjections;\n}\nexport function getCustomInstanceDetails(instance: an {\n    return backendInjections.getCustomInstanceDetails(instance);\n}\nexport function getCustomObjectDetails(value: any, proto: any) {\n    return backendInjections.getCustomObjectDetails(value, proto);\n}\nexport function getBackendInjections() {\n    return backendInjections.backendInjections;\n}\nexport function isVueInstanc, proto: any {\n    return backendInjections.isVueInstanc(proto);\n}\nexport function isCustomInstance(instance: any) {\n    return backendInjections.isCustomInstance(instance);\n}\nexport function isCustomInstance): boolean {\n    return backendInjections.isCustomInstance();\n}\nexport function isVueInstance(instance: any) {\n    return backendInjections.isVueInstance(instance);\n}\nexport function isCustomRouterInstance(instance {\n    return backendInjections.getCustomObjectDetails(value, proto);\n}\nexport function isVueInstance(value: any) {\n    return backendInjections.isVueInstance(value);\n}\nexport function isCustomRouterInstance(value: any) {\n    return backendInjections.isCustomRouterInstance(value);\n}\nexport function isCusto): boolean {\n    return backendInjections.isCustom();\n}\nexport function isCustom(): boolean {\n    return backendInjections.isCustom();\n}\nexport function isCustomVueInstance(value: any) {\n    return backendInjection {\n    return backendInjections.isVueInstance(value);\n}\n// @TODO refactor\nexport function getCustomRouterDetails(router: any) {\n    return {\n        _custom: {\n            type: \"router\",\n            display: \"VueRouter\",\n            value: {\n                options: router.options,\n                currentRoute: router.currentRoute,\n            },\n            fields:): {\n                abstract: true,\n            },\n        },\n    };\n}\n// @TODO refactor\nexport function getCustomRouterDetails(router: any) {\n    return {\n        _custom: {\n            type: \"router\",\n            display: \"Vu {\n    return {\n        _custom: {\n            type: \"router\",\n            display: \"VueRouter\",\n            value: {\n                options: router.options,\n                currentRoute: router.currentRoute,\n            },\n            fields: {\n                abstract: true,\n            },\n        },\n    };\n}\n// @TODO refactor\nexport function getCustomStoreDetails(store: any) {\n    return {\n        _custom: {\n            type: \"store\",\n            display: \"Store\",\n            value: {\n                state: store.state,\n                getters: getCatchedGetters(store),\n            },\n            fields: {): {\n                abstract: true,\n            },\n        },\n    };\n}\n// @TODO refactor\nexport function getCustomStoreDetails(store: any) {\n    return {\n        _custom: {\n            type: \"store\",\n            display: \"Stor {\n    return {\n        _custom: {\n            type: \"store\",\n            display: \"Store\",\n            value: {\n                state: store.state,\n                getters: getCatchedGetters(store),\n            },\n            fields: {\n                abstract: true,\n            },\n        },\n    };\n}\n// @TODO refactor\nexport function getCatchedGetters(store: any) {\n    const getters = {};\n    const origGetters = store.getters || {};\n    const keys = Object.keys(origGetters);\n    for (let i = 0; i < keys.length; i++) {\n        const ke): string = keys[i];\n        Object.defineProperty(getters, ke, {\n            enumerable: true,\n            get: () => {\n                try {\n                    return origGetters[ke];\n                }\n                catch (e) {\n                    return e; {\n    const getters = {};\n    const origGetters = store.getters || {};\n    const keys = Object.keys(origGetters);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        Object.defineProperty(getters, key, {\n            enumerable: true,\n            get: (): any => {\n                try {\n                    return origGetters[key];\n                }\n                catch (e) {\n                    return e;\n                }\n            },\n        });\n    }\n    return getters;\n}\n}\n}\n}\n}\n} => {\n                try {\n                    return origGetters[key];\n                }\n                catch (e) {\n                    return e;\n                }\n            },\n        });\n    }\n    return getters;\n}\n","score":419,"fallbacked":false,"num_type_errors":196},{"code":"export const backendInjections = {\n    instanceMap: new Map(),\n    isVueInstance: ((): boolean) => false) as ((value: any) => boolean),\n    isVueComponent: (value: any) => false,\n    isVueOptions: (value: any) => false,\n    getVueOptionsDetails: (value: any) => undefined,\n    getVueInstanceDetail) => boolean),\n    getCustomInstanceDetails: ((): (instance: any) => any) => undefined,\n    getCustomObjectDetails: (value: any, proto: any) => undefined,\n    getInstanceDetails: (instance) => undefined,\n    isVueInstance: (instance) => instance.i => ({})) as ((instance: any) => boolean),\n    getVueInstanceDetail: (instance) => instance as any,\n    getVueInstanceDetails: (instance) => instance as any,\n    getCustomInstanceDetails: (instance) => instance as any,\n    getCustomObjectDetail) => any),\n    getCustomObjectDetails: ((): (customObject: any) => any) => undefined,\n    getVueInstanceDetail: (instance) => instance as any,\n    getVueInstanceDetails: (instance) => instance as any,\n    isVueOptions: (options: any => undefined) as (value: any) => boolean,\n    getVueOptionsDetails: (options: any) => undefined,\n    getVueInstanceDetail: (instance) => instance as any,\n    getVueInstanceDetails: (instance) => instance as any,\n    getCustomInstanc, proto: any,\n};\nexport function isVueInstance(instance) {\n    return backendInjections.isVueInstance(instance);\n}\nexport function getVueInstanceDetail(instance) {\n    return backendInjections.getVueInstanceDetail) => any,\n};\nexport function getInstanceMap(): Map<any, any> {\n    return backendInjections.instanceMap;\n}\nexport function isVueInstance(instance) {\n    return backendInjections.isVueInstance(instance);\n}\nexport function getVueInstanceDetail {\n    return backendInjections.instanceMap;\n}\nexport function getCustomInstanceDetails(instance: any) {\n    return backendInjections.getCustomInstanceDetails(instance);\n}\nexport function getCustomObjectDetails(value, proto) {\n    return backendInjections.getCustomObjectDetails(value, proto);\n}\nexport function isVu): boolean {\n    return backendInjections.isVu;\n}\nexport function getVueOptionsDetails(options: any) {\n    return backendInjections.getVueOptionsDetails(options);\n}\nexport function getVueInstanceDetail(instanc {\n    return backendInjections.getCustomInstanceDetails(instance);\n}\nexport function getCustomObjectDetails(value: any, proto: any) {\n    return backendInjections.getCustomObjectDetails(value, proto);\n}\nexport function isVueInstance(instance) {\n    return backendInjections.isVueInstance(instance);\n}\nexport functio, proto: any;\nexport function getVueOptionsDetails(options: any) {\n    return backendInjections.getVueOptionsDetails(options);\n}\nexport function getVueInstanceDetail(instance) {\n    return backendInjections.getVueInstanc): any;\n}\nexport function getVueInstanceDetail(instance) {\n    return backendInjections.instanceMap;\n}\nexport function getCustomInstanceDetails(instance) {\n    return backendInjections.getCustomInstanceDetails(instance); {\n    return backendInjections.getCustomObjectDetails(value, proto);\n}\nexport function isVueInstance(value: any) {\n    return backendInjections.isVueInstance(value);\n}\nexport function getVueOptionsDetails(value: any) {\n    return backendInjections.getVueOptionsDetails(value);\n}\nexport function getVu): any {\n    return backendInjections.getVueOptionsDetails(value);\n}\nexport function getVueInstanceDetail(instance) {\n    return backendInjections.getVueInstanceDetails(instance);\n}\nexport function isVu(instanc {\n    return backendInjections.isVueInstance(value);\n}\n// @TODO refactor\nexport function getCustomRouterDetails(router: any) {\n    return {\n        _custom: {\n            type: \"router\",\n            display: \"VueRouter\",\n            value: {\n                options: router.options,\n                currentRoute: router.currentRoute,\n            },\n            fields:): {\n                router: true,\n            },\n        },\n    };\n}\nexport function isRouter(router) {\n    return backendInjections.isRouter(router);\n}\nexport function getCustomComponentsDetails(components: any) {\n    retur {\n    return {\n        _custom: {\n            type: \"router\",\n            display: \"VueRouter\",\n            value: {\n                options: router.options,\n                currentRoute: router.currentRoute,\n            },\n            fields: {\n                abstract: true,\n            },\n        },\n    };\n}\n// @TODO refactor\nexport function getCustomStoreDetails(store: any) {\n    return {\n        _custom: {\n            type: \"store\",\n            display: \"Store\",\n            value: {\n                state: store.state,\n                getters: getCatchedGetters(store),\n            },\n            fields: {): {\n                store: true,\n            },\n        },\n    };\n}\nexport function isStore(store) {\n    return backendInjections.isStore(store);\n}\nexport function getCustomAsyncDataDetails(getter: any) { {\n    return {\n        _custom: {\n            type: \"store\",\n            display: \"Store\",\n            value: {\n                state: store.state,\n                getters: getCatchedGetters(store),\n            },\n            fields: {\n                abstract: true,\n            },\n        },\n    };\n}\n// @TODO refactor\nexport function getCatchedGetters(store: any): {\n    return store.state[getter].getters;\n}\nexport function isAsyncData(getter) {\n    return backendInjections.isAsyncData(getter);\n}\nexport function getCustomAsyncDataDetails(getter: any) {\n    const getters = {};\n    const origGetters = store.getters || {};\n    const keys = Object.keys(origGetters);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        Object.defineProperty(getters, key, {\n            enumerable: true,\n            get: (): any => {\n                try {\n                    return origGetters[key];\n                }\n                catch (e) {\n                    return e;\n                }\n            },\n        });\n    }\n    return getters;\n}\nexport function getCatchedState(store: any => {\n                try {\n                    return origGetters[key];\n                }\n                catch (e) {\n                    return e;\n                }\n            },\n        });\n    }\n    return getters;\n}\n","score":488,"fallbacked":false,"num_type_errors":210},{"code":"export const backendInjections = {\n    instanceMap: new Map(),\n    isVueInstance: ((): boolean) => false,\n    isVue3Instance: ((): boolean) => false,\n    isVue2Instance: ((): boolean) => false,\n    createInstance: (instance: Instance) => instance,\n    createInstance2: (instanc => false) as ((value: Instance) => Instance),\n    createInstance3: (instanc => false) as ((value: 3) => Instance),\n    createInstance2: (instanc => false) as ((value: 2) => Instance),\n    createInstanc) => boolean),\n    getCustomInstanceDetails: ((): (instance: Instance) => ({})) as ((instance: Instance) => ({})),\n    getBackendOptions: ((): BackendOptions) => ({\n        useVue2: true,\n        useVue3: true,\n        useVueRouter: true,\n        useStore: true,\n        useAxios: true) => any),\n    getCustomObjectDetails: ((): (value: any) => ({})) as ((value: any) => ({})),\n    getBackendApi: ((): BackendApi) => ({\n        getBackendOptions: (\n            (instance: Instance) => backendInjections.getBackendOptions => undefined) as (value: Instance) => BackendOptions) => BackendOptions,\n        getBackendApi: (instance: Instance) => backendInjections.getBackendApi => backendInjections.getBackendApi,\n        getBackendOptions: (instance: Instance) => backendInjectio, proto: \"http\", baseUrl: \"http://localhost\", baseApiUrl: \"http://localhost\",\n        createInstance: (instance: Instance) => backendInjections.createInstance as ((instance: Instance) => Instance),\n        getBackendApi: (instance) => any,\n};\nexport function getInstanceMap(): Map {\n    return backendInjections.instanceMap;\n}\nexport function getCustomInstanceDetails(instance: Instance) {\n    return backendInjections.getCustomInstanceDetails(instance);\n}\nexport function isVueInstance(instance: Instance) {\n    return backendInjections.isVueInstance(instance);\n}\nexport function getCustomRouterDetails): RouterDetails {\n    return backendInjections.getCustomRouterDetails(router);\n}\nexport function getBackendApi(instance: Instance) {\n    return backendInjections.getBackendApi(instance);\n}\nexport function getBackendOptions {\n    return backendInjections.getCustomInstanceDetails(instance);\n}\nexport function getCustomObjectDetails(value: any) {\n    return backendInjections.getCustomObjectDetails(value);\n}\nexport function isVueInstance(value: any) {\n    return backendInjections.isVueInstance(value);\n}\nexport function getBackendApi, proto: \"http\", baseUrl: \"http://localhost\", baseApiUrl: \"http://localhost\",\n}\nexport interface BackendApi {\n    getBackendOptions: (instance: Instance) => BackendOptions;\n    getBackendApi: (instance: Instance): BackendApi;\n    createInstance: (instance: Instance) => Instance;\n    getBackendApi: (instance: Instance) => BackendApi;\n    getCustomObjectDetails: (value: any, proto: \"http\" | \"https\" | {\n    return backendInjections.getCustomObjectDetails(value, proto);\n}\nexport function isVueInstance(value: any) {\n    return backendInjections.isVueInstance(value);\n}\nexport interface RouterOptions {\n    routes: RouterRoute[];\n    base?: string;\n    mode?: \"hash\" | \"history\";\n    history?: boolean;): RouterApiOptions;\n}\nexport interface RouterApiOptions {\n    instance: Instance;\n    instanceApi?: InstanceApi;\n    instanceApiOptions?: InstanceApiOptions;\n}\nexport interface RouterRoute {\n    path: string;\n    meta? {\n    return backendInjections.isVueInstance(value);\n}\n// @TODO refactor\nexport function getCustomRouterDetails(router: Router) {\n    return {\n        _custom: {\n            type: \"router\",\n            display: \"VueRouter\",\n            value: {\n                options: router.options,\n                currentRoute: router.currentRoute,\n            },\n            fields:): {\n                abstract: true,\n            },\n        },\n    };\n}\nexport interface RouterApiOptions {\n    instance: Instance;\n    instanceApi?: InstanceApi;\n    instanceApiOptions?: InstanceApiOptions;\n}\nexport interface RouterRoute {\n    return {\n        _custom: {\n            type: \"router\",\n            display: \"VueRouter\",\n            value: {\n                options: router.options,\n                currentRoute: router.currentRoute,\n            },\n            fields: {\n                abstract: true,\n            },\n        },\n    };\n}\n// @TODO refactor\nexport function getCustomStoreDetails(store: Store) {\n    const state = store.state;\n    const getters = store.getters || {};\n    const modules = store.modules || {};\n    const actions = store.actions || {};\n    const mutations = store.mutations || {};\n    const stric): {\n        _custom: {\n            type: \"store\",\n            display: \"Store\",\n            value: {\n                state,\n                getters,\n                actions,\n                mutations,\n                modules,\n            },\n            fields: {\n                abstract: true,\n            } {\n    return {\n        _custom: {\n            type: \"store\",\n            display: \"Store\",\n            value: {\n                state: store.state,\n                getters: getCatchedGetters(store),\n            },\n            fields: {\n                abstract: true,\n            },\n        },\n    };\n}\n// @TODO refactor\nexport function getCatchedGetters(store: Store): any {\n    const getters = {};\n    const origGetters = store.getters || {};\n    const keys = Object.keys(origGetters);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        Object.defineProperty(getters, key, {\n            enumerable: true,\n            get: (): any => {\n                try {\n                    return origGetters[key];\n                }\n                catch (e) {\n                    return e;\n                }\n            },\n        });\n    }\n    return getters;\n}\n}\n// @TODO refactor\nexport function get => {\n                try {\n                    return origGetters[key];\n                }\n                catch (e) {\n                    return e;\n                }\n            },\n        });\n    }\n    return getters;\n}\n","score":221,"fallbacked":false,"num_type_errors":228}]}
{"dataset_elem":{"alphanum_fraction":0.5765567766,"avg_line_length":23.9473684211,"content":"export class ListNode {\n  public val: number;\n  public next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nexport function createLinkedList(nums: number[]): ListNode | null {\n  let head: ListNode | null = null;\n  let curr: ListNode | null = null;\n  for (let num of nums) {\n    if (head === null) {\n      head = new ListNode(num);\n      curr = head;\n    } else if (curr !== null) {\n      curr.next = new ListNode(num);\n      curr = curr.next;\n    }\n  }\n  return head;\n}\n\nexport function createCycleLinkedList(nums: number[], pos: number): ListNode | null {\n  let head: ListNode | null = null;\n  let curr: ListNode | null = null;\n  let cycle: ListNode | null = null;\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n    if (!head) {\n      head = new ListNode(num);\n      curr = head;\n    } else if (curr !== null) {\n      curr.next = new ListNode(num);\n      curr = curr.next;\n    }\n    if (i === pos) {\n      cycle = curr;\n    }\n  }\n  if (curr) {\n    curr.next = cycle;\n  }\n  return head;\n}\n\nexport function parseLinkedList(head: ListNode | null): number[] {\n  let result: number[] = [];\n  let curr: ListNode | null = head;\n  while (curr !== null) {\n    result.push(curr.val);\n    curr = curr.next;\n  }\n  return result;\n}\n","content_without_annotations":"export class ListNode {\n  public val;\n  public next;\n  constructor(val?, next?) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n  }\n}\n\nexport function createLinkedList(nums) {\n  let head = null;\n  let curr = null;\n  for (let num of nums) {\n    if (head === null) {\n      head = new ListNode(num);\n      curr = head;\n    } else if (curr !== null) {\n      curr.next = new ListNode(num);\n      curr = curr.next;\n    }\n  }\n  return head;\n}\n\nexport function createCycleLinkedList(nums, pos) {\n  let head = null;\n  let curr = null;\n  let cycle = null;\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n    if (!head) {\n      head = new ListNode(num);\n      curr = head;\n    } else if (curr !== null) {\n      curr.next = new ListNode(num);\n      curr = curr.next;\n    }\n    if (i === pos) {\n      cycle = curr;\n    }\n  }\n  if (curr) {\n    curr.next = cycle;\n  }\n  return head;\n}\n\nexport function parseLinkedList(head) {\n  let result = [];\n  let curr = head;\n  while (curr !== null) {\n    result.push(curr.val);\n    curr = curr.next;\n  }\n  return result;\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":395,"ext":"ts","fun_ann_density":0.0253164557,"function_parameters":6,"function_signatures":0,"function_usages":0,"functions":4,"hexsha":"6950b0c6d8ed7c8e7929ed15895c89d2b1d81e39","lang":"TypeScript","loc":53,"loc_per_function":10.25,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"13cb7aac323dd68c670b1548a8d72667eb68bd7c","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"eteplus/leetcode","max_forks_repo_path":"typescript/src/libs/linked_list.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"13cb7aac323dd68c670b1548a8d72667eb68bd7c","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"eteplus/leetcode","max_issues_repo_path":"typescript/src/libs/linked_list.ts","max_line_length":85,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"13cb7aac323dd68c670b1548a8d72667eb68bd7c","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"eteplus/leetcode","max_stars_repo_path":"typescript/src/libs/linked_list.ts","max_stars_repo_stars_event_max_datetime":"2022-01-25T09:03:59.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-25T09:03:59.000Z","metric":0.3074047761,"predefined_density":0.3333333333,"predefined_types":7,"prop_ann_density":0.0050632911,"property_declarations":2,"size":1365,"trivial_density":0.0,"trivial_types":0,"type_definitions":1,"typedef_density":0.0025316456,"var_ann_density":0.0227848101,"variable_declarations":9},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export class ListNode {\n    public val: number;\n    public next: ListNode | null;\n    constructor(val?: number, next?: ListNode) {\n        this.val = val === undefined ? 0 : val;\n        this.next = next === undefined ? null : next;\n    }\n}\nexport function createLinkedList(nums: number[]): ListNode {\n    let head = null;\n    let curr = null;\n    for (let num of nums) {\n        if (head === null) {\n            head = new ListNode(num);\n            curr = head;\n        }\n        else if (curr !== null) {\n            curr.next = new ListNode(num);\n            curr = curr.next;\n        }\n    }\n    return head;\n}\nexport function createCycleLinkedList(nums: number[]): ListNode {\n    let head = null;\n    let curr = null;\n    for (let i = 0; i < nums.length; i++) {\n        if (head === null) {\n            head = new ListNode(num, pos: i);\n            curr = head;\n        }\n        else if (curr!== null) {\n            curr.next = new ListNode(num, pos: i);\n            curr = curr.next;\n        }\n    }\n    return head;\n}): ListNode {\n    let head = null;\n    let curr = null;\n    let cycle = null;\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        if (!head) {\n            head = new ListNode(num);\n            curr = head;\n        }\n        else if (curr !== null) {\n            curr.next = new ListNode(num);\n            curr = curr.next;\n        }\n        if (i === pos) {\n            cycle = curr;\n        }\n    }\n    if (curr) {\n        curr.next = cycle;\n    }\n    return head;\n}\nexport function parseLinkedList(head: ListNode) {\n    if (head === null) {\n        return [];\n    }\n    const result = [];\n    let curr = head;\n    while (curr!== null) {\n        result.push(curr.val);\n        curr = curr.nex): {\n            curr = curr.next;\n        }\n    }\n    return result;\n}\nexport function toArray(head: ListNode) {\n    let result = [];\n    let curr = head;\n    while (curr !== null) {\n        result.push(curr.val);\n        curr = curr.next;\n    }\n    return result;\n}\n","score":269,"fallbacked":false,"num_type_errors":17},{"code":"export class ListNode {\n    public val: number;\n    public next?: ListNode;\n    constructor(val?: number, next?: ListNode) {\n        this.val = val === undefined? 0 : val;\n        this.next = next === undefined? null : next;\n    };\n    public next: ListNode;\n}\nexport class LinkedListNode {\n    public val: number;\n    public next?: LinkedListNode;\n    constructor(val?: number, next?: LinkedListNode) {\n        this.val = val === undefined? 0 : val;\n    constructor(val?: number) {\n        this.val = val === undefined? 0 : val;\n    }\n}\nexport class ListNode {\n    public val: number;\n    public next?: ListNode;\n    constructor(val?: number, next?: ListNode) {\n        this.val = val === undefined ? 0 : val;\n        this.next = next === undefined ? null : next;\n    }\n}\nexport function createLinkedList(nums: number[]): ListNode {\n    let head = null;\n    let curr = null;\n    for (let num of nums) {\n        if (head === null) {\n            head = new ListNode(num);\n            curr = head;\n        }\n        else if (curr !== null) {\n            curr.next = new ListNode(num);\n            curr = curr.next;\n        }\n    }\n    return head;\n}\nexport function createCycleLinkedList(nums: number[]) {\n    let head = null;\n    let curr = null;\n    for (let num of nums) {\n        if (head === null) {\n            head = new ListNode(num);\n            curr = head;\n        }\n        else i, pos: for (pos in nums) {\n            if (pos === curr.next.val) {\n                break;\n            }\n            else {\n                curr = curr.next;\n            }\n        }\n    }\n    if (!head) {\n        return null): {\n        head: ListNode;\n        next: ListNode;\n    }\n}\nexport function createLinkedList(nums: number[]): ListNode {\n    let head = null;\n    let curr = null;\n    for (let i = 0; {\n    let head = null;\n    let curr = null;\n    let cycle = null;\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        if (!head) {\n            head = new ListNode(num);\n            curr = head;\n        }\n        else if (curr !== null) {\n            curr.next = new ListNode(num);\n            curr = curr.next;\n        }\n        if (i === pos) {\n            cycle = curr;\n        }\n    }\n    if (curr) {\n        curr.next = cycle;\n    }\n    return head;\n}\nexport function parseLinkedList(head: ListNode): ListNode {\n    if (!head) {\n        return head;\n    }\n    let curr = head;\n    while (curr!== null) {\n        curr = curr.next;\n    }\n    return curr;\n}\nexport function parseListNod): ListNode {\n    let head: ListNode | null = null;\n    let curr = head;\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        if (!head) {\n    let result = [];\n    let curr = head;\n    while (curr !== null) {\n        result.push(curr.val);\n        curr = curr.next;\n    }\n    return result;\n}\n","score":227,"fallbacked":false,"num_type_errors":45},{"code":"export class ListNode {\n    public val: number;\n    public next: ListNode;\n    constructor(val: number, next?: ListNode) {\n        this.val = val === undefined? 0 : val;\n        this.next = next === undefined? null : next;\n    }\n}\nexport class ListNode;\n    constructor(val?: number, next?: ListNode) {\n        this.val = val === undefined? 0 : val;\n        this.next = next === undefined? null : next;\n    }\n}\nexport class ListNode {\n    public val: number;\n    public next: ListNod) {\n        this.val = val === undefined ? 0 : val;\n        this.next = next === undefined ? null : next;\n    }\n}\nexport function createLinkedList(nums: number[]): ListNode {\n    let head: ListNode = null;\n    let curr: ListNode = null;\n    for (let num of nums) {\n        if (head === null) {\n            head = new ListNode(num);\n            curr = hea): {\n                curr = new ListNode(num);\n            }\n        }\n        else if (curr!== null) {\n            curr.next = new ListNode(num);\n            curr = curr.next;\n        }\n    }\n    return head;\n} {\n    let head = null;\n    let curr = null;\n    for (let num of nums) {\n        if (head === null) {\n            head = new ListNode(num);\n            curr = head;\n        }\n        else if (curr !== null) {\n            curr.next = new ListNode(num);\n            curr = curr.next;\n        }\n    }\n    return head;\n}\nexport function createCycleLinkedList(nums: number[]): ListNode {\n    let head: ListNode = null;\n    let curr: ListNode = null;\n    for (let num of nums) {\n        if (head === null) {\n            head = new ListNode(num);\n            curr = hea, pos: number = 0;\n        }\n        else if (curr!== null) {\n            curr.next = new ListNode(num);\n            curr = curr.next;\n            pos++;\n        }\n    }\n    return head;\n}\nexport function i): ListNode {\n    let head = null;\n    let curr = null;\n    let cycle = null;\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        if (!head) {\n            head = new ListNode(num);\n            curr = head;\n        }\n        else if (curr !== null) {\n            curr.next = new ListNode(num);\n            curr = curr.next;\n        }\n        if (i === pos) {\n            cycle = curr;\n        }\n    }\n    if (curr) {\n        curr.next = cycle;\n    }\n    return head;\n}\nexport function parseLinkedList(head: ListNode | null, next: ListNode | null): ListNode | null {\n    if (!head ||!head.next) {\n        return head;\n    }\n    head.val = head.next.val;\n    head.next = head.nex): ListNode | null {\n        return head.next;\n    }\n}\nexport function reverseList(head: ListNode | null): ListNode | null {\n    if (!head ||!head.next) {\n        return head;\n    }\n    const nex {\n    let result = [];\n    let curr = head;\n    while (curr !== null) {\n        result.push(curr.val);\n        curr = curr.next;\n    }\n    return result;\n}\n","score":161,"fallbacked":false,"num_type_errors":59}]}
{"dataset_elem":{"alphanum_fraction":0.6069057105,"avg_line_length":21.8260869565,"content":"export interface Stats\n{\n    weaponDamage: number\n\n    vitality: number\n\n    strength: number\n    dexterity: number\n    intelligence: number\n    mind: number\n\n    critical: number\n    determination: number\n    direct: number\n    skillspeed: number\n    spellspeed: number\n    tenacity: number\n}\n\nexport type StatGroup =\n    | 'weaponDamage'\n    | 'vitality'\n    | 'mainStat'\n    | 'subStat'\n\nexport const statMap: Record<keyof Stats, StatGroup> = {\n    weaponDamage: 'weaponDamage',\n    vitality: 'vitality',\n    strength: 'mainStat',\n    dexterity: 'mainStat',\n    intelligence: 'mainStat',\n    mind: 'mainStat',\n    critical: 'subStat',\n    determination: 'subStat',\n    direct: 'subStat',\n    skillspeed: 'subStat',\n    spellspeed: 'subStat',\n    tenacity: 'subStat',\n}\n\n/**\n * Helper function to initialize a stats object with default values\n * @param someStats optionally specify some stats fields\n */\nexport function makeStats(someStats?: Partial<Stats> | Array<Partial<Stats>>): Stats {\n    const stats: Stats = {\n        weaponDamage: 0,\n        vitality: 390,\n        strength: 448,\n        dexterity: 448,\n        intelligence: 448,\n        mind: 448,\n        critical: 400,\n        determination: 390,\n        direct: 400,\n        skillspeed: 400,\n        spellspeed: 400,\n        tenacity: 400,\n    }\n\n    if (Array.isArray(someStats)) {\n        return someStats.reduce<Stats>(\n            (total, s) => total = { ...total, ...s }, stats\n        )\n    }\n\n    return { ...stats, ...someStats }\n}\n","content_without_annotations":"export interface Stats\n{\n    weaponDamage\n\n    vitality\n\n    strength\n    dexterity\n    intelligence\n    mind\n\n    critical\n    determination\n    direct\n    skillspeed\n    spellspeed\n    tenacity\n}\n\nexport type StatGroup =\n    | 'weaponDamage'\n    | 'vitality'\n    | 'mainStat'\n    | 'subStat'\n\nexport const statMap = {\n    weaponDamage: 'weaponDamage',\n    vitality: 'vitality',\n    strength: 'mainStat',\n    dexterity: 'mainStat',\n    intelligence: 'mainStat',\n    mind: 'mainStat',\n    critical: 'subStat',\n    determination: 'subStat',\n    direct: 'subStat',\n    skillspeed: 'subStat',\n    spellspeed: 'subStat',\n    tenacity: 'subStat',\n}\n\n/**\n * Helper function to initialize a stats object with default values\n * @param someStats optionally specify some stats fields\n */\nexport function makeStats(someStats?) {\n    const stats = {\n        weaponDamage: 0,\n        vitality: 390,\n        strength: 448,\n        dexterity: 448,\n        intelligence: 448,\n        mind: 448,\n        critical: 400,\n        determination: 390,\n        direct: 400,\n        skillspeed: 400,\n        spellspeed: 400,\n        tenacity: 400,\n    }\n\n    if (Array.isArray(someStats)) {\n        return someStats.reduce<Stats>(\n            (total, s) => total = { ...total, ...s }, stats\n        )\n    }\n\n    return { ...stats, ...someStats }\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":430,"ext":"ts","fun_ann_density":0.011627907,"function_parameters":3,"function_signatures":0,"function_usages":0,"functions":2,"hexsha":"19bb848d35047dfc5869aa1160fd54a9b17f89cd","lang":"TypeScript","loc":56,"loc_per_function":10.5,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"b183f4ec85be527430664ce807551a031e9272b4","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"hintxiv/reassemble","max_forks_repo_path":"src/simulator/gear/stats.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"b183f4ec85be527430664ce807551a031e9272b4","max_issues_repo_issues_event_max_datetime":"2022-02-05T21:22:46.000Z","max_issues_repo_issues_event_min_datetime":"2022-02-05T21:22:46.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"hintxiv/reassemble","max_issues_repo_path":"src/simulator/gear/stats.ts","max_line_length":86,"max_stars_count":null,"max_stars_repo_head_hexsha":"b183f4ec85be527430664ce807551a031e9272b4","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"hintxiv/reassemble","max_stars_repo_path":"src/simulator/gear/stats.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2191380553,"predefined_density":0.6315789474,"predefined_types":12,"prop_ann_density":0.0279069767,"property_declarations":12,"size":1506,"trivial_density":0.0,"trivial_types":0,"type_definitions":2,"typedef_density":0.0046511628,"var_ann_density":0.0046511628,"variable_declarations":2},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export interface Stats {\n    weaponDamage: number;\n    mainStat: number;\n    subStat: number;\n    vitality: number;\n    strength: number;\n    dexterity: number;\n    mind: number;\n    critical: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsGroup {;\n    intelligence: number;\n    strength: number;\n    dexterity: number;\n    intelligence;\n    strength;\n    dexterity;\n    vitality: number;\n    mainStat: number;\n    subStat: number;\n    mind: number;\n    critical: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsGroupWithWeapon {\n    weaponDamage;\n    critical: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsGroupWithWeaponAndMainStat {\n    weaponDamage: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsGroupWithWeaponAndSubStat {\n    weaponDamage: number;\n    mainStat: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsGroupWithWeaponAndVitality {\n    weaponDamage: number;\n    vitality: number;\n    mainSta;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsGroupWithWeaponAndDetermination {\n    weaponDamage: number;\n    determination: number;\n    mainStat: number;\n    subStat: numbe;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsGroupWithWeaponAndStrength {\n    weaponDamage: number;\n    strength: number;\n    mainStat: number;\n    subStat: number;\n    dexterity: number;\n    tenacity: number;\n}\nexport interface StatsGroupWithWeaponAndDexterity {\n    weaponDamage: number;\n    dexterity: number;\n    strength: number;\n    dexterity: number;\n    intelligence: number;\n    strengt;\n}\nexport type StatGroup = \"weaponDamage\" | \"vitality\" | \"mainStat\" | \"subStat\";\nexport const statMap = {\n    weaponDamage: \"weaponDamage\",\n    vitality: \"vitality\",\n    strength: \"mainStat\",\n    dexterity: \"mainStat\",\n    intelligence: \"mainStat\",\n    mind: \"mainStat\",\n    critical: \"subStat\",\n    determination: \"subStat\",\n    direct: \"subStat\",\n    skillspeed: \"subStat\",\n    spellspeed: \"subStat\",\n    tenacity: \"subStat\",\n};\n/**\n * Helper function to initialize a stats object with default values\n * @param someStats optionally specify some stats fields\n */\nexport function makeStats(someStats?: StatGroupWithWeaponAndDetermination | StatsGroupWithWeaponAndWeaponDamage | StatsGroupWithWeaponAndVitality | StatsGroupWithWeaponAndStrength | StatsGroupWithWeaponAndDexterity | StatsGroupWithWeaponAndSubStat): StatsGroupWithWeaponAndDetermination | StatsGroupWithWeaponAndWeaponDamage | StatsGroupWithWeaponAndVitality | StatsGroupWithWeaponAndStrength | StatsGroupWithWeaponAndDexterity | StatsGroupWithWeaponAndSubStat {\n    const stats = {\n        weaponDamage: 0,\n        vitality: 390,\n        strength: 448,\n        dexterity: 448,\n        intelligence: 448,\n        mind: 448,\n        critical: 400,\n        determination: 390,\n        direct: 400,\n        skillspeed: 400,\n        spellspeed: 400,\n        tenacity: 400,\n    };\n    if (Array.isArray(someStats)) {\n        return someStats.reduce<Stats>((total: Stats, s: StatGroupWithWeaponAndDetermination | StatGroupWithWeaponAndWeaponDamage | StatGroupWithWeaponAndVitality | StatGroupWithWeaponAndStrength | StatGroupWithWeaponAndDexterity | StatGroupWithWeapo, s: number) => {\n            if (s.weaponDamage) {\n                total[tatMap.weaponDamage] = s.weaponDamage;\n            }\n            if (s.vitality) {\n                total[tatMap.vitality): number = s.vitality;\n            }\n            if (s.strength) {\n                total[tatMap.strength]: number = s.strength;\n            }\n            if (s.dexterity) {\n                total[tatMap => total = { ...total, ...s }, stats);\n    }\n    return { ...stats, ...someStats };\n}\n","score":85,"fallbacked":false,"num_type_errors":44},{"code":"export interface Stats {\n    weaponDamage: number;\n    mainStat: number;\n    subStat: number;\n    vitality: number;\n    strength: number;\n    dexterity: number;\n    intelligence: number;\n    mind: number;\n    critical: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    te;\n    dexterity: number;\n    tenacity: number;\n    intelligence: number;\n    mind: number;\n    critical: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsWithGroup extends Stats {\n    statGrou;\n    critical: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsWithoutGroup extends Stats {\n    weaponDamage: number;;\n    determination: number;\n    direct: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsWithoutGroupAndTenacity extends StatsWithoutGroup {\n    tenacity: 0;\n}\nexport interface StatsWithou;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsWithouAndTenacity extends StatsWithou {\n    tenacity: 0;\n}\nexport interface StatsWithouAndTenacityAndCritica;\n    spellspeed: number;\n    tenacity: number;\n    critical: number;\n}\nexport interface StatsWithouAndTenacityAndCriticaAndDetermination;\n    critical: number;\n    determination: number;\n}\nexport interface StatsWitho;\n    tenacity: number;\n    determination: number;\n    direct: number;\n}\nexport interface StatsWithouAndTenacityAndCriticaAndDeterminationAndDirect {\n    critical: number;\n    determination: number;\n    direct: number;;\n}\nexport type StatGroup = \"weaponDamage\" | \"vitality\" | \"mainStat\" | \"subStat\";\nexport const statMap = {\n    weaponDamage: \"weaponDamage\",\n    vitality: \"vitality\",\n    strength: \"mainStat\",\n    dexterity: \"mainStat\",\n    intelligence: \"mainStat\",\n    mind: \"mainStat\",\n    critical: \"subStat\",\n    determination: \"subStat\",\n    direct: \"subStat\",\n    skillspeed: \"subStat\",\n    spellspeed: \"subStat\",\n    tenacity: \"subStat\",\n};\n/**\n * Helper function to initialize a stats object with default values\n * @param someStats optionally specify some stats fields\n */\nexport function makeStats(someStats?: Stats): Stats {\n    if (someStats === undefined) {\n        return {};\n    }\n    return {\n      ...someStats,\n    };\n}\nexport function mergeStatsWithDefaults(someStats?: StatsWithoutGroup | StatsWithou | StatsWitho {\n    const stats = {\n        weaponDamage: 0,\n        vitality: 390,\n        strength: 448,\n        dexterity: 448,\n        intelligence: 448,\n        mind: 448,\n        critical: 400,\n        determination: 390,\n        direct: 400,\n        skillspeed: 400,\n        spellspeed: 400,\n        tenacity: 400,\n    };\n    if (Array.isArray(someStats)) {\n        return someStats.reduce<Stats>((total: StatsWithouAndTenacityAndCriticaAndDeterminationAndDirect, s) => total = {...total,...s }, stats);\n    }\n    if (typeof someStats === \"object\") {\n        return Object.entries(someStat, s: (value: any, key: string): StatsWithouAndTenacityAndCriticaAndDeterminationAndDirect => ({...total, [key]: value }));\n    }\n    if (typeof someStats === \"number\") {\n        return stats;\n    }\n    if (typeof someStats == => total = { ...total, ...s }, stats);\n    }\n    return { ...stats, ...someStats };\n}\n","score":78,"fallbacked":false,"num_type_errors":62},{"code":"export interface Stats {\n    weaponDamage: number;\n    mainStat: number;\n    subStat: number;\n}\nexport interface StatsGroup {\n    weaponDamage: Stats;\n    vitality: Stats;\n    mainStat: Stats;\n    subStat: Stats;\n    vitality: Stats;\n}\nexport interface StatGroupProps {\n    weaponDamage: Stats;\n    vitality: Stats;\n    mainStat: Stats;\n    subStat: Stats;\n    strength: number;\n    dexterity: number;\n    intelligence: number;\n    mind: number;\n    critical: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    te;\n    dexterity: number;\n}\nexport interface StatProps {\n    weaponDamage: number;\n    vitality: number;\n    strength: number;\n    dexterity: number;\n    intelligence: number;\n    mind: number;\n    critical: numbe;\n    intelligence: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatsWithVitalityProps extends StatsGroup {\n    vitalit;\n    mind: number;\n    determination: number;\n}\nexport interface StatsWithDeterminationProps extends StatsGroup {\n    determination: number;\n}\nexport interface StatsWithDirectProps extends StatsGroup {\n    direct: number;\n}\nexpor;\n    critical: number;\n    determination: number;\n    direct: number;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n    intelligence: number;\n    dexterity: number;\n    mind: number;;\n    determination: number;\n    mainStat: number;\n    subStat: number;\n    vitality: number;\n    vitalit: number;\n}\nexport interface StatGroupWithDeterminationProps extends StatsGroup {\n    determination: number;;\n    direct: number;\n}\nexport interface StatGroupWithDirectProps extends StatsGroup {\n    direct: number;\n}\nexport interface StatGroupWithSubStatProps extends StatsGroup {\n    subStat: number;\n}\nexport interface StatGroupWit;\n    skillspeed: number;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatGroupWithSubStatProps extends StatsGroup {\n    subStat: number;\n}\nexport interface StatGroupWithIntelligenceProps extends StatsGroup;\n    spellspeed: number;\n    tenacity: number;\n}\nexport interface StatGroupWithIntelligenceProps extends StatsGroup {\n    intelligence: number;\n}\nexport interface StatGroupWithStrengthProps extends StatsGroup;\n    direct: number;;\n    tenacity: number;\nexport interface StatGroupWithStrengthProps extends StatsGroup {\n    strength: number;\n}\nexport interface StatGroupWithDirectProps extends StatsGroup {\n    direct: number;\n}\nexport interface StatGroupWithVitalityProp;\n}\nexport type StatGroup = \"weaponDamage\" | \"vitality\" | \"mainStat\" | \"subStat\";\nexport const statMap = {\n    weaponDamage: \"weaponDamage\",\n    vitality: \"vitality\",\n    strength: \"mainStat\",\n    dexterity: \"mainStat\",\n    intelligence: \"mainStat\",\n    mind: \"mainStat\",\n    critical: \"subStat\",\n    determination: \"subStat\",\n    direct: \"subStat\",\n    skillspeed: \"subStat\",\n    spellspeed: \"subStat\",\n    tenacity: \"subStat\",\n};\n/**\n * Helper function to initialize a stats object with default values\n * @param someStats optionally specify some stats fields\n */\nexport function makeStats(someStats?: StatGroupWithSubStatProps | StatGroupWithSubStatProps | StatGroupWithIntelligenceProps | StatGroupWithIntelligenceProps | StatGroupWithStrengthProps | StatGroupWithStrengthProps | StatGroupWithDirectProps | StatGroupWith): StatsGroupWithSubStatProps | StatGroupWithSubStatProps | StatGroupWithIntelligenceProps | StatGroupWithIntelligenceProps | StatGroupWithStrengthProps | StatGroupWithStrengthProps | StatGroupWithDirectProps | StatGroupWith {\n    const stats = {\n        weaponDamage: 0,\n        vitality: 390,\n        strength: 448,\n        dexterity: 448,\n        intelligence: 448,\n        mind: 448,\n        critical: 400,\n        determination: 390,\n        direct: 400,\n        skillspeed: 400,\n        spellspeed: 400,\n        tenacity: 400,\n    };\n    if (Array.isArray(someStats)) {\n        return someStats.reduce<Stats>((total: Stats, s) => total = {...total,...s }, stats);\n    }\n    if (someStats) {\n        return someStats.reduce<Stats>((total: Stats, s: StatGroupWithSubStatProps | StatGroupWithIntelligenceProps | StatGroupWithStrengthProps | StatGroupWithDirectProps) => total = {...total,...s }, stats);\n    }\n    return stats;\n}\n/**\n * Helper functio): Returns a new StatsGroupWithSubStatProps object with the provided stats and the provided subStats\n * @param stats stats object to add\n * @param someStats subStats to add\n */\nexport function makeStatsGroup(stats: Stat => total = { ...total, ...s }, stats);\n    }\n    return { ...stats, ...someStats };\n}\n","score":91,"fallbacked":false,"num_type_errors":68}]}
{"dataset_elem":{"alphanum_fraction":0.3846652268,"avg_line_length":21.4351851852,"content":"export const xml = hljs => {\n  const regex = hljs.regex\n  const TAG_NAME_RE = regex.concat(\n    /[A-Z_]/,\n    regex.optional(/[A-Z0-9_.-]*:/),\n    /[A-Z0-9_.-]*/\n  )\n  const XML_IDENT_RE: RegExp = /[A-Za-z0-9._:-]+/\n  const XML_ENTITIES: {\n    className: string;\n    begin: RegExp;\n  } = {\n    className: 'symbol',\n    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n  }\n  const XML_META_KEYWORDS: {\n    begin: RegExp;\n    contains: {\n      className: string;\n      begin: RegExp;\n      illegal: RegExp;\n    }[];\n  } = {\n    begin: /\\s/,\n    contains: [\n      {\n        className: 'keyword',\n        begin: /#?[a-z_][a-z1-9_-]+/,\n        illegal: /\\n/\n      }\n    ]\n  }\n  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n    begin: /\\(/,\n    end: /\\)/\n  })\n  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n    className: 'string'\n  })\n  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n    className: 'string'\n  })\n  const TAG_INTERNALS = {\n    endsWithParent: true,\n    illegal: /</,\n    relevance: 0,\n    contains: [\n      {\n        className: 'attr',\n        begin: XML_IDENT_RE,\n        relevance: 0\n      },\n      {\n        begin: /=\\s*/,\n        relevance: 0,\n        contains: [\n          {\n            className: 'string',\n            endsParent: true,\n            variants: [\n              {\n                begin: /\"/,\n                end: /\"/,\n                contains: [XML_ENTITIES]\n              },\n              {\n                begin: /'/,\n                end: /'/,\n                contains: [XML_ENTITIES]\n              },\n              { begin: /[^\\s\"'=<>`]+/ }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n  return {\n    name: 'HTML, XML',\n    aliases: [\n      'html',\n      'xhtml',\n      'rss',\n      'atom',\n      'xjb',\n      'xsd',\n      'xsl',\n      'plist',\n      'wsf',\n      'svg'\n    ],\n    case_insensitive: true,\n    contains: [\n      {\n        className: 'meta',\n        begin: /<![a-z]/,\n        end: />/,\n        relevance: 10,\n        contains: [\n          XML_META_KEYWORDS,\n          QUOTE_META_STRING_MODE,\n          APOS_META_STRING_MODE,\n          XML_META_PAR_KEYWORDS,\n          {\n            begin: /\\[/,\n            end: /\\]/,\n            contains: [\n              {\n                className: 'meta',\n                begin: /<![a-z]/,\n                end: />/,\n                contains: [\n                  XML_META_KEYWORDS,\n                  XML_META_PAR_KEYWORDS,\n                  QUOTE_META_STRING_MODE,\n                  APOS_META_STRING_MODE\n                ]\n              }\n            ]\n          }\n        ]\n      },\n      hljs.COMMENT(/<!--/, /-->/, { relevance: 10 }),\n      {\n        begin: /<!\\[CDATA\\[/,\n        end: /\\]\\]>/,\n        relevance: 10\n      },\n      XML_ENTITIES,\n      {\n        className: 'meta',\n        end: /\\?>/,\n        variants: [\n          {\n            begin: /<\\?xml/,\n            relevance: 10,\n            contains: [QUOTE_META_STRING_MODE]\n          },\n          {\n            begin: /<\\?[a-z][a-z0-9]+/\n          }\n        ]\n      },\n      {\n        className: 'tag',\n        begin: /<style(?=\\s|>)/,\n        end: />/,\n        keywords: { name: 'style' },\n        contains: [TAG_INTERNALS],\n        starts: {\n          end: /<\\/style>/,\n          returnEnd: true,\n          subLanguage: ['css', 'xml']\n        }\n      },\n      {\n        className: 'tag',\n        begin: /<script(?=\\s|>)/,\n        end: />/,\n        keywords: { name: 'script' },\n        contains: [TAG_INTERNALS],\n        starts: {\n          end: /<\\/script>/,\n          returnEnd: true,\n          subLanguage: ['javascript', 'handlebars', 'xml']\n        }\n      },\n      {\n        className: 'tag',\n        begin: /<>|<\\/>/\n      },\n      // open tag\n      {\n        className: 'tag',\n        begin: regex.concat(\n          /</,\n          regex.lookahead(\n            regex.concat(\n              TAG_NAME_RE,\n              regex.either(/\\/>/, />/, /\\s/)\n            )\n          )\n        ),\n        end: /\\/?>/,\n        contains: [\n          {\n            className: 'name',\n            begin: TAG_NAME_RE,\n            relevance: 0,\n            starts: TAG_INTERNALS\n          }\n        ]\n      },\n      {\n        className: 'tag',\n        begin: regex.concat(\n          /<\\//,\n          regex.lookahead(regex.concat(TAG_NAME_RE, />/))\n        ),\n        contains: [\n          {\n            className: 'name',\n            begin: TAG_NAME_RE,\n            relevance: 0\n          },\n          {\n            begin: />/,\n            relevance: 0,\n            endsParent: true\n          }\n        ]\n      }\n    ]\n  }\n}\n","content_without_annotations":"export const xml = hljs => {\n  const regex = hljs.regex\n  const TAG_NAME_RE = regex.concat(\n    /[A-Z_]/,\n    regex.optional(/[A-Z0-9_.-]*:/),\n    /[A-Z0-9_.-]*/\n  )\n  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/\n  const XML_ENTITIES = {\n    className: 'symbol',\n    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n  }\n  const XML_META_KEYWORDS = {\n    begin: /\\s/,\n    contains: [\n      {\n        className: 'keyword',\n        begin: /#?[a-z_][a-z1-9_-]+/,\n        illegal: /\\n/\n      }\n    ]\n  }\n  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n    begin: /\\(/,\n    end: /\\)/\n  })\n  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n    className: 'string'\n  })\n  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n    className: 'string'\n  })\n  const TAG_INTERNALS = {\n    endsWithParent: true,\n    illegal: /</,\n    relevance: 0,\n    contains: [\n      {\n        className: 'attr',\n        begin: XML_IDENT_RE,\n        relevance: 0\n      },\n      {\n        begin: /=\\s*/,\n        relevance: 0,\n        contains: [\n          {\n            className: 'string',\n            endsParent: true,\n            variants: [\n              {\n                begin: /\"/,\n                end: /\"/,\n                contains: [XML_ENTITIES]\n              },\n              {\n                begin: /'/,\n                end: /'/,\n                contains: [XML_ENTITIES]\n              },\n              { begin: /[^\\s\"'=<>`]+/ }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n  return {\n    name: 'HTML, XML',\n    aliases: [\n      'html',\n      'xhtml',\n      'rss',\n      'atom',\n      'xjb',\n      'xsd',\n      'xsl',\n      'plist',\n      'wsf',\n      'svg'\n    ],\n    case_insensitive: true,\n    contains: [\n      {\n        className: 'meta',\n        begin: /<![a-z]/,\n        end: />/,\n        relevance: 10,\n        contains: [\n          XML_META_KEYWORDS,\n          QUOTE_META_STRING_MODE,\n          APOS_META_STRING_MODE,\n          XML_META_PAR_KEYWORDS,\n          {\n            begin: /\\[/,\n            end: /\\]/,\n            contains: [\n              {\n                className: 'meta',\n                begin: /<![a-z]/,\n                end: />/,\n                contains: [\n                  XML_META_KEYWORDS,\n                  XML_META_PAR_KEYWORDS,\n                  QUOTE_META_STRING_MODE,\n                  APOS_META_STRING_MODE\n                ]\n              }\n            ]\n          }\n        ]\n      },\n      hljs.COMMENT(/<!--/, /-->/, { relevance: 10 }),\n      {\n        begin: /<!\\[CDATA\\[/,\n        end: /\\]\\]>/,\n        relevance: 10\n      },\n      XML_ENTITIES,\n      {\n        className: 'meta',\n        end: /\\?>/,\n        variants: [\n          {\n            begin: /<\\?xml/,\n            relevance: 10,\n            contains: [QUOTE_META_STRING_MODE]\n          },\n          {\n            begin: /<\\?[a-z][a-z0-9]+/\n          }\n        ]\n      },\n      {\n        className: 'tag',\n        begin: /<style(?=\\s|>)/,\n        end: />/,\n        keywords: { name: 'style' },\n        contains: [TAG_INTERNALS],\n        starts: {\n          end: /<\\/style>/,\n          returnEnd: true,\n          subLanguage: ['css', 'xml']\n        }\n      },\n      {\n        className: 'tag',\n        begin: /<script(?=\\s|>)/,\n        end: />/,\n        keywords: { name: 'script' },\n        contains: [TAG_INTERNALS],\n        starts: {\n          end: /<\\/script>/,\n          returnEnd: true,\n          subLanguage: ['javascript', 'handlebars', 'xml']\n        }\n      },\n      {\n        className: 'tag',\n        begin: /<>|<\\/>/\n      },\n      // open tag\n      {\n        className: 'tag',\n        begin: regex.concat(\n          /</,\n          regex.lookahead(\n            regex.concat(\n              TAG_NAME_RE,\n              regex.either(/\\/>/, />/, /\\s/)\n            )\n          )\n        ),\n        end: /\\/?>/,\n        contains: [\n          {\n            className: 'name',\n            begin: TAG_NAME_RE,\n            relevance: 0,\n            starts: TAG_INTERNALS\n          }\n        ]\n      },\n      {\n        className: 'tag',\n        begin: regex.concat(\n          /<\\//,\n          regex.lookahead(regex.concat(TAG_NAME_RE, />/))\n        ),\n        contains: [\n          {\n            className: 'name',\n            begin: TAG_NAME_RE,\n            relevance: 0\n          },\n          {\n            begin: />/,\n            relevance: 0,\n            endsParent: true\n          }\n        ]\n      }\n    ]\n  }\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":1267,"ext":"ts","fun_ann_density":0.001578532,"function_parameters":1,"function_signatures":0,"function_usages":0,"functions":1,"hexsha":"c5d1ba02e6d0b3653f7aed3e4b704bd6fd0c3c18","lang":"TypeScript","loc":214,"loc_per_function":212.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"d17443a5ada2d3a825f7529cbb54a8d396783364","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"Tyh2001/bright-code","max_forks_repo_path":"src/bright-code/code/xml.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"d17443a5ada2d3a825f7529cbb54a8d396783364","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"Tyh2001/bright-code","max_issues_repo_path":"src/bright-code/code/xml.ts","max_line_length":71,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"d17443a5ada2d3a825f7529cbb54a8d396783364","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"Tyh2001/bright-code","max_stars_repo_path":"src/bright-code/code/xml.ts","max_stars_repo_stars_event_max_datetime":"2022-03-27T14:36:32.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-27T14:36:32.000Z","metric":0.2002460894,"predefined_density":0.1666666667,"predefined_types":2,"prop_ann_density":0.0,"property_declarations":0,"size":4630,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0078926598,"variable_declarations":10},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export const xml = (hljs: any) => {\n    const XML_SYMBOL = {\n        className: \"symbol\",\n        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/,): {\n            relevance: 0,\n            begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n        },\n        relevance: 0\n    }; => {\n    const regex = hljs.regex;\n    const TAG_NAME_RE = regex.concat(/[A-Z_]/, regex.optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);\n    const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;\n    const XML_ENTITIES = {\n        className: \"symbol\",\n        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n    };\n    const XML_META_KEYWORDS = {\n        begin: /\\s/,\n        contains: [\n            {\n                className: \"keyword\",\n                begin: /#?[a-z_][a-z1-9_-]+/,\n                illegal: /\\n/\n            }\n        ]\n    };\n    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n        begin: /\\(/,\n        end: /\\)/\n    });\n    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n        className: \"string\"\n    });\n    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n        className: \"string\"\n    });\n    const TAG_INTERNALS = {\n        endsWithParent: true,\n        illegal: /</,\n        relevance: 0,\n        contains: [\n            {\n                className: \"attr\",\n                begin: XML_IDENT_RE,\n                relevance: 0\n            },\n            {\n                begin: /=\\s*/,\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"string\",\n                        endsParent: true,\n                        variants: [\n                            {\n                                begin: /\"/,\n                                end: /\"/,\n                                contains: [XML_ENTITIES]\n                            },\n                            {\n                                begin: /'/,\n                                end: /'/,\n                                contains: [XML_ENTITIES]\n                            },\n                            { begin: /[^\\s\"'=<>`]+/ }\n                        ]\n                    }\n                ]\n            }\n        ]\n    };\n    return {\n        name: \"HTML, XML\",\n        aliases: [\n            \"html\",\n            \"xhtml\",\n            \"rss\",\n            \"atom\",\n            \"xjb\",\n            \"xsd\",\n            \"xsl\",\n            \"plist\",\n            \"wsf\",\n            \"svg\"\n        ],\n        case_insensitive: true,\n        contains: [\n            {\n                className: \"meta\",\n                begin: /<![a-z]/,\n                end: />/,\n                relevance: 10,\n                contains: [\n                    XML_META_KEYWORDS,\n                    QUOTE_META_STRING_MODE,\n                    APOS_META_STRING_MODE,\n                    XML_META_PAR_KEYWORDS,\n                    {\n                        begin: /\\[/,\n                        end: /\\]/,\n                        contains: [\n                            {\n                                className: \"meta\",\n                                begin: /<![a-z]/,\n                                end: />/,\n                                contains: [\n                                    XML_META_KEYWORDS,\n                                    XML_META_PAR_KEYWORDS,\n                                    QUOTE_META_STRING_MODE,\n                                    APOS_META_STRING_MODE\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            },\n            hljs.COMMENT(/<!--/, /-->/, { relevance: 10 }),\n            {\n                begin: /<!\\[CDATA\\[/,\n                end: /\\]\\]>/,\n                relevance: 10\n            },\n            XML_ENTITIES,\n            {\n                className: \"meta\",\n                end: /\\?>/,\n                variants: [\n                    {\n                        begin: /<\\?xml/,\n                        relevance: 10,\n                        contains: [QUOTE_META_STRING_MODE]\n                    },\n                    {\n                        begin: /<\\?[a-z][a-z0-9]+/\n                    }\n                ]\n            },\n            {\n                className: \"tag\",\n                begin: /<style(?=\\s|>)/,\n                end: />/,\n                keywords: { name: \"style\" },\n                contains: [TAG_INTERNALS],\n                starts: {\n                    end: /<\\/style>/,\n                    returnEnd: true,\n                    subLanguage: [\"css\", \"xml\"]\n                }\n            },\n            {\n                className: \"tag\",\n                begin: /<script(?=\\s|>)/,\n                end: />/,\n                keywords: { name: \"script\" },\n                contains: [TAG_INTERNALS],\n                starts: {\n                    end: /<\\/script>/,\n                    returnEnd: true,\n                    subLanguage: [\"javascript\", \"handlebars\", \"xml\"]\n                }\n            },\n            {\n                className: \"tag\",\n                begin: /<>|<\\/>/\n            },\n            // open tag\n            {\n                className: \"tag\",\n                begin: regex.concat(/</, regex.lookahead(regex.concat(TAG_NAME_RE, regex.either(/\\/>/, />/, /\\s/)))),\n                end: /\\/?>/,\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0,\n                        starts: TAG_INTERNALS\n                    }\n                ]\n            },\n            {\n                className: \"tag\",\n                begin: regex.concat(/<\\//, regex.lookahead(regex.concat(TAG_NAME_RE, />/))),\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0\n                    },\n                    {\n                        begin: />/,\n                        relevance: 0,\n                        endsParent: true\n                    }\n                ]\n            }\n        ]\n    };\n};\n","score":464,"fallbacked":false,"num_type_errors":17},{"code":"export const xml = (hljs: HLJS, options: ESCAPING_OPTIONS): Syntax => {\n    const { SUBST_CONTENT } = options;\n    const SUBST_RE = regex.concat(hljs.SUBST_END_RE, SUBST): Syntax;\n    return {\n        name: \"XML\",\n        keywords: {\n            keyword: \"namespace\",\n            keyword: \"element\",\n            keyword: \"attribute\",\n            keyword: \"text\",\n            keyword: \"processing-instruction\",\n            keyword => {\n    const regex = hljs.regex;\n    const TAG_NAME_RE = regex.concat(/[A-Z_]/, regex.optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);\n    const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;\n    const XML_ENTITIES = {\n        className: \"symbol\",\n        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n    };\n    const XML_META_KEYWORDS = {\n        begin: /\\s/,\n        contains: [\n            {\n                className: \"keyword\",\n                begin: /#?[a-z_][a-z1-9_-]+/,\n                illegal: /\\n/\n            }\n        ]\n    };\n    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n        begin: /\\(/,\n        end: /\\)/\n    });\n    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n        className: \"string\"\n    });\n    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n        className: \"string\"\n    });\n    const TAG_INTERNALS = {\n        endsWithParent: true,\n        illegal: /</,\n        relevance: 0,\n        contains: [\n            {\n                className: \"attr\",\n                begin: XML_IDENT_RE,\n                relevance: 0\n            },\n            {\n                begin: /=\\s*/,\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"string\",\n                        endsParent: true,\n                        variants: [\n                            {\n                                begin: /\"/,\n                                end: /\"/,\n                                contains: [XML_ENTITIES]\n                            },\n                            {\n                                begin: /'/,\n                                end: /'/,\n                                contains: [XML_ENTITIES]\n                            },\n                            { begin: /[^\\s\"'=<>`]+/ }\n                        ]\n                    }\n                ]\n            }\n        ]\n    };\n    return {\n        name: \"HTML, XML\",\n        aliases: [\n            \"html\",\n            \"xhtml\",\n            \"rss\",\n            \"atom\",\n            \"xjb\",\n            \"xsd\",\n            \"xsl\",\n            \"plist\",\n            \"wsf\",\n            \"svg\"\n        ],\n        case_insensitive: true,\n        contains: [\n            {\n                className: \"meta\",\n                begin: /<![a-z]/,\n                end: />/,\n                relevance: 10,\n                contains: [\n                    XML_META_KEYWORDS,\n                    QUOTE_META_STRING_MODE,\n                    APOS_META_STRING_MODE,\n                    XML_META_PAR_KEYWORDS,\n                    {\n                        begin: /\\[/,\n                        end: /\\]/,\n                        contains: [\n                            {\n                                className: \"meta\",\n                                begin: /<![a-z]/,\n                                end: />/,\n                                contains: [\n                                    XML_META_KEYWORDS,\n                                    XML_META_PAR_KEYWORDS,\n                                    QUOTE_META_STRING_MODE,\n                                    APOS_META_STRING_MODE\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            },\n            hljs.COMMENT(/<!--/, /-->/, { relevance: 10 }),\n            {\n                begin: /<!\\[CDATA\\[/,\n                end: /\\]\\]>/,\n                relevance: 10\n            },\n            XML_ENTITIES,\n            {\n                className: \"meta\",\n                end: /\\?>/,\n                variants: [\n                    {\n                        begin: /<\\?xml/,\n                        relevance: 10,\n                        contains: [QUOTE_META_STRING_MODE]\n                    },\n                    {\n                        begin: /<\\?[a-z][a-z0-9]+/\n                    }\n                ]\n            },\n            {\n                className: \"tag\",\n                begin: /<style(?=\\s|>)/,\n                end: />/,\n                keywords: { name: \"style\" },\n                contains: [TAG_INTERNALS],\n                starts: {\n                    end: /<\\/style>/,\n                    returnEnd: true,\n                    subLanguage: [\"css\", \"xml\"]\n                }\n            },\n            {\n                className: \"tag\",\n                begin: /<script(?=\\s|>)/,\n                end: />/,\n                keywords: { name: \"script\" },\n                contains: [TAG_INTERNALS],\n                starts: {\n                    end: /<\\/script>/,\n                    returnEnd: true,\n                    subLanguage: [\"javascript\", \"handlebars\", \"xml\"]\n                }\n            },\n            {\n                className: \"tag\",\n                begin: /<>|<\\/>/\n            },\n            // open tag\n            {\n                className: \"tag\",\n                begin: regex.concat(/</, regex.lookahead(regex.concat(TAG_NAME_RE, regex.either(/\\/>/, />/, /\\s/)))),\n                end: /\\/?>/,\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0,\n                        starts: TAG_INTERNALS\n                    }\n                ]\n            },\n            {\n                className: \"tag\",\n                begin: regex.concat(/<\\//, regex.lookahead(regex.concat(TAG_NAME_RE, />/))),\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0\n                    },\n                    {\n                        begin: />/,\n                        relevance: 0,\n                        endsParent: true\n                    }\n                ]\n            }\n        ]\n    };\n};\n","score":400,"fallbacked":false,"num_type_errors":19},{"code":"export const xml = (hljs: import(\"highlight.js\").Highlight.Language) => ({\n    keywords: {\n        keyword: \"case default class const continue debugger debugger-exit do else enum extends false finally for function import implements import-meta interface is let long namespace module namespace modul): return module extends package implements module-namespace module-alias module-main module-path module-root module-package module-description module-description-path module-description-main module-description-alias module-description-alias-path module => {\n    const regex = hljs.regex;\n    const TAG_NAME_RE = regex.concat(/[A-Z_]/, regex.optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);\n    const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;\n    const XML_ENTITIES = {\n        className: \"symbol\",\n        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n    };\n    const XML_META_KEYWORDS = {\n        begin: /\\s/,\n        contains: [\n            {\n                className: \"keyword\",\n                begin: /#?[a-z_][a-z1-9_-]+/,\n                illegal: /\\n/\n            }\n        ]\n    };\n    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n        begin: /\\(/,\n        end: /\\)/\n    });\n    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n        className: \"string\"\n    });\n    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n        className: \"string\"\n    });\n    const TAG_INTERNALS = {\n        endsWithParent: true,\n        illegal: /</,\n        relevance: 0,\n        contains: [\n            {\n                className: \"attr\",\n                begin: XML_IDENT_RE,\n                relevance: 0\n            },\n            {\n                begin: /=\\s*/,\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"string\",\n                        endsParent: true,\n                        variants: [\n                            {\n                                begin: /\"/,\n                                end: /\"/,\n                                contains: [XML_ENTITIES]\n                            },\n                            {\n                                begin: /'/,\n                                end: /'/,\n                                contains: [XML_ENTITIES]\n                            },\n                            { begin: /[^\\s\"'=<>`]+/ }\n                        ]\n                    }\n                ]\n            }\n        ]\n    };\n    return {\n        name: \"HTML, XML\",\n        aliases: [\n            \"html\",\n            \"xhtml\",\n            \"rss\",\n            \"atom\",\n            \"xjb\",\n            \"xsd\",\n            \"xsl\",\n            \"plist\",\n            \"wsf\",\n            \"svg\"\n        ],\n        case_insensitive: true,\n        contains: [\n            {\n                className: \"meta\",\n                begin: /<![a-z]/,\n                end: />/,\n                relevance: 10,\n                contains: [\n                    XML_META_KEYWORDS,\n                    QUOTE_META_STRING_MODE,\n                    APOS_META_STRING_MODE,\n                    XML_META_PAR_KEYWORDS,\n                    {\n                        begin: /\\[/,\n                        end: /\\]/,\n                        contains: [\n                            {\n                                className: \"meta\",\n                                begin: /<![a-z]/,\n                                end: />/,\n                                contains: [\n                                    XML_META_KEYWORDS,\n                                    XML_META_PAR_KEYWORDS,\n                                    QUOTE_META_STRING_MODE,\n                                    APOS_META_STRING_MODE\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            },\n            hljs.COMMENT(/<!--/, /-->/, { relevance: 10 }),\n            {\n                begin: /<!\\[CDATA\\[/,\n                end: /\\]\\]>/,\n                relevance: 10\n            },\n            XML_ENTITIES,\n            {\n                className: \"meta\",\n                end: /\\?>/,\n                variants: [\n                    {\n                        begin: /<\\?xml/,\n                        relevance: 10,\n                        contains: [QUOTE_META_STRING_MODE]\n                    },\n                    {\n                        begin: /<\\?[a-z][a-z0-9]+/\n                    }\n                ]\n            },\n            {\n                className: \"tag\",\n                begin: /<style(?=\\s|>)/,\n                end: />/,\n                keywords: { name: \"style\" },\n                contains: [TAG_INTERNALS],\n                starts: {\n                    end: /<\\/style>/,\n                    returnEnd: true,\n                    subLanguage: [\"css\", \"xml\"]\n                }\n            },\n            {\n                className: \"tag\",\n                begin: /<script(?=\\s|>)/,\n                end: />/,\n                keywords: { name: \"script\" },\n                contains: [TAG_INTERNALS],\n                starts: {\n                    end: /<\\/script>/,\n                    returnEnd: true,\n                    subLanguage: [\"javascript\", \"handlebars\", \"xml\"]\n                }\n            },\n            {\n                className: \"tag\",\n                begin: /<>|<\\/>/\n            },\n            // open tag\n            {\n                className: \"tag\",\n                begin: regex.concat(/</, regex.lookahead(regex.concat(TAG_NAME_RE, regex.either(/\\/>/, />/, /\\s/)))),\n                end: /\\/?>/,\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0,\n                        starts: TAG_INTERNALS\n                    }\n                ]\n            },\n            {\n                className: \"tag\",\n                begin: regex.concat(/<\\//, regex.lookahead(regex.concat(TAG_NAME_RE, />/))),\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0\n                    },\n                    {\n                        begin: />/,\n                        relevance: 0,\n                        endsParent: true\n                    }\n                ]\n            }\n        ]\n    };\n};\n","score":250,"fallbacked":false,"num_type_errors":72}]}
{"dataset_elem":{"alphanum_fraction":0.6077057793,"avg_line_length":26.765625,"content":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n// Convert form data into interface submission data format\nexport const valuesToData = (values, inlongGroupId) => {\n  const array = values.map(item => {\n    const {\n      inlongStreamId,\n      predefinedFields = [],\n      rowTypeFields = [],\n      dataSourceType,\n      dataSourcesConfig = [],\n      streamSink = [],\n      ...rest\n    } = item;\n    const output = {} as any;\n    if (dataSourceType !== 'AUTO_PUSH') {\n      output.sourceInfo = dataSourcesConfig.map(k => {\n        return {\n          ...k,\n          sourceType: dataSourceType,\n          inlongGroupId,\n          inlongStreamId,\n        };\n      });\n    } else {\n      output.sourceInfo = [\n        {\n          sourceType: dataSourceType,\n          sourceName: inlongStreamId,\n          inlongGroupId,\n          inlongStreamId,\n        },\n      ];\n    }\n\n    output.sinkInfo = streamSink.reduce((acc, type) => {\n      if (!type) return acc;\n\n      const data = rest[`streamSink${type}`] || [];\n      delete rest[`streamSink${type}`];\n      const formatData = data.map(ds => ({\n        ...ds,\n        inlongGroupId,\n        inlongStreamId,\n        sinkType: type,\n      }));\n\n      return acc.concat(formatData);\n    }, []);\n\n    const fieldList = predefinedFields.concat(rowTypeFields).map((item, idx) => ({\n      ...item,\n      inlongGroupId,\n      inlongStreamId,\n      isPredefinedField: idx < predefinedFields.length ? 1 : 0,\n    }));\n\n    output.streamInfo = {\n      ...rest,\n      inlongGroupId,\n      inlongStreamId,\n      dataSourceType,\n    };\n\n    if (fieldList?.length) output.streamInfo.fieldList = fieldList;\n\n    return output;\n  });\n\n  return array;\n};\n\n// Convert interface data to form data\nexport const dataToValues = data => {\n  const array = data.map(item => {\n    const { sourceInfo, sinkInfo, streamInfo } = item;\n    let output = {\n      dataSourceType: sourceInfo[0]?.sourceType || 'AUTO_PUSH',\n      dataSourcesConfig: sourceInfo,\n    } as any;\n\n    sinkInfo.forEach(({ sinkType, ...item }) => {\n      if (!output[`streamSink${sinkType}`]) output[`streamSink${sinkType}`] = [];\n      output[`streamSink${sinkType}`].push(item);\n    });\n    output.streamSink = sinkInfo.map(item => item.sinkType);\n\n    const fieldList = streamInfo.fieldList?.reduce(\n      (acc, cur) => {\n        cur.isPredefinedField ? acc.predefinedFields.push(cur) : acc.rowTypeFields.push(cur);\n        return acc;\n      },\n      {\n        predefinedFields: [],\n        rowTypeFields: [],\n      },\n    );\n\n    output = {\n      hasHigher: false,\n      ...output,\n      ...fieldList,\n      ...streamInfo,\n    };\n\n    return output;\n  });\n\n  return array;\n};\n","content_without_annotations":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n// Convert form data into interface submission data format\nexport const valuesToData = (values, inlongGroupId) => {\n  const array = values.map(item => {\n    const {\n      inlongStreamId,\n      predefinedFields = [],\n      rowTypeFields = [],\n      dataSourceType,\n      dataSourcesConfig = [],\n      streamSink = [],\n      ...rest\n    } = item;\n    const output = {} as any;\n    if (dataSourceType !== 'AUTO_PUSH') {\n      output.sourceInfo = dataSourcesConfig.map(k => {\n        return {\n          ...k,\n          sourceType: dataSourceType,\n          inlongGroupId,\n          inlongStreamId,\n        };\n      });\n    } else {\n      output.sourceInfo = [\n        {\n          sourceType: dataSourceType,\n          sourceName: inlongStreamId,\n          inlongGroupId,\n          inlongStreamId,\n        },\n      ];\n    }\n\n    output.sinkInfo = streamSink.reduce((acc, type) => {\n      if (!type) return acc;\n\n      const data = rest[`streamSink${type}`] || [];\n      delete rest[`streamSink${type}`];\n      const formatData = data.map(ds => ({\n        ...ds,\n        inlongGroupId,\n        inlongStreamId,\n        sinkType: type,\n      }));\n\n      return acc.concat(formatData);\n    }, []);\n\n    const fieldList = predefinedFields.concat(rowTypeFields).map((item, idx) => ({\n      ...item,\n      inlongGroupId,\n      inlongStreamId,\n      isPredefinedField: idx < predefinedFields.length ? 1 : 0,\n    }));\n\n    output.streamInfo = {\n      ...rest,\n      inlongGroupId,\n      inlongStreamId,\n      dataSourceType,\n    };\n\n    if (fieldList?.length) output.streamInfo.fieldList = fieldList;\n\n    return output;\n  });\n\n  return array;\n};\n\n// Convert interface data to form data\nexport const dataToValues = data => {\n  const array = data.map(item => {\n    const { sourceInfo, sinkInfo, streamInfo } = item;\n    let output = {\n      dataSourceType: sourceInfo[0]?.sourceType || 'AUTO_PUSH',\n      dataSourcesConfig: sourceInfo,\n    } as any;\n\n    sinkInfo.forEach(({ sinkType, ...item }) => {\n      if (!output[`streamSink${sinkType}`]) output[`streamSink${sinkType}`] = [];\n      output[`streamSink${sinkType}`].push(item);\n    });\n    output.streamSink = sinkInfo.map(item => item.sinkType);\n\n    const fieldList = streamInfo.fieldList?.reduce(\n      (acc, cur) => {\n        cur.isPredefinedField ? acc.predefinedFields.push(cur) : acc.rowTypeFields.push(cur);\n        return acc;\n      },\n      {\n        predefinedFields: [],\n        rowTypeFields: [],\n      },\n    );\n\n    output = {\n      hasHigher: false,\n      ...output,\n      ...fieldList,\n      ...streamInfo,\n    };\n\n    return output;\n  });\n\n  return array;\n};\n","dynamism_density":0.0023529412,"dynamism_heuristic":2,"estimated_tokens":850,"ext":"ts","fun_ann_density":0.0305882353,"function_parameters":15,"function_signatures":0,"function_usages":0,"functions":11,"hexsha":"dac7a34c23c6505fd564304a224f764b68dd8397","lang":"TypeScript","loc":92,"loc_per_function":18.4545454545,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"b482895e1130fc6b9826ca665e35998c2be61f6b","max_forks_repo_licenses":["Apache-2.0"],"max_forks_repo_name":"xuesongxs/incubator-inlong","max_forks_repo_path":"inlong-dashboard/src/pages/AccessCreate/DataStream/helper.ts","max_issues_count":11.0,"max_issues_repo_head_hexsha":"b482895e1130fc6b9826ca665e35998c2be61f6b","max_issues_repo_issues_event_max_datetime":"2022-03-16T12:52:15.000Z","max_issues_repo_issues_event_min_datetime":"2022-02-09T09:13:18.000Z","max_issues_repo_licenses":["Apache-2.0"],"max_issues_repo_name":"xuesongxs/incubator-inlong","max_issues_repo_path":"inlong-dashboard/src/pages/AccessCreate/DataStream/helper.ts","max_line_length":93,"max_stars_count":3.0,"max_stars_repo_head_hexsha":"b482895e1130fc6b9826ca665e35998c2be61f6b","max_stars_repo_licenses":["Apache-2.0"],"max_stars_repo_name":"xuesongxs/incubator-inlong","max_stars_repo_path":"inlong-dashboard/src/pages/AccessCreate/DataStream/helper.ts","max_stars_repo_stars_event_max_datetime":"2022-02-10T04:52:33.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-24T10:03:02.000Z","metric":0.2866090391,"predefined_density":0.0,"predefined_types":0,"prop_ann_density":0.0,"property_declarations":0,"size":3426,"trivial_density":0.0526315789,"trivial_types":2,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0141176471,"variable_declarations":12},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// Convert form data into interface submission data format\nexport const valuesToData = (values: any) => {\n    const array = values.map((item) => {\n        const { inlongStreamId, predefinedFields = [], rowTypeFields = [], dataSourceType, dataSourcesConfig = [], streamSink = [],...rest } = ite, inlongGroupId: string | undefined = undefined;\n        if (!inlongStreamId) {\n            const predefinedFieldNames: string[] = predefinedFields.map((k) => {\n                return k.fieldName;\n            });\n            const rowTypeFieldNames: string[] = ro): string[] = rowTypeFields.map((k) => {\n                return k.fieldName;\n            });\n            const dataSourcesConfigObj: InlongStreamSinkConfig = dataSourcesConfig.find((c) => {\n                return c.sinkTyp => {\n    const array = values.map((item: any) => {\n                        const { inlongStreamId, predefinedFields = [], rowTypeFields = [], dataSourceType, dataSourcesConfig = [], streamSink = [],...rest } = ite;\n                        if (!inlongStreamId) {): string[] = predefinedFields.map((k) => {\n                            return k.fieldName;\n                        });\n                        const rowTypeFieldNames: string[] = rowTypeFields.map((k) => {\n                            return k.fieldName;\n                        });\n                        const dat => {\n        const { inlongStreamId, predefinedFields = [], rowTypeFields = [], dataSourceType, dataSourcesConfig = [], streamSink = [], ...rest } = item;\n        const output = {} as any;\n        if (dataSourceType !== \"AUTO_PUSH\") {\n            output.sourceInfo = dataSourcesConfig.map((k: InlongStreamSinkConfig) => {\n                return {\n                    sourceName: k.inlongStreamId,\n                    sourceConfig: {\n                      ...k.predefinedConfig,\n                        sourceFields: predefinedFieldNames,\n                    },\n                };\n            });): InlongStreamSinkConfig | undefined;\n        } else if (dataSourcesConfig.length > 0) {\n            output.sourceInfo = dataSourcesConfig.map((k: InlongStreamSinkConfig) => {\n                const { inlon => {\n                return {\n                    ...k,\n                    sourceType: dataSourceType,\n                    inlongGroupId,\n                    inlongStreamId,\n                };\n            });\n        }\n        else {\n            output.sourceInfo = [\n                {\n                    sourceType: dataSourceType,\n                    sourceName: inlongStreamId,\n                    inlongGroupId,\n                    inlongStreamId,\n                },\n            ];\n        }\n        output.sinkInfo = streamSink.reduce((acc: { sinkName: string, sinkType: string }, item: InlongStreamSinkConfig) => {\n            if (!item.sinkType || item.sinkType === \"INLONG\") {\n                if (item.sinkName) {\n                    cons, type: \"INLONG_STREAM\"\n                }\n            } else {\n                type: \"INLONG_TABLE\"\n            }\n            return {\n                sinkName: item.sinkName,\n                sinkType: type,\n            };\n        }, []);\n        output.sin): InlongStreamSinkConfig | undefined;\n        return output;\n    };\n\n    private getPredefinedFields(config: InlongStreamSinkConfig): InlongStreamSinkConfig | undefined {\n        const { predefinedConfig } = config;\n        if (pr => {\n            if (!type)\n                return acc;\n            const data = rest[`streamSink${type}`] || [];\n            delete rest[`streamSink${type}`];\n            const formatData = data.map((ds: InlongStreamSinkConfig) => {\n                if (!ds.predefinedConfig ||!ds.predefinedConfig.rowType) {\n                    return undefined;\n                }\n                const fieldList = ds.predefinedConfig.rowType.split(\"): \");\n                const field = fieldList[0];\n                if (field) {\n                    const { rowType } = ds;\n                    return {\n                        name: field,\n                        type: rowType.split(\":\")[1],\n                        format: {\n                            isDateTim => ({\n                ...ds,\n                inlongGroupId,\n                inlongStreamId,\n                sinkType: type,\n            }));\n            return acc.concat(formatData);\n        }, []);\n        const fieldList = predefinedFields.concat(rowTypeFields).map((item: string) => item.split(\":\")[0]);\n        const fieldMap = {};\n        fieldList.forEach((field: string) => {\n            fieldMap[field] = 1;\n        });\n        if (fieldList.some(field =>, idx: number) && fieldMap[fieldList[0]] === 1) {\n            predefinedConfig.rowType = predefinedFields.map((item: string) => item.split(\":\")[1]).join(\"): \");\n            const formatData: Inlon): InlongStreamSinkConfig = {\n              ...predefinedConfig,\n            };\n            formatData.forEach(item => {\n                const field = item.name.split(\":\")[0];\n                if (field) {\n                    formatData[idx] = => ({\n            ...item,\n            inlongGroupId,\n            inlongStreamId,\n            isPredefinedField: idx < predefinedFields.length ? 1 : 0,\n        }));\n        output.streamInfo = {\n            ...rest,\n            inlongGroupId,\n            inlongStreamId,\n            dataSourceType,\n        };\n        if (fieldList?.length)\n            output.streamInfo.fieldList = fieldList;\n        return output;\n    });\n    return array;\n};\n// Convert interface data to form data\nexport const dataToValues = (data: any) => {\n    const array: any = [];\n    const predefinedFields: any = [];\n    const rowTypeFields: any = [];\n    const {\n        inlongGroupId,\n        inlongStreamId,\n        dataSourceType,\n        predefinedConfig): InlongStreamSinkConfig = {\n            inlongGroupId,\n            inlongStreamId,\n            dataSourceType,\n        };\n    Object.keys(data).forEach((key: string) => {\n        if (key.includes(\"sink\")) { => {\n    const array = data.map((item: any) => {\n                const { sourceInfo, sinkInfo, streamInfo } = item;\n                if (sinkInfo.length && sinkInfo[0].sinkType === \"INLONG_STREAM_TO_INLONG\") {\n                    predefinedField): any = sinkInfo[0].sinkFields.filter((item: any) => item.name.startsWith(\"inlongGroupId\") && item.name.endsWith(\":inlongStreamId\"));\n                    predefinedFields.push(...predefinedField); => {\n        const { sourceInfo, sinkInfo, streamInfo } = item;\n        let output = {\n            dataSourceType: sourceInfo[0]?.sourceType || \"AUTO_PUSH\",\n            dataSourcesConfig: sourceInfo,\n        } as any;\n        sinkInfo.forEach(({ sinkType, ...item }: { sinkType, sinkFields: [] }) => {\n            if (!output[`sinkSink${sinkType}`])\n                output[`sinkSink${sinkType}`] = [];\n            output[`sinkSink${sinkType}`].push(item);): { output.dataSourceType = \"AUTO_PUSH\" };\n        });\n        predefinedFields.forEach(({ name, type, nameSpace }) => {\n            const predefinedField: any = predefinedFields.filter((item: any) => item.name == => {\n            if (!output[`streamSink${sinkType}`])\n                output[`streamSink${sinkType}`] = [];\n            output[`streamSink${sinkType}`].push(item);\n        });\n        output.streamSink = sinkInfo.map((item: any): { name, type, nameSpace }) as any;\n        predefinedFields.forEach(({ name, type, nameSpace }) => {\n            if (!output.streamSink) {\n                output.streamSink = [];\n            }\n            output.streamSink => item.sinkType);\n        const fieldList = streamInfo.fieldList?.reduce((acc: any, cur: any) => {\n            if (cur.name.startsWith(\"inlongGroupId\") && cur.name.endsWith(\":inlongStreamId\")) {\n                if (output[`streamSink${sinkType}`]) {\n                    cur, cur: any;\n                    cur.isPredefinedField? acc.predefinedFields.push(cur) : acc.rowTypeFields.push(cur);\n                }\n            }\n        return acc;\n        }, { predefinedFields: [], rowTypeFields): any => {\n            cur.isPredefinedField ? acc.predefinedFields.push(cur) : acc.rowTypeFields.push(cur);\n            return acc;\n        }, {\n            predefinedFields: [],\n            rowTypeFields: [],\n        });\n        output = {\n            hasHigher: false,\n            ...output,\n            ...fieldList,\n            ...streamInfo,\n        };\n        return output;\n    });\n    return array;\n};\n","score":406,"fallbacked":false,"num_type_errors":154},{"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// Convert form data into interface submission data format\nexport const valuesToData = (values: Record<string, string>): any => {\n    const result = {};\n    for (const k in values) {\n        const v = values[k];\n        if (typeof v === 'object') {\n            if (Array.isArray(, inlongGroupId: string) && v.length === 2) {\n                result[k] = v[0];\n            }\n        }\n        else {\n            result[k] = v;\n        }\n    }\n    return result;\n};\n\n// Conver): data interface form data to interface submission data format\nexport const dataToValues = (data: any): Record<string, string> => {\n    if (Array.isArray(data)) {\n        return data.reduce((result, item) = => {\n    const array = values.map((item: any) => {\n        return item[item.length - 1];\n    });\n    if (array.includes(item)) {\n        return result;\n    }\n    result[item] = values[item][0];\n    return result;): any;\n}, {});\n    }\n    else {\n        return Object.entries(data).reduce((result, [key, value]) => {\n            if (Array.isArray(value)) {\n                return {\n                  ...result,\n                    [key] => {\n        const { inlongStreamId, predefinedFields = [], rowTypeFields = [], dataSourceType, dataSourcesConfig = [], streamSink = [], ...rest } = item;\n        const output = {} as any;\n        if (dataSourceType !== \"AUTO_PUSH\") {\n            output.sourceInfo = dataSourcesConfig.map((k: any) => {\n                return {\n                    sourceType: k.sourceType,\n                    sourceName: k.sourceName,\n                    inlongGroupId: k.inlongGroupId,\n                    inlongStreamId: k.inlongStreamId,\n                };): any;\n        }\n        if (predefinedFields.length > 0) {\n            output.predefinedFields = predefinedFields.map((k: any) => {\n                return {\n                    name: k.name,\n                    type: k => {\n                return {\n                    ...k,\n                    sourceType: dataSourceType,\n                    inlongGroupId,\n                    inlongStreamId,\n                };\n            });\n        }\n        else {\n            output.sourceInfo = [\n                {\n                    sourceType: dataSourceType,\n                    sourceName: inlongStreamId,\n                    inlongGroupId,\n                    inlongStreamId,\n                },\n            ];\n        }\n        output.sinkInfo = streamSink.reduce((acc: any, sink) => {\n            if (!sink.sinkName)\n                return acc;\n            return {\n              ...acc,\n                [sink.sinkName]: {\n                    sinkName: sink.sinkName,\n                    sinkType: sink.sinkTyp, type: sink.sinkTyp,\n                    sinkType: sink.sinkTyp,\n                    sinkConfig: sink.sinkConfig,\n                },\n            };\n        }, {});\n        return {\n          ...output,\n          ...rest,\n        };\n    }\n\n    /**\n     * 获): 获取 Inlong Stream 信息\n     * @param configInlongId - Inlong Stream ID\n     */\n    async getInlongStream(configInlongId: string): Promise<InlongStreamInfo> {\n        let res = await this.sourc => {\n            if (!type)\n                return acc;\n            const data = rest[`streamSink${type}`] || [];\n            delete rest[`streamSink${type}`];\n            const formatData = data.map((ds: any) => ({\n                inlongGroupId: ds.inlongGroupId,\n                inlongStreamId: ds.inlongStreamId,\n                sinkType: ds.sinkType,\n            }));\n            return acc.concat(formatData);\n        }): Promise<InlongStreamInfo[]>;\n\n        const inlongStreamInfo: InlongStreamInfo[] = res.filter(item => item.inlongGroupId === configInlongId);\n        return inlongStreamInfo[0];\n    } => ({\n                ...ds,\n                inlongGroupId,\n                inlongStreamId,\n                sinkType: type,\n            }));\n            return acc.concat(formatData);\n        }, []);\n        const fieldList = predefinedFields.concat(rowTypeFields).map((item: Field) => item.field);\n\n        const {\n            inlongGroupId,\n            inlongStreamId,\n            dataSourceType,\n        } = ds;\n        const output = array.reduce((acc, item: StreamField) => {\n            if, idx: number;\n            const { idx, field } = item;\n            if (field && fieldList.includes(field)) {\n                if (idx < predefinedFields.length) {\n                    acc[idx] = {\n                        field,\n                        fieldName: predefine): void => {\n                            acc[idx] = field;\n                        },\n                    };\n                } else if (idx < predefinedFields.length + rowTypeFields.length) {\n                    acc[idx] = {\n                        field,\n                        fieldName: predefine => ({\n            ...item,\n            inlongGroupId,\n            inlongStreamId,\n            isPredefinedField: idx < predefinedFields.length ? 1 : 0,\n        }));\n        output.streamInfo = {\n            ...rest,\n            inlongGroupId,\n            inlongStreamId,\n            dataSourceType,\n        };\n        if (fieldList?.length)\n            output.streamInfo.fieldList = fieldList;\n        return output;\n    });\n    return array;\n};\n// Convert interface data to form data\nexport const dataToValues = (data: InterfaceOutput) => {\n    const values = [];\n    const streamFields = streamOutputToFields(data);\n    streamFields.forEach((item) => {\n        const { inlongGroupId, inlongStreamId, fieldName, isPredefinedFiel): void => {\n            if (isPredefinedFiel) {\n                values.push({\n                    [fieldName]: predefinedFields.find((f) => f.field === fieldName)\n                      ?.value,\n                });\n            } else {\n                values => {\n    const array = data.map((item: any) => {\n    if (item.inlongGroupId === inlongGroupId && item.inlongStreamId === inlongStreamId) {\n        const { field, value } = item;\n        const fieldObj = streamFields.find(): FieldInfo;\n        return {\n            field: fieldObj?.field,\n            value,\n        };\n    }\n    return null;\n});\n                const fieldObj = streamFields.find(): FieldInfo;\n                const { field, value } = array => {\n        const { sourceInfo, sinkInfo, streamInfo } = item;\n        let output = {\n            dataSourceType: sourceInfo[0]?.sourceType || \"AUTO_PUSH\",\n            dataSourcesConfig: sourceInfo,\n        } as any;\n        sinkInfo.forEach(({ sinkType, ...item }: Record<string, any>) => {\n            if (!output[sinkType])\n                output[sinkType] = [];\n            output[sinkType].push(item);\n        });\n        output.streamSink = sinkInfo.map((item) =): {\n            sinkType: item.sinkType,\n            sinkName: item.sinkName,\n            sinkUrl: item.sinkUrl,\n            sinkConfig: item.sinkConfig,\n        } => {\n            const { sinkType, sinkName => {\n            if (!output[`streamSink${sinkType}`])\n                output[`streamSink${sinkType}`] = [];\n            output[`streamSink${sinkType}`].push(item);\n        });\n        output.streamSink = sinkInfo.map((item: Record<string, any>) => {\n            const { sinkType, sinkName, sinkUrl, sinkConfig } = item;\n            return {\n                sinkType,\n                sinkName,\n                sinkUrl,\n                sinkConfig,\n            };\n        }): any;\n        const streamType = streamInfo.type;\n        const streamTypeObj = streamTypes.find(item => item.type === streamType);\n        if (!streamTypeObj)\n            return {};\n        const inlongGroupId = streamTyp => item.sinkType);\n        const fieldList = streamInfo.fieldList?.reduce((acc: any, item: FieldInfo) => {\n            if (!acc.rowTypeFields.some(cur => cur.field === item.field))\n                acc.rowTypeFields.push(item);\n            return acc;\n        }, {\n            predefine, cur: {}, predefinedFields: [],\n        });\n        const array = streamTypeObj.sinkInfo.map(item => {\n            const sinkInfo = item.sinkInfo;\n            const output = {\n                inlongGroupId: inlongGroupId(item): {\n                    sinkType: sinkType,\n                    sinkName: sinkName,\n                    sinkUrl: sinkUrl,\n                    sinkConfig: sinkConfig,\n                },\n            };\n            return output;\n        });\n        const array2 = fieldList.predefine? => {\n            cur.isPredefinedField ? acc.predefinedFields.push(cur) : acc.rowTypeFields.push(cur);\n            return acc;\n        }, {\n            predefinedFields: [],\n            rowTypeFields: [],\n        });\n        output = {\n            hasHigher: false,\n            ...output,\n            ...fieldList,\n            ...streamInfo,\n        };\n        return output;\n    });\n    return array;\n};\n","score":454,"fallbacked":false,"num_type_errors":160},{"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// Convert form data into interface submission data format\nexport const valuesToData = (values: any): any => {\n    const array = values.map((item) => {\n        const { inlongGroupId, predefinedFields = [], rowTypeFields = [], dataSourceType, dataSourcesConfig = [], streamSink = [],...rest } = ite, inlongGroupId: string | number | undefined;\n        const output: any = {};\n        if (predefinedFields.length > 0) {\n            output.predefinedFields = predefinedFields.map((k) => {\n                return {\n                    name: k): any => ({\n                        id: k.id,\n                        name: k.name,\n                        type: k.type,\n                        isRequired: k.isRequired,\n                    }),\n                };\n            });\n        }\n        if (rowTypeFields.length > => {\n    const array = values.map((item: any) => {\n                const { inlongGroupId, predefinedFields = [], rowTypeFields = [], dataSourceType, dataSourcesConfig = [], streamSink = [],...rest } = item;\n                const output: any = {};\n                if (predefine): any {\n                    output.predefinedFields = predefinedFields.map((k) => {\n                        return {\n                            name: k.name,\n                            type: k.type,\n                            isRequired: k.isRequired,\n                        };\n                    });\n                }\n                i => {\n        const { inlongStreamId, predefinedFields = [], rowTypeFields = [], dataSourceType, dataSourcesConfig = [], streamSink = [], ...rest } = item;\n        const output = {} as any;\n        if (dataSourceType !== \"AUTO_PUSH\") {\n            output.sourceInfo = dataSourcesConfig.map((k: any) => ({\n                sourceName: k.name,\n                sourceType: k.type,\n                inlongGroupId,\n                inlongStreamId,\n            }));\n        } else if (dataSourceType === \"AUTO_PUSH\") {\n            output.sourc): any {\n                output.sourceInfo = dataSourcesConfig.map((k: any) => ({\n                    sourceName: k.name,\n                    sourceType: k.type,\n                    inlongGroupId,\n                    inlongStreamId,\n                })); => {\n                return {\n                    ...k,\n                    sourceType: dataSourceType,\n                    inlongGroupId,\n                    inlongStreamId,\n                };\n            });\n        }\n        else {\n            output.sourceInfo = [\n                {\n                    sourceType: dataSourceType,\n                    sourceName: inlongStreamId,\n                    inlongGroupId,\n                    inlongStreamId,\n                },\n            ];\n        }\n        output.sinkInfo = streamSink.reduce((acc: any, k) => {\n            return {\n              ...acc,\n                [k.sinkType]: {\n                    sinkName: k.sinkName,\n                    sinkType: k.sinkType,\n                    sinkConfig: k.sinkConfig,\n                    i, type: k.type,\n                },\n            };\n        }, {});\n        output.outputFields = rowTypeFields.concat(dFields).reduce((acc: any, item) => {\n            if (!item.name)\n                return acc;\n            const dat): any {\n                fieldName: string;\n                fieldType: FieldType;\n                fieldFormatType: FieldFormatType;\n            } = item;\n            const dIdx = dFields.findIndex((d) => d.name === dat.fieldName);\n            i => {\n            if (!type)\n                return acc;\n            const data = rest[`streamSink${type}`] || [];\n            delete rest[`streamSink${type}`];\n            const formatData = data.map((ds: any) => ({\n              ...ds,\n                inlongGroupId,\n                inlongStreamId,\n            }));\n            return acc.concat(formatData);\n        }, []);\n        output.outputFields = output.outputFields.filter((f) =>): boolean => {\n            if (!f.fieldType)\n                return false;\n            switch (f.fieldType) {\n            case FieldType.STRING:\n            case FieldType.INT:\n            case FieldType.LONG:\n            case FieldType.FLOAT => ({\n                ...ds,\n                inlongGroupId,\n                inlongStreamId,\n                sinkType: type,\n            }));\n            return acc.concat(formatData);\n        }, []);\n        const fieldList = predefinedFields.concat(rowTypeFields).map((item: any) => item.name);\n        output.fieldList = fieldList;\n        output.outputFields = output.outputFields.map((item: any) => {\n            if (item.isPredefinedField)\n                return item;, idx: number => idx < predefinedFields.length? 1 : 0;\n            return {\n              ...item,\n                inlongGroupId,\n                inlongStreamId,\n                isPredefinedField: fieldList.indexOf(item.name) >=): boolean => {\n                if (!item.fieldType)\n                    return false;\n                switch (item.fieldType) {\n                case FieldType.STRING:\n                case FieldType.INT:\n                case FieldType.LONG:\n                case FieldType.FLOAT = => ({\n            ...item,\n            inlongGroupId,\n            inlongStreamId,\n            isPredefinedField: idx < predefinedFields.length ? 1 : 0,\n        }));\n        output.streamInfo = {\n            ...rest,\n            inlongGroupId,\n            inlongStreamId,\n            dataSourceType,\n        };\n        if (fieldList?.length)\n            output.streamInfo.fieldList = fieldList;\n        return output;\n    });\n    return array;\n};\n// Convert interface data to form data\nexport const dataToValues = (data: Record<string, any>): any => {\n    const output = {};\n    data.outputFields.forEach((item) => {\n        const { name, fieldType, value } = item;\n        if (!output[name] && value && fieldTyp): boolean => {\n            output[name] = value;\n            return {\n              ...item,\n                inlongGroupId,\n                inlongStreamId,\n                isPredefinedField: name === \"rowType\",\n                inlongStreamSource: false, => {\n    const array = data.map((item: Record<string, any>) => {\n                    if (item.name!.indexOf(\"rowType\") >= 0)\n                        return item;\n                    if (item.name! === \"rowType\" && item.fieldType! === FieldType): boolean => {\n                        if (!item.fieldType)\n                            return false;\n                        switch (item.fieldType) {\n                        case FieldType.STRING:\n                        case FieldType.INT:\n                        case FieldType.LONG:\n                        case FieldType.FLOAT => {\n        const { sourceInfo, sinkInfo, streamInfo } = item;\n        let output = {\n            dataSourceType: sourceInfo[0]?.sourceType || \"AUTO_PUSH\",\n            dataSourcesConfig: sourceInfo,\n        } as any;\n        sinkInfo.forEach(({ sinkType, ...item }: any) => {\n            if (sinkType === \"kafka\") {\n                output.sinkType = sinkType;\n                output.kafkaConfig = item;\n            } else if (sinkType === \"file\") {\n                output.sinkType = sin): boolean => {\n                    if (sinkType === \"file\") {\n                        const { type, config, path, pathInfo } = item;\n                        if (!type)\n                            return false;\n                        switch (type) {\n                        case \"hdfs\":\n                        cas => {\n            if (!output[`streamSink${sinkType}`])\n                output[`streamSink${sinkType}`] = [];\n            output[`streamSink${sinkType}`].push(item);\n        });\n        output.streamSink = sinkInfo.map((item: { sinkType, type, config, pathInfo }) => ({\n            sinkType,\n            type,\n            config,\n            path,\n            pathInfo,\n        }));\n                        }\n                        const isHDFS = output.streamSink.some(({ type }) =): boolean =>\n                            type === \"hdfs\";\n                        if (!isHDFS) {\n                            output.pathInfo = pathInfo.map(i => ({\n                                url: i.url,\n                                path: i.path,\n                            }));\n                        }\n                        retur => item.sinkType);\n        const fieldList = streamInfo.fieldList?.reduce((acc: { predefinedFields: any[], rowTypeFields: any[] }, cur) => {\n            if (cur.isPredefinedField) {\n                acc.predefinedFields.push(cur);\n            } else {\n                acc.rowTypeFields, cur: { name: string };\n            }\n            return acc;\n        }, {\n            predefinedFields: [],\n            rowTypeFields: [],\n        });\n        const streamInfo = streamInfo.reduce((acc: { predefinedFields: any[], rowTypeFields: an): any => {\n            if (acc.predefinedFields.some(({ name }) => name === cur.name)) {\n                cur.isPredefinedField = true;\n                cur.config = cur.config || {};\n                cur.config.typ => {\n            cur.isPredefinedField ? acc.predefinedFields.push(cur) : acc.rowTypeFields.push(cur);\n            return acc;\n        }, {\n            predefinedFields: [],\n            rowTypeFields: [],\n        });\n        output = {\n            hasHigher: false,\n            ...output,\n            ...fieldList,\n            ...streamInfo,\n        };\n        return output;\n    });\n    return array;\n};\n","score":472,"fallbacked":false,"num_type_errors":177}]}
{"dataset_elem":{"alphanum_fraction":0.641146078,"avg_line_length":24.1931818182,"content":"const ABSOLUTE_PATH_REGEX = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|/])/;\nconst RELATIVE_PATH_REGEX = /^\\.?\\.\\//;\nconst ALL_BACKSLASHES_REGEX = /\\\\/g;\nconst ANY_SLASH_REGEX = /[/\\\\]/;\nconst EXTNAME_REGEX = /\\.[^.]+$/;\n\nexport function isAbsolute(path: string): boolean {\n\treturn ABSOLUTE_PATH_REGEX.test(path);\n}\n\nexport function isRelative(path: string): boolean {\n\treturn RELATIVE_PATH_REGEX.test(path);\n}\n\nexport function normalize(path: string): string {\n\treturn path.replace(ALL_BACKSLASHES_REGEX, '/');\n}\n\nexport function basename(path: string): string {\n\treturn path.split(ANY_SLASH_REGEX).pop() || '';\n}\n\nexport function dirname(path: string): string {\n\tconst match = /[/\\\\][^/\\\\]*$/.exec(path);\n\tif (!match) return '.';\n\n\tconst dir = path.slice(0, -match[0].length);\n\n\t// If `dir` is the empty string, we're at root.\n\treturn dir ? dir : '/';\n}\n\nexport function extname(path: string): string {\n\tconst match = EXTNAME_REGEX.exec(basename(path)!);\n\treturn match ? match[0] : '';\n}\n\nexport function relative(from: string, to: string): string {\n\tconst fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);\n\tconst toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);\n\n\tif (fromParts[0] === '.') fromParts.shift();\n\tif (toParts[0] === '.') toParts.shift();\n\n\twhile (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\twhile (toParts[0] === '..' && fromParts.length > 0) {\n\t\ttoParts.shift();\n\t\tfromParts.pop();\n\t}\n\n\twhile (fromParts.pop()) {\n\t\ttoParts.unshift('..');\n\t}\n\n\treturn toParts.join('/');\n}\n\nexport function resolve(...paths: string[]): string {\n\tconst firstPathSegment = paths.shift();\n\tif (!firstPathSegment) {\n\t\treturn '/';\n\t}\n\tlet resolvedParts = firstPathSegment.split(ANY_SLASH_REGEX);\n\n\tfor (const path of paths) {\n\t\tif (isAbsolute(path)) {\n\t\t\tresolvedParts = path.split(ANY_SLASH_REGEX);\n\t\t} else {\n\t\t\tconst parts = path.split(ANY_SLASH_REGEX);\n\n\t\t\twhile (parts[0] === '.' || parts[0] === '..') {\n\t\t\t\tconst part = parts.shift();\n\t\t\t\tif (part === '..') {\n\t\t\t\t\tresolvedParts.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolvedParts.push(...parts);\n\t\t}\n\t}\n\n\treturn resolvedParts.join('/');\n}\n","content_without_annotations":"const ABSOLUTE_PATH_REGEX = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|/])/;\nconst RELATIVE_PATH_REGEX = /^\\.?\\.\\//;\nconst ALL_BACKSLASHES_REGEX = /\\\\/g;\nconst ANY_SLASH_REGEX = /[/\\\\]/;\nconst EXTNAME_REGEX = /\\.[^.]+$/;\n\nexport function isAbsolute(path) {\n\treturn ABSOLUTE_PATH_REGEX.test(path);\n}\n\nexport function isRelative(path) {\n\treturn RELATIVE_PATH_REGEX.test(path);\n}\n\nexport function normalize(path) {\n\treturn path.replace(ALL_BACKSLASHES_REGEX, '/');\n}\n\nexport function basename(path) {\n\treturn path.split(ANY_SLASH_REGEX).pop() || '';\n}\n\nexport function dirname(path) {\n\tconst match = /[/\\\\][^/\\\\]*$/.exec(path);\n\tif (!match) return '.';\n\n\tconst dir = path.slice(0, -match[0].length);\n\n\t// If `dir` is the empty string, we're at root.\n\treturn dir ? dir : '/';\n}\n\nexport function extname(path) {\n\tconst match = EXTNAME_REGEX.exec(basename(path)!);\n\treturn match ? match[0] : '';\n}\n\nexport function relative(from, to) {\n\tconst fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);\n\tconst toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);\n\n\tif (fromParts[0] === '.') fromParts.shift();\n\tif (toParts[0] === '.') toParts.shift();\n\n\twhile (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\twhile (toParts[0] === '..' && fromParts.length > 0) {\n\t\ttoParts.shift();\n\t\tfromParts.pop();\n\t}\n\n\twhile (fromParts.pop()) {\n\t\ttoParts.unshift('..');\n\t}\n\n\treturn toParts.join('/');\n}\n\nexport function resolve(...paths) {\n\tconst firstPathSegment = paths.shift();\n\tif (!firstPathSegment) {\n\t\treturn '/';\n\t}\n\tlet resolvedParts = firstPathSegment.split(ANY_SLASH_REGEX);\n\n\tfor (const path of paths) {\n\t\tif (isAbsolute(path)) {\n\t\t\tresolvedParts = path.split(ANY_SLASH_REGEX);\n\t\t} else {\n\t\t\tconst parts = path.split(ANY_SLASH_REGEX);\n\n\t\t\twhile (parts[0] === '.' || parts[0] === '..') {\n\t\t\t\tconst part = parts.shift();\n\t\t\t\tif (part === '..') {\n\t\t\t\t\tresolvedParts.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolvedParts.push(...parts);\n\t\t}\n\t}\n\n\treturn resolvedParts.join('/');\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":722,"ext":"ts","fun_ann_density":0.0235457064,"function_parameters":9,"function_signatures":0,"function_usages":2,"functions":8,"hexsha":"cb4740ebaff249e3fd3fae4fc531be634a8f3b45","lang":"TypeScript","loc":67,"loc_per_function":5.75,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"b8315e03f9790d610a413316fbf6d565f9340cab","max_forks_repo_licenses":["0BSD","MIT"],"max_forks_repo_name":"internet-of-presence/rollup","max_forks_repo_path":"browser/path.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"b8315e03f9790d610a413316fbf6d565f9340cab","max_issues_repo_issues_event_max_datetime":"2022-03-23T10:02:41.000Z","max_issues_repo_issues_event_min_datetime":"2022-03-23T10:02:41.000Z","max_issues_repo_licenses":["0BSD","MIT"],"max_issues_repo_name":"internet-of-presence/rollup","max_issues_repo_path":"browser/path.ts","max_line_length":68,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"b8315e03f9790d610a413316fbf6d565f9340cab","max_stars_repo_licenses":["0BSD","MIT"],"max_stars_repo_name":"internet-of-presence/rollup","max_stars_repo_path":"browser/path.ts","max_stars_repo_stars_event_max_datetime":"2022-03-18T15:21:33.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-18T15:21:33.000Z","metric":0.2882954331,"predefined_density":0.5483870968,"predefined_types":17,"prop_ann_density":0.0,"property_declarations":0,"size":2129,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0193905817,"variable_declarations":14},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"const ABSOLUTE_PATH_REGEX = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|/])/;\nconst RELATIVE_PATH_REGEX = /^\\.?\\.\\//;\nconst ALL_BACKSLASHES_REGEX = /\\\\/g;\nconst ANY_SLASH_REGEX = /[/\\\\]/;\nconst EXTNAME_REGEX = /\\.[^.]+$/;\nexport function isAbsolute(path: string) {\n    return ABSOLUTE_PATH_REGEX.test(path);\n}\nexport function isDirectory(path) {\n    return path.endsWith(\"/\");\n}\nexport function isRooted(path) {\n    return pat): boolean {\n        if (path === \"/\")\n            return true;\n        const parts = path.split(ANY_SLASH_REGEX).filter(Boolean);\n        const root = parts.length > 1? parts.slice(0, -1) {\n    return ABSOLUTE_PATH_REGEX.test(path);\n}\nexport function isRelative(path: string) {\n    if (!path) {\n        return false;\n    }\n    const parts = path.split(ANY_SLASH_REGEX).filter(Boolean);\n    const root = parts.length > 1? parts.slice(0): [];\n    return root.length > 1 || root[0] === \"\";\n}\nexport function normalizeSlashes(path) {\n    return path.replace(ALL_BACKSLASHES_REGEX, \"/\");\n}\nexport function resolve {\n    return RELATIVE_PATH_REGEX.test(path);\n}\nexport function normalize(path: string, to) {\n    const resolvedPath = resolve(path, to);\n    if (!resolvedPath)\n        throw new Error(\"Path \" + path + \" cannot be resolved to \" + to);\n    return normalizeSlashes(resolvedPath)): string;\n}\nexport function resolveObject(path: string, to) {\n    const resolvedPath = resolve(path, to);\n    if (!resolvedPath)\n        throw new Error(\"Path \" + path + \" cannot be resolved to {\n    return path.replace(ALL_BACKSLASHES_REGEX, \"/\");\n}\nexport function basename(path: string) {\n    const match = basenameRegex.exec(path);\n    return match? match[1] : \"\";\n}\nexport function extname(path: string) {\n    const match = EXTNAME_REGEX.exec(basename): string | undefined;\n    return match? match[1] : \"\";\n}\nexport function normalizePath(path: string) {\n    return normalizeSlashes(path).replace(SLASH_REGEX, \"/\");\n}\nexport function join(pat {\n    return path.split(ANY_SLASH_REGEX).pop() || \"\";\n}\nexport function dirname(path: string) {\n    const parts = path.split(ANY_SLASH_REGEX).filter(Boolean);\n    const root = parts.length > 1? parts.slice(0, -1) : [];\n    return root.length >): string;\n}\nexport function relative(from, to) {\n    if (from === to)\n        return \"\";\n    const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);\n    const toParts = to {\n    const match = /[/\\\\][^/\\\\]*$/.exec(path);\n    if (!match)\n        return \".\";\n    const dir = path.slice(0, -match[0].length);\n    // If `dir` is the empty string, we're at root.\n    return dir ? dir : \"/\";\n}\nexport function extname(path: string) {\n    const match = EXTNAME_REGEX.exec(basename(path)!);\n    return match? match[0] : \"\";\n}\nexport function resolve(from, to) {\n    const resolvedFrom = resolveObject): string | undefined;\n    const resolvedTo = resolveObject): string | undefined;\n    if (resolvedFrom && resolvedTo)\n        return resolvedFrom === resolvedTo? resolvedFrom : undefined;\n    // Normalize from\n    if (!resolvedFrom && from & {\n    const match = EXTNAME_REGEX.exec(basename(path)!);\n    return match ? match[0] : \"\";\n}\nexport function relative(from: string, to: string): string | undefined {\n    const resolvedFrom = resolveObject(from);\n    if (!resolvedFrom)\n        return from;\n    // Normalize to\n    if (!resolvedTo)\n        return to;\n    // If `from, to: ./foo`\n    if (resolvedFrom === to)\n        return \"\";\n    // If `from:../foo`\n    if (resolvedFrom.slice(0, resolvedFrom.length - resolvedTo.length) === resolvedTo)\n        return resolve): undefined;\n    // If `from:./foo`\n    if (resolvedFrom === \"./\" + to)\n        return \"\";\n    // If `from:././foo`\n    if (resolvedFrom === \"./\" + \"./\" + to) {\n    const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);\n    const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);\n    if (fromParts[0] === \".\")\n        fromParts.shift();\n    if (toParts[0] === \".\")\n        toParts.shift();\n    while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {\n        fromParts.shift();\n        toParts.shift();\n    }\n    while (toParts[0] === \"..\" && fromParts.length > 0) {\n        toParts.shift();\n        fromParts.pop();\n    }\n    while (fromParts.pop()) {\n        toParts.unshift(\"..\");\n    }\n    return toParts.join(\"/\");\n}\nexport function resolve(...paths: string[]): string {\n    let resolvedPath = \"\";\n    for (const path of paths) {\n        if (path) {\n            resolvedPath += path + \"/\";\n            continue;\n        }\n        if (!resolvedPath)\n            return \"\";\n    }): string {\n    if (!resolvedPath)\n        return \"\";\n    return resolvedPath.slice(0, -1);\n}\nexport function resolveObject(path: string): { root: string | undefined, dir: string | undefined, base {\n    const firstPathSegment = paths.shift();\n    if (!firstPathSegment) {\n        return \"/\";\n    }\n    let resolvedParts = firstPathSegment.split(ANY_SLASH_REGEX);\n    for (const path of paths) {\n        if (isAbsolute(path)) {\n            resolvedParts = path.split(ANY_SLASH_REGEX);\n        }\n        else {\n            const parts = path.split(ANY_SLASH_REGEX);\n            while (parts[0] === \".\" || parts[0] === \"..\") {\n                const part = parts.shift();\n                if (part === \"..\") {\n                    resolvedParts.pop();\n                }\n            }\n            resolvedParts.push(...parts);\n        }\n    }\n    return resolvedParts.join(\"/\");\n}\n","score":386,"fallbacked":false,"num_type_errors":71},{"code":"const ABSOLUTE_PATH_REGEX = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|/])/;\nconst RELATIVE_PATH_REGEX = /^\\.?\\.\\//;\nconst ALL_BACKSLASHES_REGEX = /\\\\/g;\nconst ANY_SLASH_REGEX = /[/\\\\]/;\nconst EXTNAME_REGEX = /\\.[^.]+$/;\nexport function isAbsolute(path: string) {\n    return ABSOLUTE_PATH_REGEX.test(path);\n}\nexport function resolvePath(path: string, base: string | undefined) {\n    if (path === \"\") {\n        return \"/\";\n    }): if (isAbsolute(path)) {\n        return path;\n    }\n    if (base && path.startsWith(base)) {\n        return path;\n    }\n    return resolve(base || \".\", path);\n}\nexport function normalizePath(pat {\n    return ABSOLUTE_PATH_REGEX.test(path);\n}\nexport function isRelative(path: string) {\n    return RELATIVE_PATH_REGEX.test(path);\n}\nexport function ensureTrailingSlash(path: string) {\n    if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {\n        return path;): if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {\n            return path;\n        }\n    }\n    else if (path === \".\") {\n        return path;\n    }\n    return path + \"/\";\n}\nexport function ensureLeadingSlash(pat {\n    return RELATIVE_PATH_REGEX.test(path);\n}\nexport function normalize(path: string, base?: string | undefined) {\n    if (base && path.startsWith(base)) {\n        return path;\n    }\n    if (isAbsolute(path)) {\n        return path;\n    }\n    if (!path) {\n        retur): if (path === \"\") {\n            return \"/\";\n        }\n    }\n    if (path.startsWith(\".\")) {\n        return ensureLeadingSlash(path);\n    }\n    if (path.startsWith(\"/\")) {\n        return ensureLeadingSlash(path); {\n    return path.replace(ALL_BACKSLASHES_REGEX, \"/\");\n}\nexport function basename(path: string) {\n    const match = /[^\\\\/](?=\\.[^.]+$)/.exec(path);\n    if (match) {\n        return match[0];\n    }\n    return \"\";\n}\nexport function normalizeSlashes): string {\n    return path.normalize(path).replace(ALL_SLASHES_REGEX, \"/\");\n}\nexport function resolve(from, to) {\n    let resolvedPath = path.resolve(from, to);\n    if (!isAbsolut {\n    return path.split(ANY_SLASH_REGEX).pop() || \"\";\n}\nexport function dirname(path: string) {\n    const match = /[^\\\\/](?=\\.[^.]+$)/.exec(path);\n    if (!match)\n        return \"/\";\n    const dir = path.slice(0, -match[0].length);): if (path === \".\") {\n        return \"/\";\n    }\n    else {\n        return dir;\n    }\n}\nexport function resolveFrom(from, to) {\n    return path.resolve(from, to);\n}\nexport function join {\n    const match = /[/\\\\][^/\\\\]*$/.exec(path);\n    if (!match)\n        return \".\";\n    const dir = path.slice(0, -match[0].length);\n    // If `dir` is the empty string, we're at root.\n    return dir ? dir : \"/\";\n}\nexport function extname(path: string) {\n    if (!path)\n        return \"\";\n    const match = /\\.[^.]+$/.exec(path);\n    return match? match[0] : \"\";\n}\nexport function extname(path: string) {\n    const matc): string | undefined {\n    const match = /\\.[^.]+$/.exec(path);\n    return match? match[0] : undefined;\n}\nexport function basename(path: string) {\n    return path.split(ANY_SLASH {\n    const match = EXTNAME_REGEX.exec(basename(path)!);\n    return match ? match[0] : \"\";\n}\nexport function relative(from: string, to: string) {\n    return path.relative(from, to);\n}\nexport function relative(from: string, to: string) {\n    const fromParts = from.split(ANY_SLASH_REGEX).filter, to: any;\n    const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);\n    if (fromParts[0] === \".\")\n        fromParts.shift();\n    if (toParts[0] === \".\")\n        toPart): if (toParts.length === 1) {\n        toParts.unshift(\"\");\n    }\n    const result: string[] = [\"\"];\n    for (let part of fromParts) {\n        if (part === \".\")\n            continue;\n        els {\n    const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);\n    const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);\n    if (fromParts[0] === \".\")\n        fromParts.shift();\n    if (toParts[0] === \".\")\n        toParts.shift();\n    while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {\n        fromParts.shift();\n        toParts.shift();\n    }\n    while (toParts[0] === \"..\" && fromParts.length > 0) {\n        toParts.shift();\n        fromParts.pop();\n    }\n    while (fromParts.pop()) {\n        toParts.unshift(\"..\");\n    }\n    return toParts.join(\"/\");\n}\nexport function resolve(...paths: string[]): string {\n    const pathsArray = paths.map(path => path.replace(/\\\\/g, \"/\"));\n    if (isAbsolutePath(paths[0])) {\n        return pathsArray[0];\n    }\n    const normalizedPaths): string[] = [];\n    const root = normalizeSlashes(process.cwd());\n    let current = root;\n    for (let i = 0; i < pathsArray.length; i++) {\n        const path = pathsArray[i] {\n    const firstPathSegment = paths.shift();\n    if (!firstPathSegment) {\n        return \"/\";\n    }\n    let resolvedParts = firstPathSegment.split(ANY_SLASH_REGEX);\n    for (const path of paths) {\n        if (isAbsolute(path)) {\n            resolvedParts = path.split(ANY_SLASH_REGEX);\n        }\n        else {\n            const parts = path.split(ANY_SLASH_REGEX);\n            while (parts[0] === \".\" || parts[0] === \"..\") {\n                const part = parts.shift();\n                if (part === \"..\") {\n                    resolvedParts.pop();\n                }\n            }\n            resolvedParts.push(...parts);\n        }\n    }\n    return resolvedParts.join(\"/\");\n}\n","score":369,"fallbacked":false,"num_type_errors":74},{"code":"const ABSOLUTE_PATH_REGEX = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|/])/;\nconst RELATIVE_PATH_REGEX = /^\\.?\\.\\//;\nconst ALL_BACKSLASHES_REGEX = /\\\\/g;\nconst ANY_SLASH_REGEX = /[/\\\\]/;\nconst EXTNAME_REGEX = /\\.[^.]+$/;\nexport function isAbsolute(path: string) {\n    return ABSOLUTE_PATH_REGEX.test(path);\n}\nexport function isAbsolutePath(path: string) {\n    return isAbsolute(path) || isRelative(path);\n}\nexport function i): string {\n    return path.charCodeAt(0) === 47 /* \"/\" */;\n}\nexport function join(...parts) {\n    return parts.join(path.sep);\n}\nexport function isRooted(path: strin {\n    return ABSOLUTE_PATH_REGEX.test(path);\n}\nexport function isRelative(path: string) {\n    return RELATIVE_PATH_REGEX.test(path);\n}\nexport function isExternal(path: string) {\n    return isAbsolute(path) && path.charAt(0) === \".\";\n}\nexpor): void {\n    /**\n     * Normalize a path to be a valid directory name\n     *\n     * @param path\n     */\n    function normalizeDirectory(path: string) {\n        path = normalizeSlashes(path);\n        if (path.length == {\n    return RELATIVE_PATH_REGEX.test(path);\n}\nexport function normalize(path: string) {\n    return normalizeSlashes(path).replace(ALL_BACKSLASHES_REGEX, \"/\");\n}\n}\nexport function normalizeSlashes(path: string) {\n    return path.replace(ANY_SLASH_REGEX): string;\n}\nexport function resolveDirectory(path: string, parentDirectory?: string) {\n    const resolvedPath = normalizeSlashes(path);\n    const parentPath = normalizeSlashes(parentDirectory);\n    if (parentPath === \". {\n    return path.replace(ALL_BACKSLASHES_REGEX, \"/\");\n}\nexport function basename(path: string) {\n    if (path === \".\") {\n        return \"\";\n    }\n    let i = 0;\n    if (path.charCodeAt(0) === 47 /* \"/\" */) {\n        i++;\n    }\n    const extensionIndex = pat): number {\n        return path.slice(i, path.length - EXTNAME_REGEX.exec(path).index - i);\n    }\n}\nexport function dirname(path: string) {\n    const match = /[/\\\\][ {\n    return path.split(ANY_SLASH_REGEX).pop() || \"\";\n}\nexport function dirname(path: string, includeTrailingSlash?: boolean) {\n    let dir = normalizeSlashes(path);\n    if (!isRooted(path)) {\n        const parentDirectory = normalizeSlashes(dirname(parentDirectory));\n        if (parentDirectory === \".\"): {\n            if (!includeTrailingSlash) {\n                return \"\";\n            }\n            else {\n                return \".\";\n            }\n        }\n        else if (isExternal(parentDirectory)) {\n            return parentDirectory;\n        }\n        else {\n            return resolveDirector {\n    const match = /[/\\\\][^/\\\\]*$/.exec(path);\n    if (!match)\n        return \".\";\n    const dir = path.slice(0, -match[0].length);\n    // If `dir` is the empty string, we're at root.\n    return dir ? dir : \"/\";\n}\nexport function extname(path: string) {\n    const match = EXTNAME_REGEX.exec(basename(path)!);\n    return match? match[0] : \"\";\n}\nexport function normalizeSlashes(path: string) {\n    if (path === \".\"): {\n        return \".\";\n    }\n    const match = path.match(ALL_BACKSLASHES_REGEX);\n    return match? path.replace(ALL_BACKSLASHES_REGEX, \"/\") : path;\n}\nexport function resolve {\n    const match = EXTNAME_REGEX.exec(basename(path)!);\n    return match ? match[0] : \"\";\n}\nexport function relative(from: string, to: string) {\n    const match = basename(from)!.match(EXTNAME_REGEX);\n    if (!match) {\n        return dirname(from) + \"/\" + resolve(dirname(from), to);\n    }, to: resolve(from, to);\n}\nexport function isRooted(path: string) {\n    const match = path.match(ROOT_REGEX);\n    return match && match[1] === \"/\";\n}\nexport function isExternal): (path: string) => boolean {\n    return path[0] === \".\" || path.match(EXTERNAL_REGEX);\n}\nexport function isRootedOrExternal(path: string) {\n    return isRooted(path) | {\n    const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);\n    const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);\n    if (fromParts[0] === \".\")\n        fromParts.shift();\n    if (toParts[0] === \".\")\n        toParts.shift();\n    while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {\n        fromParts.shift();\n        toParts.shift();\n    }\n    while (toParts[0] === \"..\" && fromParts.length > 0) {\n        toParts.shift();\n        fromParts.pop();\n    }\n    while (fromParts.pop()) {\n        toParts.unshift(\"..\");\n    }\n    return toParts.join(\"/\");\n}\nexport function resolve(...paths: string[]) {\n    if (paths.length === 0) {\n        return \".\";\n    }\n    if (paths.length === 1) {\n        return normalizeSlashes(paths[0]);\n    }\n    const resolved = paths.reduc): (path: string) => string {\n        const parts = path.split(ANY_SLASH_REGEX);\n        for (const part of parts) {\n            if (part === \"..\") {\n                if (parts.length > 0) {\n    const firstPathSegment = paths.shift();\n    if (!firstPathSegment) {\n        return \"/\";\n    }\n    let resolvedParts = firstPathSegment.split(ANY_SLASH_REGEX);\n    for (const path of paths) {\n        if (isAbsolute(path)) {\n            resolvedParts = path.split(ANY_SLASH_REGEX);\n        }\n        else {\n            const parts = path.split(ANY_SLASH_REGEX);\n            while (parts[0] === \".\" || parts[0] === \"..\") {\n                const part = parts.shift();\n                if (part === \"..\") {\n                    resolvedParts.pop();\n                }\n            }\n            resolvedParts.push(...parts);\n        }\n    }\n    return resolvedParts.join(\"/\");\n}\n","score":350,"fallbacked":false,"num_type_errors":104}]}
{"dataset_elem":{"alphanum_fraction":0.7148994337,"avg_line_length":25.8636363636,"content":"interface GameState {\n  cups: number[],\n  currentCupIndex: number\n}\n\nexport function playRound(gameState: GameState): GameState {\n  const localCups = [...gameState.cups];\n  \n  const currentIndex = gameState.currentCupIndex;\n\n  const tail = localCups.splice(0, currentIndex);\n  localCups.push(...tail);\n\n  const currentCup = localCups[0];\n\n  const nextThreeCups = localCups.splice(1, 3);\n\n  let destinationCup = currentCup - 1;\n  if (destinationCup === 0) {\n    destinationCup = Math.max(...gameState.cups);\n  }\n  while (nextThreeCups.includes(destinationCup)) {\n    destinationCup -= 1;\n    if (destinationCup === 0) {\n      destinationCup = Math.max(...gameState.cups);\n    }\n  }\n\n  const destinationIndex = localCups.indexOf(destinationCup) + 1;\n\n  localCups.splice(destinationIndex, 0, ...nextThreeCups);\n\n  const head = localCups.splice(localCups.length - currentIndex, currentIndex);\n  localCups.unshift(...head);\n\n  return {\n    cups: localCups,\n    currentCupIndex: (currentIndex + 1) % localCups.length\n  };\n}\n\nexport function playXRound(gameState: GameState, numberOfRounds: number): GameState {\n  let currentGameState = gameState;\n  for (let i = 0; i < numberOfRounds; i++) {\n    currentGameState = playRound(currentGameState);\n  }\n\n  return currentGameState;\n}\n\nexport function getCupsLabeling(input: string, numberOfRounds: number): string {\n  const cups = input.split('').map(i => parseInt(i)); //?\n\n  const gameState = {\n    cups,\n    currentCupIndex: 0\n  }\n  \n  const result = playXRound(gameState, numberOfRounds);\n\n  const indexOf1 = result.cups.indexOf(1);\n  \n  const tail = result.cups.splice(0, indexOf1);\n  result.cups.push(...tail);\n\n  result.cups.shift()\n\n  return result.cups\n    .join('');\n}\n\n\n\n\n\nexport interface GameStateLinkedArray {\n  cups: number[],\n  currentCup: number,\n  maxCup: number\n}\n\nexport function convertToLinkedArray(orderedListOfCups: number[]): number[] {\n  const linkedArray: number[] = [-1];\n\n  for(let i = 0; i < orderedListOfCups.length; i++) {\n    const currentCup = orderedListOfCups[i];\n    const nextIndex = (i+1) % orderedListOfCups.length;\n    const nextCup = orderedListOfCups[nextIndex];\n    linkedArray[currentCup] = nextCup;\n  }\n\n  return linkedArray;\n}\n\nexport function convertToOrderedArray(linkedListOfCups: number[]): number[] {\n  const orderedArray: number[] = [];\n\n  const firstItem = linkedListOfCups[1]; //?\n\n  orderedArray.push(firstItem);\n\n  let previousIndex = linkedListOfCups.indexOf(firstItem);\n\n  while (previousIndex !== firstItem) {\n    orderedArray.unshift(previousIndex);\n    previousIndex = linkedListOfCups.indexOf(previousIndex);\n  }\n\n  return orderedArray;\n}\n\nexport function shiftOrderedArray(orderedListOfCups: number[], startingCup: number) {\n  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);\n\n  const tail = orderedListOfCups.splice(0, indexOfStartingCup);\n\n  orderedListOfCups.push(...tail);\n}\n\nexport function removeNext(linkedListOfCups:number[], cup: number) {\n  const nextCup = linkedListOfCups[cup];\n  const nextNextCup = linkedListOfCups[nextCup];\n\n  linkedListOfCups[cup] = nextNextCup;\n\n  return nextCup;\n}\n\nexport function removeNextThree(linkedListOfCups:number[], cup: number): number[] {\n  return [\n    removeNext(linkedListOfCups, cup),\n    removeNext(linkedListOfCups, cup),\n    removeNext(linkedListOfCups, cup)\n  ]\n}\n\nexport function insertNext (linkedListOfCups:number[], cup: number, insertedCup: number) {\n  const nextCup = linkedListOfCups[cup];\n\n  linkedListOfCups[cup] = insertedCup;\n\n  linkedListOfCups[insertedCup] = nextCup;\n}\n\nexport function insertNextThree(linkedListOfCups:number[], cup: number, insertedCups: number[]) {\n  insertedCups.reverse().forEach(insertedCup => {\n    insertNext(linkedListOfCups, cup, insertedCup)\n  })\n}\n\nexport function playRoundLinkedArray(gameState: GameStateLinkedArray) {\n  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?\n\n  let destinationCup = gameState.currentCup;\n  do {\n    destinationCup -= 1;\n    if (destinationCup === 0) {\n      destinationCup = gameState.maxCup;\n    }\n  } while (nextThree.includes(destinationCup))\n\n  insertNextThree(gameState.cups, destinationCup, nextThree);\n\n  gameState.currentCup = gameState.cups[gameState.currentCup];\n}\n\nexport function playXRoundLinkedArray(gameState: GameStateLinkedArray, numberOfRounds: number) {\n  for (let i = 0; i < numberOfRounds; i++) {\n    playRoundLinkedArray(gameState);\n  }\n}\n\nexport function getStars(input: string, numberOfRounds: number): number {\n  const cups = input.split('').map(i => parseInt(i)); //?\n  const linkedCups = convertToLinkedArray(cups); //?.\n\n  const macCups = 1_000_000;\n  \n  const maxCupsFromFile = Math.max(...cups);\n  let lastCup = cups[cups.length - 1];\n  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {\n    insertNext(linkedCups, lastCup, i);\n    lastCup = i;\n  }\n\n  const gameState = {\n    cups: linkedCups,\n    currentCup: cups[0],\n    maxCup: macCups\n  };\n\n  playXRoundLinkedArray(gameState, numberOfRounds);\n\n  const nextCup1 = gameState.cups[1];\n  const nextCup2 = gameState.cups[nextCup1];\n\n  return nextCup1 * nextCup2;\n}","content_without_annotations":"interface GameState {\n  cups,\n  currentCupIndex\n}\n\nexport function playRound(gameState) {\n  const localCups = [...gameState.cups];\n  \n  const currentIndex = gameState.currentCupIndex;\n\n  const tail = localCups.splice(0, currentIndex);\n  localCups.push(...tail);\n\n  const currentCup = localCups[0];\n\n  const nextThreeCups = localCups.splice(1, 3);\n\n  let destinationCup = currentCup - 1;\n  if (destinationCup === 0) {\n    destinationCup = Math.max(...gameState.cups);\n  }\n  while (nextThreeCups.includes(destinationCup)) {\n    destinationCup -= 1;\n    if (destinationCup === 0) {\n      destinationCup = Math.max(...gameState.cups);\n    }\n  }\n\n  const destinationIndex = localCups.indexOf(destinationCup) + 1;\n\n  localCups.splice(destinationIndex, 0, ...nextThreeCups);\n\n  const head = localCups.splice(localCups.length - currentIndex, currentIndex);\n  localCups.unshift(...head);\n\n  return {\n    cups: localCups,\n    currentCupIndex: (currentIndex + 1) % localCups.length\n  };\n}\n\nexport function playXRound(gameState, numberOfRounds) {\n  let currentGameState = gameState;\n  for (let i = 0; i < numberOfRounds; i++) {\n    currentGameState = playRound(currentGameState);\n  }\n\n  return currentGameState;\n}\n\nexport function getCupsLabeling(input, numberOfRounds) {\n  const cups = input.split('').map(i => parseInt(i)); //?\n\n  const gameState = {\n    cups,\n    currentCupIndex: 0\n  }\n  \n  const result = playXRound(gameState, numberOfRounds);\n\n  const indexOf1 = result.cups.indexOf(1);\n  \n  const tail = result.cups.splice(0, indexOf1);\n  result.cups.push(...tail);\n\n  result.cups.shift()\n\n  return result.cups\n    .join('');\n}\n\n\n\n\n\nexport interface GameStateLinkedArray {\n  cups,\n  currentCup,\n  maxCup\n}\n\nexport function convertToLinkedArray(orderedListOfCups) {\n  const linkedArray = [-1];\n\n  for(let i = 0; i < orderedListOfCups.length; i++) {\n    const currentCup = orderedListOfCups[i];\n    const nextIndex = (i+1) % orderedListOfCups.length;\n    const nextCup = orderedListOfCups[nextIndex];\n    linkedArray[currentCup] = nextCup;\n  }\n\n  return linkedArray;\n}\n\nexport function convertToOrderedArray(linkedListOfCups) {\n  const orderedArray = [];\n\n  const firstItem = linkedListOfCups[1]; //?\n\n  orderedArray.push(firstItem);\n\n  let previousIndex = linkedListOfCups.indexOf(firstItem);\n\n  while (previousIndex !== firstItem) {\n    orderedArray.unshift(previousIndex);\n    previousIndex = linkedListOfCups.indexOf(previousIndex);\n  }\n\n  return orderedArray;\n}\n\nexport function shiftOrderedArray(orderedListOfCups, startingCup) {\n  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);\n\n  const tail = orderedListOfCups.splice(0, indexOfStartingCup);\n\n  orderedListOfCups.push(...tail);\n}\n\nexport function removeNext(linkedListOfCups, cup) {\n  const nextCup = linkedListOfCups[cup];\n  const nextNextCup = linkedListOfCups[nextCup];\n\n  linkedListOfCups[cup] = nextNextCup;\n\n  return nextCup;\n}\n\nexport function removeNextThree(linkedListOfCups, cup) {\n  return [\n    removeNext(linkedListOfCups, cup),\n    removeNext(linkedListOfCups, cup),\n    removeNext(linkedListOfCups, cup)\n  ]\n}\n\nexport function insertNext (linkedListOfCups, cup, insertedCup) {\n  const nextCup = linkedListOfCups[cup];\n\n  linkedListOfCups[cup] = insertedCup;\n\n  linkedListOfCups[insertedCup] = nextCup;\n}\n\nexport function insertNextThree(linkedListOfCups, cup, insertedCups) {\n  insertedCups.reverse().forEach(insertedCup => {\n    insertNext(linkedListOfCups, cup, insertedCup)\n  })\n}\n\nexport function playRoundLinkedArray(gameState) {\n  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?\n\n  let destinationCup = gameState.currentCup;\n  do {\n    destinationCup -= 1;\n    if (destinationCup === 0) {\n      destinationCup = gameState.maxCup;\n    }\n  } while (nextThree.includes(destinationCup))\n\n  insertNextThree(gameState.cups, destinationCup, nextThree);\n\n  gameState.currentCup = gameState.cups[gameState.currentCup];\n}\n\nexport function playXRoundLinkedArray(gameState, numberOfRounds) {\n  for (let i = 0; i < numberOfRounds; i++) {\n    playRoundLinkedArray(gameState);\n  }\n}\n\nexport function getStars(input, numberOfRounds) {\n  const cups = input.split('').map(i => parseInt(i)); //?\n  const linkedCups = convertToLinkedArray(cups); //?.\n\n  const macCups = 1_000_000;\n  \n  const maxCupsFromFile = Math.max(...cups);\n  let lastCup = cups[cups.length - 1];\n  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {\n    insertNext(linkedCups, lastCup, i);\n    lastCup = i;\n  }\n\n  const gameState = {\n    cups: linkedCups,\n    currentCup: cups[0],\n    maxCup: macCups\n  };\n\n  playXRoundLinkedArray(gameState, numberOfRounds);\n\n  const nextCup1 = gameState.cups[1];\n  const nextCup2 = gameState.cups[nextCup1];\n\n  return nextCup1 * nextCup2;\n}","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":1524,"ext":"ts","fun_ann_density":0.0282152231,"function_parameters":27,"function_signatures":0,"function_usages":9,"functions":16,"hexsha":"c5cbef909f0917171ef87f6f627d749ffbf01b40","lang":"TypeScript","loc":142,"loc_per_function":6.875,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-01-28T17:21:42.000Z","max_forks_repo_forks_event_min_datetime":"2022-01-28T17:21:42.000Z","max_forks_repo_head_hexsha":"608c15619b9cae3bbc65d2d5d42455710d517221","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"Ldoppea/advent-of-code-2020-typescript","max_forks_repo_path":"challenges/day23.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"608c15619b9cae3bbc65d2d5d42455710d517221","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"Ldoppea/advent-of-code-2020-typescript","max_issues_repo_path":"challenges/day23.ts","max_line_length":97,"max_stars_count":null,"max_stars_repo_head_hexsha":"608c15619b9cae3bbc65d2d5d42455710d517221","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"Ldoppea/advent-of-code-2020-typescript","max_stars_repo_path":"challenges/day23.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.325784,"predefined_density":0.3636363636,"predefined_types":32,"prop_ann_density":0.0032808399,"property_declarations":5,"size":5121,"trivial_density":0.0,"trivial_types":0,"type_definitions":2,"typedef_density":0.001312336,"var_ann_density":0.0262467192,"variable_declarations":40},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"interface GameState {\n    cups: number[];\n    currentCupIndex: number;\n}\nexport function readGameState(input) {\n    const lines = input.split(\"\\n\");\n    const cups = lines[0].split(\",\").map((i) => parseInt;\n    currentCupIndex: number = parseInt(lines[1]);\n    gameState: GameState = {\n        cups,\n        currentCupIndex\n    };\n    return gameState;\n}\nexport interface GameStateList {\n    gameState: GameState;\n}\nexport function readGameStateLis;\n}\nexport function playRound(gameState: GameStateList, roundNumber): GameStateList {\n    const localCups = [...gameState.cups];\n    const currentIndex = gameState.currentCupIndex;\n    const tail = localCups.splice(0, currentIndex);\n    localCups.push(...tail);\n    const currentCup = localCups[0];\n    const nextThreeCups = localCups.splice(1, 3);\n    let destinationCup = currentCup - 1;\n    if (destinationCup === 0) {\n        destinationCup = Math.max(...gameState.cups);\n    }\n    while (nextThreeCups.includes(destinationCup)) {\n        destinationCup -= 1;\n        if (destinationCup === 0) {\n            destinationCup = Math.max(...gameState.cups);\n        }\n    }\n    const destinationIndex = localCups.indexOf(destinationCup) + 1;\n    localCups.splice(destinationIndex, 0, ...nextThreeCups);\n    const head = localCups.splice(localCups.length - currentIndex, currentIndex);\n    localCups.unshift(...head);\n    return {\n        cups: localCups,\n        currentCupIndex: (currentIndex + 1) % localCups.length\n    };\n}\nexport function playXRound(gameState: GameState, numberOfRounds: number): GameStateList {\n    const currentGameState = gameState;\n    for (let i = 0; i < numberOfRounds; i++) {\n        currentGameState = playRound(currentGameState, numberOfRounds);\n    }, numberOfRounds: number;\n    return currentGameState;\n}\nexport function playRoundsByInput(input: string, numberOfRounds: number) {\n    let gameState = parseGameState(input);\n    let currentGameState = gameState;\n    for (let i =): GameStateList {\n        gameState = playRound(currentGameState, numberOfRounds);\n        currentGameState = gameState;\n    }\n    return currentGameState;\n}\nexport function playRoundsByInputL(input: string, numberOfRounds: number) { {\n    let currentGameState = gameState;\n    for (let i = 0; i < numberOfRounds; i++) {\n        currentGameState = playRound(currentGameState);\n    }\n    return currentGameState;\n}\nexport function getCupsLabeling(input: string, numberOfRounds: number): GameStateLinkedArray {\n    const cups = input.split(\"\").map((i) => parseInt(i)); //?\n    const gameState = {\n        cups,\n        currentCupIndex: 0\n    }, numberOfRounds: number;\n    for (let i = 0; i < numberOfRounds; i++) {\n        gameState = playXRound(gameState, numberOfRounds);\n    }\n    return gameState.cups\n      .map(cup => {\n            const cu): CupLabel = {\n                cup,\n                currentCupIndex: 0\n            };\n            return cu;\n        });\n}\nexport function getCupsLabelingL(input: string, numberOfRounds: number): GameStateLinkedArray { {\n    const cups = input.split(\"\").map((i: string) => parseInt(i)); //?\n    const gameState = {\n        cups,\n        currentCupIndex: 0\n    }, numberOfRounds: number;\n    for (let i = 0; i < numberOfRounds; i++)): GameStateLinkedArray {\n        gameState = playXRound(gameState, numberOfRounds);\n    }\n    return gameState.cups\n     .map(cup => {\n           const cu: CupLabel = {\n                cup,\n                currentCupIndex => parseInt(i)); //?\n    const gameState = {\n        cups,\n        currentCupIndex: 0\n    };\n    const result = playXRound(gameState, numberOfRounds);\n    const indexOf1 = result.cups.indexOf(1);\n    const tail = result.cups.splice(0, indexOf1);\n    result.cups.push(...tail);\n    result.cups.shift();\n    return result.cups\n        .join(\"\");\n}\nexport interface GameStateLinkedArray {\n    cups: number[];\n    currentCupIndex: number;\n    maxCupIndex: number;\n}\nexport function getCupsLabelingL(input: string, numberOfRounds: number): GameStateLinkedArray {\n    const cups = input.spli;\n    currentCup: number;\n    maxCup: number;\n    let currentCup = 0, maxCup = 0;\n    for (let i = 0; i < numberOfRounds; i++) {\n        currentCup = i %;\n    maxCup: number;\n        if (cups[i] === \"1\") {\n            currentCup++;\n            maxCup++;\n        } else {\n            currentCup--;\n            maxCup--;\n        }\n        const gameState = {\n            cups;\n}\nexport function convertToLinkedArray(orderedListOfCups: CupsOrderedList) {\n    const linkedArray = [];\n    if (orderedListOfCups.length === 1) {\n        return linkedListOfCups;\n    }\n    for (let i = 0; i < orderedListO): GameStateLinkedArray {\n        gameState.cups = [cups[i],...cups.slice(i + 1)];\n        gameState.currentCupIndex = currentCup;\n        gameState.maxCupIndex = maxCu {\n    const linkedArray = [-1];\n    for (let i = 0; i < orderedListOfCups.length; i++) {\n        const currentCup = orderedListOfCups[i];\n        const nextIndex = (i + 1) % orderedListOfCups.length;\n        const nextCup = orderedListOfCups[nextIndex];\n        linkedArray[currentCup] = nextCup;\n    }\n    return linkedArray;\n}\nexport function convertToOrderedArray(linkedListOfCups: GameStateLinkedArray): CupsOrderedList {\n    const linkedArray = [];\n    if (linkedListOfCups.length === 1) {\n        return linkedArray;\n    }\n    for (let i = 0; i < linkedListO): GameStateLinkedArray {\n        const gameState = {\n            cups: linkedListOfCups.cups,\n            currentCupIndex: linkedListOfCups.currentCupIndex,\n            maxCupIndex: linkedListOfCups.max {\n    const orderedArray = [];\n    const firstItem = linkedListOfCups[1]; //?\n    orderedArray.push(firstItem);\n    let previousIndex = linkedListOfCups.indexOf(firstItem);\n    while (previousIndex !== firstItem) {\n        orderedArray.unshift(previousIndex);\n        previousIndex = linkedListOfCups.indexOf(previousIndex);\n    }\n    return orderedArray;\n}\nexport function shiftOrderedArray(orderedListOfCups: CupsOrderedList): GameStateOrderedArray {\n    const orderedArray = [];\n    const shift = linkedListOfCups.shift();\n    if (shift === -1) {\n        return orderedArray;\n    }\n    const firstItem = shift;, startingCup: number = linkedListOfCups[1];\n    let previousIndex = linkedListOfCups.indexOf(firstItem);\n    while (previousIndex!== firstItem) {\n        orderedArray.unshift(previousIndex);\n        previousIndex = linkedListOf): GameStateOrderedArray {\n        const nextItem = removeNext(linkedListOfCups, previousIndex);\n        orderedArray.push(nextItem);\n        if (previousIndex === firstItem) {\n            break;\n        }\n        previousIndex = linkedLis {\n    const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);\n    const tail = orderedListOfCups.splice(0, indexOfStartingCup);\n    orderedListOfCups.push(...tail);\n}\nexport function removeNext(linkedListOfCups: CupsOrderedList, index: number) {\n    const nextCup = linkedListOfCups[index];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[index] = nextNex, cup: number = linkedListOfCups.indexOf(nextCup);\n    linkedListOfCups[nextCup] = nextNextCup;\n    return nextCup;\n}\nexport function shiftOrderedArray(orderedListOfCups): GameStateOrderedArray {\n    const orderedArray = [];\n    const shift = linkedListOfCups.shift();\n    if (shift === -1) {\n        return orderedArray;\n    }\n    const firstItem = shift;\n    let previousIndex = linkedLis {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cup] = nextNextCup;\n    return nextCup;\n}\nexport function removeNextThree(linkedListOfCups: CupsOrderedList, index: number) {\n    const nextCup = linkedListOfCups[index];\n    linkedListOfCups[index] = nextCup;\n    const nextNextCup = linkedListOfCups[next, cup: number = linkedListOfCups.indexOf(nextCup);\n    linkedListOfCups[nextCup] = nextNextCup;\n}\nexport function removeNextFour(linkedListOfCups: CupsOrderedList, inde): GameStateOrderedArray {\n    const nextCup = linkedListOfCups[index];\n    linkedListOfCups[index] = nextCup;\n    const nextNextCup = linkedListOfCups[next, cup: number = linkedLis {\n    return [\n        removeNext(linkedListOfCups, cup),\n        removeNext(linkedListOfCups, cup),\n        removeNext(linkedListOfCups, cup)\n    ];\n}\nexport function insertNext(linkedListOfCups: CupsOrderedList, cup, insertedCup) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cup, cup: number] = nextNextCup, cup: number = linkedListOfCups.indexOf(nextCup);\n    return nextCup;\n}\nexport function insertNextTwo(linkedListOfCups: CupsOrderedList, insertedCup: Cup, cup: number) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cup, cup: numbe): GameStateOrderedArray = [\n        insertNext(linkedListOfCups, cup, insertedCup),\n        insertNext(linkedListOfCups, cup, nextCup)\n    ];\n}\nexport function insertNextFour {\n    const nextCup = linkedListOfCups[cup];\n    linkedListOfCups[cup] = insertedCup;\n    linkedListOfCups[insertedCup] = nextCup;\n}\nexport function insertNextThree(linkedListOfCups: CupsOrderedList, cup: number) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cup, cu, cup: number]: GameStateOrderedArray = [\n        insertNext(linkedListOfCups, cup, nextCup),\n        insertNext(linkedListOfCups, cup, nextNextCup)\n    ];\n}\nexport function remov, insertedCups: number, cup: number, index = 0) {\n    if (index === 0) {\n        removeNext(linkedListOfCups, cup);\n    }\n    else if (index === 1) {\n        removeNex): GameStateOrderedArray = [\n            removeNext(linkedListOfCups, cup),\n            removeNext(linkedListOfCups, cup)\n        ];\n    }\n    else if (index === 2) {\n        removeNextTwo {\n    insertedCups.reverse().forEach((insertedCup: number) => {\n        insertNext(linkedListOfCups, cup, insertedCup);\n    });\n}\n}\n}\nexport function remov(linkedListOfCups: CupsOrderedList, cup: numbe): GameStateOrderedArray {\n    const nextCup = linkedListOfCups[cup];\n    linkedListOfCups[cup]: number = undefined;\n    return [\n        removeNext(linkedListOfCups, cup),\n        removeNext(lin => {\n        insertNext(linkedListOfCups, cup, insertedCup);\n    });\n}\nexport function playRoundLinkedArray(gameState: GameStateOrderedArray): GameStateOrderedArray {\n    const cups: number[] = [];\n    for (let i = 0; i < gameState.cups.length; i++) {\n        if (gameState.cups[i] === gameStat): {\n            gameState.cups[i] = gameState.cups[i + 1];\n            gameState.cups[i + 1] = undefined;\n            gameState.cups[i + 2] = gameState.cup {\n    const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?\n    let destinationCup = gameState.currentCup;\n    do {\n        destinationCup -= 1;\n        if (destinationCup === 0) {\n            destinationCup = gameState.maxCup;\n        }\n    } while (nextThree.includes(destinationCup));\n    insertNextThree(gameState.cups, destinationCup, nextThree);\n    gameState.currentCup = gameState.cups[gameState.currentCup];\n}\nexport function playXRoundLinkedArray(gameState: GameStateOrderedArray): GameStateOrderedArray {\n    const cups: number[] = [];\n    for (let i = 0; i < gameState.cups.length; i++) {\n        if (gameState.cups[i] === gam, numberOfRounds: number) {\n            gameState.cups[i] = gameState.cups[i + 1];\n            gameState.cups[i + 1] = gameState.cups[i + 2];\n            gameState.cups): number = gameState.cups[gameState.cups.length - 1];\n            gameState.cups[gameState.cups.length - 1] = undefined;\n            gameState.cups[gameState.cups.length - {\n    for (let i = 0; i < numberOfRounds; i++) {\n        playRoundLinkedArray(gameState);\n    }\n}\nexport function getStars(input: number): number {\n    const stars = 1 + (input / 100);\n    return stars;\n}\nexport function addCupToState(cup: number, gameState: GameStateOrderedArray): void {\n    const current, numberOfRounds: number;\n    const gameState: GameStateOrderedArray = gameState;\n    const nextThree = removeNextThree(gameState.cups, cup); //?\n    let destinationCup = cup;\n    do {\n        destinationCup -=): number = gameState.cups[gameState.cups.length - 1];\n        if (destinationCup === 0) {\n            destinationCup = gameState.maxCup;\n        }\n    } while (nextThree.includes {\n    const cups = input.split(\"\").map((i: string) => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const macCups = 1000000;\n    const maxCupsFromFile = Math.max(..): number = gameState.cups[gameState.cups.length - 1];\n    let lastCup = cups[cups.length - 1];\n    for (let i = maxCupsFromFile + 1; i < => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const macCups = 1000000;\n    const maxCupsFromFile = Math.max(...cups);\n    let lastCup = cups[cups.length - 1];\n    for (let i = maxCupsFromFile + 1; i <= macCups; i++) {\n        insertNext(linkedCups, lastCup, i);\n        lastCup = i;\n    }\n    const gameState = {\n        cups: linkedCups,\n        currentCup: cups[0],\n        maxCup: macCups\n    };\n    playXRoundLinkedArray(gameState, numberOfRounds);\n    const nextCup1 = gameState.cups[1];\n    const nextCup2 = gameState.cups[nextCup1];\n    return nextCup1 * nextCup2;\n}\n","score":324,"fallbacked":false,"num_type_errors":255},{"code":"interface GameState {\n    cups: number[];\n    currentCupIndex: number;\n}\nexport function setGameState(gameState: GameState) {\n    return {\n        type: \"set-game-state\",\n        gameState\n    };\n}\nexport interface GameStateLinkState {;\n    currentCupIndex: number;\n    gameState: GameState;\n}\nexport function setGameStateLinkState(state: GameStateLinkState) {\n    return {\n        type: \"set-game-state-link-state\",\n        state\n    };\n}\nexport interfac;\n}\nexport function playRound(gameState: GameState) {\n    const localCups = [...gameState.cups];\n    const currentCupIndex = gameState.currentCupIndex;\n    const tail = localCups.splice(0, currentCupIndex);\n    localCup): GameState;\n    if (currentCupIndex + 1 === gameState.cups.length) {\n    const localCups = [...gameState.cups];\n    const currentIndex = gameState.currentCupIndex;\n    const tail = localCups.splice(0, currentIndex);\n    localCups.push(...tail);\n    const currentCup = localCups[0];\n    const nextThreeCups = localCups.splice(1, 3);\n    let destinationCup = currentCup - 1;\n    if (destinationCup === 0) {\n        destinationCup = Math.max(...gameState.cups);\n    }\n    while (nextThreeCups.includes(destinationCup)) {\n        destinationCup -= 1;\n        if (destinationCup === 0) {\n            destinationCup = Math.max(...gameState.cups);\n        }\n    }\n    const destinationIndex = localCups.indexOf(destinationCup) + 1;\n    localCups.splice(destinationIndex, 0, ...nextThreeCups);\n    const head = localCups.splice(localCups.length - currentIndex, currentIndex);\n    localCups.unshift(...head);\n    return {\n        cups: localCups,\n        currentCupIndex: (currentIndex + 1) % localCups.length\n    };\n}\nexport function playXRound(gameState: GameState) {\n    const localCups = [...gameState.cups];\n    const currentCupIndex = gameState.currentCupIndex;\n    const nextThreeCups = localCups.splice(currentCupIndex + 1, numberOfRounds: 3);\n    const head = localCups.splice(0, currentCupIndex + 1);\n    localCups.unshift(...head);\n    return {\n        cups: localCups,\n        currentCupIndex: (curren): number => (curren + 1) % numberOfRounds\n    };\n}\nfunction playRound(gameState: GameState) {\n    let currentCupIndex = gameState.currentCupIndex;\n    if (currentCupIndex > gameState {\n    let currentGameState = gameState;\n    for (let i = 0; i < numberOfRounds; i++) {\n        currentGameState = playRound(currentGameState);\n    }\n    return currentGameState;\n}\nexport function getCupsLabeling(input: GameStateLinkedArray, numberOfRounds: number) {\n    const cups = input.cups;\n    const currentCup = input.currentCup;\n    const maxCup = input.maxCup;\n    let cupsLabelin, numberOfRounds: number;\n    if (cups.length === 0) {\n        return \"0\";\n    }\n    if (cups.length === 1) {\n        return cups[0].toString();\n    }\n    if (cups): number {\n        const cupsLabeling = \"\";\n        for (let i = 0; i < cups.length; i++) {\n            if (i === 0) {\n                cupsLabeling += cups[i].toStrin {\n    const cups = input.split(\"\").map((i: number): number => parseInt(i)); //?\n    const gameState = {\n        cups,\n        currentCupIndex: 0\n    };\n    const result = playXRound(gameState, numberOfRounds);\n    const indexOf1 = result.cu): number => (result.cups.indexOf(1) + 1) % 3; //?\n    const indexOf2 = result.cups.indexOf(2);\n    const indexOf3 = result.cups.indexOf(3) => parseInt(i)); //?\n    const gameState = {\n        cups,\n        currentCupIndex: 0\n    };\n    const result = playXRound(gameState, numberOfRounds);\n    const indexOf1 = result.cups.indexOf(1);\n    const tail = result.cups.splice(0, indexOf1);\n    result.cups.push(...tail);\n    result.cups.shift();\n    return result.cups\n        .join(\"\");\n}\nexport interface GameStateLinkedArray {\n    cups: number[];\n    currentCupIndex: number;\n    maxCup: number;\n}\n}\nexport interface GameState {\n    cups: number[];\n    currentCupIndex: number;\n    maxCup: number;\n};\n    currentCup: number;\n}\nexport function playXRound(gameState: GameState, numberOfRounds: number) {\n    const cups: number[] = gameState.cups;\n    const currentCupIndex: number = gameState.currentCupIndex;\n    maxCup: number = gameState.maxCup;\n    let remainingCups: number[] = cups.slice(currentCupIndex);\n    let solutionCups: number[] = [];\n    for (let round = 0; round < numberOfRound;\n}\nexport function convertToLinkedArray(orderedListOfCups: number[]) {\n    const linkedArray = new Array(maxCup + 1);\n    for (let i = 0; i < orderedListOfCups.length; i++) {\n        const currentCup = orderedListOf): number => (orderedList.indexOf(1) + 1) % 3; //?\n        linkedArray[currentCup] = i; //?\n    }\n    return linkedArray;\n}\nexport function convertToLinkedList(orde {\n    const linkedArray = [-1];\n    for (let i = 0; i < orderedListOfCups.length; i++) {\n        const currentCup = orderedListOfCups[i];\n        const nextIndex = (i + 1) % orderedListOfCups.length;\n        const nextCup = orderedListOfCups[nextIndex];\n        linkedArray[currentCup] = nextCup;\n    }\n    return linkedArray;\n}\nexport function convertToOrderedArray(linkedListOfCups: number[]) {\n    const orderedArray: number[] = [];\n    for (let i = 0; i < linkedListOfCups.length; i++) {\n        const nextCup = linkedListOfCups[i + 1];): number => {\n            if (linkedListOfCups[i]!== -1) {\n                return linkedListOfCups[i];\n            }\n            else {\n                return -1;\n            }\n        };\n        orderedArray.push(next {\n    const orderedArray = [];\n    const firstItem = linkedListOfCups[1]; //?\n    orderedArray.push(firstItem);\n    let previousIndex = linkedListOfCups.indexOf(firstItem);\n    while (previousIndex !== firstItem) {\n        orderedArray.unshift(previousIndex);\n        previousIndex = linkedListOfCups.indexOf(previousIndex);\n    }\n    return orderedArray;\n}\nexport function shiftOrderedArray(orderedListOfCups: number[], startingCup: number) {\n    const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);\n    const tail = orderedListOfCups.splice(0, indexOfStartingCup);\n    orderedLis, startingCup: number;\n    return linkedListOfCups;\n}\nexport function reverseCupOrder(orderedCups: number[]) {\n    const reversedOrderedCups = orderedCups.reverse();\n    const reversedLinkedArray = reverseLinkedList(reversedOrdere): number[];\n    return reversedOrderedCups;\n}\nexport function reverseLinkedList(linkedArray: number[]) {\n    const reversedLinkedArray = [];\n    for (let i = 0; i < linkedArray.length; i++) { {\n    const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);\n    const tail = orderedListOfCups.splice(0, indexOfStartingCup);\n    orderedListOfCups.push(...tail);\n}\nexport function removeNext(linkedListOfCups: number[], cup) {\n    const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);\n    const tail = orderedListOfCups.splice(0, indexOfStartingCup);\n    orderedListOfCup, cup: number;\n    return linkedListOfCups;\n}\nexport function removeNextTwo(linkedListOfCups: number[], cup) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup): number[] {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cup] = nextNextCup;\n    return [nex {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cup] = nextNextCup;\n    return nextCup;\n}\nexport function removeNextThree(linkedListOfCups: number[], cup) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    const nextNextNextCup = linkedListOfCups[nextNex, cup: number];\n    linkedListOfCups[cup] = nextNextNextCup;\n    return nextNextNextCup;\n}\nexport function removeNextFour(linkedListOfCups: number[], cup) {\n    const next): number[] {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    const nextNextNextCup = linkedListOfCups[nextNextCup] {\n    return [\n        removeNext(linkedListOfCups, cup),\n        removeNext(linkedListOfCups, cup),\n        removeNext(linkedListOfCups, cup)\n    ];\n}\nexport function insertNext(linkedListOfCups: number[], cup, insertedCup) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cup] = inserted, cup: number;\n    linkedListOfCups[inserted] = nextCup;\n    linkedListOfCups[nextCup] = nextNextCup;\n    linkedListOfCups[nextNextCup] = nextNextNextCup;, insertedCup: number;\n}\nexport function insertNextTwo(linkedListOfCups: number[], cup, insertedCup) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOf): number[] {\n    const next = removeNext(linkedListOfCups, cup);\n    const nextNext = removeNext(linkedListOfCups, cup);\n    const [nextNextNext, cup] = insertNext {\n    const nextCup = linkedListOfCups[cup];\n    linkedListOfCups[cup] = insertedCup;\n    linkedListOfCups[insertedCup] = nextCup;\n}\nexport function insertNextThree(linkedListOfCups: number[], cup, insertedCup) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    const nextNextNextCup = linkedListOf, cup: number;\n}\nexport function insertNextFour(linkedListOfCups: number[], cup, insertedCup) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOf, insertedCups: number[];\n}\nexport function insertNextFive(linkedListOfCups: number[], cup, insertedCup) {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOf): number[] {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOf: number[], cup: number;\n}\nexport function insertNextSix(linkedListOfCups: number[] {\n    insertedCups.reverse().forEach((insertedCup: number) => {\n        const nextCup = linkedListOfCups[cup];\n        const nextNextCup = linkedListOfCups[nextCup];\n        const nextNextNextCup = linkedListOfCups[nextNextCu): number[] {\n        const next = removeNext(linkedListOfCups, cup);\n        const nextNext = removeNext(linkedListOfCups, cup);\n        const nextNextNext = removeNext(linkedListOfCup => {\n        insertNext(linkedListOfCups, cup, insertedCup);\n    });\n}\nexport function playRoundLinkedArray(gameState: Game, numberOfRounds) {\n    if (numberOfRounds === 0) {\n        gameState.cups.forEach(cup => {\n            const next = removeNext(gameState.cups, gameState.currentCup);\n            if (next): number[] {\n                gameState.currentCup = gameState.cups[next];\n            }\n        });\n        gameState.cups.forEach((cup: number) => {\n            const next = removeNext(gameState.cups, cup) {\n    const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?\n    let destinationCup = gameState.currentCup;\n    do {\n        destinationCup -= 1;\n        if (destinationCup === 0) {\n            destinationCup = gameState.maxCup;\n        }\n    } while (nextThree.includes(destinationCup));\n    insertNextThree(gameState.cups, destinationCup, nextThree);\n    gameState.currentCup = gameState.cups[gameState.currentCup];\n}\nexport function playXRoundLinkedArray(gameState: Game, numberOfRounds) {\n    for (let i = 0; i < numberOfRounds; i++) {\n        playRoundLinkedArray(gameState, numberOfRounds);\n    }\n}\nexport function getStars(input: string, numberOfRound, numberOfRounds: number) {\n    const cups = input.split(\"\").map((i) => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const macCups = 1000): number[] {\n        const stars = [];\n        for (let i = 0; i < numberOfRound; i++) {\n            const gameState = {\n                cups: linkedCups,\n                currentCup: gameState.cups[0] {\n    for (let i = 0; i < numberOfRounds; i++) {\n        playRoundLinkedArray(gameState);\n    }\n}\nexport function getStars(input: string, numberOfRound, numberOfRounds: number) {\n    const cups = input.split(\"\").map((i) => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const mac, numberOfRounds: number;\n    if (numberOfRound === 5) {\n        mac = 5;\n        numberOfRounds = 10;\n    } else if (numberOfRound === 6) {\n        mac = 6;\n        numberOfRounds =): number[] {\n            const stars = [];\n            for (let i = 0; i < numberOfRound; i++) {\n                const gameState = {\n                    cups: linkedCups,\n                    currentCup: gameState.cups[0 {\n    const cups = input.split(\"\").map((i: number) => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const macCups = 1000000;\n    const maxCupsFromFile = Math.max(..): number[] {\n        const stars = [];\n        for (let i = 0; i < numberOfRound; i++) {\n            const gameState = {\n                cups: linkedCups,\n                currentCup: gameState.cups[0 => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const macCups = 1000000;\n    const maxCupsFromFile = Math.max(...cups);\n    let lastCup = cups[cups.length - 1];\n    for (let i = maxCupsFromFile + 1; i <= macCups; i++) {\n        insertNext(linkedCups, lastCup, i);\n        lastCup = i;\n    }\n    const gameState = {\n        cups: linkedCups,\n        currentCup: cups[0],\n        maxCup: macCups\n    };\n    playXRoundLinkedArray(gameState, numberOfRounds);\n    const nextCup1 = gameState.cups[1];\n    const nextCup2 = gameState.cups[nextCup1];\n    return nextCup1 * nextCup2;\n}\n","score":353,"fallbacked":false,"num_type_errors":267},{"code":"interface GameState {\n    cups: number[];\n    currentCupIndex: number;\n}\nexport function loadCups(data: string) {\n    const orderedListOfCups = data.split(\",\").map((i) => parseInt(i));\n    return orderedLis;\n    currentCupIndex: number;\n    cups: number[];\n}\nexport function loadCups(data: GameStateLinkedArray) {\n    const gameState = {\n        cups: data.cups,\n        currentCupIndex: data.currentCup;\n}\nexport function playRound(gameState: GameStateLinkedArray): GameStateLinkedArray {\n    const localCups = [...gameState.cups];\n    const currentIndex = gameState.currentCupIndex;\n    const tail = localCups.splice(0, currentIndex);\n    localCups.push(...tail) {\n    const localCups = [...gameState.cups];\n    const currentIndex = gameState.currentCupIndex;\n    const tail = localCups.splice(0, currentIndex);\n    localCups.push(...tail);\n    const currentCup = localCups[0];\n    const nextThreeCups = localCups.splice(1, 3);\n    let destinationCup = currentCup - 1;\n    if (destinationCup === 0) {\n        destinationCup = Math.max(...gameState.cups);\n    }\n    while (nextThreeCups.includes(destinationCup)) {\n        destinationCup -= 1;\n        if (destinationCup === 0) {\n            destinationCup = Math.max(...gameState.cups);\n        }\n    }\n    const destinationIndex = localCups.indexOf(destinationCup) + 1;\n    localCups.splice(destinationIndex, 0, ...nextThreeCups);\n    const head = localCups.splice(localCups.length - currentIndex, currentIndex);\n    localCups.unshift(...head);\n    return {\n        cups: localCups,\n        currentCupIndex: (currentIndex + 1) % localCups.length\n    };\n}\nexport function playXRound(gameState: GameStateLinkedArray): GameStateLinkedArray {\n    const localCups = [...gameState.cups];\n    const currentIndex = gameState.currentCupIndex;\n    const tail = localCups.splice(0, currentIndex);\n    localCups, numberOfRounds: number;\n    for (numberOfRounds = 0; numberOfRounds < 6; numberOfRounds++) {\n        const localCups = playRound(localCups);\n    }\n    return {\n        cups: localCups,\n        current): number {\n            const currentCupIndex = localCups[0] - 1;\n            if (currentCupIndex === 0) {\n                return 0;\n            }\n            const currentCup = localCups[0] {\n    let currentGameState = gameState;\n    for (let i = 0; i < numberOfRounds; i++) {\n        currentGameState = playRound(currentGameState);\n    }\n    return currentGameState;\n}\nexport function getCupsLabeling(input: string): string {\n    const cups = input.split(\"\").map((i) => parseInt(i));\n    const gameState = {\n        cups,\n        currentCupIndex: 0\n    };\n    const result = playXRound(gameStat, numberOfRounds: 0);\n    const indexOf1 = result.cups.indexOf(1);\n    const tail = result.cups.splice(0, indexOf1);\n    result.cups.push(...tail);\n    result.cups.shift()): string {\n    const currentCupIndex = result.cups[0] - 1;\n    return result.cups[currentCupIndex] - 1;\n}\nexport function convertToCups(order: string): strin {\n    const cups = input.split(\"\").map((i: number) => parseInt(i)); //?\n    const gameState = {\n        cups,\n        currentCupIndex: 0\n    };\n    const result = playXRound(gameState, numberOfRounds: 0);\n    const indexOf1 = resul): number {\n        const currentCupIndex = result.cups[0] - 1;\n        return result.cups[currentCupIndex] - 1;\n    }\n}\nexport function convertToCups(input: strin => parseInt(i)); //?\n    const gameState = {\n        cups,\n        currentCupIndex: 0\n    };\n    const result = playXRound(gameState, numberOfRounds);\n    const indexOf1 = result.cups.indexOf(1);\n    const tail = result.cups.splice(0, indexOf1);\n    result.cups.push(...tail);\n    result.cups.shift();\n    return result.cups\n        .join(\"\");\n}\nexport interface GameStateLinkedArray {\n    cups: number[];\n    currentCupIndex: number;\n    maxCupIndex: number;\n}\nexport function convertToLinkedArray(orderedListOfCups: number[], gameState: GameStateLinkedArray): GameStateLinkedArray {\n    if (orderedLis;\n    currentCup: number;\n    nextCup: number;\n    gameState.cups = [];\n    gameState.currentCupIndex = 0;\n    gameState.maxCupIndex = 0;\n    for (let i = 0; i < orde;\n    maxCup: number;\n    i++) {\n        const currentCup = orderedListOfCups[i];\n        const nextCup = orderedListOfCups[i + 1];\n        if (currentCup > 0 && nextCu;\n}\nexport function convertToLinkedArray(orderedListOfCups: number[], gameState: GameStateLinkedArray): GameStateLinkedArray {\n    if (orderedLis;\n    currentCup: number;\n    nextCup: number;\n    gameState.cups = [];\n    gameState.currentCupIndex =): number {\n        const cups = [];\n        const currentCupIndex = gameState.currentCupIndex;\n        const maxCupIndex = gameState.maxCupIndex;\n        const maxCup = gameState.cups[maxCu {\n    const linkedArray = [-1];\n    for (let i = 0; i < orderedListOfCups.length; i++) {\n        const currentCup = orderedListOfCups[i];\n        const nextIndex = (i + 1) % orderedListOfCups.length;\n        const nextCup = orderedListOfCups[nextIndex];\n        linkedArray[currentCup] = nextCup;\n    }\n    return linkedArray;\n}\nexport function convertToOrderedArray(linkedListOfCups: GameStateLinkedArray): number {\n    if (linkedArray.length === 0) {\n        return -1;\n    }\n    const gameState = { cups: [], currentCupIndex: 0, maxCupIndex: 0 }): number {\n    const orderedListOfCups: number[] = [];\n    const linkedArray = linkedListOfCups;\n    let startingCup = linkedArray[0];\n    while (startingCup) {\n        orderedListOfCups {\n    const orderedArray = [];\n    const firstItem = linkedListOfCups[1]; //?\n    orderedArray.push(firstItem);\n    let previousIndex = linkedListOfCups.indexOf(firstItem);\n    while (previousIndex !== firstItem) {\n        orderedArray.unshift(previousIndex);\n        previousIndex = linkedListOfCups.indexOf(previousIndex);\n    }\n    return orderedArray;\n}\nexport function shiftOrderedArray(orderedListOfCups: number[], startingCup) {\n    const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);\n    const tail = orderedListOfCups.splice(0, indexOfStartingCup);\n    orderedListOf, startingCup: number;\n}\nfunction createCupMap(cups: number[]): CupMap {\n    const cupMap: CupMap = {};\n    for (let cupIndex = 0; cupIndex < cups): CupMap {\n        const cup = cups[cupIndex];\n        cupMap[cup] = cupIndex;\n}\nreturn cupMap;\n}\nconst cupMap = createCupMap(gameState {\n    const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);\n    const tail = orderedListOfCups.splice(0, indexOfStartingCup);\n    orderedListOfCups.push(...tail);\n}\nexport function removeNext(linkedListOfCups: GameStateLinkedArray, cupToRemove: number) {\n    const nextCup = linkedListOfCups[cupToRemove];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cupToRemove, cup: ] = nextNextCup;\n    return nextCup;\n}\nexport function removeNextTwo(linkedListOfCups, cupToRemove) {\n    const nextCup = linkedListOfCups[cupToRemove];\n    const nex): number | undefined {\n        let nextCup = linkedListOfCups[cupToRemove];\n        let nextNextCup = linkedListOfCups[nextCup];\n        while (nextNextCup) {\n            nextCup = nextNex {\n    const nextCup = linkedListOfCups[cup];\n    const nextNextCup = linkedListOfCups[nextCup];\n    linkedListOfCups[cup] = nextNextCup;\n    return nextCup;\n}\nexport function removeNextThree(linkedListOfCups: GameStateLinkedArray, cupToRemove) {\n    const nextCup = linkedListOfCups[cupToRemove];\n    const nex = linkedListOfCups[nextCup];\n    if (nex) {\n        const nextNextCup, cup: number;\n        return removeNextThree(linkedListOfCups, nextCup);\n    }\n}\nexport function removeNextFour(linkedListOfCups, cupToRemove) {\n    const nextCup = linkedListOfCup): number | undefined {\n        let nextCup = linkedListOfCups[cupToRemove];\n        let nextNextCup = linkedListOfCups[nextCup];\n        while (nextNextCup) {\n            nextCup = next {\n    return [\n        removeNext(linkedListOfCups, cup),\n        removeNext(linkedListOfCups, cup),\n        removeNext(linkedListOfCups, cup)\n    ];\n}\nexport function insertNext(linkedListOfCups: GameStateLinkedArray, cup: number, insertedCup: number) {\n    const nextCup = linkedListOfCups[cup];\n    linkedListOfCups[cup] = insertedCup;\n    linkedListOfCups[inserted, cup: ] = nextCup;\n}\nexport function insertNextTwo(linkedListOfCups, cup, insertedCup) {\n    const nextCup = linkedListOfCups[cup];\n    linkedListOfCups[cup, insertedCup: ] = nextCup;\n    return [\n        removeNext(linkedListOfCups, nextCup),\n        removeNext(linkedListOfCups, nextCup),\n        removeNext(linkedListOfCups, nextCu): number | undefined {\n    let nextCup = linkedListOfCups[cupToRemove];\n    let nextNextCup = linkedListOfCups[nextCup];\n    if (nextNextCup) {\n        const nextNextNextCu {\n    const nextCup = linkedListOfCups[cup];\n    linkedListOfCups[cup] = insertedCup;\n    linkedListOfCups[insertedCup] = nextCup;\n}\nexport function insertNextThree(linkedListOfCups: GameStateLinkedArray, cupToRemove, insertedCup) {\n    const nextCup = linkedListOfCups[cupToRemove];\n    const nextNextCup = linkedListOfCups[nextCup];\n    if (nextNextCu, cup: number | undefined {\n        const nextCup = linkedListOfCups[cupToRemove];\n        const nextNextNextCup = linkedListOfCups[nextCup];\n        if (nextNextNextCup) {\n            return [\n                remov, insertedCups: [\n                    removeNext(linkedListOfCups, cup),\n                    removeNext(linkedListOfCups, cup),\n                    removeNext(linkedListOfCups, cup)\n                ]\n            ];\n        }\n    }): undefined {\n        return insertNextThree(linkedListOfCups, cupToRemove, insertedCup);\n    }\n}\n}\nfunction removeNextThree(cups: GameStateCupArray, cupToRemove: number) { {\n    insertedCups.reverse().forEach((insertedCup: number) => {\n        removeNext(cups, cupToRemove, insertedCup);\n    });\n}\nfunction removeNext(cups: GameStateCupArray, cupToRemove: number, insertedCup: number) {): number | undefined {\n    const nextCup = cups[cupToRemove];\n    if (nextCup) {\n        cups[cupToRemove] = cups[nextCup];\n        if (nextCup > 0) => {\n        insertNext(linkedListOfCups, cup, insertedCup);\n    });\n}\nexport function playRoundLinkedArray(gameState: GameStateLinkedArray, currentCup: number) {\n    const nextThree = removeNextThree(gameState.cups, currentCup); //?\n    let destinationCup = currentCup;\n    do {\n        destinationCup -=): number | undefined {\n            const nextThree = removeNextThree(gameState.cups, destinationCup); //?\n            if (nextThree.includes(destinationCup)) {\n                return destinationCup;\n            }\n            if (nextThre {\n    const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?\n    let destinationCup = gameState.currentCup;\n    do {\n        destinationCup -= 1;\n        if (destinationCup === 0) {\n            destinationCup = gameState.maxCup;\n        }\n    } while (nextThree.includes(destinationCup));\n    insertNextThree(gameState.cups, destinationCup, nextThree);\n    gameState.currentCup = gameState.cups[gameState.currentCup];\n}\nexport function playXRoundLinkedArray(gameState: GameStateLinkedArray, currentCup: number) {\n    const nextThree = removeNextThree(gameState.cups, currentCup); //?\n    let destinationCup = currentCup;\n    do {\n        destinationCup -=, numberOfRounds: number) {\n            const nextThree = removeNextThree(gameState.cups, destinationCup); //?\n            if (nextThree.includes(destinationCup)) {\n                return destinationCup;\n            }\n            if (nextThree): Array<number> {\n                const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?\n                let destinationCup = gameState.currentCup;\n                do {\n                    destinationCup -= 1 {\n    for (let i = 0; i < numberOfRounds; i++) {\n        playRoundLinkedArray(gameState);\n    }\n}\nexport function getStars(input: number) {\n    const cups = input.split(\"\").map((i) => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const macCups = 1000, numberOfRounds: number) {\n    const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?\n    let destinationCup = gameState.currentCup;\n    do {\n        destinationCup -= 1;\n        i): Array<number> {\n            if (nextThree.includes(destinationCup)) {\n                return destinationCup;\n            }\n            if (nextThree): Array<number> {\n                const nextThree = removeNextThree(gameState.cup {\n    const cups = input.split(\"\").map((i: number) => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const macCups = 1000000;\n    const maxCupsFromFile = Math.max(..): number) {\n    const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?\n    let destinationCup = gameState.currentCup;\n    do {\n        destinationCup -= 1; => parseInt(i)); //?\n    const linkedCups = convertToLinkedArray(cups); //?.\n    const macCups = 1000000;\n    const maxCupsFromFile = Math.max(...cups);\n    let lastCup = cups[cups.length - 1];\n    for (let i = maxCupsFromFile + 1; i <= macCups; i++) {\n        insertNext(linkedCups, lastCup, i);\n        lastCup = i;\n    }\n    const gameState = {\n        cups: linkedCups,\n        currentCup: cups[0],\n        maxCup: macCups\n    };\n    playXRoundLinkedArray(gameState, numberOfRounds);\n    const nextCup1 = gameState.cups[1];\n    const nextCup2 = gameState.cups[nextCup1];\n    return nextCup1 * nextCup2;\n}\n","score":364,"fallbacked":false,"num_type_errors":338}]}
{"dataset_elem":{"alphanum_fraction":0.5529470529,"avg_line_length":27.4246575342,"content":"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nexport default function wrapAnsiString(\n  string: string,\n  terminalWidth: number,\n): string {\n  if (terminalWidth === 0) {\n    // if the terminal width is zero, don't bother word-wrapping\n    return string;\n  }\n\n  const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/gu;\n  const tokens = [];\n  let lastIndex = 0;\n  let match;\n\n  while ((match = ANSI_REGEXP.exec(string))) {\n    const ansi = match[0];\n    const index = match['index'];\n    if (index != lastIndex) {\n      tokens.push(['string', string.slice(lastIndex, index)]);\n    }\n    tokens.push(['ansi', ansi]);\n    lastIndex = index + ansi.length;\n  }\n\n  if (lastIndex != string.length - 1) {\n    tokens.push(['string', string.slice(lastIndex, string.length)]);\n  }\n\n  let lastLineLength = 0;\n\n  return tokens\n    .reduce(\n      (lines, [kind, token]) => {\n        if (kind === 'string') {\n          if (lastLineLength + token.length > terminalWidth) {\n            while (token.length) {\n              const chunk = token.slice(0, terminalWidth - lastLineLength);\n              const remaining = token.slice(\n                terminalWidth - lastLineLength,\n                token.length,\n              );\n              lines[lines.length - 1] += chunk;\n              lastLineLength += chunk.length;\n              token = remaining;\n              if (token.length) {\n                lines.push('');\n                lastLineLength = 0;\n              }\n            }\n          } else {\n            lines[lines.length - 1] += token;\n            lastLineLength += token.length;\n          }\n        } else {\n          lines[lines.length - 1] += token;\n        }\n\n        return lines;\n      },\n      [''],\n    )\n    .join('\\n');\n}\n","content_without_annotations":"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nexport default function wrapAnsiString(\n  string,\n  terminalWidth,\n) {\n  if (terminalWidth === 0) {\n    // if the terminal width is zero, don't bother word-wrapping\n    return string;\n  }\n\n  const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/gu;\n  const tokens = [];\n  let lastIndex = 0;\n  let match;\n\n  while ((match = ANSI_REGEXP.exec(string))) {\n    const ansi = match[0];\n    const index = match['index'];\n    if (index != lastIndex) {\n      tokens.push(['string', string.slice(lastIndex, index)]);\n    }\n    tokens.push(['ansi', ansi]);\n    lastIndex = index + ansi.length;\n  }\n\n  if (lastIndex != string.length - 1) {\n    tokens.push(['string', string.slice(lastIndex, string.length)]);\n  }\n\n  let lastLineLength = 0;\n\n  return tokens\n    .reduce(\n      (lines, [kind, token]) => {\n        if (kind === 'string') {\n          if (lastLineLength + token.length > terminalWidth) {\n            while (token.length) {\n              const chunk = token.slice(0, terminalWidth - lastLineLength);\n              const remaining = token.slice(\n                terminalWidth - lastLineLength,\n                token.length,\n              );\n              lines[lines.length - 1] += chunk;\n              lastLineLength += chunk.length;\n              token = remaining;\n              if (token.length) {\n                lines.push('');\n                lastLineLength = 0;\n              }\n            }\n          } else {\n            lines[lines.length - 1] += token;\n            lastLineLength += token.length;\n          }\n        } else {\n          lines[lines.length - 1] += token;\n        }\n\n        return lines;\n      },\n      [''],\n    )\n    .join('\\n');\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":509,"ext":"ts","fun_ann_density":0.0117878193,"function_parameters":4,"function_signatures":0,"function_usages":0,"functions":2,"hexsha":"6a6db4d3da5521347d2bbadd27ec0c2d62649284","lang":"TypeScript","loc":56,"loc_per_function":37.5,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-01-29T22:58:26.000Z","max_forks_repo_forks_event_min_datetime":"2022-01-29T22:58:26.000Z","max_forks_repo_head_hexsha":"006d9f40742cf03117b4b527a8f98c2bf10e38d0","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"F3n67u/jest","max_forks_repo_path":"packages/jest-reporters/src/wrapAnsiString.ts","max_issues_count":5.0,"max_issues_repo_head_hexsha":"368eefd8637ff90f2eecc7238995776f586dcbbe","max_issues_repo_issues_event_max_datetime":"2022-03-29T00:22:20.000Z","max_issues_repo_issues_event_min_datetime":"2022-03-27T00:22:17.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"michalwarda/jest","max_issues_repo_path":"packages/jest-reporters/src/wrapAnsiString.ts","max_line_length":75,"max_stars_count":null,"max_stars_repo_head_hexsha":"368eefd8637ff90f2eecc7238995776f586dcbbe","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"michalwarda/jest","max_stars_repo_path":"packages/jest-reporters/src/wrapAnsiString.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2552708115,"predefined_density":0.2,"predefined_types":3,"prop_ann_density":0.0,"property_declarations":0,"size":2002,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0176817289,"variable_declarations":9},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nexport default function wrapAnsiString(string: string, terminalWidth: number) {\n    if (terminalWidth === 0) {\n        // if the terminal width is zero, don't bother word-wrapping\n        return string;\n    }\n    const ANSI_REGEXP = /[\\, terminalWidth: \\d]+m/gu;\n    const tokens = [];\n    let lastIndex = 0;\n    let match;\n    while ((match = ANSI_REGEXP.exec(string))) {\n        const ansi = match[0];\n        const index): number = ANSI_REGEXP.lastIndex;\n        if (index!= lastIndex) {\n            tokens.push([\"string\", string.slice(lastIndex, index)]);\n        }\n        tokens.push([\"ansi\", ansi]);\n        lastIndex = index + ans {\n    if (terminalWidth === 0) {\n        // if the terminal width is zero, don't bother word-wrapping\n        return string;\n    }\n    const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/gu;\n    const tokens = [];\n    let lastIndex = 0;\n    let match;\n    while ((match = ANSI_REGEXP.exec(string))) {\n        const ansi = match[0];\n        const index = match[\"index\"];\n        if (index != lastIndex) {\n            tokens.push([\"string\", string.slice(lastIndex, index)]);\n        }\n        tokens.push([\"ansi\", ansi]);\n        lastIndex = index + ansi.length;\n    }\n    if (lastIndex != string.length - 1) {\n        tokens.push([\"string\", string.slice(lastIndex, string.length)]);\n    }\n    let lastLineLength = 0;\n    return tokens\n        .reduce((lines: string[], [kind, token]) => {\n            if (kind === \"string\") {\n                if (lastLineLength + token.length > terminalWidth) {\n                    const chunk = token.slice(0, terminalWidth - lastLineLength), [kind, token]: [kind, token] = [\"ansi\", token.slice(0, terminalWidth - lastLineLength)];\n                    if (token.length > terminalWidth) {\n                        lines.push(chunk + token.slice(terminalWidth - lastLineLengt): [kind, token];\n                    } else {\n                        lines.push(chunk);\n                    }\n                    lastLineLength = chunk.length;\n                } else {\n                    lines.push(token);\n                    lastLineLength += token.length;\n                } => {\n        if (kind === \"string\") {\n            if (lastLineLength + token.length > terminalWidth) {\n                while (token.length) {\n                    const chunk = token.slice(0, terminalWidth - lastLineLength);\n                    const remaining = token.slice(terminalWidth - lastLineLength, token.length);\n                    lines[lines.length - 1] += chunk;\n                    lastLineLength += chunk.length;\n                    token = remaining;\n                    if (token.length) {\n                        lines.push(\"\");\n                        lastLineLength = 0;\n                    }\n                }\n            }\n            else {\n                lines[lines.length - 1] += token;\n                lastLineLength += token.length;\n            }\n        }\n        else {\n            lines[lines.length - 1] += token;\n        }\n        return lines;\n    }, [\"\"])\n        .join(\"\\n\");\n}\n","score":370,"fallbacked":false,"num_type_errors":16},{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nexport default function wrapAnsiString(string: string, terminalWidth: number) {\n    if (terminalWidth === 0) {\n        // if the terminal width is zero, don't bother word-wrapping\n        return string;\n    }\n    const ANSI_REGEXP = /[\\, terminalWidth: (\\d+)\\]/;\n    const tokens = [];\n    let lastIndex = 0;\n    let match;\n    while ((match = ANSI_REGEXP.exec(string))) {\n        const ansi = match[0];\n        const index = match[): string;\n        if (index!= lastIndex) {\n            tokens.push([\"string\", string.slice(lastIndex, index)]);\n        }\n        tokens.push([\"ansi\", ansi]);\n        lastIndex = index + ansi.length;\n    } {\n    if (terminalWidth === 0) {\n        // if the terminal width is zero, don't bother word-wrapping\n        return string;\n    }\n    const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/gu;\n    const tokens = [];\n    let lastIndex = 0;\n    let match;\n    while ((match = ANSI_REGEXP.exec(string))) {\n        const ansi = match[0];\n        const index = match[\"index\"];\n        if (index != lastIndex) {\n            tokens.push([\"string\", string.slice(lastIndex, index)]);\n        }\n        tokens.push([\"ansi\", ansi]);\n        lastIndex = index + ansi.length;\n    }\n    if (lastIndex != string.length - 1) {\n        tokens.push([\"string\", string.slice(lastIndex, string.length)]);\n    }\n    let lastLineLength = 0;\n    return tokens\n        .reduce((lines: string[], [kind, token]) => {\n            if (kind === \"string\") {\n                lines[lines.length - 1] += token;\n                lastLineLength += token.length;\n                return lines;\n            } else if (kin, [kind, token]: [string, string]) {\n                lines.push(token);\n                lastLineLength += token.length;\n                return lines;\n            } else if (kin, kind === \"ansi\") {\n                const ansiIndex = string.indexOf(ans): number;\n                if (ansiIndex === -1) {\n                    throw new Error(\"Cannot parse ansi code\");\n                }\n                const chunk = string.slice(lastLineLength, ansiIndex + 1);\n                lastLineLength += chun => {\n        if (kind === \"string\") {\n            if (lastLineLength + token.length > terminalWidth) {\n                while (token.length) {\n                    const chunk = token.slice(0, terminalWidth - lastLineLength);\n                    const remaining = token.slice(terminalWidth - lastLineLength, token.length);\n                    lines[lines.length - 1] += chunk;\n                    lastLineLength += chunk.length;\n                    token = remaining;\n                    if (token.length) {\n                        lines.push(\"\");\n                        lastLineLength = 0;\n                    }\n                }\n            }\n            else {\n                lines[lines.length - 1] += token;\n                lastLineLength += token.length;\n            }\n        }\n        else {\n            lines[lines.length - 1] += token;\n        }\n        return lines;\n    }, [\"\"])\n        .join(\"\\n\");\n}\n","score":429,"fallbacked":false,"num_type_errors":42},{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nexport default function wrapAnsiString(string: string, terminalWidth: number, terminalWidth: number): string {\n    // If the string is not long enough to be wrapped, then just return it.\n    if (terminalWidth === 0) {\n        return string;\n    }\n    const ANSI_REGEXP = /\\u001): /gu;\n    const tokens = [];\n    let lastIndex = 0;\n    let match;\n    while ((match = ANSI_REGEXP.exec(string))) {\n        const ansi = match[0];\n        const index = match[\"index\"] {\n    if (terminalWidth === 0) {\n        // if the terminal width is zero, don't bother word-wrapping\n        return string;\n    }\n    const ANSI_REGEXP = /[\\u001b\\u009b]\\[\\d{1,2}m/gu;\n    const tokens = [];\n    let lastIndex = 0;\n    let match;\n    while ((match = ANSI_REGEXP.exec(string))) {\n        const ansi = match[0];\n        const index = match[\"index\"];\n        if (index != lastIndex) {\n            tokens.push([\"string\", string.slice(lastIndex, index)]);\n        }\n        tokens.push([\"ansi\", ansi]);\n        lastIndex = index + ansi.length;\n    }\n    if (lastIndex != string.length - 1) {\n        tokens.push([\"string\", string.slice(lastIndex, string.length)]);\n    }\n    let lastLineLength = 0;\n    return tokens\n        .reduce((lines: string[], [kind, token]) => {\n            if (kind === \"string\") {\n                if (lastLineLength + token.length > terminalWidth) {\n                    while (token.length) {\n                        const chunk = token.slice(, [kind, token]: [string, string] => [string, string]);\n                        lines.push(chunk[0]);\n                        lastLineLength += chunk[0].length;\n                    }\n                } else {\n                    lines.push(token);\n                    lastLineLength += toke): [string, string] => [string, string];\n                }\n            } else if (kind === \"ansi\") {\n                lines.push(token);\n                lastLineLength += token.length;\n            }\n            return lines;\n        }, []) => {\n        if (kind === \"string\") {\n            if (lastLineLength + token.length > terminalWidth) {\n                while (token.length) {\n                    const chunk = token.slice(0, terminalWidth - lastLineLength);\n                    const remaining = token.slice(terminalWidth - lastLineLength, token.length);\n                    lines[lines.length - 1] += chunk;\n                    lastLineLength += chunk.length;\n                    token = remaining;\n                    if (token.length) {\n                        lines.push(\"\");\n                        lastLineLength = 0;\n                    }\n                }\n            }\n            else {\n                lines[lines.length - 1] += token;\n                lastLineLength += token.length;\n            }\n        }\n        else {\n            lines[lines.length - 1] += token;\n        }\n        return lines;\n    }, [\"\"])\n        .join(\"\\n\");\n}\n","score":380,"fallbacked":false,"num_type_errors":69}]}
{"dataset_elem":{"alphanum_fraction":0.6319444444,"avg_line_length":25.1428571429,"content":"interface Time {\n  hours: number\n  minutes: number\n}\n\nexport const parseTime = (time: string): null | Time => {\n  const values = (time || '').split(':')\n  if (values.length >= 2) {\n    let hours = Number.parseInt(values[0], 10)\n    const minutes = Number.parseInt(values[1], 10)\n    const timeUpper = time.toUpperCase()\n    if (timeUpper.includes('AM') && hours === 12) {\n      hours = 0\n    } else if (timeUpper.includes('PM') && hours !== 12) {\n      hours += 12\n    }\n    return {\n      hours,\n      minutes,\n    }\n  }\n\n  return null\n}\n\nexport const compareTime = (time1: string, time2: string): number => {\n  const value1 = parseTime(time1)\n  if (!value1) return -1\n  const value2 = parseTime(time2)\n  if (!value2) return -1\n  const minutes1 = value1.minutes + value1.hours * 60\n  const minutes2 = value2.minutes + value2.hours * 60\n  if (minutes1 === minutes2) {\n    return 0\n  }\n  return minutes1 > minutes2 ? 1 : -1\n}\n\nexport const padTime = (time: number | string) => {\n  return `${time}`.padStart(2, '0')\n}\nexport const formatTime = (time: Time): string => {\n  return `${padTime(time.hours)}:${padTime(time.minutes)}`\n}\n\nexport const nextTime = (time: string, step: string): string => {\n  const timeValue = parseTime(time)\n  if (!timeValue) return ''\n\n  const stepValue = parseTime(step)\n  if (!stepValue) return ''\n\n  const next = {\n    hours: timeValue.hours,\n    minutes: timeValue.minutes,\n  }\n  next.minutes += stepValue.minutes\n  next.hours += stepValue.hours\n  next.hours += Math.floor(next.minutes / 60)\n  next.minutes = next.minutes % 60\n  return formatTime(next)\n}\n","content_without_annotations":"interface Time {\n  hours\n  minutes\n}\n\nexport const parseTime = (time) => {\n  const values = (time || '').split(':')\n  if (values.length >= 2) {\n    let hours = Number.parseInt(values[0], 10)\n    const minutes = Number.parseInt(values[1], 10)\n    const timeUpper = time.toUpperCase()\n    if (timeUpper.includes('AM') && hours === 12) {\n      hours = 0\n    } else if (timeUpper.includes('PM') && hours !== 12) {\n      hours += 12\n    }\n    return {\n      hours,\n      minutes,\n    }\n  }\n\n  return null\n}\n\nexport const compareTime = (time1, time2) => {\n  const value1 = parseTime(time1)\n  if (!value1) return -1\n  const value2 = parseTime(time2)\n  if (!value2) return -1\n  const minutes1 = value1.minutes + value1.hours * 60\n  const minutes2 = value2.minutes + value2.hours * 60\n  if (minutes1 === minutes2) {\n    return 0\n  }\n  return minutes1 > minutes2 ? 1 : -1\n}\n\nexport const padTime = (time) => {\n  return `${time}`.padStart(2, '0')\n}\nexport const formatTime = (time) => {\n  return `${padTime(time.hours)}:${padTime(time.minutes)}`\n}\n\nexport const nextTime = (time, step) => {\n  const timeValue = parseTime(time)\n  if (!timeValue) return ''\n\n  const stepValue = parseTime(step)\n  if (!stepValue) return ''\n\n  const next = {\n    hours: timeValue.hours,\n    minutes: timeValue.minutes,\n  }\n  next.minutes += stepValue.minutes\n  next.hours += stepValue.hours\n  next.hours += Math.floor(next.minutes / 60)\n  next.minutes = next.minutes % 60\n  return formatTime(next)\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":489,"ext":"ts","fun_ann_density":0.0245398773,"function_parameters":7,"function_signatures":0,"function_usages":3,"functions":5,"hexsha":"c6f7caaa0590e6613ea1d397ac2df028f848091b","lang":"TypeScript","loc":55,"loc_per_function":8.2,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"efd6c2b2a7ccacf48bb847264bbda0156568a149","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"yhuijune/analyse-element-plus","max_forks_repo_path":"packages/components/time-select/src/utils.ts","max_issues_count":3.0,"max_issues_repo_head_hexsha":"efd6c2b2a7ccacf48bb847264bbda0156568a149","max_issues_repo_issues_event_max_datetime":"2022-03-14T21:43:33.000Z","max_issues_repo_issues_event_min_datetime":"2022-03-13T20:43:36.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"yhuijune/analyse-element-plus","max_issues_repo_path":"packages/components/time-select/src/utils.ts","max_line_length":70,"max_stars_count":null,"max_stars_repo_head_hexsha":"efd6c2b2a7ccacf48bb847264bbda0156568a149","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"yhuijune/analyse-element-plus","max_stars_repo_path":"packages/components/time-select/src/utils.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.3379420313,"predefined_density":0.4,"predefined_types":12,"prop_ann_density":0.0040899796,"property_declarations":2,"size":1584,"trivial_density":0.0,"trivial_types":0,"type_definitions":1,"typedef_density":0.0020449898,"var_ann_density":0.0327198364,"variable_declarations":16},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"interface Time {\n    hours: number;\n    minutes: number;\n    minutes: number;\n}\nexport interface TimeStep {\n    minutes: number;\n    hours: number;\n}\nexport interface TimeStepList {\n    [key: string]: TimeStep;\n}\nexport interface TimeStepList {\n    [ke;\n}\nexport const parseTime = (time: string): Time | null => {\n    if (!time) {\n        return null;\n    }\n    if (time.length < 5) {\n        return null;\n    }\n    const hours = Number.parseInt(time.substr(0, => {\n    const values = (time || \"\").split(\":\");\n    if (values.length >= 2) {\n        let hours = Number.parseInt(values[0], 10);\n        const minutes = Number.parseInt(values[1], 10);\n        const timeUpper = time.toUpperCase();\n        if (timeUpper.includes(\"AM\") && hours === 12) {\n            hours = 0;\n        }\n        else if (timeUpper.includes(\"PM\") && hours !== 12) {\n            hours += 12;\n        }\n        return {\n            hours,\n            minutes,\n        };\n    }\n    return null;\n};\nexport const compareTime = (time1: Time, time2: Time): number => {\n    if (time1 === time2) {\n        return 0;\n    }\n    if (!time1 ||!time2) {\n        return -1;\n    }\n    const hours1, time2: Time = parseTime(time1);\n    const hours2, time2: Time = parseTime(time2);\n    if (!hours1 &&!hours2) {\n        return 0;\n    }\n    if (!hours1 ||!hour): {\n        return 1;\n    }\n    if (!hours2 ||!hour): {\n        return -1;\n    }\n    if (hours1.hours!== hours2.hours) {\n        return hours1.hours > hours2.hour => {\n    const value1 = parseTime(time1);\n    if (!value1)\n        return -1;\n    const value2 = parseTime(time2);\n    if (!value2)\n        return -1;\n    const minutes1 = value1.minutes + value1.hours * 60;\n    const minutes2 = value2.minutes + value2.hours * 60;\n    if (minutes1 === minutes2) {\n        return 0;\n    }\n    return minutes1 > minutes2 ? 1 : -1;\n};\nexport const padTime = (time: Time) => {\n    const hour = time.hours;\n    const minutes = time.minutes;\n    if (hour === 0) {\n        if (minutes === 0) {\n            return \"00:00\";\n        }): if (minutes === 30) {\n            return \"00:30\";\n        } else if (minutes === 45) {\n            return \"00:45\";\n        } else {\n            return \"00\"; => {\n    return `${time}`.padStart(2, \"0\");\n};\nexport const formatTime = (time: Time) => {\n    if (time) {\n        const hours = time.hours;\n        const minutes = time.minutes;\n        const hourString = padTime(time);\n        const minuteString = padTime(time);\n        if (hour): if (minutes === 0) {\n            return `${hourString}:00`;\n        } else if (minutes === 30) {\n            return `${hourString}:30`;\n        } else if (minutes === 45) => {\n    return `${padTime(time.hours)}:${padTime(time.minutes)}`;\n};\nexport const nextTime = (time: Time) => {\n    const next = parseTime(time);\n    if (!next)\n        return \"\";\n    next.hours += 1;\n    if (next.hours === 24) {\n        next.hours = 0;, step: 60;\n    }\n    return formatTime(next);\n};\nexport const prevTime = (time: Time, step: Time): string => {\n    const prev = parseTime(time);\n    if (!prev)\n        return \"\";\n    prev.hours -= 1;\n    if (prev.hours === -1) {\n        prev.hours = 23;\n        pre => {\n    const timeValue = parseTime(time);\n    if (!timeValue)\n        return \"\";\n    const stepValue = parseTime(step);\n    if (!stepValue)\n        return \"\";\n    const next = {\n        hours: timeValue.hours,\n        minutes: timeValue.minutes,\n    };\n    next.minutes += stepValue.minutes;\n    next.hours += stepValue.hours;\n    next.hours += Math.floor(next.minutes / 60);\n    next.minutes = next.minutes % 60;\n    return formatTime(next);\n};\n","score":309,"fallbacked":false,"num_type_errors":34},{"code":"interface Time {\n    hours: number;\n    minutes: number;\n    minutes: number;\n}\nexport interface TimeOptions {\n    is24Hour: boolean;\n}\nexport const parseTime = (time: string): Time => {\n    if (!time ||!time.trim()) {\n        return null;\n    }\n    if (time.match(/^\\d{2}:\\d{2}$/)) {\n        return {\n            hours: Number.parseInt(tim => {\n    const values = (time || \"\").split(\":\");\n    if (values.length >= 2) {\n        let hours = Number.parseInt(values[0], 10);\n        const minutes = Number.parseInt(values[1], 10);\n        const timeUpper = time.toUpperCase();\n        if (timeUpper.includes(\"AM\") && hours === 12) {\n            hours = 0;\n        }\n        else if (timeUpper.includes(\"PM\") && hours !== 12) {\n            hours += 12;\n        }\n        return {\n            hours,\n            minutes,\n        };\n    }\n    return null;\n};\nexport const compareTime = (time1: Time, time2: Time) => {\n    const value1 = parseTime(time1);\n    if (!value1)\n        return -1;\n    const value2 = parseTime(time2);\n    if (!value2)\n        retur, time2: any;\n    const minutes1 = value1.minutes + value1.hours * 60;\n    const minutes2 = value2.minutes + value2.hours * 60;\n    if (minutes1 === minutes2)): {\n        return 0;\n    }\n    return minutes1 > minutes2? 1 : -1;\n};\nexport const padTime = (time: number) => {\n    return `${time}`.padStart(2, \"0\") => {\n    const value1 = parseTime(time1);\n    if (!value1)\n        return -1;\n    const value2 = parseTime(time2);\n    if (!value2)\n        return -1;\n    const minutes1 = value1.minutes + value1.hours * 60;\n    const minutes2 = value2.minutes + value2.hours * 60;\n    if (minutes1 === minutes2) {\n        return 0;\n    }\n    return minutes1 > minutes2 ? 1 : -1;\n};\nexport const padTime = (time: Time) => {\n    if (time.hours === 0) {\n        return \"12:00\";\n    }\n    if (time.hours === 12) {\n        return \"12:00 AM\";): {\n        if (time.minutes === 0) {\n            return \"00:00\";\n        }\n        else if (time.minutes === 1) {\n            return \"00:10\";\n        }\n        else if => {\n    return `${time}`.padStart(2, \"0\");\n};\nexport const formatTime = (time: Time) => {\n    return `${padTime(time.hours)}:${padTime(time.minutes)}`;\n};\nexport const parseTime = (time: string) => {\n    const timeUpper = time.toUpperCase();\n    if): (timeUpper === \"AM\") {\n        return {\n            hours: 0,\n            minutes: 0,\n        };\n    }\n    else if (timeUpper === \"PM\") {\n        return {\n            hours: 12,\n            minute => {\n    return `${padTime(time.hours)}:${padTime(time.minutes)}`;\n};\nexport const nextTime = (time: Time) => {\n    if (time.hours === 12) {\n        time.hours = 0;\n    }\n    else if (time.hours === 0) {\n        time.hours = 12;\n    }, step: 12 * 60;\n    }\n    else {\n        time.hours += 1;\n    }\n    return time;\n};\nexport const nextTime = (time: Time) => {\n    if (time.hours ===): {\n        time.hours = 12;\n    }\n    else if (time.hours === 12) {\n        time.hours = 0;\n    }\n    else {\n        time.hours += 1;\n    }\n    retur => {\n    const timeValue = parseTime(time);\n    if (!timeValue)\n        return \"\";\n    const stepValue = parseTime(step);\n    if (!stepValue)\n        return \"\";\n    const next = {\n        hours: timeValue.hours,\n        minutes: timeValue.minutes,\n    };\n    next.minutes += stepValue.minutes;\n    next.hours += stepValue.hours;\n    next.hours += Math.floor(next.minutes / 60);\n    next.minutes = next.minutes % 60;\n    return formatTime(next);\n};\n","score":326,"fallbacked":false,"num_type_errors":48},{"code":"interface Time {\n    hours: number;\n    minutes: number;\n    minutes: number;\n}\nexport interface Schedule {\n    id: number;\n    time: Time;\n    text: string;\n}\nexport interface ScheduleService {\n    create(time, text) {\n        return create(time, text);;\n}\nexport const parseTime = (time: string): Schedule => {\n    const values = (time || \"\").split(\":\");\n    if (values.length >= 2) {\n        let hours = Number.parseInt(values[0], 10);\n        const minutes = Number.parseInt(values => {\n    const values = (time || \"\").split(\":\");\n    if (values.length >= 2) {\n        let hours = Number.parseInt(values[0], 10);\n        const minutes = Number.parseInt(values[1], 10);\n        const timeUpper = time.toUpperCase();\n        if (timeUpper.includes(\"AM\") && hours === 12) {\n            hours = 0;\n        }\n        else if (timeUpper.includes(\"PM\") && hours !== 12) {\n            hours += 12;\n        }\n        return {\n            hours,\n            minutes,\n        };\n    }\n    return null;\n};\nexport const compareTime = (time1: string, time2: string) => {\n    const value1 = parseTime(time1);\n    if (!value1)\n        return -1;\n    const value2 = parseTime(time2);\n    if (!value2)\n        retur, time2: number;\n    const minutes1 = value1.minutes + value1.hours * 60;\n    const minutes2 = value2.minutes + value2.hours * 60;\n    if (minutes1 === minutes2)): {\n        return 0;\n    }\n    return minutes1 > minutes2? 1 : -1;\n};\nexport const compareScheduleTime = (time1: Schedule, time2: Schedule) => {\n    const value1 = pars => {\n    const value1 = parseTime(time1);\n    if (!value1)\n        return -1;\n    const value2 = parseTime(time2);\n    if (!value2)\n        return -1;\n    const minutes1 = value1.minutes + value1.hours * 60;\n    const minutes2 = value2.minutes + value2.hours * 60;\n    if (minutes1 === minutes2) {\n        return 0;\n    }\n    return minutes1 > minutes2 ? 1 : -1;\n};\nexport const padTime = (time: string, step: string) => {\n    const value = parseTime(time);\n    if (!value)\n        return \"\";\n    const stepValue = parseTime(step);\n    if (!stepValue)\n        return \"\";\n    const next = {): unknown};\n    const stepMinutes = stepValue.minutes + stepValue.hours * 60;\n    if (stepValue.minutes > 0) {\n        if (stepValue.minutes < 10) {\n            next.minute => {\n    return `${time}`.padStart(2, \"0\");\n};\nexport const formatTime = (time: number) => {\n    const timeValue = parseTime(time);\n    if (!timeValue)\n        return \"\";\n    return `${padTime(timeValue.hours)}:${padTime(timeValue.minutes)}`;\n};\nexport const nex): string => {\n    return time => {\n        const value = parseTime(time);\n        if (!value)\n            return \"\";\n        if (value.hours === 0) {\n            if (value.minutes === 0) {\n                return => {\n    return `${padTime(time.hours)}:${padTime(time.minutes)}`;\n};\nexport const nextTime = (time: Schedule) => {\n    const next = {\n        hours: 0,\n        minutes: 0,\n    };\n    const nextMinutes = next.minutes + next.hours * 60;\n    if (nextMinutes > 0), step: \"00\";\n    return formatTime(next);\n};\n};\nreturn formatTime(time);\n};\n};\nreturn formatTime(time);\n};\n};\nexport const next = (time: Schedule, step: strin): string => {\n    const timeValue = parseTime(time);\n    if (!timeValue)\n        return \"\";\n    const stepValue = parseTime(step);\n    if (!stepValue)\n        return \"\";\n    const next = {\n        hours: tim => {\n    const timeValue = parseTime(time);\n    if (!timeValue)\n        return \"\";\n    const stepValue = parseTime(step);\n    if (!stepValue)\n        return \"\";\n    const next = {\n        hours: timeValue.hours,\n        minutes: timeValue.minutes,\n    };\n    next.minutes += stepValue.minutes;\n    next.hours += stepValue.hours;\n    next.hours += Math.floor(next.minutes / 60);\n    next.minutes = next.minutes % 60;\n    return formatTime(next);\n};\n","score":352,"fallbacked":false,"num_type_errors":55}]}
{"dataset_elem":{"alphanum_fraction":0.6082568807,"avg_line_length":27.0807453416,"content":"interface PQEntry<K> {\n  key: K;\n  priority: number;\n}\n\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nexport class PriorityQueue<K> {\n  private readonly _arr: PQEntry<K>[];\n  private readonly _keyIndices: Map<K, number>;\n\n  constructor() {\n    this._arr = [];\n    this._keyIndices = new Map();\n  }\n\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n  size(): number {\n    return this._arr.length;\n  }\n\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n  keys(): K[] {\n    return this._arr.map(x => x.key);\n  }\n\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n  has(key: K): boolean {\n    return this._keyIndices.has(key);\n  }\n\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   */\n  priority(key: K): number | undefined {\n    const index = this._keyIndices.get(key);\n    if(index !== undefined) {\n      return this._arr[index].priority;\n    }\n  }\n\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n  min(): K {\n    if(this.size() === 0) {\n      throw new Error('Queue underflow');\n    }\n    return this._arr[0].key;\n  }\n\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function does nothing and returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param key the key to add\n   * @param priority the initial priority for the key\n   */\n  add(key: K, priority: number): boolean {\n    const keyIndices = this._keyIndices;\n    if(!keyIndices.has(key)) {\n      const arr = this._arr;\n      const index = arr.length;\n      keyIndices.set(key, index);\n      arr.push({key: key, priority: priority});\n      this._decrease(index);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n  removeMin(): K {\n    this._swap(0, this._arr.length - 1);\n    const min = this._arr.pop()!;\n    this._keyIndices.delete(min.key);\n    this._heapify(0);\n    return min.key;\n  }\n\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param key the key for which to raise priority\n   * @param priority the new priority for the key\n   */\n  decrease(key: K, priority: number): void {\n    const index = this._keyIndices.get(key);\n\n    if(index === undefined)\n      throw new RangeError('Key out of range');\n\n    if(priority > this._arr[index].priority) {\n      throw new Error('New priority is greater than current priority. ' +\n          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);\n    }\n    this._arr[index].priority = priority;\n    this._decrease(index);\n  }\n\n  private _heapify(i: number): void {\n    const arr = this._arr;\n    const l = 2 * i;\n    const r = l + 1;\n    let largest = i;\n    if(l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n      if(r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n      if(largest !== i) {\n        this._swap(i, largest);\n        this._heapify(largest);\n      }\n    }\n  }\n\n  private _decrease(index: number): void {\n    const arr = this._arr;\n    const priority = arr[index].priority;\n    let parent: number;\n    while(index !== 0) {\n      // eslint-disable-next-line no-bitwise\n      parent = index >> 1;\n      if(arr[parent].priority < priority) {\n        break;\n      }\n      this._swap(index, parent);\n      index = parent;\n    }\n  }\n\n  private _swap(i: number, j: number): void {\n    const arr = this._arr;\n    const keyIndices = this._keyIndices;\n    const origArrI = arr[i];\n    const origArrJ = arr[j];\n    arr[i] = origArrJ;\n    arr[j] = origArrI;\n    keyIndices.set(origArrJ.key, i);\n    keyIndices.set(origArrI.key, j);\n  }\n}\n","content_without_annotations":"interface PQEntry<K> {\n  key;\n  priority;\n}\n\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nexport class PriorityQueue<K> {\n  private readonly _arr;\n  private readonly _keyIndices;\n\n  constructor() {\n    this._arr = [];\n    this._keyIndices = new Map();\n  }\n\n  /**\n   * Returns the number of elements in the queue. Takes `O(1)` time.\n   */\n  size() {\n    return this._arr.length;\n  }\n\n  /**\n   * Returns the keys that are in the queue. Takes `O(n)` time.\n   */\n  keys() {\n    return this._arr.map(x => x.key);\n  }\n\n  /**\n   * Returns `true` if **key** is in the queue and `false` if not.\n   */\n  has(key) {\n    return this._keyIndices.has(key);\n  }\n\n  /**\n   * Returns the priority for **key**. If **key** is not present in the queue\n   * then this function returns `undefined`. Takes `O(1)` time.\n   */\n  priority(key) {\n    const index = this._keyIndices.get(key);\n    if(index !== undefined) {\n      return this._arr[index].priority;\n    }\n  }\n\n  /**\n   * Returns the key for the minimum element in this queue. If the queue is\n   * empty this function throws an Error. Takes `O(1)` time.\n   */\n  min() {\n    if(this.size() === 0) {\n      throw new Error('Queue underflow');\n    }\n    return this._arr[0].key;\n  }\n\n  /**\n   * Inserts a new key into the priority queue. If the key already exists in\n   * the queue this function does nothing and returns `false`; otherwise it will return `true`.\n   * Takes `O(n)` time.\n   *\n   * @param key the key to add\n   * @param priority the initial priority for the key\n   */\n  add(key, priority) {\n    const keyIndices = this._keyIndices;\n    if(!keyIndices.has(key)) {\n      const arr = this._arr;\n      const index = arr.length;\n      keyIndices.set(key, index);\n      arr.push({key: key, priority: priority});\n      this._decrease(index);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n   */\n  removeMin() {\n    this._swap(0, this._arr.length - 1);\n    const min = this._arr.pop()!;\n    this._keyIndices.delete(min.key);\n    this._heapify(0);\n    return min.key;\n  }\n\n  /**\n   * Decreases the priority for **key** to **priority**. If the new priority is\n   * greater than the previous priority, this function will throw an Error.\n   *\n   * @param key the key for which to raise priority\n   * @param priority the new priority for the key\n   */\n  decrease(key, priority) {\n    const index = this._keyIndices.get(key);\n\n    if(index === undefined)\n      throw new RangeError('Key out of range');\n\n    if(priority > this._arr[index].priority) {\n      throw new Error('New priority is greater than current priority. ' +\n          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);\n    }\n    this._arr[index].priority = priority;\n    this._decrease(index);\n  }\n\n  private _heapify(i) {\n    const arr = this._arr;\n    const l = 2 * i;\n    const r = l + 1;\n    let largest = i;\n    if(l < arr.length) {\n      largest = arr[l].priority < arr[largest].priority ? l : largest;\n      if(r < arr.length) {\n        largest = arr[r].priority < arr[largest].priority ? r : largest;\n      }\n      if(largest !== i) {\n        this._swap(i, largest);\n        this._heapify(largest);\n      }\n    }\n  }\n\n  private _decrease(index) {\n    const arr = this._arr;\n    const priority = arr[index].priority;\n    let parent;\n    while(index !== 0) {\n      // eslint-disable-next-line no-bitwise\n      parent = index >> 1;\n      if(arr[parent].priority < priority) {\n        break;\n      }\n      this._swap(index, parent);\n      index = parent;\n    }\n  }\n\n  private _swap(i, j) {\n    const arr = this._arr;\n    const keyIndices = this._keyIndices;\n    const origArrI = arr[i];\n    const origArrJ = arr[j];\n    arr[i] = origArrJ;\n    arr[j] = origArrI;\n    keyIndices.set(origArrJ.key, i);\n    keyIndices.set(origArrI.key, j);\n  }\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":1248,"ext":"ts","fun_ann_density":0.0192307692,"function_parameters":11,"function_signatures":0,"function_usages":5,"functions":13,"hexsha":"8421a8d472765fd2992d131fb5bbc260d133ef72","lang":"TypeScript","loc":102,"loc_per_function":5.4615384615,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"4b603a04de1b9821ed4bc34383d22c7d66f15b4d","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"fluggo/graphlib","max_forks_repo_path":"packages/graphlib/lib/data/priority-queue.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"4b603a04de1b9821ed4bc34383d22c7d66f15b4d","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"fluggo/graphlib","max_issues_repo_path":"packages/graphlib/lib/data/priority-queue.ts","max_line_length":95,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"4b603a04de1b9821ed4bc34383d22c7d66f15b4d","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"fluggo/graphlib","max_stars_repo_path":"packages/graphlib/lib/data/priority-queue.ts","max_stars_repo_stars_event_max_datetime":"2022-02-01T01:34:34.000Z","max_stars_repo_stars_event_min_datetime":"2022-02-01T01:34:34.000Z","metric":0.262912904,"predefined_density":0.3777777778,"predefined_types":17,"prop_ann_density":0.0032051282,"property_declarations":4,"size":4360,"trivial_density":0.0,"trivial_types":0,"type_definitions":2,"typedef_density":0.0016025641,"var_ann_density":0.0136217949,"variable_declarations":17},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"interface PQEntry<K> {\n    key: K;\n    priority;\n}\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority;\n    priority: a key's priority. If a key appears in the queue prior to adding it to the queue, then the key with the smallest priority is returned. If there is no such key, then the key with the largest priority is returned.\n\n * Th;\n}\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nexport class PriorityQueue<K> {\n    private readonly _arr: PQEntry<K>[];\n    private _keyIndices: Map<K, number>;\n    constructor() {\n        this._arr = [];\n        this._keyIndices = new Map();\n    }\n    /**\n     * Returns `true` if the queu;\n    private readonly _keyIndices: Map<K, number>;\n     *\n     * @param key The key to search for.\n     */\n    contains(key) {\n        return this._keyIndices.has(key);\n    }\n    /**\n     * Inserts **key** int;\n    constructor() {\n        this._arr = [];\n        this._keyIndices = new Map();\n    }\n    /**\n     * Returns the number of elements in the queue. Takes `O(1)` time.\n     */\n    size(): number {\n        return this._arr.length;\n    }\n    /**\n     * Returns `undefined` if the queue is empty;\n     * `undefined` if the queue contains **key**. Takes `O(1)` time.\n     */ {\n        return this._arr.length;\n    }\n    /**\n     * Returns the keys that are in the queue. Takes `O(n)` time.\n     */\n    keys(): K[] {\n        return this._arr.map((x) => x.key);\n    }\n    /**\n     * Returns the value associated with **key**. If **key** is not\n     * present in the queue then this function returns {\n        return this._arr.map((x: PQEntry<K>) => x.value).find(x => x.key === key);\n     */\n    get(key) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined) {): any}\n        return this._arr[index].value;\n    }\n    /**\n     * Removes **key** from the queue. Takes `O(1)` time.\n     */\n    remove(key) {\n        const index = this._keyIndice => x.key);\n    }\n    /**\n     * Returns `true` if **key** is in the queue and `false` if not.\n     */\n    has(key: K) {\n        return this._keyIndices.has(key);\n    }\n    /**\n     * Returns the priority for **key**. If **key** is not present in the queue\n     * then this function returns {\n        return this._ar): any\n     */\n    priority(key) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined) {): any}\n        return this._arr[index].priority;\n    }\n    /**\n     * Return {\n        return this._keyIndices.has(key);\n    }\n    /**\n     * Returns the priority for **key**. If **key** is not present in the queue\n     * then this function returns `undefined`. Takes `O(1)` time.\n     */\n    priority(key: K) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined) {): any}\n        return this._arr[index].priority;\n    }\n    /**\n     * Inserts a new key into th): queue. If **key** already exists in the queue, the new key is overwritten.\n     */\n    add(key: K, priority?: number) {\n        if (this.has(key)) {\n            this._arr[this._ke {\n        const index = this._keyIndices.get(key);\n        if (index !== undefined) {\n            return this._arr[index].priority;\n        }\n    }\n    /**\n     * Returns the key for the minimum element in this queue. If the queue is\n     * empty this function throws an Error. Takes `O(1)` time.\n     */\n    min(): K {\n        if (this.size() === 0) {\n            throw new Error(\"Queue underflow\");\n        }\n        return this._arr[0].key;\n    }\n    /**\n     * Returns the key for the maximum element in thi {\n        if (this.size() === 0) {\n            throw new Error(\"Queue underflow\");\n        }\n        return this._arr[0].key;\n    }\n    /**\n     * Inserts a new key into the priority queue. If the key already exists in\n     * the queue this function does nothing and returns `false`; otherwise it will return `true`.\n     * Takes `O(n)` time.\n     *\n     * @param key the key to add\n     * @param priority the initial priority for the key\n     */\n    add(key: K, priority?: number) {\n        const keyIndices = this._keyIndices;\n        if (!keyIndices.has(key)) {\n            const arr = this._arr;\n            const index = arr.length;\n            keyIndices.set, priority: number;\n            arr.push({ key: key, priority: priority });\n            this._decrease(index);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Removes and returns the largest key in the queue. Takes): `O(log n)` time.\n     */\n    removeMax() {\n        this._swap(0, this._arr.length - 1);\n        const max = this._arr[0];\n        this._arr[0] = thi {\n        const keyIndices = this._keyIndices;\n        if (!keyIndices.has(key)) {\n            const arr = this._arr;\n            const index = arr.length;\n            keyIndices.set(key, index);\n            arr.push({ key: key, priority: priority });\n            this._decrease(index);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n     */\n    removeMin(): K {\n        this._swap(0, this._arr.length - 1);\n        const min = this._arr[0];\n        this._arr[0] = thi {\n        const keyIndices = this._keyIndices; {\n        this._swap(0, this._arr.length - 1);\n        const min = this._arr.pop()!;\n        this._keyIndices.delete(min.key);\n        this._heapify(0);\n        return min.key;\n    }\n    /**\n     * Decreases the priority for **key** to **priority**. If the new priority is\n     * greater than the previous priority, this function will throw an Error.\n     *\n     * @param key the key for which to raise priority\n     * @param priority the new priority for the key\n     */\n    decrease(key: K, priority: number) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined)\n            throw new RangeError(\"Key out of range\");\n        const priorityNew = this._arr[index].priority, priority: number;\n        if (priorityNew > priority) {\n            throw new Error(`New priority is greater than the previous one. ` +\n                `Key: ${String(key)} Old: ${priorityNew} New: ${priority}`);\n        }): {\n            const arr = this._arr;\n            arr[index].priority = priority;\n            this._decrease(index);\n        }\n    }\n    private _decrease(index) {\n        const priority = this._arr[index].priority; {\n        const index = this._keyIndices.get(key);\n        if (index === undefined)\n            throw new RangeError(\"Key out of range\");\n        if (priority > this._arr[index].priority) {\n            throw new Error(\"New priority is greater than current priority. \" +\n                `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);\n        }\n        this._arr[index].priority = priority;\n        this._decrease(index);\n    }\n    private _heapify(i: number): void {\n        const arr = this._arr;\n        if (arr.length <= 1)\n            return;\n        const left = 2 * i + 1, right = 2 * i + 2;\n        if (left {\n        const arr = this._arr;\n        const l = 2 * i;\n        const r = l + 1;\n        let largest = i;\n        if (l < arr.length) {\n            largest = arr[l].priority < arr[largest].priority ? l : largest;\n            if (r < arr.length) {\n                largest = arr[r].priority < arr[largest].priority ? r : largest;\n            }\n            if (largest !== i) {\n                this._swap(i, largest);\n                this._heapify(largest);\n            }\n        }\n    }\n    private _decrease(index: number): void {\n        const priority = this._arr[index].priority; {\n        const index = this._keyIndices.get(key);\n        if (index === undefined)\n            throw new RangeError(\"Key out of range\");\n        if): if (priority > this._arr[index].priority) {\n            throw new Error(\"New priority is greater than current priority. \" +\n                `Key: ${String(key)} Old: ${this._arr[index].priority} New {\n        const arr = this._arr;\n        const priority = arr[index].priority;\n        let parent;\n        while (index !== 0) {\n            // eslint-disable-next-line no-bitwise\n            parent = index >> 1;\n            if (arr[parent].priority < priority) {\n                break;\n            }\n            this._swap(index, parent);\n            index = parent;\n        }\n    }\n    private _swap(i: number, j: number): void {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        arr[i] = arr[j];\n        keyIndices.set(arr[i].key, i), j: number;\n    }\n    private _heapify(index: number): void {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        let l = index * 2 + 1;\n        let r): number {\n            let largest = index;\n            if (l < arr.length) {\n                largest = arr[l].priority < arr[index].priority? l : index;\n            }\n            if (r < arr.length) { {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        const origArrI = arr[i];\n        const origArrJ = arr[j];\n        arr[i] = origArrJ;\n        arr[j] = origArrI;\n        keyIndices.set(origArrJ.key, i);\n        keyIndices.set(origArrI.key, j);\n    }\n}\n","score":388,"fallbacked":false,"num_type_errors":179},{"code":"interface PQEntry<K> {\n    key: K;\n    priority;\n}\n/**\n * A priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a priority\n * queue is that yo;\n    priority: a number greater than 0\n *\n * The priority queue data structure is a linear list of (key, priority) pairs\n * where keys are inserted into the priority queue in order of priority and then\n * removed from the queue in orde;\n}\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nexport class PriorityQueue<K> {\n    private readonly _arr: PQEntry<K>[] = [];\n    private readonly _keyIndices: Map<K, number> = new Map();\n    /**\n     * Constructs a new priority queue. Takes `O(n)` time where `n` is the\n     * numbe;\n    private readonly _keyIndices: Map<K, number> = new Map();\n     */\n    public constructor() {\n        for (let i = 0; i < arguments.length; i++) {\n            const [key, priority] = arguments[i];\n            const entr;\n    constructor() {\n        this._arr = [];\n        this._keyIndices = new Map();\n    }\n    /**\n     * Returns the number of elements in the queue. Takes `O(1)` time.\n     */\n    size(): number {\n        return this._arr.length;\n    }\n    /**\n     * Returns the priority for **key**. If **key** is not present in the queue\n     * then this function returns `undefined`.\n     */\n    priority(key {\n        return this._arr.length;\n    }\n    /**\n     * Returns the keys that are in the queue. Takes `O(n)` time.\n     */\n    keys(): K[] {\n        return this._arr.map((x) => x.key);\n    }\n    /**\n     * Returns `true` if **key** is in the queue and `false` if not.\n     */\n    has(key {\n        return this._arr.map((x: PQEntry<K>) => x.key).includes(key);\n    }\n    /**\n     * Returns the minimum key in the queue. If the queue is empty then this\n     * function returns `undefined`.\n     */\n    min() {\n        retur): K | undefined {\n            const min = this._arr[0].key;\n            if (min === undefined) {\n                return undefined;\n            }\n            for (let i = 1; i < this._arr.length; i++) => x.key);\n    }\n    /**\n     * Returns `true` if **key** is in the queue and `false` if not.\n     */\n    has(key: K) {\n        return this._arr.some((x: PQEntry<K>) => x.key === key);\n    }\n    /**\n     * Returns the value for the minimum element in the queue. If the queue is\n     * empt): this function throws an Error.\n     */\n    min() {\n        return this._arr[0].value;\n    }\n    /**\n     * Removes the minimum element in the queue. If the queue is empty this\n     * function throws an Error. {\n        return this._keyIndices.has(key);\n    }\n    /**\n     * Returns the priority for **key**. If **key** is not present in the queue\n     * then this function returns `undefined`. Takes `O(1)` time.\n     */\n    priority(key: K) {\n        const index = this._keyIndices.get(key);\n        if (index!== undefined) {\n            return this._arr[index].priority;\n        }\n    }\n    /**\n     * Returns the value for **key**): if **key** is not present in the queue then this\n     * function returns `undefined`.\n     */\n    get(key: K): V | undefined {\n        const index = this._keyIndices.get(key);\n        if (index!= {\n        const index = this._keyIndices.get(key);\n        if (index !== undefined) {\n            return this._arr[index].priority;\n        }\n    }\n    /**\n     * Returns the key for the minimum element in this queue. If the queue is\n     * empty this function throws an Error. Takes `O(1)` time.\n     */\n    min(): K {\n        if (this._arr.length === 0) {\n            throw new Error(\"Queue underflow\");\n        }\n        return this._arr[0].key;\n    }\n    /**\n     * Removes **key** from the queue i {\n        if (this.size() === 0) {\n            throw new Error(\"Queue underflow\");\n        }\n        return this._arr[0].key;\n    }\n    /**\n     * Inserts a new key into the priority queue. If the key already exists in\n     * the queue this function does nothing and returns `false`; otherwise it will return `true`.\n     * Takes `O(n)` time.\n     *\n     * @param key the key to add\n     * @param priority the initial priority for the key\n     */\n    add(key: K, priority: number): boolean {\n        const keyIndices = this._keyIndices;\n        if (!keyIndices.has(key)) {\n            const index = this._arr.length;\n            keyIndices.set(key, index);, priority: number\n            this._arr.push({ key: key, priority: priority });\n            this._decrease(index);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Removes and returns the least key in the queue.): Returns `undefined` if the queue is empty.\n     * If the queue contains multiple entries with the same priority, then the one with\n     * the lowest index is returned.\n     * Takes `O(n)` time.\n     */\n    removeMi {\n        const keyIndices = this._keyIndices;\n        if (!keyIndices.has(key)) {\n            const arr = this._arr;\n            const index = arr.length;\n            keyIndices.set(key, index);\n            arr.push({ key: key, priority: priority });\n            this._decrease(index);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n     */\n    removeMin(): K | undefined {\n        if (this._arr.length === 0) {\n            return undefined;\n        }\n        const min = this._arr[0];\n        this._keyIndices.delete(min.key);\n        this._arr {\n        this._swap(0, this._arr.length - 1);\n        const min = this._arr.pop()!;\n        this._keyIndices.delete(min.key);\n        this._heapify(0);\n        return min.key;\n    }\n    /**\n     * Decreases the priority for **key** to **priority**. If the new priority is\n     * greater than the previous priority, this function will throw an Error.\n     *\n     * @param key the key for which to raise priority\n     * @param priority the new priority for the key\n     */\n    decrease(key: K, priority: number) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined)\n            throw new RangeError(\"Key out of range\");\n        if (priority < this._arr[index].priority, priority: priority);\n        this._arr[index].priority = priority;\n        this._decrease(index);\n    }\n    /**\n     * Increases the priority for **key** to **priority**.\n     *\n     * @param key the key for whic): to raise priority\n     * @param priority the new priority for the key\n     */\n    increase(key: K, priority: number) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined)\n            throw new RangeError(\"Key out of range\");\n        if (priority > this._arr[index].priority) {\n            throw new Error(\"New priority is greater than current priority. \" +\n                `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);\n        }\n        this._arr[index].priority = priority;\n        this._decrease(index);\n    }\n    private _heapify(i: number) {\n        const arr = this._arr;\n        let largest = i;\n        if (2 * i + 1 < arr.length) {\n            largest = arr[2 * i + 1].priority < arr[largest]): largest;\n        }\n        if (2 * i + 2 < arr.length) {\n            largest = arr[2 * i + 2].priority < arr[largest]: largest;\n        }\n        if (largest!== i) { {\n        const arr = this._arr;\n        const l = 2 * i;\n        const r = l + 1;\n        let largest = i;\n        if (l < arr.length) {\n            largest = arr[l].priority < arr[largest].priority ? l : largest;\n            if (r < arr.length) {\n                largest = arr[r].priority < arr[largest].priority ? r : largest;\n            }\n            if (largest !== i) {\n                this._swap(i, largest);\n                this._heapify(largest);\n            }\n        }\n    }\n    private _decrease(index: number) {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        const priority = arr[index].priority;\n        if (priority === arr[2 * index + 1].priority) {\n            thi): {\n                this._swap(2 * index + 1, index);\n            }\n            this._decrease(2 * index + 1);\n        } else if (priority === arr[2 * index + 2].priority) {\n            t {\n        const arr = this._arr;\n        const priority = arr[index].priority;\n        let parent;\n        while (index !== 0) {\n            // eslint-disable-next-line no-bitwise\n            parent = index >> 1;\n            if (arr[parent].priority < priority) {\n                break;\n            }\n            this._swap(index, parent);\n            index = parent;\n        }\n    }\n    private _swap(i: number, j: number) {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        const origArrI = arr[i];\n        const origArrJ = arr[j];\n        arr[i, j: number];\n        keyIndices.set(origArrJ.key, i);\n        keyIndices.set(origArrI.key, j);\n    }\n}\n\nexport class SortingHeap<T extends KeyedComparable<T>): void {\n    private _arr: T[];\n    private _keyIndices: Map<string, number>;\n\n    constructor(arr?: T[]) {\n        if (arr === undefined) {\n            arr = [];\n            this._keyIndices = new Map {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        const origArrI = arr[i];\n        const origArrJ = arr[j];\n        arr[i] = origArrJ;\n        arr[j] = origArrI;\n        keyIndices.set(origArrJ.key, i);\n        keyIndices.set(origArrI.key, j);\n    }\n}\n","score":367,"fallbacked":false,"num_type_errors":180},{"code":"interface PQEntry<K> {\n    key: K;\n    priority: number;\n}\nexport class PQ {\n    private readonly _arr;\n    private readonly _keyIndices;\n    constructor() {\n        this._arr = [];\n        this._keyIndices = new Map();\n    };\n    priority: number;\n    constructor(entries: PQEntry<K>[]);\n    /**\n     * Returns the number of elements in the queue.\n     */\n    size() {\n        return this._arr.length;\n    };\n    /**\n     * Returns the key;\n}\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nexport class PriorityQueue<K> {\n    private readonly _arr: PQEntry<K>[];\n    private readonly _keyIndices;\n    constructor(entries: PQEntry<K>[]);\n    /**\n     * Returns the number of elements in the queue.\n     */\n    size() {\n        return this._arr;\n    private readonly _keyIndices: Map<K, number>;\n    constructor(entries: PQEntry<K>[]);\n    /**\n     * Adds **key** to the queue. Takes `O(log n)` time.\n     */\n    add(key: K, priority?;\n    constructor() {\n        this._arr = [];\n        this._keyIndices = new Map();\n    }\n    /**\n     * Returns the number of elements in the queue. Takes `O(1)` time.\n     */\n    size(): number;\n    /**\n     * Returns the key;\n     *\n     * @param index\n     * @throws `RangeError` if the index is outside the range `[0, size)`.\n     */\n    key(index: number) {\n        if {\n        return this._arr.length;\n    }\n    /**\n     * Returns the keys that are in the queue. Takes `O(n)` time.\n     */\n    keys(): K[];\n    }\n    /**\n     * Returns the priority for **key**. If **key** is not present in the queue\n     * then this function returns `undefined`. Takes `O(1)` time.\n     */\n    priority(key {\n        return this._arr.map((x: PQEntry<K>) => x.key)[index];\n    }\n    /**\n     * Returns the index of **key**. If **key** is not present in the queue\n     * then this function returns `-1`. Takes `O(): O(1)` time.\n     */\n    indexOf(key) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined) {\n            return -1;\n        } else {\n            return index; => x.key);\n    }\n    /**\n     * Returns `true` if **key** is in the queue and `false` if not.\n     */\n    has(key: K) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined) {\n            return false;\n        } else {\n            return true;\n    }\n    }\n    /**\n     * Returns the priority for **ke): O(1)` time.\n     */\n    remove(key: K) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined) {\n            return false;\n        } else {\n            const priority = thi {\n        return this._keyIndices.has(key);\n    }\n    /**\n     * Returns the priority for **key**. If **key** is not present in the queue\n     * then this function returns `undefined`. Takes `O(1)` time.\n     */\n    priority(key: K) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined) {\n            return undefined;\n        } else {\n            this._keyIndices.delete(key);\n            return priority;\n    }\n    /*): PQEntry<K> | undefined {\n        const index = this._keyIndices.get(key);\n        if (index === undefined) {\n            return undefined;\n        } else {\n            this._keyIndices.delete(key);\n            return thi {\n        const index = this._keyIndices.get(key);\n        if (index !== undefined) {\n            return this._arr[index].priority;\n        }\n    }\n    /**\n     * Returns the key for the minimum element in this queue. If the queue is\n     * empty this function throws an Error. Takes `O(1)` time.\n     */\n    min(): K {\n        const arr = this._arr;\n        if (arr.length === 0) {\n            throw new Error(\"Queue underflow\");\n        }\n        return arr[0].key;\n    }\n    /**\n     * Returns the key fo {\n        if (this.size() === 0) {\n            throw new Error(\"Queue underflow\");\n        }\n        return this._arr[0].key;\n    }\n    /**\n     * Inserts a new key into the priority queue. If the key already exists in\n     * the queue this function does nothing and returns `false`; otherwise it will return `true`.\n     * Takes `O(n)` time.\n     *\n     * @param key the key to add\n     * @param priority the initial priority for the key\n     */\n    add(key: K, priority: P) {\n        if (!this.has(key)) {\n            const arr = this._arr;\n            const index = arr.length;\n            arr.push({ key: key, priority: priority });\n            this._decreas, priority: this._priority = index, 0;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Inserts a new key into the priority queue if it is not already in the queue. If the key already exists in th): queue is empty this function returns `false`. Otherwise it returns `true`.\n     * Takes `O(n)` time.\n     *\n     * @param key the key to add\n     * @param priority the initial priority for the key\n     */ {\n        const keyIndices = this._keyIndices;\n        if (!keyIndices.has(key)) {\n            const arr = this._arr;\n            const index = arr.length;\n            keyIndices.set(key, index);\n            arr.push({ key: key, priority: priority });\n            this._decrease(index);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n     */\n    removeMin(): K {\n        if (this._arr.length === 0) {\n            throw new Error(\"Queue underflow\");\n        }\n        this._swap(0, this._arr.length - 1);\n        const min = this._arr {\n        this._swap(0, this._arr.length - 1);\n        const min = this._arr.pop()!;\n        this._keyIndices.delete(min.key);\n        this._heapify(0);\n        return min.key;\n    }\n    /**\n     * Decreases the priority for **key** to **priority**. If the new priority is\n     * greater than the previous priority, this function will throw an Error.\n     *\n     * @param key the key for which to raise priority\n     * @param priority the new priority for the key\n     */\n    decrease(key: K, priority: number) {\n        const index = this._keyIndices.get(key);\n        if (index === undefined)\n            throw new RangeError(\"Key out of range\");\n        if (priority < this._arr[index].priority, priority: number) {\n            throw new Error(\"New priority is less than current priority. \" +\n                `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);\n        }\n        this._arr): PriorityQueue<K> | undefined {\n        if (!this._keyIndices.has(key)) {\n            const arr = this._arr;\n            const index = arr.length;\n            arr[index] = { key: key, priority {\n        const index = this._keyIndices.get(key);\n        if (index === undefined)\n            throw new RangeError(\"Key out of range\");\n        if (priority > this._arr[index].priority) {\n            throw new Error(\"New priority is greater than current priority. \" +\n                `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);\n        }\n        this._arr[index].priority = priority;\n        this._decrease(index);\n    }\n    private _heapify(i: number): void {\n        const arr = this._arr;\n        let left = 2 * i + 1;\n        let right = 2 * i + 2;\n        if (left < arr.length && arr[left].priorit): {\n            largest = left;\n        } else {\n            largest = i;\n        }\n        if (right < arr.length && arr[right].priorit) {\n            largest = right;\n        }\n        if (largest === i) { {\n        const arr = this._arr;\n        const l = 2 * i;\n        const r = l + 1;\n        let largest = i;\n        if (l < arr.length) {\n            largest = arr[l].priority < arr[largest].priority ? l : largest;\n            if (r < arr.length) {\n                largest = arr[r].priority < arr[largest].priority ? r : largest;\n            }\n            if (largest !== i) {\n                this._swap(i, largest);\n                this._heapify(largest);\n            }\n        }\n    }\n    private _decrease(index: number): void {\n        const arr = this._arr;\n        if (arr[index].priority === undefined) {\n            return;\n        }\n        const priority = arr[index].priority;\n        let parent;\n        while (index!==): {\n            parent = index >> 1;\n            if (arr[parent].priority < priority) {\n                break;\n            }\n            this._swap(index, parent);\n            index = parent;\n        }\n    }\n    private _rebalance {\n        const arr = this._arr;\n        const priority = arr[index].priority;\n        let parent;\n        while (index !== 0) {\n            // eslint-disable-next-line no-bitwise\n            parent = index >> 1;\n            if (arr[parent].priority < priority) {\n                break;\n            }\n            this._swap(index, parent);\n            index = parent;\n        }\n    }\n    private _swap(i: number, j: number): void {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        const origArrI = arr[i];\n        const origArrJ = arr[j];\n        arr[, j: number] = [arr[j], arr[i]];\n        keyIndices.set(origArrJ.key, j);\n        keyIndices.set(origArrI.key, i);\n    }\n    private _swapKeyIndices(): void {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        const origArrI = arr[i];\n        const origArrJ = arr[j];\n        arr[i] = origArrJ;\n        arr[j] = origArrI;\n        keyIndices.set(origArrJ.key, i);\n        keyIndices.set(origArrI.key, j);\n    }\n}\n","score":350,"fallbacked":false,"num_type_errors":296}]}
{"dataset_elem":{"alphanum_fraction":0.6663542643,"avg_line_length":19.0535714286,"content":"export type State = {\n\tusername: string,\n\tclient_id: string,\n\tcreatedAt: string,\n\tprofile_src: string,\n\tisLogined: boolean\n}\n\ntype Action = {\n\ttype: \"FILL_USER\" | \"CLEAR_ALL_THE_DATA\" | \"SPECIFIC_KEY_UPDATE\",\n\tpayload: {\n\t\tusername: string,\n\t\tclient_id: string,\n\t\tcreatedAt: string,\n\t\tprofile_src: string,\n\t\tisLogined: boolean,\n\t\tkey?: string ,\n\t\tvalue?: string\n\t}\n}\n\nconst defaultState: State = {\n\tusername: '',\n\tclient_id: '',\n\tcreatedAt: '',\n\tprofile_src: '',\n\tisLogined: false\n}\n\nexport const userDataHandler = (state: State = defaultState, action: Action): State => {\n\tswitch(action.type){\n\t\t\n\t\tcase \"FILL_USER\": {\n\t\t\tconst {username, client_id, createdAt, profile_src, isLogined} = action.payload\n\n\t\t\treturn {\n\t\t\t\tusername: username,\n\t\t\t\tclient_id: client_id,\n\t\t\t\tcreatedAt: createdAt,\n\t\t\t\tprofile_src: profile_src,\n\t\t\t\tisLogined: isLogined\n\t\t\t}\n\t\t}case \"CLEAR_ALL_THE_DATA\": {\n\t\t\treturn defaultState\n\t\t}\n\t\tcase \"SPECIFIC_KEY_UPDATE\": {\n\t\t\tconst {key, value} = action.payload\n\t\t\t\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t[key!]: value\n\t\t\t}\n\t\t}\n\t\tdefault: return state\n\t}\n}","content_without_annotations":"export type State = {\n\tusername,\n\tclient_id,\n\tcreatedAt,\n\tprofile_src,\n\tisLogined\n}\n\ntype Action = {\n\ttype,\n\tpayload\n}\n\nconst defaultState = {\n\tusername: '',\n\tclient_id: '',\n\tcreatedAt: '',\n\tprofile_src: '',\n\tisLogined: false\n}\n\nexport const userDataHandler = (state = defaultState, action) => {\n\tswitch(action.type){\n\t\t\n\t\tcase \"FILL_USER\": {\n\t\t\tconst {username, client_id, createdAt, profile_src, isLogined} = action.payload\n\n\t\t\treturn {\n\t\t\t\tusername: username,\n\t\t\t\tclient_id: client_id,\n\t\t\t\tcreatedAt: createdAt,\n\t\t\t\tprofile_src: profile_src,\n\t\t\t\tisLogined: isLogined\n\t\t\t}\n\t\t}case \"CLEAR_ALL_THE_DATA\": {\n\t\t\treturn defaultState\n\t\t}\n\t\tcase \"SPECIFIC_KEY_UPDATE\": {\n\t\t\tconst {key, value} = action.payload\n\t\t\t\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t[key!]: value\n\t\t\t}\n\t\t}\n\t\tdefault: return state\n\t}\n}","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":361,"ext":"ts","fun_ann_density":0.0083102493,"function_parameters":2,"function_signatures":0,"function_usages":0,"functions":1,"hexsha":"44481f570658425682f18a6a5dc25f8f8fe067af","lang":"TypeScript","loc":50,"loc_per_function":22.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"6f5ba02f6d112ed11e48f08c1a30a1a40a42cf6d","max_forks_repo_licenses":["CC0-1.0"],"max_forks_repo_name":"callmenikk/JetChat","max_forks_repo_path":"src/Hooks/Client/userDataHandler.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"6f5ba02f6d112ed11e48f08c1a30a1a40a42cf6d","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["CC0-1.0"],"max_issues_repo_name":"callmenikk/JetChat","max_issues_repo_path":"src/Hooks/Client/userDataHandler.ts","max_line_length":88,"max_stars_count":7.0,"max_stars_repo_head_hexsha":"6f5ba02f6d112ed11e48f08c1a30a1a40a42cf6d","max_stars_repo_licenses":["CC0-1.0"],"max_stars_repo_name":"callmenikk/JetChat","max_stars_repo_path":"src/Hooks/Client/userDataHandler.ts","max_stars_repo_stars_event_max_datetime":"2022-03-14T11:40:10.000Z","max_stars_repo_stars_event_min_datetime":"2022-02-22T06:58:56.000Z","metric":0.2335824923,"predefined_density":0.8571428571,"predefined_types":12,"prop_ann_density":0.0193905817,"property_declarations":7,"size":1067,"trivial_density":0.0,"trivial_types":0,"type_definitions":2,"typedef_density":0.0055401662,"var_ann_density":0.0110803324,"variable_declarations":4},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export type State = {\n    username: string;\n    client_id: string;\n    client_id: string;\n    createdAt: string;\n    profile_src: string;\n    isLogined: boolean;\n};\ntype Action = {\n    type: \"FILL_USER\" | \"CLEAR_ALL_THE_DATA\" | \"SPECIFIC_KEY_UPDATE\";\n    payload;\n    payload: State;\n};\nconst defaultState = {\n    username: \"\",\n    client_id: \"\",\n    createdAt: \"\",\n    profile_src: \"\",\n    isLogined: false\n};\nexport const userDataHandler = (state: State = defaultState, action: Action): State => {\n    switch (action.type) {\n        case \"FILL_USER\": {\n            const { username, client_id, createdAt, profile_src, isLogined } = action.payload;\n            return {\n                username: username,\n                client_id: client_id,\n                createdAt: createdAt,\n                profile_src: profile_src,\n                isLogined: isLogined\n            };\n        }\n        case \"CLEAR_ALL_THE_DATA\": {\n            return defaultState;\n        }\n        case \"SPECIFIC_KEY_UPDATE\": {\n            const { key, value } = action.payload;\n            return {\n                ...state,\n                [key!]: value\n            };\n        }\n        default: return state;\n    }\n};\n","score":143,"fallbacked":false,"num_type_errors":5},{"code":"export type State = {\n    username: string;\n    client_id: string;\n    createdAt: string;\n    profile_src: string;\n    isLogined: boolean;\n};\nexport type UserAction = {\n    type;\n    payload;\n};\nexport type UserStat;\n    client_id: string;\n    createdAt: string;\n    profile_src: string;\n    isLogined: boolean;\n};\nexport interface User {\n    username: string;\n    client_id: string;\n    createdAt: string;\n    profile_src: string;\n    isLogined: boolean;\n}\nexport interface UserAction {\n    type;\n    payload;\n}\nexport interface UserStat {\n    username: string;\n    client_id: string;\n    profile_src: string;\n    isLogined: boolean;\n}\nexport interface Action {\n    type;\n    payload;\n}\nexport interface Dispatch {\n    fillUserData(payload: UserStat | UserAction | User): void;\n    clearAllUserData();\n    isLogined: boolean;\n}\nexport interface Store {\n    userDataHandler: (state: State, action: UserAction | UserStat) => State | UserAction | UserStat;\n}\nexport interface GetState {\n    userDataHandler: (state;\n};\ntype Action = {\n    type: \"FILL_USER\";\n    payload: {\n        username: string;\n        client_id: string;\n        createdAt: string;\n        profile_src: string;\n        isLogined: boolean;\n    };\n} | {\n    type:;\n    payload: {\n        username: string;\n        client_id: string;\n        createdAt: string;\n        profile_src: string;\n        isLogined: boolean;\n    };\n} | {\n    type:;\n    payload: {\n        username: strin;\n};\nconst defaultState = {\n    username: \"\",\n    client_id: \"\",\n    createdAt: \"\",\n    profile_src: \"\",\n    isLogined: false\n};\nexport const userDataHandler = (state: State = defaultState, action: UserAction | UserStat) => {\n    switch (action.type) {\n        case \"FILL_USER\": {\n            const { username, client_id, createdAt, profile_src, isLogined = defaultState, action: { type } } = action.payload;\n            return {\n                username: username,\n                client_id: client_id,\n                createdAt: createdAt,\n                profile_src: profile_src,\n                isLogined: isLogined\n            }): State;\n        }\n        case \"CLEAR_ALL_THE_DATA\": {\n            return defaultState;\n        }\n        case \"SPECIFIC_KEY_UPDATE\": {\n            const { username, client_id, createdAt, profile_src, i => {\n    switch (action.type) {\n        case \"FILL_USER\": {\n            const { username, client_id, createdAt, profile_src, isLogined } = action.payload;\n            return {\n                username: username,\n                client_id: client_id,\n                createdAt: createdAt,\n                profile_src: profile_src,\n                isLogined: isLogined\n            };\n        }\n        case \"CLEAR_ALL_THE_DATA\": {\n            return defaultState;\n        }\n        case \"SPECIFIC_KEY_UPDATE\": {\n            const { key, value } = action.payload;\n            return {\n                ...state,\n                [key!]: value\n            };\n        }\n        default: return state;\n    }\n};\n","score":160,"fallbacked":false,"num_type_errors":25},{"code":"export type State = {\n    username: string;\n    client_id: string;\n    client_id: string;\n    createdAt: string;\n    profile_src: string;\n    isLogined: boolean;\n};\nexport type AuthState = {\n    username: string;\n    client_id: string;\n    createdAt: string;\n    profile_src: string;\n    isLogined: boolean;\n};\nexport type AuthAction = {\n    type: \"FILL_USER\";\n    payload: State;\n};\nexport type AuthAction = {\n    type: \"CLEAR_ALL_THE;\n    isLogined: boolean;\n};\ntype Action = {\n    type: \"SPECIFIC_KEY_UPDATE\";\n    payload: AuthState;\n    payload: AuthAction;\n};\nconst defaultState = {\n    username: \"\",\n    client_id: \"\",\n    createdAt: \"\",\n    profile_src: \"\",\n    isLogined: false\n};\nexport const userDataHandler = (state: AuthState = defaultState, action: AuthAction) => {\n    switch (action.type) {\n        case \"FILL_USER\": {\n            const { username, client_id, createdAt, profile_src, isLogined } = actio = defaultState, action: AuthAction = { type: \"CLEAR_ALL_THE_DATA\", isLogined: false };\n            return {\n                username: username,\n                client_id: client_id,\n                createdAt: createdAt,\n                profile_src: profile): AuthState {\n                    username: username,\n                    client_id: client_id,\n                    createdAt: createdAt,\n                    profile_src: profile,\n                    isLogined: isLogined\n                };\n        }\n        case \"CLEAR_ALL_THE => {\n    switch (action.type) {\n        case \"FILL_USER\": {\n            const { username, client_id, createdAt, profile_src, isLogined } = action.payload;\n            return {\n                username: username,\n                client_id: client_id,\n                createdAt: createdAt,\n                profile_src: profile_src,\n                isLogined: isLogined\n            };\n        }\n        case \"CLEAR_ALL_THE_DATA\": {\n            return defaultState;\n        }\n        case \"SPECIFIC_KEY_UPDATE\": {\n            const { key, value } = action.payload;\n            return {\n                ...state,\n                [key!]: value\n            };\n        }\n        default: return state;\n    }\n};\n","score":109,"fallbacked":false,"num_type_errors":30}]}
{"dataset_elem":{"alphanum_fraction":0.6931079324,"avg_line_length":29.5769230769,"content":"// Copyright 2022 Kenth Fagerlund.\n\n// SPDX-License-Identifier: MIT\nexport interface ContractDescriptor {\n    title: string\n    logo: string\n    description: string\n    url: string\n}\n\nexport const DESCRIPTOR_STRONGBLOCK:ContractDescriptor = {\n    title:\"Strongblock\",\n    logo:\"/svg/strong-logo.svg\",\n    description:\"StrongBlock is the first and only blockchain-agnostic protocol to reward nodes\",\n    url:'https://strongblock.com/'\n}\n\nexport const DESCRIPTOR_YIELDNODE:ContractDescriptor = {\n    title:\"Yieldnodes\",\n    logo:\"/svg/yield-nodes-logo.svg\",\n    description:\"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url:'https://yieldnodes.com/'\n}\n\nexport const DESCRIPTOR_THOR:ContractDescriptor = {\n    title:\"Thor\",\n    logo:\"/svg/thor.svg\",\n    description:\"Gain passive income by leveraging THOR's Financial multi-chain yield-farming protocol\",\n    url:'https://www.thor.financial/'\n}\n\nexport const DESCRIPTOR_POLAR:ContractDescriptor = {\n    title:\"Polar\",\n    logo:\"/svg/polar.svg\",\n    description:\"Poloar nodes\",\n    url:'https://www.polar.financial/'\n}\n\nexport const DESCRIPTOR_ANCHOR:ContractDescriptor = {\n    title:\"Anchor\",\n    logo:\"/svg/anchor.svg\",\n    description:\"Anchor\",\n    url:'https://www.anchor.financial/'\n}\n\nexport const DESCRIPTOR_ETHERSTONES:ContractDescriptor = {\n    title:\"Etherstones\",\n    logo:\"/etherstones.webp\",\n    description:\"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url:'https://etherstones.fi/'\n}\n\nexport const DESCRIPTOR_PHOENIX:ContractDescriptor = {\n    title:\"Phoenix\",\n    logo:\"/crypto-icons/fire.png\",\n    description:\"Fire nodes\",\n    url:'https://thephoenix.finance/app/'\n}\n\nexport function NameToDescriptor(contractName:string):ContractDescriptor {\n    switch (contractName) {\n        case 'Strongblock':\n            return DESCRIPTOR_STRONGBLOCK\n        case 'Yieldnodes':\n            return DESCRIPTOR_YIELDNODE\n        case 'Polar':\n            return DESCRIPTOR_POLAR\n        case 'Thor':\n            return DESCRIPTOR_THOR\n        case 'Etherstones':\n            return DESCRIPTOR_ETHERSTONES\n        case 'Phoenix':\n            return DESCRIPTOR_PHOENIX\n        default:\n            return DESCRIPTOR_STRONGBLOCK\n    }\n}\n","content_without_annotations":"// Copyright 2022 Kenth Fagerlund.\n\n// SPDX-License-Identifier: MIT\nexport interface ContractDescriptor {\n    title\n    logo\n    description\n    url\n}\n\nexport const DESCRIPTOR_STRONGBLOCK = {\n    title:\"Strongblock\",\n    logo:\"/svg/strong-logo.svg\",\n    description:\"StrongBlock is the first and only blockchain-agnostic protocol to reward nodes\",\n    url:'https://strongblock.com/'\n}\n\nexport const DESCRIPTOR_YIELDNODE = {\n    title:\"Yieldnodes\",\n    logo:\"/svg/yield-nodes-logo.svg\",\n    description:\"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url:'https://yieldnodes.com/'\n}\n\nexport const DESCRIPTOR_THOR = {\n    title:\"Thor\",\n    logo:\"/svg/thor.svg\",\n    description:\"Gain passive income by leveraging THOR's Financial multi-chain yield-farming protocol\",\n    url:'https://www.thor.financial/'\n}\n\nexport const DESCRIPTOR_POLAR = {\n    title:\"Polar\",\n    logo:\"/svg/polar.svg\",\n    description:\"Poloar nodes\",\n    url:'https://www.polar.financial/'\n}\n\nexport const DESCRIPTOR_ANCHOR = {\n    title:\"Anchor\",\n    logo:\"/svg/anchor.svg\",\n    description:\"Anchor\",\n    url:'https://www.anchor.financial/'\n}\n\nexport const DESCRIPTOR_ETHERSTONES = {\n    title:\"Etherstones\",\n    logo:\"/etherstones.webp\",\n    description:\"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url:'https://etherstones.fi/'\n}\n\nexport const DESCRIPTOR_PHOENIX = {\n    title:\"Phoenix\",\n    logo:\"/crypto-icons/fire.png\",\n    description:\"Fire nodes\",\n    url:'https://thephoenix.finance/app/'\n}\n\nexport function NameToDescriptor(contractName) {\n    switch (contractName) {\n        case 'Strongblock':\n            return DESCRIPTOR_STRONGBLOCK\n        case 'Yieldnodes':\n            return DESCRIPTOR_YIELDNODE\n        case 'Polar':\n            return DESCRIPTOR_POLAR\n        case 'Thor':\n            return DESCRIPTOR_THOR\n        case 'Etherstones':\n            return DESCRIPTOR_ETHERSTONES\n        case 'Phoenix':\n            return DESCRIPTOR_PHOENIX\n        default:\n            return DESCRIPTOR_STRONGBLOCK\n    }\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":602,"ext":"tsx","fun_ann_density":0.0033222591,"function_parameters":1,"function_signatures":0,"function_usages":0,"functions":1,"hexsha":"19d57bba34088220520f0540c5898a7714748a9a","lang":"TypeScript","loc":66,"loc_per_function":16.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"c61bb1014e037121dde2b224c193edc9abab028d","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"SunblockFinance/sunblock","max_forks_repo_path":"contracts/deployedContracts.tsx","max_issues_count":29.0,"max_issues_repo_head_hexsha":"c61bb1014e037121dde2b224c193edc9abab028d","max_issues_repo_issues_event_max_datetime":"2022-03-30T09:49:47.000Z","max_issues_repo_issues_event_min_datetime":"2022-02-17T12:46:13.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"SunblockFinance/sunblock","max_issues_repo_path":"contracts/deployedContracts.tsx","max_line_length":118,"max_stars_count":3.0,"max_stars_repo_head_hexsha":"c61bb1014e037121dde2b224c193edc9abab028d","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"SunblockFinance/sunblock","max_stars_repo_path":"contracts/deployedContracts.tsx","max_stars_repo_stars_event_max_datetime":"2022-03-04T13:06:43.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-04T11:34:31.000Z","metric":0.2180118569,"predefined_density":0.3846153846,"predefined_types":5,"prop_ann_density":0.0066445183,"property_declarations":4,"size":2307,"trivial_density":0.0,"trivial_types":0,"type_definitions":1,"typedef_density":0.0016611296,"var_ann_density":0.011627907,"variable_declarations":7},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"// Copyright 2022 Kenth Fagerlund.\n// SPDX-License-Identifier: MIT\nexport interface ContractDescriptor {\n    title: string;\n    logo: string;\n    description: string;\n    url: string;\n}\nexport interface Contract {\n    name: string;\n    description: string;\n    logo: string;\n    url: string;\n}\nexport interface Contrac;\n    logo: string;\n    description: string;\n    url: string;\n}\nexport interface Contrac2020 extends Contrac {\n    name: \"Kenth Fagerlund\";\n}\nexport interface Contrac2021 extend;\n    description: string;\n    url: string;\n}\nexport interface Contrac2022 extends Contrac {\n    name: \"Kenth Fagerlund\";\n}\nexport interface Contrac2023 extends Contrac {\n    nam;\n    url: string;\n}\nexport interface Contrac2024 extends Contrac {\n    name: \"Kenth Fagerlund\";\n}\nexport interface Contrac2025 extends Contrac {\n    name: \"Kenth;\n}\nexport const DESCRIPTOR_STRONGBLOCK = {\n    title: \"Strongblock\",\n    logo: \"/svg/strong-logo.svg\",\n    description: \"StrongBlock is the first and only blockchain-agnostic protocol to reward nodes\",\n    url: \"https://strongblock.com/\"\n};\nexport const DESCRIPTOR_YIELDNODE = {\n    title: \"Yieldnodes\",\n    logo: \"/svg/yield-nodes-logo.svg\",\n    description: \"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url: \"https://yieldnodes.com/\"\n};\nexport const DESCRIPTOR_THOR = {\n    title: \"Thor\",\n    logo: \"/svg/thor.svg\",\n    description: \"Gain passive income by leveraging THOR's Financial multi-chain yield-farming protocol\",\n    url: \"https://www.thor.financial/\"\n};\nexport const DESCRIPTOR_POLAR = {\n    title: \"Polar\",\n    logo: \"/svg/polar.svg\",\n    description: \"Poloar nodes\",\n    url: \"https://www.polar.financial/\"\n};\nexport const DESCRIPTOR_ANCHOR = {\n    title: \"Anchor\",\n    logo: \"/svg/anchor.svg\",\n    description: \"Anchor\",\n    url: \"https://www.anchor.financial/\"\n};\nexport const DESCRIPTOR_ETHERSTONES = {\n    title: \"Etherstones\",\n    logo: \"/etherstones.webp\",\n    description: \"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url: \"https://etherstones.fi/\"\n};\nexport const DESCRIPTOR_PHOENIX = {\n    title: \"Phoenix\",\n    logo: \"/crypto-icons/fire.png\",\n    description: \"Fire nodes\",\n    url: \"https://thephoenix.finance/app/\"\n};\nexport function NameToDescriptor(contractName: string): ContractDescriptor {\n    switch (contractName) {\n        case \"Strongblock\":\n            return DESCRIPTOR_STRONGBLOCK;\n        case \"Yieldnodes\":\n            return DESCRIPTOR_YIELDNODE;\n        case \"Polar\":): return DESCRIPTOR_POLAR;\n        case \"Thor\":\n            return DESCRIPTOR_THOR;\n        case \"Etherstones\":\n            return DESCRIPTOR_ETHERSTONES;\n        case \"Phoenix\":\n            return DESCRIPTOR_ {\n    switch (contractName) {\n        case \"Strongblock\":\n            return DESCRIPTOR_STRONGBLOCK;\n        case \"Yieldnodes\":\n            return DESCRIPTOR_YIELDNODE;\n        case \"Polar\":\n            return DESCRIPTOR_POLAR;\n        case \"Thor\":\n            return DESCRIPTOR_THOR;\n        case \"Etherstones\":\n            return DESCRIPTOR_ETHERSTONES;\n        case \"Phoenix\":\n            return DESCRIPTOR_PHOENIX;\n        default:\n            return DESCRIPTOR_STRONGBLOCK;\n    }\n}\n","score":174,"fallbacked":false,"num_type_errors":16},{"code":"// Copyright 2022 Kenth Fagerlund.\n// SPDX-License-Identifier: MIT\nexport interface ContractDescriptor {\n    title: string;\n    logo: string;\n    logo: string;\n    description: string;\n    url: string;\n    name?: string;\n}\nexport interface Contract {\n    name: string;\n    logo?: string;\n    description?: string;\n    url?: string;\n}\nexport interface Contrac;\n    description: string;\n    logo?: string;\n    name?: string;\n    url?: string;\n}\nexport interface Contracts {\n    [contractName: string]: ContractDescriptor;\n}\nexport interface ContractList {\n    contracts: ContractDescriptor[];;\n    url: string;\n}\nexport interface ContractsResult {\n    contracts: ContractDescriptor[];\n    url: string;\n}\nexport interface ContractsResult {\n    contracts: ContractDescriptor[];\n    url: string;\n}\nexport interface ContractsResul;\n}\nexport const DESCRIPTOR_STRONGBLOCK = {\n    title: \"Strongblock\",\n    logo: \"/svg/strong-logo.svg\",\n    description: \"StrongBlock is the first and only blockchain-agnostic protocol to reward nodes\",\n    url: \"https://strongblock.com/\"\n};\nexport const DESCRIPTOR_YIELDNODE = {\n    title: \"Yieldnodes\",\n    logo: \"/svg/yield-nodes-logo.svg\",\n    description: \"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url: \"https://yieldnodes.com/\"\n};\nexport const DESCRIPTOR_THOR = {\n    title: \"Thor\",\n    logo: \"/svg/thor.svg\",\n    description: \"Gain passive income by leveraging THOR's Financial multi-chain yield-farming protocol\",\n    url: \"https://www.thor.financial/\"\n};\nexport const DESCRIPTOR_POLAR = {\n    title: \"Polar\",\n    logo: \"/svg/polar.svg\",\n    description: \"Poloar nodes\",\n    url: \"https://www.polar.financial/\"\n};\nexport const DESCRIPTOR_ANCHOR = {\n    title: \"Anchor\",\n    logo: \"/svg/anchor.svg\",\n    description: \"Anchor\",\n    url: \"https://www.anchor.financial/\"\n};\nexport const DESCRIPTOR_ETHERSTONES = {\n    title: \"Etherstones\",\n    logo: \"/etherstones.webp\",\n    description: \"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url: \"https://etherstones.fi/\"\n};\nexport const DESCRIPTOR_PHOENIX = {\n    title: \"Phoenix\",\n    logo: \"/crypto-icons/fire.png\",\n    description: \"Fire nodes\",\n    url: \"https://thephoenix.finance/app/\"\n};\nexport function NameToDescriptor(contractName: string): Descriptor {\n    switch (contractName) {\n        case \"Strongblock\":\n            return DESCRIPTOR_STRONGBLOCK;\n        case \"Yieldnodes\":\n            return DESCRIPTOR_YIELDNODE;\n        case \"Polar\":\n            return DESCRIPTOR_POLAR;\n        case \"Thor\":\n            return DESCRIPTOR_THOR;\n        case \"Etherstones\":\n            return DESCRIPTOR_ETHERSTONES;\n        case \"Phoenix\":\n            return DESCRIPTOR_PHOENIX;\n        default:\n            return DESCRIPTOR_STRONGBLOCK;\n    }\n}\n","score":125,"fallbacked":false,"num_type_errors":17},{"code":"// Copyright 2022 Kenth Fagerlund.\n// SPDX-License-Identifier: MIT\nexport interface ContractDescriptor {\n    title: string;\n    logo: string;\n    description: string;\n    url: string;\n}\nexport interface Contract {\n    name: string;\n    logo: string;\n    description: string;\n    url: string;\n}\nexport interface ContractInstance {\n    id: string;\n    name: string;\n    logo: string;\n    description: string;\n    url: string;\n    owner: string;\n    description: string;\n}\nexport interface Contracts {\n    \"0x00000000000000000000000000000000000;\n    url: string;\n    name: string;\n    logo: string;\n    description: string;\n}\nexport interface ContractsInstance {\n    \"0x0000000000000000000;\n}\nexport const DESCRIPTOR_STRONGBLOCK = {\n    title: \"Strongblock\",\n    logo: \"/svg/strong-logo.svg\",\n    description: \"StrongBlock is the first and only blockchain-agnostic protocol to reward nodes\",\n    url: \"https://strongblock.com/\"\n};\nexport const DESCRIPTOR_YIELDNODE = {\n    title: \"Yieldnodes\",\n    logo: \"/svg/yield-nodes-logo.svg\",\n    description: \"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url: \"https://yieldnodes.com/\"\n};\nexport const DESCRIPTOR_THOR = {\n    title: \"Thor\",\n    logo: \"/svg/thor.svg\",\n    description: \"Gain passive income by leveraging THOR's Financial multi-chain yield-farming protocol\",\n    url: \"https://www.thor.financial/\"\n};\nexport const DESCRIPTOR_POLAR = {\n    title: \"Polar\",\n    logo: \"/svg/polar.svg\",\n    description: \"Poloar nodes\",\n    url: \"https://www.polar.financial/\"\n};\nexport const DESCRIPTOR_ANCHOR = {\n    title: \"Anchor\",\n    logo: \"/svg/anchor.svg\",\n    description: \"Anchor\",\n    url: \"https://www.anchor.financial/\"\n};\nexport const DESCRIPTOR_ETHERSTONES = {\n    title: \"Etherstones\",\n    logo: \"/etherstones.webp\",\n    description: \"YieldNodes is a complex, multi-tiered Node rental program based on the new blockchain-based economy\",\n    url: \"https://etherstones.fi/\"\n};\nexport const DESCRIPTOR_PHOENIX = {\n    title: \"Phoenix\",\n    logo: \"/crypto-icons/fire.png\",\n    description: \"Fire nodes\",\n    url: \"https://thephoenix.finance/app/\"\n};\nexport function NameToDescriptor(contractName: string): {\n    switch (contractName) {\n        case \"Strongblock\":\n            return \"Strongblock\";\n        case \"Yieldnodes\":\n            return \"YieldNodes\";\n        case \"Polar\":\n            return \"Polar\";\n        case \"Thor\":\n            retur {\n    switch (contractName) {\n        case \"Strongblock\":\n            return DESCRIPTOR_STRONGBLOCK;\n        case \"Yieldnodes\":\n            return DESCRIPTOR_YIELDNODE;\n        case \"Polar\":\n            return DESCRIPTOR_POLAR;\n        case \"Thor\":\n            return DESCRIPTOR_THOR;\n        case \"Etherstones\":\n            return DESCRIPTOR_ETHERSTONES;\n        case \"Phoenix\":\n            return DESCRIPTOR_PHOENIX;\n        default:\n            return DESCRIPTOR_STRONGBLOCK;\n    }\n}\n","score":155,"fallbacked":false,"num_type_errors":26}]}
{"dataset_elem":{"alphanum_fraction":0.5817019577,"avg_line_length":24.7821782178,"content":"// @ts-nocheck\nlet counter = 0;\nconst beats = [];\nfunction emitBpmEvent(value) {\n  if (beats.length >= 5) {\n    beats.shift();\n  }\n  beats.push(value);\n  if (!counter) {\n    window.Events.emit(\n      'musicBpm',\n      beats.length\n        ? beats.reduce((prev, curr) => prev + curr) / beats.length\n        : 0\n    );\n  }\n\n  counter = (counter + 1) % 2;\n}\n\nasync function record() {\n  const audioSource: MediaStream = await navigator.mediaDevices.getUserMedia({\n    audio: {\n      mandatory: {\n        chromeMediaSource: 'desktop',\n      },\n    },\n    video: {\n      mandatory: {\n        chromeMediaSource: 'desktop',\n      },\n    },\n  });\n\n  (audioSource.getVideoTracks() ?? []).forEach((track) => {\n    audioSource.removeTrack(track);\n  });\n\n  const sampleRate = 5120;\n\n  const context = new AudioContext({\n    sampleRate,\n  });\n\n  const processor = context.createScriptProcessor(16384, 2, 2);\n\n  processor.onaudioprocess = (e) => {\n    const bufferData = e.inputBuffer.getChannelData(0);\n    const duration = e.inputBuffer.duration;\n\n    // 实测 这个采样率足够了。那么接下来就瞎搞吧\n    // 采样率4096, 这段时间刚好4s，真的会有30bpm的歌吗\n    // 寻找peaks，先拿一个轨道看吧\n    // 先来个放大\n    const max = Math.max(...bufferData);\n    if (max < 0.3) {\n      // 听不见\n      emitBpmEvent(0);\n      return;\n    }\n    bufferData.forEach((k, index) => {\n      bufferData[index] = k / max;\n    });\n    const peaks = [];\n    bufferData.forEach((buf, index) => {\n      if (buf > 0.7) {\n        peaks.push(index);\n      }\n    });\n    let rhythms = [];\n    peaks.forEach((k, i) => i && rhythms.push(k - peaks[i - 1]));\n    rhythms = rhythms.filter((k) => k > sampleRate / 8);\n    if (!rhythms.length) {\n      emitBpmEvent(0);\n      return;\n    }\n    if (rhythms.length > 4) {\n      const avg =\n        (rhythms.reduce((prev, curr) => prev + curr) -\n          Math.max(...rhythms) -\n          Math.min(...rhythms)) /\n        (rhythms.length - 2);\n      const beat = (60 / avg) * sampleRate;\n      emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n    } else {\n      const avg = rhythms.reduce((prev, curr) => prev + curr) / rhythms.length;\n      const beat = (60 / avg) * sampleRate;\n      emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n    }\n  };\n  // 搞个低通滤波器\n  const mediaNode = context.createMediaStreamSource(audioSource);\n  const filterNode = context.createBiquadFilter();\n  filterNode.type = 'lowpass';\n  mediaNode.connect(filterNode);\n  filterNode.connect(processor);\n  processor.connect(context.destination);\n}\n\nexport default record;\n","content_without_annotations":"// @ts-nocheck\nlet counter = 0;\nconst beats = [];\nfunction emitBpmEvent(value) {\n  if (beats.length >= 5) {\n    beats.shift();\n  }\n  beats.push(value);\n  if (!counter) {\n    window.Events.emit(\n      'musicBpm',\n      beats.length\n        ? beats.reduce((prev, curr) => prev + curr) / beats.length\n        : 0\n    );\n  }\n\n  counter = (counter + 1) % 2;\n}\n\nasync function record() {\n  const audioSource = await navigator.mediaDevices.getUserMedia({\n    audio: {\n      mandatory: {\n        chromeMediaSource: 'desktop',\n      },\n    },\n    video: {\n      mandatory: {\n        chromeMediaSource: 'desktop',\n      },\n    },\n  });\n\n  (audioSource.getVideoTracks() ?? []).forEach((track) => {\n    audioSource.removeTrack(track);\n  });\n\n  const sampleRate = 5120;\n\n  const context = new AudioContext({\n    sampleRate,\n  });\n\n  const processor = context.createScriptProcessor(16384, 2, 2);\n\n  processor.onaudioprocess = (e) => {\n    const bufferData = e.inputBuffer.getChannelData(0);\n    const duration = e.inputBuffer.duration;\n\n    // 实测 这个采样率足够了。那么接下来就瞎搞吧\n    // 采样率4096, 这段时间刚好4s，真的会有30bpm的歌吗\n    // 寻找peaks，先拿一个轨道看吧\n    // 先来个放大\n    const max = Math.max(...bufferData);\n    if (max < 0.3) {\n      // 听不见\n      emitBpmEvent(0);\n      return;\n    }\n    bufferData.forEach((k, index) => {\n      bufferData[index] = k / max;\n    });\n    const peaks = [];\n    bufferData.forEach((buf, index) => {\n      if (buf > 0.7) {\n        peaks.push(index);\n      }\n    });\n    let rhythms = [];\n    peaks.forEach((k, i) => i && rhythms.push(k - peaks[i - 1]));\n    rhythms = rhythms.filter((k) => k > sampleRate / 8);\n    if (!rhythms.length) {\n      emitBpmEvent(0);\n      return;\n    }\n    if (rhythms.length > 4) {\n      const avg =\n        (rhythms.reduce((prev, curr) => prev + curr) -\n          Math.max(...rhythms) -\n          Math.min(...rhythms)) /\n        (rhythms.length - 2);\n      const beat = (60 / avg) * sampleRate;\n      emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n    } else {\n      const avg = rhythms.reduce((prev, curr) => prev + curr) / rhythms.length;\n      const beat = (60 / avg) * sampleRate;\n      emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n    }\n  };\n  // 搞个低通滤波器\n  const mediaNode = context.createMediaStreamSource(audioSource);\n  const filterNode = context.createBiquadFilter();\n  filterNode.type = 'lowpass';\n  mediaNode.connect(filterNode);\n  filterNode.connect(processor);\n  processor.connect(context.destination);\n}\n\nexport default record;\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":839,"ext":"ts","fun_ann_density":0.0321811681,"function_parameters":16,"function_signatures":0,"function_usages":1,"functions":11,"hexsha":"75cc216858cda81da5f47cc98579e10eec11b4c8","lang":"TypeScript","loc":84,"loc_per_function":11.1818181818,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"23fdfc9c11dea4254bc26b2a67863f9a56ba5d0d","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"maotoumao/desktop-pet","max_forks_repo_path":"src/renderer/pages/main/utils/beats-detector.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"23fdfc9c11dea4254bc26b2a67863f9a56ba5d0d","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"maotoumao/desktop-pet","max_issues_repo_path":"src/renderer/pages/main/utils/beats-detector.ts","max_line_length":79,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"23fdfc9c11dea4254bc26b2a67863f9a56ba5d0d","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"maotoumao/desktop-pet","max_stars_repo_path":"src/renderer/pages/main/utils/beats-detector.ts","max_stars_repo_stars_event_max_datetime":"2022-01-22T18:41:47.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-22T18:41:47.000Z","metric":0.3118322157,"predefined_density":0.0,"predefined_types":0,"prop_ann_density":0.0,"property_declarations":0,"size":2503,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0202622169,"variable_declarations":17},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"// @ts-nocheck\nlet counter = 0;\nconst beats = [];\nfunction emitBpmEvent(value: number): void {\n    if (!counter) {\n        counter = (counter + 1) % 2;\n    }\n    if (counter === 0) {\n        window.Events.emit(\"musicBpm\", value);\n    } else if {\n    if (beats.length >= 5) {\n        beats.shift();\n    }\n    beats.push(value);\n    if (!counter) {\n        window.Events.emit(\"musicBpm\", beats.length\n            ? beats.reduce((prev: number, curr: number) => prev + curr) / beats.length\n             : 0);\n    }\n    counter = (counter + 1) % 2;\n}\nasync function record() {\n    const audioSource = awai, curr: AudioBuffer | undefined = await window.Events.getAudioSource();\n    if (!curr) {\n        // new AudioBuffer(1, 44100, 48000);\n        curr = new AudioBuffer(): any;\n    }\n    curr.copyToChannel(new Float32Array(44100), 0);\n    beats.push(window.Events.getAudioSource().currentTime);\n    emitBpmEvent(beats => prev + curr) / beats.length\n            : 0);\n    }\n    counter = (counter + 1) % 2;\n}\nasync function record(): Promise<AudioBuffer | undefined> {\n    const audioSource = awai, curr: AudioBuffer | undefined = await window.Events.getAudioSource();\n    if (!curr) {\n        // new AudioBuffer(1, 44 {\n    const audioSource = await navigator.mediaDevices.getUserMedia({\n        audio: {\n            mandatory: {\n                chromeMediaSource: \"desktop\",\n            },\n        },\n        video: {\n            mandatory: {\n                chromeMediaSource: \"desktop\",\n            },\n        },\n    });\n    (audioSource.getVideoTracks() ?? []).forEach((track: {\n        track,\n    }) => {\n        audioSource.addTrack(track);\n    });\n    const sampleRate = 5120;\n    const context = new AudioContext({\n        sampleRate,\n    });\n    const processor = context): AudioProcessor | undefined => {\n        if (processor) {\n            return processor;\n        }\n        processor = context.createScriptProcessor(16384, 2, 2);\n        processor.onaudioprocess = (e) = => {\n        audioSource.removeTrack(track);\n    });\n    const sampleRate = 5120;\n    const context = new AudioContext({\n        sampleRate,\n    });\n    const processor = context.createScriptProcessor(16384, 2, 2);\n    processor.onaudioprocess = (e: AudioProcessingEvent) => {\n    audioSource.removeTrack(track);\n    };\n    processor.connect(context.destination);\n    return processor;\n    };\n    return processor;\n    }\n}\nfunction emitBpmEvent(bpm: numbe): void {\n    if (bpmEvent) {\n        clearTimeout(bpmEvent);\n    }\n    bpmEvent = setTimeout(() => {\n        bpmEvent = undefined;\n        if (bpm) {\n            window.Events.setBPM(bpm) => {\n        const bufferData = e.inputBuffer.getChannelData(0);\n        const duration = e.inputBuffer.duration;\n        // 实测 这个采样率足够了。那么接下来就瞎搞吧\n        // 采样率4096, 这段时间刚好4s，真的会有30bpm的歌吗\n        // 寻找peaks，先拿一个轨道看吧\n        // 先来个放大\n        const max = Math.max(...bufferData);\n        if (max < 0.3) {\n            // 听不见\n            emitBpmEvent(0);\n            return;\n        }\n        bufferData.forEach((k: number, index) => {\n            bufferData[index] = k / max;\n        });\n        const peaks = [];\n        bufferData.forEach((buf, index) => {\n            if (buf > 0.7) {\n                peaks, index: number;\n            }\n        });\n        if (peaks.length < 4) {\n            emitBpmEvent(0);\n            return;\n        }\n        // let rhythms = [];\n        peaks.forEach((k, i) => i &): number;\n        const last = peaks[peaks.length - 1];\n        const next = peaks[0];\n        const diff = next - last;\n        const index = bufferData.indexOf(0);\n        bufferData[index] += dif => {\n            bufferData[index] = k / max;\n        });\n        const peaks = [];\n        bufferData.forEach((buf: number, index: number) => {\n            if (buf > 0.7) {\n                peaks.push(index);\n            }\n        });\n        if (peaks.length < 4) {\n            emitBpmEvent(0);, index: number;\n        } else {\n            let rhythm = peaks[0] + peaks[1] + peaks[2] + peaks[3];\n            rhythm = (rhythm - Math.min(rhythm, 0): number);\n            if (rhythm > 0.5) {\n                emitBpmEvent(rhythm);\n            }\n        }\n    };\n    }\n}\n\n// const bufferData = e.inputBuffer.getChannelData => {\n            if (buf > 0.7) {\n                peaks.push(index);\n            }\n        });\n        let rhythms = [];\n        peaks.forEach((k: number, i) => i && rhythms.push(k - peaks[i - 1]));\n        rhythms = rhythms.filter((k) => k > sampleRate / 8);\n        if (!rhyt, i: number, j: number) {\n            rhythms = rhythms.filter((k: number) => k > sampleRate / 8);\n        }\n        if (rhythms.length < 4) {\n            emit): number;\n        } else {\n            const avg = (rhythms.reduce((prev, curr) => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) => i && rhythms.push(k - peaks[i - 1]));\n        rhythms = rhythms.filter((k: number) => k > sampleRate / 8);\n        if (!rhythms.length) {\n            emitBpmEvent(0);\n            return;\n        }\n        if (rhythms.length > 4) {): number;\n            const avg = (rhythms.reduce((prev, curr) => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) => i && rhyt => k > sampleRate / 8);\n        if (!rhythms.length) {\n            emitBpmEvent(0);\n            return;\n        }\n        if (rhythms.length > 4) {\n            const avg = (rhythms.reduce((prev: number, curr: number) => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) => i && rhythms.push(k - peaks[i -, curr: number]);\n        rhythms = rhythms.filter((k: number) => k > sampleRate / 8);\n        if (!rhythms.length) {\n            emitBpmEvent(0);\n            return;): number;\n        }\n        if (rhythms.length > 4) {\n            const avg = (rhythms.reduce((prev: number, curr: number) => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) /\n                (rhythms.length - 2);\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n        }\n        else {\n            const avg = rhythms.reduce((prev: number, curr: number): number => prev + curr) / rhythms.length;\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200? beat / 2 : beat, rhythm => prev + curr) / rhythms.length;\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n        }\n    };\n    // 搞个低通滤波器\n    const mediaNode = context.createMediaStreamSource(audioSource);\n    const filterNode = context.createBiquadFilter();\n    filterNode.type = \"lowpass\";\n    mediaNode.connect(filterNode);\n    filterNode.connect(processor);\n    processor.connect(context.destination);\n}\nexport default record;\n","score":371,"fallbacked":false,"num_type_errors":45},{"code":"// @ts-nocheck\nlet counter = 0;\nconst beats = [];\nfunction emitBpmEvent(value: number): void {\n    if (!counter) {\n        window.Events.emit(\"musicBpm\", 0);\n    }\n    counter = (counter + 1) % 2;\n}\nfunction emitSongEvent(value: string): voi {\n    if (beats.length >= 5) {\n        beats.shift();\n    }\n    beats.push(value);\n    if (!counter) {\n        window.Events.emit(\"musicBpm\", beats.length\n            ? beats.reduce((prev: number, curr: number) => prev + curr) / beats.length\n             : 0);\n    }\n    counter = (counter + 1) % 2;\n}\nfunction emitBeatEvent(value: string): void, curr: number): void {\n    if (beats.length === 1) {\n        emitSongEvent(beats[0]);\n        return;\n    }\n    emitBpmEvent(beats.length / duration);\n    if (counter === 0)): {\n        emitSongEvent(value);\n        return;\n    }\n    emitBpmEvent(0);\n}\nconst beatsPerMinute = 200;\nfunction play(audioSource: AudioSource, bpm: number => prev + curr) / beats.length\n            : 0);\n    }\n    counter = (counter + 1) % 2;\n}\nasync function record(): Promise<void> {\n    if (audioSource) {\n        audioSource.disconnect();\n    }\n    audioSource = new AudioSource(audioContext, {\n        sampleRate: 44100,\n    });\n    audioSource.connec {\n    const audioSource = await navigator.mediaDevices.getUserMedia({\n        audio: {\n            mandatory: {\n                chromeMediaSource: \"desktop\",\n            },\n        },\n        video: {\n            mandatory: {\n                chromeMediaSource: \"desktop\",\n            },\n        },\n    });\n    (audioSource.getVideoTracks() ?? []).forEach((track: MediaStreamTrack): void => {\n        audioSource.addTrack(track);\n    });\n    const sampleRate = 44100;\n    const context = new AudioContext({\n        sampleRate,\n    });\n    const processor = context): AudioDestinationNode => {\n        const audioDestination = context.createMediaStreamDestination();\n        audioDestination.connect(processor);\n        const audioBuffer = context.createBuffer(4096, 0);\n        const audioBufferSource = context => {\n        audioSource.removeTrack(track);\n    });\n    const sampleRate = 5120;\n    const context = new AudioContext({\n        sampleRate,\n    });\n    const processor = context.createScriptProcessor(16384, 2, 2);\n    processor.onaudioprocess = (e: AudioProcessingEvent) => {\n        const bufferData = e.inputBuffer.getChannelData(0);\n        const duration = e.inputBuffer.duration;\n        bufferData.forEach((k, index) => {\n            bufferData[index): number;\n            audioBuffer.copyToChannel(k, index);\n        });\n        audioBufferSource(context)(audioBuffer);\n        audioBuffer.duration = duration;\n    };\n    const audioDestination = context.createMediaStreamDestination();\n    audioDestinatio => {\n        const bufferData = e.inputBuffer.getChannelData(0);\n        const duration = e.inputBuffer.duration;\n        // 实测 这个采样率足够了。那么接下来就瞎搞吧\n        // 采样率4096, 这段时间刚好4s，真的会有30bpm的歌吗\n        // 寻找peaks，先拿一个轨道看吧\n        // 先来个放大\n        const max = Math.max(...bufferData);\n        if (max < 0.3) {\n            // 听不见\n            emitBpmEvent(0);\n            return;\n        }\n        bufferData.forEach((k: number, index) => {\n            bufferData[index] = k / max;\n        });\n        const peaks = [];\n        bufferData.forEach((buf, index) => {\n            if (buf > 0.7) {\n                peaks, index: number;\n            }\n        });\n        if (!peaks.length) {\n            emitBpmEvent(0);\n            return;\n        }\n        if (peaks.length > 4) {\n            peaks.forEach((k: number, i) =): number => {\n                return Math.min(1, buf - peaks[i - 1]);\n            };\n        }\n        // 先取4个值，然后计算和，然后取最大值\n        const maxIndex = Math.max => {\n            bufferData[index] = k / max;\n        });\n        const peaks = [];\n        bufferData.forEach((buf: number, index: number) => {\n            if (buf > 0.7) {\n                peaks.push(index);\n            }\n        });\n        const avg = (peaks.reduce((prev, curr) => prev + curr) -, index: number) / 4;\n        if (avg < 0.2) {\n            emitBpmEvent(0);\n            return;\n        }\n        const duration = audioBuffer.duration;\n        const bpm = bpmFromBuffer(audi): number;\n        const bpmEstimate = bpmFromBuffer(audioBuffer, duration * 2): number;\n        emitBpmEvent(bpmEstimate);\n    };\n    audioDestination.onaudioprocess = audioDestinatio;\n}; => {\n            if (buf > 0.7) {\n                peaks.push(index);\n            }\n        });\n        let rhythms = [];\n        peaks.forEach((k: number, i) => {\n            return Math.min(1, buf - peaks[i - 1]);\n        });\n        rhythms = rhythms.filter((k) => k > sampleRate / 8);\n        if (, i: number) {\n            rhythms.forEach((k: number, i) => {\n                return Math.min(1, buf - rhythms[i - 1]);\n            });\n        }\n        if (!rhythms.lengt): {\n            emitBpmEvent(0);\n            return;\n        }\n        if (rhythms.length > 4) {\n            const avg = (rhythms.reduce((prev, curr) => prev + curr) => i && rhythms.push(k - peaks[i - 1]));\n        rhythms = rhythms.filter((k: number, i) => k > sampleRate / 8);\n        if (rhythms.length < 4) {\n            rhythms = [];\n            return;\n        }\n        if (rhythms.length >): {\n            const avg = (rhythms.reduce((prev, curr) => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) /\n                (rhyt => k > sampleRate / 8);\n        if (!rhythms.length) {\n            emitBpmEvent(0);\n            return;\n        }\n        if (rhythms.length > 4) {\n            const avg = (rhythms.reduce((prev: number, curr: number) => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) /\n                (rhythms.length - 2);\n            const beat, curr: number;\n            rhythms.forEach((k: number, i) => {\n                return Math.min(1, buf - rhythms[i - 1]);\n            });\n            rhythms = rhythms.filter((): boolean => k > sampleRate / 8);\n            if (rhythms.length < 4) {\n                rhythms = [];\n                return;\n            }\n            if (rhythms.length > 4) { => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) /\n                (rhythms.length - 2);\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n        }\n        else {\n            const avg = rhythms.reduce((prev: number, curr: number) => prev + curr) / rhythms.length;\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200? beat / 2, curr: 0);\n        }\n    };\n    const emitBpmEvent = (beat: number, rhythm?: number): void => {\n        const bpm = (beat * 60 + rhythm) / sampleRate;\n        bpmEvent): void => {\n            if (bpmEvent.onBeat) {\n                bpmEvent.onBeat(bpm);\n            }\n        };\n    };\n    const record = (audioSource: MediaStreamSource, context: AudioContext, sampleRate: numbe => prev + curr) / rhythms.length;\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n        }\n    };\n    // 搞个低通滤波器\n    const mediaNode = context.createMediaStreamSource(audioSource);\n    const filterNode = context.createBiquadFilter();\n    filterNode.type = \"lowpass\";\n    mediaNode.connect(filterNode);\n    filterNode.connect(processor);\n    processor.connect(context.destination);\n}\nexport default record;\n","score":355,"fallbacked":false,"num_type_errors":61},{"code":"// @ts-nocheck\nlet counter = 0;\nconst beats = [];\nfunction emitBpmEvent(value: number): void {\n    counter = 0;\n    if (!beats.length) {\n        return;\n    }\n    const bpm = beats.reduce((prev, curr) => prev + curr) / beats.length;\n    beats {\n    if (beats.length >= 5) {\n        beats.shift();\n    }\n    beats.push(value);\n    if (!counter) {\n        window.Events.emit(\"musicBpm\", beats.length\n            ? beats.reduce((prev: number, curr: number) => prev + curr) / beats.length\n             : 0);\n    }\n    counter = (counter + 1) % 2;\n}\nasync function record() {\n    const audioSource = awai, curr: number = 0, last = 0;\n    let bufferData = [];\n    let audioTrack = audioSource.getAudioTracks()[0];\n    const sampleRate = 4096;\n    const context = new AudioContext({): AudioContext;\n    const processor = context.createScriptProcessor(16384, 2, 2);\n    processor.onaudioprocess = (e) => {\n        const bufferData = e.inputBuffer.getChannelData => prev + curr) / beats.length\n            : 0);\n    }\n    counter = (counter + 1) % 2;\n}\nasync function record(): Promise<any> {\n    const audioSource = await navigator.mediaDevices.getUserMedia({\n        audio: {\n            mandatory: {\n                chromeMediaSource: \"desktop\",\n            },\n        },\n        video: {\n            mandatory: {\n                chromeMedi {\n    const audioSource = await navigator.mediaDevices.getUserMedia({\n        audio: {\n            mandatory: {\n                chromeMediaSource: \"desktop\",\n            },\n        },\n        video: {\n            mandatory: {\n                chromeMediaSource: \"desktop\",\n            },\n        },\n    });\n    (audioSource.getVideoTracks() ?? []).forEach((track: {}) => {\n        audioSource.removeTrack(track);\n    });\n    const sampleRate = 5120;\n    const context = new AudioContext({\n        sampleRate,\n    });\n    const processor = context.createScriptProcessor): {\n        let last = 0, prev = 0;\n        let bufferData = [];\n        let audioTrack = audioSource.getAudioTracks()[0];\n        const sampleRate = 4096;\n        const context = new Audi => {\n        audioSource.removeTrack(track);\n    });\n    const sampleRate = 5120;\n    const context = new AudioContext({\n        sampleRate,\n    });\n    const processor = context.createScriptProcessor(16384, 2, 2);\n    processor.onaudioprocess = (e: { inputBuffer: AudioBuffer }) => {\n        const bufferData = e.inputBuffer.getChannelData(0);\n        bufferData.forEach((k, index) => {\n            bufferData[index] = k / last;\n        });): void 0;\n        if (audioTrack) {\n            audioTrack.applyConstraints({\n                channelCount: 1,\n                channelCountMode: \"explicit\",\n                echoCancellation: true,\n                noiseSuppression: false,\n                googEchoCancellation => {\n        const bufferData = e.inputBuffer.getChannelData(0);\n        const duration = e.inputBuffer.duration;\n        // 实测 这个采样率足够了。那么接下来就瞎搞吧\n        // 采样率4096, 这段时间刚好4s，真的会有30bpm的歌吗\n        // 寻找peaks，先拿一个轨道看吧\n        // 先来个放大\n        const max = Math.max(...bufferData);\n        if (max < 0.3) {\n            // 听不见\n            emitBpmEvent(0);\n            return;\n        }\n        bufferData.forEach((k: number) => {\n            bufferData[index] = k / max;\n        });\n        const peaks = [];\n        bufferData.forEach((buf, index) => {\n            if (buf > 0.7) {\n                peaks.push, index: index;\n            }\n        });\n        let rhythms = [];\n        peaks.forEach((k, i) => i && rhythms.push(k - peaks[i - 1]));\n        rhythms = rhythms.filte): void 0;\n        if (rhythms.length < 4) {\n            emitBpmEvent(0);\n            return;\n        }\n        let rhythm = 0;\n        rhythms.forEach((k) => => {\n            bufferData[index] = k / max;\n        });\n        const peaks = [];\n        bufferData.forEach((buf: number) => {\n            if (buf > 0.7) {\n                peaks.push(index);\n            }\n        });\n        let rhythm = 0;\n        peaks.forEach((k, i) => i && rhythm +=, index: number): void 0;\n        if (rhythm < 0.02) {\n            // 听不见\n            emitBpmEvent(0);\n            return;\n        }\n        // 对于频率4096): 0.27226904761153971931040877040000000000000000000 => {\n            if (buf > 0.7) {\n                peaks.push(index);\n            }\n        });\n        let rhythms = [];\n        peaks.forEach((k: number, i: number) => i && rhythms.push(k - peaks[i - 1]));\n        rhythms = rhythms.filter((k) => k > sampleRate / 4);\n        if (!, i: number, k: number): void 0;\n        rhythms.forEach((k, i) => i && rhythms.splice(i, 1));\n        if (!rhythms.length) {\n            emitBp): void 0;\n            return;\n        }\n        const avg = rhythms.reduce((prev, curr) => prev + curr) / rhythms.length;\n        const beat = (60 / avg) * sampleRate; => i && rhythms.push(k - peaks[i - 1]));\n        rhythms = rhythms.filter((k: number, i: number) => i && rhythms.splice(i, 1));\n        if (rhythms.length > 4) {\n            const avg = rhythms.reduce((prev, curr) => pre): void 0;\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200? beat / 2 : beat, rhythms.length);\n        }\n        else { => k > sampleRate / 8);\n        if (!rhythms.length) {\n            emitBpmEvent(0);\n            return;\n        }\n        if (rhythms.length > 4) {\n            const avg = (rhythms.reduce((prev: number, curr: number) => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) /\n                (rhythms.length - 2);\n            const beat, curr: number, prev: number;\n            rhythms.forEach((k, i) => i && rhythms.splice(i, 1));\n            if (!rhythms.length) {\n                emitBpmEvent(0)): void 0;\n                return;\n            }\n            const avg = rhythms.reduce((prev, curr) => prev + curr) / rhythms.length;\n            const beat = (60 / avg) * sampleRate; => prev + curr) -\n                Math.max(...rhythms) -\n                Math.min(...rhythms)) /\n                (rhythms.length - 2);\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n        }\n        else {\n            const avg = rhythms.reduce((prev: number, curr: number) => prev + curr) / rhythms.length;\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200? beat / 2, curr: 0): void 0;\n        }\n    };\n    // 发出BPM值\n    const emitBpmEvent = (beat: number, rhythm: number): void 0 => {\n        const bpm = Math.round(bea): void 0;\n        if (bpm!== currentBpm) {\n            currentBpm = bpm;\n            const bpmEvent = new BpmEvent(beat, rhythm);\n            bpmEvents.push(bpmEvent); => prev + curr) / rhythms.length;\n            const beat = (60 / avg) * sampleRate;\n            emitBpmEvent(beat > 200 ? beat / 2 : beat, rhythms.length);\n        }\n    };\n    // 搞个低通滤波器\n    const mediaNode = context.createMediaStreamSource(audioSource);\n    const filterNode = context.createBiquadFilter();\n    filterNode.type = \"lowpass\";\n    mediaNode.connect(filterNode);\n    filterNode.connect(processor);\n    processor.connect(context.destination);\n}\nexport default record;\n","score":408,"fallbacked":false,"num_type_errors":81}]}
{"dataset_elem":{"alphanum_fraction":0.5934911243,"avg_line_length":23.8028169014,"content":"/**\n * The compare function to correct the order for \"array\" or \"object\":\n * - The order for 2 values with different types are: boolean, number, string, null, array, object.\n * - The order for 2 values with the same type is according to the type:\n *   - For boolean, number, string: use the `<` sign.\n *   - For array and object: preserve the original order (or do we have a better idea?)\n */\n\nconst getOrderByType = (value: any) => {\n  if (typeof value === 'boolean') {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return 1;\n  }\n  if (typeof value === 'string') {\n    return 2;\n  }\n  if (value === null) {\n    return 3;\n  }\n  if (Array.isArray(value)) {\n    return 4;\n  }\n  if (typeof value === 'object') {\n    return 5;\n  }\n};\n\nconst cmp = (a: any, b: any) => {\n  const orderByTypeA = getOrderByType(a);\n  const orderByTypeB = getOrderByType(b);\n\n  if (orderByTypeA !== orderByTypeB) {\n    return orderByTypeA - orderByTypeB;\n  }\n\n  if (a === null && b === null || Array.isArray(a) && Array.isArray(b) || orderByTypeA === 5 && orderByTypeB === 5) {\n    return 0;\n  }\n\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'string':\n      return a.localeCompare(b);\n    case 'boolean':\n      return (+a) - (+b);\n  }\n};\n\nconst sortInnerArrays = (source: any) => {\n  if (!source || typeof source !== 'object') {\n    return source;\n  }\n\n  if (Array.isArray(source)) {\n    const result = [...source];\n    result.sort((a, b) => cmp(a, b));\n    return result.map(item => sortInnerArrays(item));\n  }\n\n  const result = { ...source };\n  for (const key in result) {\n    result[key] = sortInnerArrays(result[key]);\n  }\n  return result;\n};\n\nexport default sortInnerArrays;\n","content_without_annotations":"/**\n * The compare function to correct the order for \"array\" or \"object\":\n * - The order for 2 values with different types are: boolean, number, string, null, array, object.\n * - The order for 2 values with the same type is according to the type:\n *   - For boolean, number, string: use the `<` sign.\n *   - For array and object: preserve the original order (or do we have a better idea?)\n */\n\nconst getOrderByType = (value) => {\n  if (typeof value === 'boolean') {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return 1;\n  }\n  if (typeof value === 'string') {\n    return 2;\n  }\n  if (value === null) {\n    return 3;\n  }\n  if (Array.isArray(value)) {\n    return 4;\n  }\n  if (typeof value === 'object') {\n    return 5;\n  }\n};\n\nconst cmp = (a, b) => {\n  const orderByTypeA = getOrderByType(a);\n  const orderByTypeB = getOrderByType(b);\n\n  if (orderByTypeA !== orderByTypeB) {\n    return orderByTypeA - orderByTypeB;\n  }\n\n  if (a === null && b === null || Array.isArray(a) && Array.isArray(b) || orderByTypeA === 5 && orderByTypeB === 5) {\n    return 0;\n  }\n\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'string':\n      return a.localeCompare(b);\n    case 'boolean':\n      return (+a) - (+b);\n  }\n};\n\nconst sortInnerArrays = (source) => {\n  if (!source || typeof source !== 'object') {\n    return source;\n  }\n\n  if (Array.isArray(source)) {\n    const result = [...source];\n    result.sort((a, b) => cmp(a, b));\n    return result.map(item => sortInnerArrays(item));\n  }\n\n  const result = { ...source };\n  for (const key in result) {\n    result[key] = sortInnerArrays(result[key]);\n  }\n  return result;\n};\n\nexport default sortInnerArrays;\n","dynamism_density":0.0117878193,"dynamism_heuristic":6,"estimated_tokens":509,"ext":"ts","fun_ann_density":0.0235756385,"function_parameters":7,"function_signatures":0,"function_usages":3,"functions":5,"hexsha":"b350ec9afb7525ac8312058890c66c9660eef021","lang":"TypeScript","loc":54,"loc_per_function":9.8,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"339bac1947e69ba3a7bab2cc648a916814ee8d62","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"RexSkz/json-diff-kit","max_forks_repo_path":"src/utils/sort-inner-arrays.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"339bac1947e69ba3a7bab2cc648a916814ee8d62","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"RexSkz/json-diff-kit","max_issues_repo_path":"src/utils/sort-inner-arrays.ts","max_line_length":117,"max_stars_count":8.0,"max_stars_repo_head_hexsha":"339bac1947e69ba3a7bab2cc648a916814ee8d62","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"RexSkz/json-diff-kit","max_stars_repo_path":"src/utils/sort-inner-arrays.ts","max_stars_repo_stars_event_max_datetime":"2022-03-28T10:54:19.000Z","max_stars_repo_stars_event_min_datetime":"2022-02-09T07:58:55.000Z","metric":0.2657923183,"predefined_density":0.0,"predefined_types":0,"prop_ann_density":0.0,"property_declarations":0,"size":1690,"trivial_density":0.2105263158,"trivial_types":4,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0137524558,"variable_declarations":7},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * The compare function to correct the order for \"array\" or \"object\":\n * - The order for 2 values with different types are: boolean, number, string, null, array, object.\n * - The order for 2 values with the same type is according to the type:\n *   - For boolean, number, string: use the `<` sign.\n *   - For array and object: preserve the original order (or do we have a better idea?)\n */\nconst getOrderByType = (value: any) => {\n    if (Array.isArray(value)) {\n        return 4;\n    }\n    if (typeof value === \"object\") {\n        return 5;\n    }\n};\n/**\n * The compare function to correct th): order for 2 values with different types: boolean, number, string, null, array, object:\n * - The order for 2 values with different types are: boolean, number, string, null, array, object.\n * => {\n    if (typeof value === \"boolean\") {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return 1;\n    }\n    if (typeof value === \"string\") {\n        return 2;\n    }\n    if (value === null) {\n        return 3;\n    }\n    if (Array.isArray(value)) {\n        return 4;\n    }\n    if (typeof value === \"object\") {\n        return 5;\n    }\n};\nconst cmp = (a: any, b: any) => {\n    const orderByTypeA = getOrderByType(a);\n    const orderByTypeB = getOrderByType(b);\n    if (orderByTypeA!== orderByTypeB) {\n        return orderByTypeA, b: a;\n    }\n    switch (typeof a) {\n        case \"boolean\":\n            return a - b;\n        case \"number\":\n            return a - b;\n        case \"string\":\n            return a.localeCompare(b);\n        case \"objec): if (Array.isArray(a)) {\n                return b.length - a.length;\n            }\n            if (typeof a === \"object\") {\n                return b.localeCompare(a.toString());\n            }\n            return 0; => {\n    const orderByTypeA = getOrderByType(a);\n    const orderByTypeB = getOrderByType(b);\n    if (orderByTypeA !== orderByTypeB) {\n        return orderByTypeA - orderByTypeB;\n    }\n    if (a === null && b === null || Array.isArray(a) && Array.isArray(b) || orderByTypeA === 5 && orderByTypeB === 5) {\n        return 0;\n    }\n    switch (typeof a) {\n        case \"number\":\n            return a - b;\n        case \"string\":\n            return a.localeCompare(b);\n        case \"boolean\":\n            return (+a) - (+b);\n    }\n};\nconst sortInnerArrays = (source: any, target: any): any => {\n    if (!source || typeof source!== \"object\") {\n        return source;\n    }\n    if (Array.isArray(source)) {\n        const result = [...source];\n        result.sort((a, b) => sort => {\n    if (!source || typeof source !== \"object\") {\n        return source;\n    }\n    if (Array.isArray(source)) {\n        const result = [...source];\n        result.sort((a: any, b: any) => cmp(a, b));\n        return result.map((item) => sortInnerArrays(item));\n    }\n    return 0;\n});\n        return result.map((item) => sortInnerArrays, b: any): any;\n    }\n    const result = {...source };\n    for (const key in result) {\n        result[key] = sortInnerArrays(result[key]);\n    }\n    return result;\n};\nconst cmp = (a => cmp(a, b));\n        return result.map((item: any): any => {\n    if (!source || typeof source!== \"object\") {\n        return source;\n    }\n    if (Array.isArray(source)) {\n        const result = [...source];\n        result.sort((a, b) => sortInnerArrays(item));\n    }\n    const result = { ...source };\n    for (const key in result) {\n        result[key] = sortInnerArrays(result[key]);\n    }\n    return result;\n};\nexport default sortInnerArrays;\n","score":500,"fallbacked":false,"num_type_errors":1},{"code":"/**\n * The compare function to correct the order for \"array\" or \"object\":\n * - The order for 2 values with different types are: boolean, number, string, null, array, object.\n * - The order for 2 values with the same type is according to the type:\n *   - For boolean, number, string: use the `<` sign.\n *   - For array and object: preserve the original order (or do we have a better idea?)\n */\nconst getOrderByType = (value: any): number => {\n    if (typeof value === \"boolean\") {\n        return -1;\n    }\n    if (typeof value === \"number\") {\n        return 1;\n    }\n    if (typeof value === \"string\") {\n        return => {\n    if (typeof value === \"boolean\") {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return 1;\n    }\n    if (typeof value === \"string\") {\n        return 2;\n    }\n    if (value === null) {\n        return 3;\n    }\n    if (Array.isArray(value)) {\n        return 4;\n    }\n    if (typeof value === \"object\") {\n        return 5;\n    }\n};\nconst cmp = (a: any, b: any): number => {\n    return compareValues(a, b);\n};\nconst compareValues = (a, b) => {\n    const orderByTypeA = getOrderByType(a);\n    const orderByTypeB, b: any;\n    switch (orderByTypeA) {\n        case 0:\n            b = getOrderByType(b);\n            break;\n        case 1:\n            b = getOrderByType(b);\n            break;\n        case 2:): b = getOrderByType(b);\n            break;\n        case 3:\n            b = getOrderByType(b);\n            break;\n        case 4:\n            b = getOrderByType(b);\n            break;\n        case => {\n    const orderByTypeA = getOrderByType(a);\n    const orderByTypeB = getOrderByType(b);\n    if (orderByTypeA !== orderByTypeB) {\n        return orderByTypeA - orderByTypeB;\n    }\n    if (a === null && b === null || Array.isArray(a) && Array.isArray(b) || orderByTypeA === 5 && orderByTypeB === 5) {\n        return 0;\n    }\n    switch (typeof a) {\n        case \"number\":\n            return a - b;\n        case \"string\":\n            return a.localeCompare(b);\n        case \"boolean\":\n            return (+a) - (+b);\n    }\n};\nconst sortInnerArrays = (source: any, b: any): any => {\n    if (!source || typeof source !== \"object\") {\n        return source;\n    }\n    if (Array.isArray(source)) {\n        const result = [...source];\n        result.sort((a: any, b: any) => cmp(a, b));\n        return result;\n    }\n    if (typeof source === \"object\") {\n        const result = {...source };\n        for (const key in result) {\n            result[key, b: any] = sortInnerArrays(result[key], b);\n        }\n        return result;\n    }\n    return source;\n};\nexport const sortInnerArrays = (a: any, b: any): any => {\n    if (): boolean => true;\n    if (Array.isArray(a)) {\n        const result = [...a];\n        result.sort((a: any, b: any) => cmp(a, b));\n        return result.map((item: any) => sortInnerArrays(item));\n    }\n    if (typeof a === \"object\") {\n        const result = {...a };\n        for (const key in result) {\n            result[key, b: any] = sortInnerArray): boolean => true;\n        }\n        return result;\n    }\n    return false;\n};\nexport const sortInnerObject = (source: any): any => {\n    if (!source || typeof source!== \"object\") {\n        return source; => sortInnerArrays(item));\n    }\n    const result = { ...source };\n    for (const key in result) {\n        result[key] = sortInnerArrays(result[key]);\n    }\n    return result;\n};\nexport default sortInnerArrays;\n","score":475,"fallbacked":false,"num_type_errors":37},{"code":"/**\n * The compare function to correct the order for \"array\" or \"object\":\n * - The order for 2 values with different types are: boolean, number, string, null, array, object.\n * - The order for 2 values with the same type is according to the type:\n *   - For boolean, number, string: use the `<` sign.\n *   - For array and object: preserve the original order (or do we have a better idea?)\n */\nconst getOrderByType = (value: any): number => {\n    if (typeof value === \"boolean\") {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return 1;\n    }\n    if (typeof value === \"string\") {\n        return 2;\n    }\n    if (value === null) {\n        return 3;\n    }\n    if (Array.isArray(value)) {\n        return 4;\n    }\n    if (typeof value === \"object\") {\n        return 5;\n    }\n};\nconst cmp = (a: any, b: any): number => {\n    const orderByTypeA = getOrderByType(a);\n    const orderByTypeB = getOrderByType(b);\n    if (orderByTypeA!== orderByTypeB) {\n        return orderByType, b: a;\n    }\n    if (a === null && b === null) {\n        return 0;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return 0;\n    }\n    if): {\n        return orderByTypeA - orderByTypeB;\n    }\n};\nconst sortInnerObjects = (source) => {\n    if (!source || typeof source!== \"object\") {\n        return source;\n    }\n    if (Array.isArra => {\n    const orderByTypeA = getOrderByType(a);\n    const orderByTypeB = getOrderByType(b);\n    if (orderByTypeA !== orderByTypeB) {\n        return orderByTypeA - orderByTypeB;\n    }\n    if (a === null && b === null || Array.isArray(a) && Array.isArray(b) || orderByTypeA === 5 && orderByTypeB === 5) {\n        return 0;\n    }\n    switch (typeof a) {\n        case \"number\":\n            return a - b;\n        case \"string\":\n            return a.localeCompare(b);\n        case \"boolean\":\n            return (+a) - (+b);\n    }\n};\nconst sortInnerArrays = (source: any): any => {\n    if (!source || typeof source!== \"object\") {\n        return source;\n    }\n    if (Array.isArray(source)) {\n        const result = [...source];\n        result.sort((a, b) =): number => {\n            if (typeof a === \"string\") {\n                return 1;\n            }\n            if (typeof b === \"string\") {\n                return -1;\n            }\n            if (a === null && b === null) { => {\n    if (!source || typeof source !== \"object\") {\n        return source;\n    }\n    if (Array.isArray(source)) {\n        const result = [...source];\n        result.sort((a: any, b: any) => cmp(a, b));\n        return result.map((item) => sortInnerObjects(item));\n    }\n    const result = {...source };\n    for (const key in result) {\n        result, b: any;\n    }\n    return 0;\n};\nreturn result;\n};\n    return result;\n};\nexport const sortInnerArrays: (a: any, b: any) => any = (a: any, b: an): any => {\n    if (!a || typeof a!== \"object\") {\n        return a;\n    }\n    if (!b || typeof b!== \"object\") {\n        return b;\n    }\n    if (Array.isArray(a)) { => cmp(a, b));\n        return result.map((item: any): any => sortInnerArrays(item));\n    }\n    if (Array.isArray(b)) { => cmp(a, b);\n        return result.map((item: any): any => sortInnerArrays(item));\n    }\n    const result = { ...source };\n    for (const key in result) {\n        result[key] = sortInnerArrays(result[key]);\n    }\n    return result;\n};\nexport default sortInnerArrays;\n","score":461,"fallbacked":false,"num_type_errors":55}]}
{"dataset_elem":{"alphanum_fraction":0.5938325991,"avg_line_length":18.0158730159,"content":"export const DIFFICULTY = {\n  EASY: 0,\n  MEDIUM: 1,\n  HARD: 2,\n} as const;\n\nexport const OPERATOR = {\n  SUBTRACT: \"-\",\n  ADD: \"+\",\n  MULTIPLY: \"*\",\n  DEVIDE: \"/\",\n  SMALLER: \"<\",\n  LARGER: \">\",\n  EQUAL: \"=\",\n} as const;\n\nexport const GAME_STATE = {\n  PENDING: 1,\n  DONE: 2,\n  UNDECIDED: 3,\n  ERROR: 4,\n} as const;\n\nexport const OPERATOR_COLLECTION = {\n  ADD: [OPERATOR.ADD],\n  SUBTRACT: [OPERATOR.SUBTRACT],\n  MULTIPLY: [OPERATOR.MULTIPLY],\n  DEVIDE: [OPERATOR.DEVIDE],\n  BASIC: [OPERATOR.ADD, OPERATOR.SUBTRACT],\n  AVERAGE: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY],\n  FULL: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY, OPERATOR.DEVIDE],\n};\n\nexport const colors = [\n  \"blue\",\n  \"red\",\n  \"orange\",\n  \"yellow\",\n  \"green\",\n  \"violet\",\n  \"white\",\n];\n\nexport const operatorMapper = (s: string | number): string => {\n  if (s === \"*\") {\n    return \"×\";\n  } else if (s === \"/\") {\n    return \"÷\";\n  } else {\n    return s + \"\";\n  }\n};\n\nexport const ICONS = {\n  PLAY: \"play\",\n  COLOR_SWITCH: \"color-switch\",\n  CHEVRON_LEFT: \"chevron-left\",\n  HELP: \"help\",\n  RESTART: \"restart\",\n  CLOSE: \"close\",\n  TRASH: \"trash\",\n} as const;\n","content_without_annotations":"export const DIFFICULTY = {\n  EASY: 0,\n  MEDIUM: 1,\n  HARD: 2,\n} as const;\n\nexport const OPERATOR = {\n  SUBTRACT: \"-\",\n  ADD: \"+\",\n  MULTIPLY: \"*\",\n  DEVIDE: \"/\",\n  SMALLER: \"<\",\n  LARGER: \">\",\n  EQUAL: \"=\",\n} as const;\n\nexport const GAME_STATE = {\n  PENDING: 1,\n  DONE: 2,\n  UNDECIDED: 3,\n  ERROR: 4,\n} as const;\n\nexport const OPERATOR_COLLECTION = {\n  ADD: [OPERATOR.ADD],\n  SUBTRACT: [OPERATOR.SUBTRACT],\n  MULTIPLY: [OPERATOR.MULTIPLY],\n  DEVIDE: [OPERATOR.DEVIDE],\n  BASIC: [OPERATOR.ADD, OPERATOR.SUBTRACT],\n  AVERAGE: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY],\n  FULL: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY, OPERATOR.DEVIDE],\n};\n\nexport const colors = [\n  \"blue\",\n  \"red\",\n  \"orange\",\n  \"yellow\",\n  \"green\",\n  \"violet\",\n  \"white\",\n];\n\nexport const operatorMapper = (s) => {\n  if (s === \"*\") {\n    return \"×\";\n  } else if (s === \"/\") {\n    return \"÷\";\n  } else {\n    return s + \"\";\n  }\n};\n\nexport const ICONS = {\n  PLAY: \"play\",\n  COLOR_SWITCH: \"color-switch\",\n  CHEVRON_LEFT: \"chevron-left\",\n  HELP: \"help\",\n  RESTART: \"restart\",\n  CLOSE: \"close\",\n  TRASH: \"trash\",\n} as const;\n","dynamism_density":0.0099009901,"dynamism_heuristic":4,"estimated_tokens":404,"ext":"ts","fun_ann_density":0.004950495,"function_parameters":1,"function_signatures":0,"function_usages":0,"functions":1,"hexsha":"66050b37a0775a6164dfd8cc595165bcd9391a46","lang":"TypeScript","loc":56,"loc_per_function":7.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"9ad2d2099478efdf850c86d338f7a3f0dd72c90b","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"veit30/mind-games","max_forks_repo_path":"src/data/constants.ts","max_issues_count":3.0,"max_issues_repo_head_hexsha":"9ad2d2099478efdf850c86d338f7a3f0dd72c90b","max_issues_repo_issues_event_max_datetime":"2022-02-28T03:49:35.000Z","max_issues_repo_issues_event_min_datetime":"2022-02-13T12:24:01.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"vs1998/math-master","max_issues_repo_path":"src/data/constants.ts","max_line_length":78,"max_stars_count":null,"max_stars_repo_head_hexsha":"9ad2d2099478efdf850c86d338f7a3f0dd72c90b","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"vs1998/math-master","max_stars_repo_path":"src/data/constants.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2362970583,"predefined_density":0.3333333333,"predefined_types":3,"prop_ann_density":0.0,"property_declarations":0,"size":1135,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0173267327,"variable_declarations":7},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export const DIFFICULTY = {\n    EASY: 0,\n    MEDIUM: 1,\n    HARD: 2,\n} as const;\nexport const OPERATOR = {\n    SUBTRACT: \"-\",\n    ADD: \"+\",\n    MULTIPLY: \"*\",\n    DEVIDE: \"/\",\n    SMALLER: \"<\",\n    LARGER: \">\",\n    EQUAL: \"=\",\n} as const;\nexport const GAME_STATE = {\n    PENDING: 1,\n    DONE: 2,\n    UNDECIDED: 3,\n    ERROR: 4,\n} as const;\nexport const OPERATOR_COLLECTION = {\n    ADD: [OPERATOR.ADD],\n    SUBTRACT: [OPERATOR.SUBTRACT],\n    MULTIPLY: [OPERATOR.MULTIPLY],\n    DEVIDE: [OPERATOR.DEVIDE],\n    BASIC: [OPERATOR.ADD, OPERATOR.SUBTRACT],\n    AVERAGE: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY],\n    FULL: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY, OPERATOR.DEVIDE],\n};\nexport const colors = [\n    \"blue\",\n    \"red\",\n    \"orange\",\n    \"yellow\",\n    \"green\",\n    \"violet\",\n    \"white\",\n];\nexport const operatorMapper = (s: string): string => {\n    switch (s) {\n        case OPERATOR.ADD:\n            return \"+\";\n        case OPERATOR.SUBTRACT:\n            return \"-\";\n        case OPERATOR.MULTIPLY:\n            return \"*\";\n        case OPERATOR.D => {\n    if (s === \"*\") {\n        return \"\\u00D7\";\n    }\n    else if (s === \"/\") {\n        return \"\\u00F7\";\n    }\n    else {\n        return s + \"\";\n    }\n};\nexport const ICONS = {\n    PLAY: \"play\",\n    COLOR_SWITCH: \"color-switch\",\n    CHEVRON_LEFT: \"chevron-left\",\n    HELP: \"help\",\n    RESTART: \"restart\",\n    CLOSE: \"close\",\n    TRASH: \"trash\",\n} as const;\n","score":375,"fallbacked":false,"num_type_errors":4},{"code":"export const DIFFICULTY = {\n    EASY: 0,\n    MEDIUM: 1,\n    HARD: 2,\n} as const;\nexport const OPERATOR = {\n    SUBTRACT: \"-\",\n    ADD: \"+\",\n    MULTIPLY: \"*\",\n    DEVIDE: \"/\",\n    SMALLER: \"<\",\n    LARGER: \">\",\n    EQUAL: \"=\",\n} as const;\nexport const GAME_STATE = {\n    PENDING: 1,\n    DONE: 2,\n    UNDECIDED: 3,\n    ERROR: 4,\n} as const;\nexport const OPERATOR_COLLECTION = {\n    ADD: [OPERATOR.ADD],\n    SUBTRACT: [OPERATOR.SUBTRACT],\n    MULTIPLY: [OPERATOR.MULTIPLY],\n    DEVIDE: [OPERATOR.DEVIDE],\n    BASIC: [OPERATOR.ADD, OPERATOR.SUBTRACT],\n    AVERAGE: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY],\n    FULL: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY, OPERATOR.DEVIDE],\n};\nexport const colors = [\n    \"blue\",\n    \"red\",\n    \"orange\",\n    \"yellow\",\n    \"green\",\n    \"violet\",\n    \"white\",\n];\nexport const operatorMapper = (s: OPERATOR): string => {\n    if (s === OPERATOR.ADD) {\n        return \"+\";\n    }\n    else if (s === OPERATOR.SUBTRACT) {\n        return \"-\";\n    }\n    else if (s === OPERATOR): {\n        return \"×\";\n    }\n    else if (s === OPERATOR.MULTIPLY) {\n        return \"÷\";\n    }\n    else if (s === OPERATOR.DEVIDE) {\n        return \"÷\"; => {\n    if (s === \"*\") {\n        return \"\\u00D7\";\n    }\n    else if (s === \"/\") {\n        return \"\\u00F7\";\n    }\n    else {\n        return s + \"\";\n    }\n};\nexport const ICONS = {\n    PLAY: \"play\",\n    COLOR_SWITCH: \"color-switch\",\n    CHEVRON_LEFT: \"chevron-left\",\n    HELP: \"help\",\n    RESTART: \"restart\",\n    CLOSE: \"close\",\n    TRASH: \"trash\",\n} as const;\n","score":375,"fallbacked":false,"num_type_errors":5},{"code":"export const DIFFICULTY = {\n    EASY: 0,\n    MEDIUM: 1,\n    HARD: 2,\n} as const;\nexport const OPERATOR = {\n    SUBTRACT: \"-\",\n    ADD: \"+\",\n    MULTIPLY: \"*\",\n    DEVIDE: \"/\",\n    SMALLER: \"<\",\n    LARGER: \">\",\n    EQUAL: \"=\",\n} as const;\nexport const GAME_STATE = {\n    PENDING: 1,\n    DONE: 2,\n    UNDECIDED: 3,\n    ERROR: 4,\n} as const;\nexport const OPERATOR_COLLECTION = {\n    ADD: [OPERATOR.ADD],\n    SUBTRACT: [OPERATOR.SUBTRACT],\n    MULTIPLY: [OPERATOR.MULTIPLY],\n    DEVIDE: [OPERATOR.DEVIDE],\n    BASIC: [OPERATOR.ADD, OPERATOR.SUBTRACT],\n    AVERAGE: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY],\n    FULL: [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY, OPERATOR.DEVIDE],\n};\nexport const colors = [\n    \"blue\",\n    \"red\",\n    \"orange\",\n    \"yellow\",\n    \"green\",\n    \"violet\",\n    \"white\",\n];\nexport const operatorMapper = (s: string) => {\n    if (OPERATOR_COLLECTION[s]) {\n        return OPERATOR_COLLECTION[s];\n    }\n    return [OPERATOR.ADD, OPERATOR.SUBTRACT, OPERATOR.MULTIPLY, OPERATOR.DEVID): []\n} as const;\nexport const operatorIconMapper = (s: string) => {\n    if (s === \"*\") {\n        return \"\\u00D7\";\n    }\n    else if (s === \"/\") {\n        return \"\\u00F7\";\n    }\n    else {\n        return s + \"\";\n    }\n};\nexport const ICONS = {\n    PLAY: \"play\",\n    COLOR_SWITCH: \"color-switch\",\n    CHEVRON_LEFT: \"chevron-left\",\n    HELP: \"help\",\n    RESTART: \"restart\",\n    CLOSE: \"close\",\n    TRASH: \"trash\",\n} as const;\n","score":409,"fallbacked":false,"num_type_errors":6}]}
{"dataset_elem":{"alphanum_fraction":0.5301010101,"avg_line_length":27.808988764,"content":"export type Migration = {\n  name: string;\n  statements: string[];\n};\n\nexport type MigrateParams = {\n  db: any; // db is not defined to avoid type issues with different libs\n  migrations: Migration[];\n};\n\nconst createMigrationsTable = `\nCREATE TABLE IF NOT EXISTS \"_migrations\" (\n  \"id\"                    INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n  \"migration_name\"        TEXT NOT NULL,\n  \"created_at\"            DATETIME NOT NULL DEFAULT current_timestamp\n);\n`;\n\nconst insertMigration = `\nINSERT INTO \"_migrations\" (migration_name) VALUES (:migration_name);\n`;\n\nconst getLastMigration = `\nSELECT * FROM \"_migrations\" ORDER BY \"migration_name\" DESC LIMIT 1;\n`;\n\nfunction migrationComparator(a, b) {\n  if (a.name < b.name) {\n    return -1;\n  }\n  if (a.name > b.name) {\n    return 1;\n  }\n  return 0;\n}\n\nexport function migrate({ db, migrations }: MigrateParams) {\n  return new Promise<undefined>((resolve, reject) => {\n    try {\n      migrations.sort(migrationComparator);\n\n      db.transaction(\n        (tx) => {\n          tx.executeSql(createMigrationsTable, []);\n          tx.executeSql(getLastMigration, [], (_txn, res) => {\n            if (res.rows.length === 0) {\n              // apply all migrations\n              migrations.forEach((migration) => {\n                migration.statements.forEach((statement) => {\n                  tx.executeSql(statement, []);\n                });\n                tx.executeSql(insertMigration, [migration.name]);\n              });\n            } else if (\n              migrations[migrations.length - 1].name ===\n              res.rows.item(0).migration_name\n            ) {\n              // apply no migration\n            } else {\n              // identify and apply remaining migrations\n              const migrationsToApply = [];\n              migrations.forEach((migration) => {\n                if (migration.name > res.rows.item(0).migration_name) {\n                  migrationsToApply.push(migration);\n                }\n              });\n\n              migrationsToApply.forEach((migration) => {\n                migration.statements.forEach((statement) => {\n                  tx.executeSql(statement, []);\n                });\n                tx.executeSql(insertMigration, [migration.name]);\n              });\n            }\n          });\n        },\n        (error) => {\n          reject(error);\n        },\n        () => {\n          resolve(undefined);\n        }\n      );\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n","content_without_annotations":"export type Migration = {\n  name;\n  statements;\n};\n\nexport type MigrateParams = {\n  db; // db is not defined to avoid type issues with different libs\n  migrations;\n};\n\nconst createMigrationsTable = `\nCREATE TABLE IF NOT EXISTS \"_migrations\" (\n  \"id\"                    INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n  \"migration_name\"        TEXT NOT NULL,\n  \"created_at\"            DATETIME NOT NULL DEFAULT current_timestamp\n);\n`;\n\nconst insertMigration = `\nINSERT INTO \"_migrations\" (migration_name) VALUES (:migration_name);\n`;\n\nconst getLastMigration = `\nSELECT * FROM \"_migrations\" ORDER BY \"migration_name\" DESC LIMIT 1;\n`;\n\nfunction migrationComparator(a, b) {\n  if (a.name < b.name) {\n    return -1;\n  }\n  if (a.name > b.name) {\n    return 1;\n  }\n  return 0;\n}\n\nexport function migrate({ db, migrations }) {\n  return new Promise<undefined>((resolve, reject) => {\n    try {\n      migrations.sort(migrationComparator);\n\n      db.transaction(\n        (tx) => {\n          tx.executeSql(createMigrationsTable, []);\n          tx.executeSql(getLastMigration, [], (_txn, res) => {\n            if (res.rows.length === 0) {\n              // apply all migrations\n              migrations.forEach((migration) => {\n                migration.statements.forEach((statement) => {\n                  tx.executeSql(statement, []);\n                });\n                tx.executeSql(insertMigration, [migration.name]);\n              });\n            } else if (\n              migrations[migrations.length - 1].name ===\n              res.rows.item(0).migration_name\n            ) {\n              // apply no migration\n            } else {\n              // identify and apply remaining migrations\n              const migrationsToApply = [];\n              migrations.forEach((migration) => {\n                if (migration.name > res.rows.item(0).migration_name) {\n                  migrationsToApply.push(migration);\n                }\n              });\n\n              migrationsToApply.forEach((migration) => {\n                migration.statements.forEach((statement) => {\n                  tx.executeSql(statement, []);\n                });\n                tx.executeSql(insertMigration, [migration.name]);\n              });\n            }\n          });\n        },\n        (error) => {\n          reject(error);\n        },\n        () => {\n          resolve(undefined);\n        }\n      );\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":563,"ext":"ts","fun_ann_density":0.0461811723,"function_parameters":14,"function_signatures":0,"function_usages":0,"functions":12,"hexsha":"aaefbb78dd0623b290d8909d776a71929372ed56","lang":"TypeScript","loc":77,"loc_per_function":13.5833333333,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"14a185d3e90ef587323c61aedb6b947a6c568f68","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"SerenityNotes/serenity-tools","max_forks_repo_path":"packages/migrate/src/index.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"14a185d3e90ef587323c61aedb6b947a6c568f68","max_issues_repo_issues_event_max_datetime":"2022-01-23T08:06:53.000Z","max_issues_repo_issues_event_min_datetime":"2022-01-23T08:06:53.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"SerenityNotes/serenity-tools","max_issues_repo_path":"packages/migrate/src/index.ts","max_line_length":72,"max_stars_count":9.0,"max_stars_repo_head_hexsha":"14a185d3e90ef587323c61aedb6b947a6c568f68","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"SerenityNotes/serenity-tools","max_stars_repo_path":"packages/migrate/src/index.ts","max_stars_repo_stars_event_max_datetime":"2022-02-28T22:23:44.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-25T16:47:24.000Z","metric":0.3065524242,"predefined_density":0.0588235294,"predefined_types":2,"prop_ann_density":0.0071047957,"property_declarations":4,"size":2475,"trivial_density":0.0294117647,"trivial_types":1,"type_definitions":2,"typedef_density":0.0035523979,"var_ann_density":0.0071047957,"variable_declarations":4},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export type Migration = {\n    name: string;\n    version: string;\n    created_at: Date;\n    updated_at: Date;\n    migration_name: string;\n    statements: SqlStatement[];\n};\nexport interface SqlStatement {\n    sql: string;\n    params?;\n    statements: SqlStatement[];\n}\nexport interface SqlStatementResult {\n    sqlStatementResult: SqlStatementResult;\n    lastInsertId: number;\n}\nexport interface SqlStatementResult {\n    sqlStatementResult: SqlStatementResult;\n    lastInsertI;\n};\nexport type MigrateParams = {\n    db: Database;\n    migrations: Migration[];\n};\nexport interface Config {\n    db: {\n        driver: string;\n        name: string;\n        host?: string;\n        port?: number;\n        user?: string;\n        password?: string;\n    }; // db is not defined to avoid type issues with different libs\n    migrations: Migration[];\n    storage?: string | Storage; // if string, then we use it as the file name to save the migrations\n    storageOptions?: StorageOptions; // if StorageOptions, then we use it as the options to save the migrations\n    storag;\n};\nconst createMigrationsTable = `\nCREATE TABLE IF NOT EXISTS \"_migrations\" (\n  \"id\"                    INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n  \"migration_name\"        TEXT NOT NULL,\n  \"created_at\"            DATETIME NOT NULL DEFAULT current_timestamp\n);\n`;\nconst insertMigration = `\nINSERT INTO \"_migrations\" (migration_name) VALUES (:migration_name);\n`;\nconst getLastMigration = `\nSELECT * FROM \"_migrations\" ORDER BY \"migration_name\" DESC LIMIT 1;\n`;\nfunction migrationComparator(a: Migration, b: Migration): boolean {\n    if (a.name < b.name) {\n        return -1;\n    }\n    if (a.name > b.name) {\n        return 1;\n    }\n    return, b: 0;\n}\nexport function createMigrationTable(db: Database, params: MigrateParams) {\n    return new Promise<void>((resolve, reject) => {\n        try {\n            db.transaction((tx) => {\n                tx): Promise<SqlStatementResult>;\n                tx.executeSql(createMigrationsTable, []);\n                resolve();\n            });\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n}\nexport function insertMigrationTable(d {\n    if (a.name < b.name) {\n        return -1;\n    }\n    if (a.name > b.name) {\n        return 1;\n    }\n    return 0;\n}\nexport function migrate({ db, migrations }: { db: Database, migrations: Migration[] }): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        try {\n            migrations.sort(migrationComparator);\n            db.transaction((tx) =>): Promise<SqlStatementResult>;\n            migrations.forEach((migration) => {\n                migration.statements.forEach((statement) => {\n                    tx.executeSql(statement.sql, statement.params, _txn => {\n                        console.log(\"migratio {\n    return new Promise<undefined>((resolve: (resolve: (value: undefined) => void) => void, reject: (e: any) => void) => {\n      tx.executeSql(statement.sql, statement.params);\n      resolve();\n    });\n  }})\n    );, reject: (e: any) => {\n      console.error(e.message);\n      reject(e);\n    }});\n                });\n            });\n            resolve();\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n}): SqlStatementResult {\n    migrations.sort(migrationComparator);\n    return new Promise<SqlStatementResult>((resolve, reject) => {\n        try {\n            let sql = \"INSERT INTO \" + migrationsTableName + \" (\" + migrationsTableColumns => {\n        try {\n            migrations.sort(migrationComparator);\n            db.transaction((tx: any) => {\n                migrations.forEach((migration) => {\n                    migration.statements.forEach((statement) => {\n                        tx.executeSql(statement.sql, statement.params, _txn => {\n                            console.log(\"migrati): {\n    return new Promise<undefined>((resolve: (resolve: (value: undefined) => void) => void, reject: (e: any) => void) => {\n      tx.executeSql(statement.sql, statement.param => {\n                tx.executeSql(createMigrationsTable, []);\n                tx.executeSql(getLastMigration, [], (_txn: any) => {\n                    const lastMigration = _txn.rows[0].id;\n                    if (lastMigration === 0) {\n                        resolve({\n                            name: migration.name,\n                            sql: \"CREATE TABLE \" + migrationsTableName +, res: { res: 0 },\n                            lastMigration: 0,\n                        });\n                    }\n                    else {\n                        resolve({\n                            name: migration.name,\n                            sql: \"DROP TABLE \" + migrationsTableName + \";\", res: { res:): 0 },\n                            lastMigration: lastMigration,\n                        });\n                    }\n                }, _reject => {\n                    _reject(e);\n                });\n            });\n        }\n        catch (e) {\n            console.log(e);\n        }\n    };\n    tr => {\n                    if (res.rows.length === 0) {\n                        // apply all migrations\n                        migrations.forEach((migration: { name: string; statements: import(\"src/migrations/migrations\").default })): Promise<import(\"src/migrations/migrations\").default> => {\n                            res = tr.executeSql(statement.sql, statement.params);\n                        });\n                    }\n                    else if (res.rows.item(0).id === res => {\n                            migration.statements.forEach((statement: { sql: string; params: string[] })): Promise<import(\"src/migrations/migrations\").default> => {\n                                res = tr.executeSql(statement.sql, statement.params);\n                            });\n                    }\n                    else {\n                        consol): Promise<import(\"src/migrations/migrations\").default> => {\n                            res = tr.executeSql(insertMigration, [migration.name]);\n                        };\n                    }\n\n                    res = tr.executeSql(\"SELECT name FROM \" + migrationsTableName => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                    else if (migrations[migrations.length - 1].name ===\n                        res.rows.item(0).migration_name) {\n                        // apply no migration\n                    }\n                    else {\n                        // identify and apply remaining migrations\n                        const migrationsToApply = [];\n                        migrations.forEach((migration: import(\"src/migrations/migrations\").default)): Promise<import(\"src/migrations/migrations\").default> => {\n                            if (migration.name > res.rows.item(0).migration_name) {\n                                migrationsToApply.push(migration);\n                            }\n                        });\n                        migrationsT => {\n                            if (migration.name > res.rows.item(0).migration_name) {\n                                migrationsToApply.push(migration);\n                            }\n                        });\n                        migrationsToApply.forEach((migration: import(\"src/migrations/migrations\").default)): Promise<import(\"src/migrations/migrations\").default> => {\n                            if (res.rows.length === 0) {\n                                const statement = `INSERT INTO ${migrationsTableName} (migration_name) VALUES (?)`;\n                                const inser => {\n                            migration.statements.forEach((statement: import(\"src/migrations/migrations\").default).InsertStatement) => {\n                                tx.executeSql(statement, [migration.name]);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                })): Promise<void> => {\n                    if (res.rows.length === 0) {\n                        const statement = `INSERT INTO ${migrationsTableName} (migration_name) VALUES (?)`;\n                        const inser => {\n                            migrations.forEach((migratio => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                });\n            }, (error: Error | undefined) => {\n                if (error instanceof Error) {\n                    reject(error);\n                }\n                else {\n                    resolve(undefined);\n                }\n            }, () => {\n                resolve(undefined);\n            });\n        }\n        catch (error): Promise<void> {\n            reject(error);\n        }\n    });\n}\n\nexport function rollbackMigration(tx: import(\"src/db/tx-interface\").default, migrationsTableName: string, migrationsTableNameToRollback: string): Promis => {\n                reject(error);\n            }, (): Promise<void> => {\n                return new Promise((resolve, reject) => {\n                    const sqlStatement = `SELECT migration_name FROM ${migrationsTableName} ORDER BY migration_name ASC`;\n                    const rollbackSqlStatement = `SELECT migration_nam => {\n                resolve(undefined);\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n","score":276,"fallbacked":false,"num_type_errors":188},{"code":"export type Migration = {\n    name: string;\n    statements: string[];\n    statements: string[];\n};\nexport type Migrations = {\n    name: string;\n    migrations: Migration[];\n};\nexport type MigrationsParams = {\n    db; // db is not defined to avoid type issues with different libs\n    migrations;;\n};\nexport type MigrateParams = {\n    db: IDatabase;\n    schema?: string;\n    migrations?: Migrations;\n};\nexport interface CreateDbParams {\n    name: string;\n    version?: number;\n    schema?: string;\n    createTables?: boolean;\n    migrations?: Migrations; // db is not defined to avoid type issues with different libs\n    migrations: Migration[];\n    dropTables?: boolean;\n}\nexport interface CreateDbResult {\n    createdDb?: IDatabase;\n}\nexport interface CreateDbTask {\n    name: string;\n    params: CreateDbParams;\n    run: () =;\n};\nconst createMigrationsTable = `\nCREATE TABLE IF NOT EXISTS \"_migrations\" (\n  \"id\"                    INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n  \"migration_name\"        TEXT NOT NULL,\n  \"created_at\"            DATETIME NOT NULL DEFAULT current_timestamp\n);\n`;\nconst insertMigration = `\nINSERT INTO \"_migrations\" (migration_name) VALUES (:migration_name);\n`;\nconst getLastMigration = `\nSELECT * FROM \"_migrations\" ORDER BY \"migration_name\" DESC LIMIT 1;\n`;\nfunction migrationComparator(a: Migration, b: Migration): 1 | 0 {\n    if (a.created_at < b.created_at) {\n        return -1;\n    }\n    if (a.created_at > b.created_at, b: Migration) {\n        return 1;\n    }\n    return 0;\n}\nexport async function createDatabase({ db, params }) {\n    if (params.createTables) {\n        await db.executeSql(createMigrationsTable): Promise<CreateDbResult>;\n    }\n    if (params.migrations) {\n        migrations = params.migrations.filter(m => m.name!.match(/^(10\\.[0-9]+)$/));\n        migrations.sort(( {\n    if (a.name < b.name) {\n        return -1;\n    }\n    if (a.name > b.name) {\n        return 1;\n    }\n    return 0;\n}\nexport function migrate({ db, migrations }: Migration, { params }: Params) {\n    return new Promise<CreateDbResult>((resolve, reject) => {\n        db.transaction((tx) => {\n            tx.executeSql(insertMigration, [params.name], (_t): any => {\n                resolve(true);\n            }, (_t): any => {\n                reject(new Error('Failed to migrate'));\n            });\n        }, (_t): any => {\n            reject(new Error('Failed to start transaction'));\n        }, ( {\n    return new Promise<undefined>((resolve: any) => {\n        migrations.forEach((migration) => {\n            migration.statements.forEach((statement) => {\n                tx.executeSql(statement, [], (_t): any => {\n                    resolve();\n                }, (_t): any =>, reject: (err) => {\n                    reject(new Error(`Error in migration ${migration.name}: ${err}`));\n                });\n            });\n        });\n    });\n});\n});\n}\n}\n}\n}\nasync function createMigrationsTable): Promise<CreateDbResult> {\n    return new Promise<CreateDbResult>((resolve, reject) => {\n        db.transaction((tx) => {\n            tx.executeSql(createMigrationsTable, []);\n            resolve(true); => {\n        try {\n            migrations.sort(migrationComparator);\n            db.transaction((tx: any) => {\n                migrations.forEach((migration) => {\n                    migration.statements.forEach((statement) => {\n                        tx.executeSql(statement, []);\n                    });\n                    tx.executeSql(insertMigraion, [migration): any => {\n                        resolve();\n                    }, (_t): any => {\n                        reject(new Error('Failed to insert migration'));\n                    });\n                });\n            });\n        } catch (e) {\n            reject(new Error(e));\n        } => {\n                tx.executeSql(createMigrationsTable, []);\n                tx.executeSql(getLastMigration, [], (_txn: any) => {\n                    resolve(parseInt(getLastMigration.lastID));\n                }, (_t): any => {\n                    reject(new Error('Failed to get last migration ID'));\n                });\n            }\n        };\n    });\n});\n});, res: any => {\n    migrations.sort(migrationComparator);\n    res.forEach((migration) => {\n        migration.statements.forEach((statement) => {\n            db.transaction((tx) => {\n                tx.executeSql(statement, []);): any => {\n                    tx.executeSql(insertMigration, [migration]): any => {\n                    };\n                };\n            });\n        });\n    });\n});\n});\n}\n}\n\nfunction getLatestMigrations(migrations: Migrations | nul => {\n                    if (res.rows.length === 0) {\n                        // apply all migrations\n                        migrations.forEach((migration: Migration): void => {\n                            migration.statements.forEach((statement) => {\n                                db.transaction((tx) => {\n                                    tx.executeSql(statement, []);\n                                });\n                            });\n                            db.transaction((tx) => {\n                                tx.executeSq => {\n                            migration.statements.forEach((statement: MigrationStatement) => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                        migrations.sort(migrationComparator);\n                        res.rows.item(0).migratio): any => {\n                            res.rows.forEach((migration) => {\n                                migration.statements.forEach((statement) => {\n                                    db.transaction((tx) => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                    else if (migrations[migrations.length - 1].name ===\n                        res.rows.item(0).migration_name) {\n                        // apply no migration\n                    }\n                    else {\n                        // identify and apply remaining migrations\n                        const migrationsToApply = [];\n                        migrations.forEach((migration: MigrationStatement) => {\n                            if (migration.name < res.rows.item(0).migration_name) {\n                                migrationsToApply.push(migration);\n                            }\n                        });\n                        migrationsToApply.forEach((migration) => {): any => {\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                    db.transaction((tx) => {\n                        tx.executeSql(queryAllMigrations, [], (tx) => {\n                            tx => {\n                            if (migration.name > res.rows.item(0).migration_name) {\n                                migrationsToApply.push(migration);\n                            }\n                        });\n                        migrationsToApply.forEach((migration: MigrationStatement) => {\n                            const statement = `ALTER TABLE ${migration.table_name} ADD ${migration.addStatement}`;\n                            db.transaction((tx) => {\n                                tx.executeSql(statement, []);\n                            });\n                        });\n                    })): any => {\n                        resolve(undefined);\n                    });\n                }\n                else {\n                    resolve(undefined);\n                }\n            });\n        }\n        catch (error) {\n            reject(err);\n        }\n    });\n}\n\nfunction queryAllMigration => {\n                            migration.statements.forEach((statement: MigrationStatement) => {\n                                const statement = `SELECT * FROM ${statement.table_name} WHERE name = '${statement.name}'`;\n                                tx.executeSql(statement, [], (tx): any => {\n                                    if (tx.rows.length) {\n                                        const res = tx.rows.item(0);\n                                        if (res.migration_name > statement.version) {\n                                            statement.version = res.migration_name => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                });\n            }, (error: any) => {\n                reject(error);\n            }, () => {\n                resolve(undefined);\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n\nfunction insertMigration => {\n            migration): any => {\n                const statement = `CREATE TABLE ${migration.table_name} (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    version INTEGER NOT NULL\n                )`;\n                tx.executeSql(statement, [], => {\n                reject(error);\n            }, (): any => {\n                reject(error);\n            }, () => {\n                resolve(undefined);\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n","score":401,"fallbacked":false,"num_type_errors":191},{"code":"export type Migration = {\n    name: string;\n    statements: (Statement | Statement[])[];\n};\nexport type Statement = {\n    sql: string;\n    params?: Array<any>;\n};\nexport type Table = {\n    name: string;\n    columns: Column[];;\n    statements: Statement[];\n};\nexport type Column = {\n    name: string;\n    type: string;\n    notNull: boolean;\n    primaryKey: boolean;\n};\nexport type Schema = {\n    name: string;\n    tables: Table[];;\n};\nexport type MigrateParams = {\n    db: IDBDatabase;\n    params: MigrateParams;\n    schema?: Schema;\n    callback?: (err: any, result: boolean) => void;\n};\nexport interface MigrateTableError extends Error {\n    message: string;\n}\nexpor; // db is not defined to avoid type issues with different libs\n    migrations: Migration[];\n}\nexport class DatabaseMigrator {\n    public constructor(db: IDBDatabase, schema: Schema | null = null) {\n        if (!db) {\n            throw new Error(\"No DB provided\");\n        }\n        if (;\n};\nconst createMigrationsTable = `\nCREATE TABLE IF NOT EXISTS \"_migrations\" (\n  \"id\"                    INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n  \"migration_name\"        TEXT NOT NULL,\n  \"created_at\"            DATETIME NOT NULL DEFAULT current_timestamp\n);\n`;\nconst insertMigration = `\nINSERT INTO \"_migrations\" (migration_name) VALUES (:migration_name);\n`;\nconst getLastMigration = `\nSELECT * FROM \"_migrations\" ORDER BY \"migration_name\" DESC LIMIT 1;\n`;\nfunction migrationComparator(a: Migration, b: Migration) {\n    if (a.created_at < b.created_at) {\n        return -1;\n    }\n    if (a.created_at > b.created_at) {\n        return, b: -1;\n    }\n    return 0;\n}\nexport async function migrate({ db, schema, callback }) {\n    if (schema) {\n        try {\n            await db.transaction((tx) => {\n                tx.executeSql): Promise<any> | Promise<any> | Promise<any> | Promise<any> | Promise<any>;\n                tx.executeSql(createMigrationsTable, []);\n                return tx.executeSql(getLastMigration, [], (_tx {\n    if (a.name < b.name) {\n        return -1;\n    }\n    if (a.name > b.name) {\n        return 1;\n    }\n    return 0;\n}\nexport function migrate({ db, migrations }: {\n    db: IDBDatabase;\n    migrations: Migration[];\n}) {\n    const lastMigration = res.rows.item(0).migration_name;\n    const lastCreatedAt = res.rows.item(0).created_a): Promise<any>;\n    if (!lastMigration ||!lastCreatedAt) {\n        throw new Error(\"Database is not initialized yet\");\n    }\n    const lastMigrationDate = new Date(lastCreatedAt);\n    const currentMigrations = migrations {\n    return new Promise<undefined>((resolve: (err: any) => void, resolve: (res: any) => void) => {\n        db.transaction((tx) => {\n            tx.executeSql(getLastMigration, [], (_tx {\n    if (lastMigration < current, reject: (err: any) => void) {\n        if (err) {\n            reject(err);\n            return;\n        }\n        resolve(tx.executeSql(getMigration, [lastMigration], (_tx, res) => {\n            if): Promise<any> | Promise<any> | Promise<any> | Promise<any>;\n            return tx.executeSql(insertMigration, [res.rows.item(0).migration_name, res.rows.item(0) => {\n        try {\n            migrations.sort(migrationComparator);\n            db.transaction((tx: IDBDatabase) => {\n                migrations.forEach((migration) => {\n                    tx.executeSql(statementToRun, [migration.statements]);\n                });\n            });\n            resolve(res);\n        } catch (err) {\n            throw new Erro): any;\n        }\n    }\n}\n});\n    }));\n}\n}\nfunction migrationComparator(a: Migration, b: Migration): number {\n    if (a.name < b.name) {\n        return -1; => {\n                tx.executeSql(createMigrationsTable, []);\n                tx.executeSql(getLastMigration, [], (_txn: IDBDatabase, res: any) => {\n                if (res.rows.length === 0) {\n                    // apply all migrations\n                    migrations.forEach((migration) => {\n                        migration.statements.forEach((statement) => {\n                            t, res: any = tx.executeSql(statement);\n                        });\n                        tx.executeSql(insertMigration, [migration.name]);\n                    });\n                }\n            });\n        };\n    }\n    else if (a.name > b.name) {\n        retur): Promise<any> | Promise<any> | Promise<any> | Promise<any>;\n        return tx.executeSql(createMigrationsTable, []);\n    }\n    else {\n        // a.name === b.name\n        return => {\n                    if (res.rows.length === 0) {\n                        // apply all migrations\n                        migrations.forEach((migration: Migration) => {\n                            migration.statements.forEach((statement) => {\n                                t, res: any = tx.executeSql(statement);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }): any;\n                };\n    }\n}\nfunction insertMigration(migrationName: string, _onSuccess?: () => void, _onError?: () => void) {\n    return tx.executeSql(insertMigration, [migrationName], _onSuccess => {\n                            migration.statements.forEach((statement: string) => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n}\nfunction createMigrationsTable(onSuccess?: () => void, onError?: () =): Promise<any> | Promise<any> | Promise<any> | Promise<any>;\nexport function migrations(name: string, currentVersion: number): Promise<Migration[]> {\n    return new Promise((resolve, reject) => { => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                    else if (migrations[migrations.length - 1].name ===\n                        res.rows.item(0).migration_name) {\n                        // apply no migration\n                    }\n                    else {\n                        // identify and apply remaining migrations\n                        const migrationsToApply = [];\n                        migrations.forEach((migration: Migration) => {\n                            if (migration.name > res.rows.item(0).migration_name) {\n                                migrationsToApply.push(migration);\n                            }\n                        });\n                        migrationsToApply.forEach((migration) => {\n                            migratio): Promise<any> | Promise<any> | Promise<any> | Promise<any>;\n                            tx.executeSql(statement, []);\n                        });\n                        migrationsToApply.forEach((migration) => {\n                            migration.statements.forEach((statement => {\n                            if (migration.name > res.rows.item(0).migration_name) {\n                                migrationsToApply.push(migration);\n                            }\n                        });\n                        migrationsToApply.forEach((migration: Migration) => {\n                            tx.executeSql(statement, []);\n                        });\n                        migrationsToApply.forEach((migration: Migration) => {\n                            migration.statements.forEach((statement) => {\n                                tx.executeSql(statement, []);\n                            })): Promise<any> | Promise<any> | Promise<any> | Promise<any>;\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                });\n            }, (error) => {\n                reject(erro => {\n                            migration.statements.forEach((statement: SqlStatement) => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                });\n            }, () => {\n                resolve(undefined);\n            });\n        }\n        catc): Promise<any> {\n            return new Promise<any>((resolve, reject) => {\n                tx.executeSql(selectMigrations, [], (res) => {\n                    if (res.rows.length > 0) {\n                        migration => {\n                                tx.executeSql(statement, []);\n                            });\n                            tx.executeSql(insertMigration, [migration.name]);\n                        });\n                    }\n                });\n            }, (error: any) => {\n                reject(erro => {\n                            tx.executeSql(statement, []);\n                        });\n            }, () => {\n                resolve(undefined);\n            });\n        }\n        catch (error: any) {\n            reject(error);): Promise<any> {\n            return new Promise<any>((resolve, reject) => {\n                reject(error);\n            }, (): Promise<any> => {\n                resolve(undefined);\n            });\n        }\n    });\n}\nfunction getLatest(): Promise<SqlStatement[]> {\n    return new Promise<SqlStatement[]>((resolve, reject) => {\n        sql.all( => {\n                resolve(undefined);\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n","score":321,"fallbacked":false,"num_type_errors":248}]}
{"dataset_elem":{"alphanum_fraction":0.6301703163,"avg_line_length":24.3555555556,"content":"\nexport type AnnotationType = 'Highlight' | 'Note' | 'Bookmark';\n\nexport interface KindleAnnotation {\n  timestamp: Date;\n  type: AnnotationType;\n  content?: string;\n  page?: number;\n  location: {\n    start: number;\n    end?: number;\n  }\n}\n\nexport interface KindleBook extends BookMetadata {\n  lastAnnotation: Date;\n  annotations: Array<KindleAnnotation>;\n}\n\ninterface BookMetadata {\n  title: string;\n  author?: string;\n}\n\nexport const parseTitleLine = (titleLine: string) => {\n  const title = titleLine.replace(/\\([^)]+\\)$/g, '').trim();\n  const authorMatches = /\\((?<author>[^)]+)\\)$/g.exec(titleLine);\n\n  const author = authorMatches?.groups?.[\"author\"]?.trim();\n\n  return { title, author };\n}\n\nexport const parseMetaLine = (metaLine: string): KindleAnnotation => {\n  const typeRx = /^- Your\\s(?<type>Note|Highlight|Bookmark)/;\n  const pageRx = /page\\s+(?<page>\\d+)/;\n  const locationRx = /Location\\s+(?<start>\\d+)(-(?<end>\\d+))?/;\n  const timestampRx = /Added on\\s+(?<timestamp>.*)$/;\n\n  const type = typeRx.exec(metaLine)?.groups?.['type'];\n\n  const pageVal = pageRx.exec(metaLine)?.groups?.['page'];\n  let page: number | undefined;\n\n  if (pageVal) {\n    page = parseInt(pageVal);\n  }\n\n  const locationVal = locationRx.exec(metaLine)?.groups;\n\n  if (!locationVal) {\n    throw new Error(`Could not find location: ${metaLine}`);\n  }\n\n  let start: number | undefined;\n  let end: number | undefined;\n\n  if (locationVal['start']) {\n    start = parseInt(locationVal['start']);\n  }\n\n  if (locationVal['end']) {\n    end = parseInt(locationVal['end']);\n  }\n\n  let timestamp = new Date();\n\n  const timestampVal = timestampRx.exec(metaLine)?.groups?.['timestamp'];\n\n  if (timestampVal) {\n    timestamp = new Date(Date.parse(timestampVal));\n  }\n\n  return {\n    type,\n    page,\n    timestamp,\n    location: {\n      start,\n      end\n    }\n  } as KindleAnnotation;\n}\n\nexport const parseClipping = (clipping: string): KindleAnnotation & BookMetadata => {\n  const lines = clipping.trim().split(/\\n/);\n  \n  if (lines.length < 2) {\n    throw new Error(`Could not parse clipping, not enough lines: ${clipping}`);\n  }\n\n  const title = parseTitleLine(lines.shift()!.trim());\n  const metadata = parseMetaLine(lines.shift()!.trim());\n\n  const content = lines.join('\\n').trim();\n\n  return {\n    ...title,\n    ...metadata,\n    content\n  };\n}\n\nexport const parseKindleHighlights = (content: string): Array<KindleBook> => {\n  const clippings = content.split(/^==========$/gm).filter(line => Boolean(line.trim())).map(parseClipping);\n  return clippings.reduce((result, clipping) => {\n    let book = result.find((b) => b.title === clipping.title && b.author === clipping.author);\n\n    if (!book) {\n      book = {\n        title: clipping.title,\n        author: clipping.author,\n        annotations: [],\n        lastAnnotation: clipping.timestamp\n      };\n      result.push(book);\n    }\n\n    if (book.lastAnnotation < clipping.timestamp) {\n      book.lastAnnotation = clipping.timestamp;\n    }\n\n    book.annotations.push({\n      content: clipping.content,\n      location: clipping.location,\n      timestamp: clipping.timestamp,\n      type: clipping.type,\n      page: clipping.page\n    });\n\n    return result;\n  }, [] as Array<KindleBook>)\n    // @ts-ignore\n    .sort((a, b) => b.lastAnnotation - a.lastAnnotation);\n}","content_without_annotations":"\nexport type AnnotationType = 'Highlight' | 'Note' | 'Bookmark';\n\nexport interface KindleAnnotation {\n  timestamp;\n  type;\n  content?;\n  page?;\n  location\n}\n\nexport interface KindleBook extends BookMetadata {\n  lastAnnotation;\n  annotations;\n}\n\ninterface BookMetadata {\n  title;\n  author?;\n}\n\nexport const parseTitleLine = (titleLine) => {\n  const title = titleLine.replace(/\\([^)]+\\)$/g, '').trim();\n  const authorMatches = /\\((?<author>[^)]+)\\)$/g.exec(titleLine);\n\n  const author = authorMatches?.groups?.[\"author\"]?.trim();\n\n  return { title, author };\n}\n\nexport const parseMetaLine = (metaLine) => {\n  const typeRx = /^- Your\\s(?<type>Note|Highlight|Bookmark)/;\n  const pageRx = /page\\s+(?<page>\\d+)/;\n  const locationRx = /Location\\s+(?<start>\\d+)(-(?<end>\\d+))?/;\n  const timestampRx = /Added on\\s+(?<timestamp>.*)$/;\n\n  const type = typeRx.exec(metaLine)?.groups?.['type'];\n\n  const pageVal = pageRx.exec(metaLine)?.groups?.['page'];\n  let page;\n\n  if (pageVal) {\n    page = parseInt(pageVal);\n  }\n\n  const locationVal = locationRx.exec(metaLine)?.groups;\n\n  if (!locationVal) {\n    throw new Error(`Could not find location: ${metaLine}`);\n  }\n\n  let start;\n  let end;\n\n  if (locationVal['start']) {\n    start = parseInt(locationVal['start']);\n  }\n\n  if (locationVal['end']) {\n    end = parseInt(locationVal['end']);\n  }\n\n  let timestamp = new Date();\n\n  const timestampVal = timestampRx.exec(metaLine)?.groups?.['timestamp'];\n\n  if (timestampVal) {\n    timestamp = new Date(Date.parse(timestampVal));\n  }\n\n  return {\n    type,\n    page,\n    timestamp,\n    location: {\n      start,\n      end\n    }\n  } as KindleAnnotation;\n}\n\nexport const parseClipping = (clipping) => {\n  const lines = clipping.trim().split(/\\n/);\n  \n  if (lines.length < 2) {\n    throw new Error(`Could not parse clipping, not enough lines: ${clipping}`);\n  }\n\n  const title = parseTitleLine(lines.shift()!.trim());\n  const metadata = parseMetaLine(lines.shift()!.trim());\n\n  const content = lines.join('\\n').trim();\n\n  return {\n    ...title,\n    ...metadata,\n    content\n  };\n}\n\nexport const parseKindleHighlights = (content) => {\n  const clippings = content.split(/^==========$/gm).filter(line => Boolean(line.trim())).map(parseClipping);\n  return clippings.reduce((result, clipping) => {\n    let book = result.find((b) => b.title === clipping.title && b.author === clipping.author);\n\n    if (!book) {\n      book = {\n        title: clipping.title,\n        author: clipping.author,\n        annotations: [],\n        lastAnnotation: clipping.timestamp\n      };\n      result.push(book);\n    }\n\n    if (book.lastAnnotation < clipping.timestamp) {\n      book.lastAnnotation = clipping.timestamp;\n    }\n\n    book.annotations.push({\n      content: clipping.content,\n      location: clipping.location,\n      timestamp: clipping.timestamp,\n      type: clipping.type,\n      page: clipping.page\n    });\n\n    return result;\n  }, [] as Array<KindleBook>)\n    // @ts-ignore\n    .sort((a, b) => b.lastAnnotation - a.lastAnnotation);\n}","dynamism_density":0.0022271715,"dynamism_heuristic":2,"estimated_tokens":898,"ext":"ts","fun_ann_density":0.0200445434,"function_parameters":10,"function_signatures":0,"function_usages":2,"functions":8,"hexsha":"44a520e620f5168e4463fcd975d71bdcee8e3767","lang":"TypeScript","loc":104,"loc_per_function":12.625,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-03-06T14:11:50.000Z","max_forks_repo_forks_event_min_datetime":"2022-03-06T14:11:50.000Z","max_forks_repo_head_hexsha":"66500ad9e52f8d5a7d48ab161f34cf2c21283189","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"theBenForce/logseq-plugin-my-highlights","max_forks_repo_path":"src/utils/parseKindleHighlights.ts","max_issues_count":6.0,"max_issues_repo_head_hexsha":"66500ad9e52f8d5a7d48ab161f34cf2c21283189","max_issues_repo_issues_event_max_datetime":"2022-03-03T21:53:52.000Z","max_issues_repo_issues_event_min_datetime":"2022-03-03T12:22:49.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"theBenForce/logseq-plugin-my-highlights","max_issues_repo_path":"src/utils/parseKindleHighlights.ts","max_line_length":108,"max_stars_count":4.0,"max_stars_repo_head_hexsha":"66500ad9e52f8d5a7d48ab161f34cf2c21283189","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"theBenForce/logseq-plugin-my-highlights","max_stars_repo_path":"src/utils/parseKindleHighlights.ts","max_stars_repo_stars_event_max_datetime":"2022-03-31T12:26:22.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-03T14:14:43.000Z","metric":0.3149801554,"predefined_density":0.25,"predefined_types":13,"prop_ann_density":0.0100222717,"property_declarations":9,"size":3288,"trivial_density":0.0,"trivial_types":0,"type_definitions":4,"typedef_density":0.004454343,"var_ann_density":0.0278396437,"variable_declarations":25},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export type AnnotationType = \"Highlight\" | \"Note\" | \"Bookmark\";\nexport interface KindleAnnotation {\n    timestamp: Date;\n    type: AnnotationType;\n    content: string;\n}\nexport interface Book {\n    title: string;\n    author?: string;\n    annotations: KindleAnnotation[];\n}\nexport interface BookPage {\n    title: string;\n    type: \"Bookmark\" | \"Note\";\n    content?: string;\n    page?: number;\n    location?: { start: number, end?: number };\n}\nexport interface BookClipping {\n    start: number;\n    end?: number;;\n    content?: string;\n}\nexport interface BookMetadata {\n    title: string;\n    author: string | undefined;\n}\nexport interface BookClippingMetadata {\n    clippings: BookClipping[];\n}\nexport interface BookClippingData;\n    page?: number;\n    clippings: BookClipping[];\n}\nexport interface BookClippingMetadataRaw {\n    title: string;\n    author?: string;\n    annotations?: KindleAnnotation[];\n    clippings?: BookClippingData[];\n};\n    location: { start: number; end?: number };\n    content: string;\n    timestamp?: Date;\n}\nexport interface BookClippingMetadataRaw {\n    title: string;\n    author?: string;\n    annotations?: KindleAnnotation[];\n    clipping;\n}\nexport interface KindleBook extends BookMetadata {\n    lastAnnotation: KindleAnnotation;\n    clippings?: BookClippingMetadataRaw[];\n}\nexport interface KindleBookMetadata {\n    title: string;\n    author?: string | undefined;\n}\nexport interface BookClippingMetadata {\n    clippings;\n    annotations: KindleAnnotation[];\n}\nexport interface KindleBookClippingMetadata {\n    clippings;\n    annotations: KindleAnnotation[];\n}\nexport interface KindleBookMetadata {\n    title: string;\n    author?: string | undefined;;\n}\ninterface BookMetadata {\n    title: string;\n    author?: string | undefined;\n}\nexport interface KindleAnnotation {\n    type: \"Annotation\" | \"Chapter\" | \"Note\";\n    content?: string;\n    timestamp?: Date;\n}\nexport interface KindleAnnotatio;\n    author?: string | undefined;\n    text?: string;\n}\nexport interface BookClipping {\n    start: number;\n    end?: number;\n    content?: string;\n}\nexport interface BookClippingMetadata {\n    clippings: BookClippin;\n}\nexport const parseTitleLine = (titleLine: string) => {\n    const title = titleLine.replace(/\\([^)]+\\)$/g, \"\").trim();\n    const authorMatches = /\\((?<author>[^)]+)\\)$/g.exec(titleLine);\n    const author = authorMatches?): { author: undefined };\n    const annotationsMatches = /\\[[^\\]]+\\]$/;\n    const annotations = annotationsMatches.exec(titleLine);\n    const annotationsData: KindleAnnotation[] | undefined = undefined;\n    if (annotations) { => {\n    const title = titleLine.replace(/\\([^)]+\\)$/g, \"\").trim();\n    const authorMatches = /\\((?<author>[^)]+)\\)$/g.exec(titleLine);\n    const author = authorMatches?.groups?.[\"author\"]?.trim();\n    return { title, author };\n};\nexport const parseMetaLine = (metaLine: string) => {\n    const typeRx = /^- Your\\s(?<type>Note|Highlight|Bookmark)/;\n    const pageRx = /page\\s+(?<page>\\d+)/;\n    const timestampRx = /Added o): (?<timestamp>.*)\\s+(?:Added on|Updated on)\\s+(?<timestamp>.*)\\s+(?:Added to clippings|Updated to clippings)\\s+(?<timestamp>.*)\\s*)?$/;\n    const type = typ => {\n    const typeRx = /^- Your\\s(?<type>Note|Highlight|Bookmark)/;\n    const pageRx = /page\\s+(?<page>\\d+)/;\n    const locationRx = /Location\\s+(?<start>\\d+)(-(?<end>\\d+))?/;\n    const timestampRx = /Added on\\s+(?<timestamp>.*)$/;\n    const type = typeRx.exec(metaLine)?.groups?.[\"type\"];\n    const pageVal = pageRx.exec(metaLine)?.groups?.[\"page\"];\n    let page;\n    if (pageVal) {\n        page = parseInt(pageVal);\n    }\n    const locationVal = locationRx.exec(metaLine)?.groups;\n    if (!locationVal) {\n        throw new Error(`Could not find location: ${metaLine}`);\n    }\n    let start;\n    let end;\n    if (locationVal[\"start\"]) {\n        start = parseInt(locationVal[\"start\"]);\n    }\n    if (locationVal[\"end\"]) {\n        end = parseInt(locationVal[\"end\"]);\n    }\n    let timestamp = new Date();\n    const timestampVal = timestampRx.exec(metaLine)?.groups?.[\"timestamp\"];\n    if (timestampVal) {\n        timestamp = new Date(Date.parse(timestampVal));\n    }\n    return {\n        type,\n        page,\n        timestamp,\n        location: {\n            start,\n            end\n        }\n    } as KindleAnnotation;\n};\nexport const parseClipping = (clipping: string) => {\n    const lines = clipping.trim().split(/\\n/);\n    if (lines.length < 2) {\n        throw new Error(`Could not parse clipping, not enough lines: ${clipping}`);\n    }\n    const title): KindleAnnotation => {\n    const titleRx = /^==========\\s+(?<title>.*)\\s*(?:added|updated)\\s+(?<timestamp>.*)\\s*)?$/;\n    const metaRx = /^(\\w+)\\s*(? => {\n    const lines = clipping.trim().split(/\\n/);\n    if (lines.length < 2) {\n        throw new Error(`Could not parse clipping, not enough lines: ${clipping}`);\n    }\n    const title = parseTitleLine(lines.shift()!.trim());\n    const metadata = parseMetaLine(lines.shift()!.trim());\n    const content = lines.join(\"\\n\").trim();\n    return {\n        ...title,\n        ...metadata,\n        content\n    };\n};\nexport const parseKindleHighlights = (content: string) => {\n    let highlights: KindleAnnotation[] = [];\n    const lines = content.split(/\\n/);\n    if (lines.length === 0) {\n        return highlights;\n    }\n    const metaRx = /^(): (?<title>.*)\\s*(?:added|updated)\\s+(?<timestamp>.*)\\s*)?$/;\n    const contentRx = /(?:[^#].*)?#(\\w+)(?:\\n)?)?\\n/g; => {\n    const clippings = content.split(/^==========$/gm).filter((line: string) => Boolean(line.trim()));\n    if (clippings.length < 2) {\n        throw new Error(`Could not parse clipping, not enough lines: ${clipping}`);\n    }\n    const metaLine = parseMetaLine(line): KindleAnnotation => {\n    const titleRx = /^==========\\s+(?<title>.*)\\s*(?:added|updated)\\s+(?<timestamp>.*)\\s*)?$/;\n    const metaRx = /^(\\w+)\\s*( => Boolean(line.trim())).map(parseClipping);\n    return clippings.reduce((result: KindleAnnotation, clipping) => {\n        if (!result.find((b) => b.title === clipping.title && b.author === clipping.author)) {\n            result.push({\n                title: clipping.title,\n                author, clipping: clipping.trim(),\n                timestamp: clipping.timestamp,\n            });\n        }\n        return result;\n    }, []).reduce((result: KindleAnnotation, annotation) => {\n        if (annotation.title === \"Unknown\") {\n            return result;): KindleAnnotation => {\n                const match = metaRx.exec(annotation.clipping);\n                if (!match) {\n                    throw new Error(`Could not parse meta line for clipping: ${annotation.clipping}`);\n                }\n                const title = match => {\n        let book = result.find((b: KindleAnnotation) => b.title === match.groups.title);\n        if (!book) {\n            book = {\n                title: match.groups.title,\n                author: annotation.author,\n                annotations: [],\n                lastAnnotation: annotatio): KindleAnnotation => {\n                    const match = titleRx.exec(annotation.clipping);\n                    if (!match) {\n                        throw new Error(`Could not parse meta line for clipping: ${annotation.clipping}`);\n                    }\n                    return {\n                        title => b.title === clipping.title && b.author === clipping.author);\n        if (!book) {\n            book = {\n                title: clipping.title,\n                author: clipping.author,\n                annotations: [],\n                lastAnnotation: clipping.timestamp\n            };\n            result.push(book);\n        }\n        if (book.lastAnnotation < clipping.timestamp) {\n            book.lastAnnotation = clipping.timestamp;\n        }\n        book.annotations.push({\n            content: clipping.content,\n            location: clipping.location,\n            timestamp: clipping.timestamp,\n            type: clipping.type,\n            page: clipping.page\n        });\n        return result;\n    }, [] as Array<KindleBook>)\n        // @ts-ignore\n        .sort((a: KindleBook, b: KindleBook) => b.lastAnnotation - a.lastAnnotation);\n};\n\nexport const parseClippings = result => {\n    if (result.length === 0) {\n        return [];, b: KindleBook;\n    }\n    return result.map((b: KindleBook) => {\n        const book = b;\n        book.annotations = b.annotations\n          .sort((a: KindleAnnotation, b: KindleAnnotation): number => b.timestamp - a.timestamp)\n         .map(a => b.lastAnnotation - a.lastAnnotation);\n};\n","score":257,"fallbacked":false,"num_type_errors":107},{"code":"export type AnnotationType = \"Highlight\" | \"Note\" | \"Bookmark\";\nexport interface KindleAnnotation {\n    timestamp: Date;\n    author: string;\n    type: AnnotationType;\n    content?: string;\n    page?: number;\n    location?: Location;\n}\nexport interface Location {\n    start: number;\n    end: number;\n}\nexport interfac;\n    type: \"Book\" | \"Clipping\";\n    content?: string;\n    page?: number;\n    author?: string;\n    lastAnnotation?: KindleAnnotation;\n    annotations?: KindleAnnotation[];\n}\nexport interface Book extends KindleBook {;\n    content?: string;\n    page?: number;\n    lastAnnotation?: KindleAnnotation;\n    annotations?: KindleAnnotation[];\n}\nexport interface Clipping {\n    content?: string;\n    page?: number;\n    lastAnnotation?: KindleAnnotation;\n    annotation;\n    page?: number;\n    author?: string;\n}\nexport interface AnnotationPage {\n    kindleAnnotations: KindleAnnotation[];\n    clippings: Clipping[];\n}\nexport interface Annotation {\n    page: number;\n    timestamp: Date;\n    typ;\n    location: Location;\n}\nexport interface BookPage extends KindleBookPage {\n    annotations: Annotation[];\n    clippings: Clipping[];\n}\nexport interface ClippingPage extends KindleBookPage {\n    annotations: Annotation[];\n}\nexpor;\n}\nexport interface KindleBook extends BookMetadata {\n    lastAnnotation: KindleAnnotation;\n    annotations: KindleAnnotation[];\n}\nexport interface KindleBookPage extends BookPageMetadata {\n    annotations: Annotation[];\n}\nexport interface KindleAnnotationInfo {\n    id: string;\n    author: string;\n    annotations: Annotation[];\n}\nexport interface KindleBookPage extends BookPageMetadata {\n    annotations: Annotation[];\n}\nexport interface KindleBookPageMetadata extends BookPageMetadata {\n    annotations: Annotation[];\n}\nexport interface KindleAnnotationMetadat;\n}\ninterface BookMetadata {\n    title: string;\n    pages?: number;\n    copyright?: string;\n    series?: string;\n    seriesDate?: Date;\n}\ninterface BookPageMetadata {\n    annotations?: AnnotationPage;\n    clippings?: ClippingPage;\n}\nexport interfac;\n    author?: string;\n    annotations?: AnnotationPage;\n    clippings?: ClippingPage;\n    content?: string;\n    date?: Date;\n    lastAnnotation?: KindleAnnotation;\n    id?: string;\n    kindleAnnotations?: KindleAnnotationInfo[];;\n}\nexport const parseTitleLine = (titleLine: string): KindleBookPageMetadata => {\n    const titleLineMatches = /^([^#]+)$/.exec(titleLine);\n    if (!titleLineMatches) {\n        throw new Error(`Could not match title line \"${titleLine}\"`);\n    }\n    cons => {\n    const title = titleLine.replace(/\\([^)]+\\)$/g, \"\").trim();\n    const authorMatches = /\\((?<author>[^)]+)\\)$/g.exec(titleLine);\n    const author = authorMatches?.groups?.[\"author\"]?.trim();\n    return { title, author };\n};\nexport const parseMetaLine = (metaLine: string): KindleBookMetadata => {\n    const metaLineMatches = /^META\\s(.*)\\n$/.exec(metaLine);\n    if (!metaLineMatches) {\n        throw new Error(`Could not match meta line \"${metaLine}\"`)): { metaLineMatches };\n    }\n    cons => {\n    const metaLine = metaLineMatches[1].replace(/\\([^)]+\\)$/g, \"\").trim();\n    const metaMatches = /(\\d{4})\\.(\\d{2} => {\n    const typeRx = /^- Your\\s(?<type>Note|Highlight|Bookmark)/;\n    const pageRx = /page\\s+(?<page>\\d+)/;\n    const locationRx = /Location\\s+(?<start>\\d+)(-(?<end>\\d+))?/;\n    const timestampRx = /Added on\\s+(?<timestamp>.*)$/;\n    const type = typeRx.exec(metaLine)?.groups?.[\"type\"];\n    const pageVal = pageRx.exec(metaLine)?.groups?.[\"page\"];\n    let page;\n    if (pageVal) {\n        page = parseInt(pageVal);\n    }\n    const locationVal = locationRx.exec(metaLine)?.groups;\n    if (!locationVal) {\n        throw new Error(`Could not find location: ${metaLine}`);\n    }\n    let start;\n    let end;\n    if (locationVal[\"start\"]) {\n        start = parseInt(locationVal[\"start\"]);\n    }\n    if (locationVal[\"end\"]) {\n        end = parseInt(locationVal[\"end\"]);\n    }\n    let timestamp = new Date();\n    const timestampVal = timestampRx.exec(metaLine)?.groups?.[\"timestamp\"];\n    if (timestampVal) {\n        timestamp = new Date(Date.parse(timestampVal));\n    }\n    return {\n        type,\n        page,\n        timestamp,\n        location: {\n            start,\n            end\n        }\n    } as KindleAnnotation;\n};\nexport const parseClipping = (clipping: string): KindleBookClipping[] => {\n    const clippings = clipping.trim().split(/\\n/);\n    if (clippings.length < 3) {\n        throw new Error(`Could not parse clipping, not enough lines: $): ${clipping}`);\n    }\n    const metaLine = clippings[1];\n    if (!metaLine.startsWith(\"Metadata Line\")) {\n        throw new Error(`Could not parse clipping, line \"${metaLine}\" does not start with \"Metadata Line => {\n    const lines = clipping.trim().split(/\\n/);\n    if (lines.length < 2) {\n        throw new Error(`Could not parse clipping, not enough lines: ${clipping}`);\n    }\n    const title = parseTitleLine(lines.shift()!.trim());\n    const metadata = parseMetaLine(lines.shift()!.trim());\n    const content = lines.join(\"\\n\").trim();\n    return {\n        ...title,\n        ...metadata,\n        content\n    };\n};\nexport const parseKindleHighlights = (content: string): KindleBookHighlight[] => {\n    const highlights = content.split(/^==========$/gm).filter((line) => Boolean(line.trim())).map(parseKindleHighlight);\n    return highlights.reduce((result, highligh): KindleBookHighlight[] => {\n        if (highligh.location) {\n            const match = /^Clipping Line\\s+(\\d+)\\s+(\\d+)\\s+(.*)$/.exec(highligh.location);\n            if ( => {\n    const clippings = content.split(/^==========$/gm).filter((line: string) => Boolean(line.trim())).map(parseKindleHighlight);\n    const clippings = clippings.filter((clipping) => clipping.page === highligh.page);\n    if (clippings.length === 0): return result;\n    const clipping = clippings.find((clipping) => clipping.page === highligh.page);\n    if (!clipping) return result;\n    const clippingPage = clipping.page;\n    const clippingLine = clipping.lin => Boolean(line.trim())).map(parseClipping);\n    return clippings.reduce((result: KindleBookHighlight[], clippingPage.map(clippingLine));\n}) as KindleBookHighlight[]>;\n}\n\nfunction parseKindleHighlight(line: string): KindleBookHighlight {\n    const match = /^(\\d+)\\, clipping: (\\d+)\\s+(.*)$/.exec(line);\n    if (!match) {\n        throw new Error(`Could not parse kindle highlight: ${line}`);\n    }\n    return {\n        page: Number(match[1]),\n        lin): Number(match[2]),\n        title: match[3]\n    };\n}\n\nfunction parseClipping(line: string): ClippingLine {\n    const match = /^Clipping Line\\s+(\\d+)\\s+(\\d+)\\ => {\n        let book = result.find((b: KindleBookHighlight) => b.page === clipping.page);\n        if (!book) {\n            throw new Error(`Could not parse clipping: ${line}`);\n        }\n        return {\n            page: clipping.page,\n            start: Number): Number,\n            end: Number\n        };\n    }\n}\n\nfunction parsePage(line: string): ClippingPage {\n    const match = /^Page\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\ => b.title === clipping.title && b.author === clipping.author);\n        if (!book) {\n            book = {\n                title: clipping.title,\n                author: clipping.author,\n                annotations: [],\n                lastAnnotation: clipping.timestamp\n            };\n            result.push(book);\n        }\n        if (book.lastAnnotation < clipping.timestamp) {\n            book.lastAnnotation = clipping.timestamp;\n        }\n        book.annotations.push({\n            content: clipping.content,\n            location: clipping.location,\n            timestamp: clipping.timestamp,\n            type: clipping.type,\n            page: clipping.page\n        });\n        return result;\n    }, [] as Array<KindleBook>)\n        // @ts-ignore\n        .sort((a: KindleBook, b: KindleBook) => b.lastAnnotation - a.lastAnnotation);\n}\n\nfunction parsePageWithTimestamp(line: string): ClippingPage {\n    const match = /^Page\\s+(\\d+), b: {\n        let book = result.find((b: KindleBookHighlight) => b.page === Number(match[1]));\n        if (!book) {\n            throw new Error(`Could not parse clipping: ${line}`);\n        }\n        le): KindleBookHighlight;\n        const start = Number(match[2]);\n        const end = Number(match[3]);\n        const timestamp = Number(match[4]);\n        const content = clipping.content.substring(start - 1 => b.lastAnnotation - a.lastAnnotation);\n};\n","score":155,"fallbacked":false,"num_type_errors":124},{"code":"export type AnnotationType = \"Highlight\" | \"Note\" | \"Bookmark\";\nexport interface KindleAnnotation {\n    timestamp: Date;\n    page: number;\n    type: AnnotationType;\n    content: string;\n    location: Location;\n}\nexport interface Location {\n    start: number;\n    end: number;\n}\nexport interface KindleClip {;\n    type: \"Clip\" | \"Highlight\" | \"Note\";\n    timestamp: Date;\n    content: string;\n}\nexport interface Clipping {\n    type: \"Clip\" | \"Highlight\" | \"Note\";\n    timestamp: Date;\n    conten;\n    content?: string;\n    location: Location;\n}\nexport interface Annotation {\n    timestamp: Date;\n    page: number;\n    type: AnnotationType;\n    content: string;\n    location: Location;\n    clipping: Clipping;\n}\nexpor;\n    page?: number;\n    timestamp?: Date;\n    content?: string;\n    clipping?: Clipping;\n    location?: Location;\n    page?: number;\n    type?: AnnotationType;\n}\nexport interface KindleBook {\n    lastAnnotation?: Annotation;;\n    location: Location;\n    title?: string;\n    author?: string;\n    bookmarks?: BookMark[];\n    lastAnnotation?: Annotation;\n    annotations?: Annotation[];\n}\nexport interface BookMark {\n    timestamp: Date;\n    page: number;\n    type;\n}\nexport interface KindleBook extends BookMetadata {\n    lastAnnotation: Annotation;\n    annotations: Annotation[];\n}\nexport interface KindleBookClip extends BookClip {\n    type: \"Clip\" | \"Highlight\" | \"Note\";\n}\nexport interface BookClip {\n    type: \"Clip\" |;\n    annotations: Annotation[];\n    content?: string;\n    timestamp?: Date;\n    location: Location;\n}\nexport interface BookClipHighlight extends BookClip {\n    type: \"Highlight\" | \"Note\";\n}\nexport interface BookClipNote extends BookCli;\n}\ninterface BookMetadata {\n    title: string;\n    author?: string;\n}\nexport interface BookClip extends BookMetadata {\n    type: \"Clip\" | \"Highlight\" | \"Note\";\n    annotations: Annotation[];\n    content?: string;\n    timestamp?: Date;\n    location?;\n    author?: string;\n}\nexport interface BookClipHighlight extends BookClip {\n    type: \"Highlight\" | \"Note\";\n}\nexport interface BookClipNote extends BookClip {\n    type: \"Note\";\n}\nexport interface BookClipHighligh;\n}\nexport const parseTitleLine = (titleLine: string) => {\n    const title = titleLine.replace(/^\\s+/, \"\").trim();\n    const authorMatches = /^\\s+Author\\s+(?<author>[^:]+):?\\s*$/g.exec(titleLine)): {\n        author: authorMatches?.groups?.[\"author\"]?.trim();\n    };\n    return { title, author: authorMatches?.groups?.[\"author\"]?.trim() };\n};\nexport const parseBookTitle = (titleLine: strin => {\n    const title = titleLine.replace(/\\([^)]+\\)$/g, \"\").trim();\n    const authorMatches = /\\((?<author>[^)]+)\\)$/g.exec(titleLine);\n    const author = authorMatches?.groups?.[\"author\"]?.trim();\n    return { title, author };\n};\nexport const parseMetaLine = (metaLine: string) => {\n    const typeRx = /^- Your\\s(?<type>Clip|Highlight|Bookmark)/;\n    const locationRx = /Location\\s+(?<start>\\d+)(-(?<end>\\d+))?/): {\n        start: locationMatches?.groups?.[\"start\"]?.trim(),\n        end: locationMatches?.groups?.[\"end\"]?.trim(),\n    };\n    const timestampRx = /Added on\\s+(?<timestamp>.*)$/;\n    cons => {\n    const typeRx = /^- Your\\s(?<type>Note|Highlight|Bookmark)/;\n    const pageRx = /page\\s+(?<page>\\d+)/;\n    const locationRx = /Location\\s+(?<start>\\d+)(-(?<end>\\d+))?/;\n    const timestampRx = /Added on\\s+(?<timestamp>.*)$/;\n    const type = typeRx.exec(metaLine)?.groups?.[\"type\"];\n    const pageVal = pageRx.exec(metaLine)?.groups?.[\"page\"];\n    let page;\n    if (pageVal) {\n        page = parseInt(pageVal);\n    }\n    const locationVal = locationRx.exec(metaLine)?.groups;\n    if (!locationVal) {\n        throw new Error(`Could not find location: ${metaLine}`);\n    }\n    let start;\n    let end;\n    if (locationVal[\"start\"]) {\n        start = parseInt(locationVal[\"start\"]);\n    }\n    if (locationVal[\"end\"]) {\n        end = parseInt(locationVal[\"end\"]);\n    }\n    let timestamp = new Date();\n    const timestampVal = timestampRx.exec(metaLine)?.groups?.[\"timestamp\"];\n    if (timestampVal) {\n        timestamp = new Date(Date.parse(timestampVal));\n    }\n    return {\n        type,\n        page,\n        timestamp,\n        location: {\n            start,\n            end\n        }\n    } as KindleAnnotation;\n};\nexport const parseClipping = (clipping: string) => {\n    const lines = clipping.trim().split(/\\n/);\n    if (lines.length < 3) {\n        throw new Error(`Could not parse clipping, not enough lines: ${clipping}`);\n    }\n    const title): KindleAnnotation => {\n    const timestampRx = /Added on\\s+(?<timestamp>.*)$/;\n    const pageRx = /page\\s+(?<page>\\d+)/;\n    const timestamp = timestampRx.exec(lines => {\n    const lines = clipping.trim().split(/\\n/);\n    if (lines.length < 2) {\n        throw new Error(`Could not parse clipping, not enough lines: ${clipping}`);\n    }\n    const title = parseTitleLine(lines.shift()!.trim());\n    const metadata = parseMetaLine(lines.shift()!.trim());\n    const content = lines.join(\"\\n\").trim();\n    return {\n        ...title,\n        ...metadata,\n        content\n    };\n};\nexport const parseKindleHighlights = (content: string): KindleAnnotation[] => {\n    const highlights = content.split(/^==========$/gm).filter((line) => Boolean(line.trim())).map(parseHighlight);\n    return highlights.reduce((result, highlight) =>): KindleAnnotation[] => {\n    if (highlights.length === 0) {\n        return result;\n    }\n    if (!result.length) {\n        return result.concat(highlights[0]);\n    }\n    if (result => {\n    const clippings = content.split(/^==========$/gm).filter((line: string) => Boolean(line.trim())).map(parseClipping);\n    const book = result[0];\n    const lastAnnotation = clipping.timestamp;\n    const lastClipping = clippings.find((c) => c.timestamp ==): KindleAnnotation => {\n    if (clippings.length == 1) {\n        return clipping;\n    }\n    if (clipping.timestamp <= book.lastAnnotation) {\n        return undefined;\n    }\n    book.lastAnnotation = clipping => Boolean(line.trim())).map(parseClipping);\n    return clippings.reduce((result: KindleAnnotation[]) => {\n    if (result.length && result[result.length - 1].timestamp < lastAnnotation) {\n        result.push(lastAnnotation);\n    }\n    if (result.length) {\n        if (las, clipping: KindleAnnotation) {\n        const [first, second, third] = result;\n        if (first.title == second.title && first.author == second.author && first.content == third.content) {\n            return result;): KindleAnnotation[] => {\n            if (clippings.length == 0) {\n                return result;\n            }\n            if (!result.length) {\n                return result.concat(highlights[0]);\n            }\n            if (result = => {\n        let book = result.find((b: KindleAnnotation) => b.title === first.title && b.author === first.author);\n        if (!book) {\n            book = {\n                title: first.title,\n                author: first.author,\n                annotations: [],): KindleAnnotation[] => {\n            if (clippings.length == 0) {\n                return result;\n            }\n            if (!book) {\n                book = {\n                    title: clipping.title,\n                    author: clipping.author,\n                    annotation => b.title === clipping.title && b.author === clipping.author);\n        if (!book) {\n            book = {\n                title: clipping.title,\n                author: clipping.author,\n                annotations: [],\n                lastAnnotation: clipping.timestamp\n            };\n            result.push(book);\n        }\n        if (book.lastAnnotation < clipping.timestamp) {\n            book.lastAnnotation = clipping.timestamp;\n        }\n        book.annotations.push({\n            content: clipping.content,\n            location: clipping.location,\n            timestamp: clipping.timestamp,\n            type: clipping.type,\n            page: clipping.page\n        });\n        return result;\n    }, [] as Array<KindleBook>)\n        // @ts-ignore\n        .sort((a: KindleBook, b: KindleBook) => b.lastAnnotation - a.lastAnnotation);\n            }\n    }, b: KindleAnnotation) => b.title === second.title && b.author === second.author);\n        if (!book) {\n            book = {\n                title: second.title,\n                author: second.author,\n                annotations: [],): KindleAnnotation[] => {\n            if (clippings.length == 0) {\n                return result;\n            }\n            if (!book) {\n                book = {\n                    title: clipping.title,\n                    author: clipping.author,\n                    annotatio => b.lastAnnotation - a.lastAnnotation);\n};\n","score":245,"fallbacked":false,"num_type_errors":172}]}
{"dataset_elem":{"alphanum_fraction":0.5476663827,"avg_line_length":35.0930232558,"content":"/*\n * Copyright (c) 2018 Princess Rosella. All rights reserved.\n *\n * @LICENSE_HEADER_START@\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * @LICENSE_HEADER_END@\n */\n\nexport const BLOCK_SIZE   = 64;\nexport const BLOCK_LENGTH = 16;\n\nconst isLittleEndian = new Uint8Array(new Uint32Array([0x12345678]).buffer)[0] === 0x78;\n\nconst rotl = function(n: number, b: number): number {\n    return (n << b) | (n >>> (32 - b));\n};\n\nconst swab32s = function(n: number): number {\n    return (rotl(n, 8) & 0x00FF00FF) | (rotl(n, 24) & 0xFF00FF00);\n};\n\nconst le32_to_cpu_uint32array = function(array: Uint32Array) {\n    if (isLittleEndian)\n        return;\n\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\n\nconst cpu_to_le32_uint32array = function(array: Uint32Array) {\n    if (isLittleEndian)\n        return;\n\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\n\nconst memcpy = function(dest: Uint8Array, destOffset: number, src: Uint8Array, srcOffset: number, length: number): void {\n    dest.set(src.subarray(srcOffset, srcOffset + length), destOffset);\n};\n\nconst bzero = function(dest: Uint8Array, offset: number, length: number): void {\n    while (length--)\n        dest[offset++] = 0;\n}\n\nconst FF = function(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    const n = a + (b & c | ~b & d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst GG = function(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    const n = a + (b & d | c & ~d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst HH = function(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    const n = a + (b ^ c ^ d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst II = function(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    const n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst transform = function(block: Uint32Array, hash: Uint32Array) {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    const dd = hash[3];\n    let   a  = aa;\n    let   b  = bb;\n    let   c  = cc;\n    let   d  = dd;\n\n    a = FF(a, b, c, d, block[ 0],  7, -680876936);\n    d = FF(d, a, b, c, block[ 1], 12, -389564586);\n    c = FF(c, d, a, b, block[ 2], 17,  606105819);\n    b = FF(b, c, d, a, block[ 3], 22, -1044525330);\n    a = FF(a, b, c, d, block[ 4],  7, -176418897);\n    d = FF(d, a, b, c, block[ 5], 12,  1200080426);\n    c = FF(c, d, a, b, block[ 6], 17, -1473231341);\n    b = FF(b, c, d, a, block[ 7], 22, -45705983);\n    a = FF(a, b, c, d, block[ 8],  7,  1770035416);\n    d = FF(d, a, b, c, block[ 9], 12, -1958414417);\n    c = FF(c, d, a, b, block[10], 17, -42063);\n    b = FF(b, c, d, a, block[11], 22, -1990404162);\n    a = FF(a, b, c, d, block[12],  7,  1804603682);\n    d = FF(d, a, b, c, block[13], 12, -40341101);\n    c = FF(c, d, a, b, block[14], 17, -1502002290);\n    b = FF(b, c, d, a, block[15], 22,  1236535329);\n\n    a = GG(a, b, c, d, block[ 1]|0,  5, -165796510);\n    d = GG(d, a, b, c, block[ 6]|0,  9, -1069501632);\n    c = GG(c, d, a, b, block[11]|0, 14,  643717713);\n    b = GG(b, c, d, a, block[ 0]|0, 20, -373897302);\n    a = GG(a, b, c, d, block[ 5]|0,  5, -701558691);\n    d = GG(d, a, b, c, block[10]|0,  9,  38016083);\n    c = GG(c, d, a, b, block[15]|0, 14, -660478335);\n    b = GG(b, c, d, a, block[ 4]|0, 20, -405537848);\n    a = GG(a, b, c, d, block[ 9]|0,  5,  568446438);\n    d = GG(d, a, b, c, block[14]|0,  9, -1019803690);\n    c = GG(c, d, a, b, block[ 3]|0, 14, -187363961);\n    b = GG(b, c, d, a, block[ 8]|0, 20,  1163531501);\n    a = GG(a, b, c, d, block[13]|0,  5, -1444681467);\n    d = GG(d, a, b, c, block[ 2]|0,  9, -51403784);\n    c = GG(c, d, a, b, block[ 7]|0, 14,  1735328473);\n    b = GG(b, c, d, a, block[12]|0, 20, -1926607734);\n\n    a = HH(a, b, c, d, block[ 5]|0,  4, -378558);\n    d = HH(d, a, b, c, block[ 8]|0, 11, -2022574463);\n    c = HH(c, d, a, b, block[11]|0, 16,  1839030562);\n    b = HH(b, c, d, a, block[14]|0, 23, -35309556);\n    a = HH(a, b, c, d, block[ 1]|0,  4, -1530992060);\n    d = HH(d, a, b, c, block[ 4]|0, 11,  1272893353);\n    c = HH(c, d, a, b, block[ 7]|0, 16, -155497632);\n    b = HH(b, c, d, a, block[10]|0, 23, -1094730640);\n    a = HH(a, b, c, d, block[13]|0,  4,  681279174);\n    d = HH(d, a, b, c, block[ 0]|0, 11, -358537222);\n    c = HH(c, d, a, b, block[ 3]|0, 16, -722521979);\n    b = HH(b, c, d, a, block[ 6]|0, 23,  76029189);\n    a = HH(a, b, c, d, block[ 9]|0,  4, -640364487);\n    d = HH(d, a, b, c, block[12]|0, 11, -421815835);\n    c = HH(c, d, a, b, block[15]|0, 16,  530742520);\n    b = HH(b, c, d, a, block[ 2]|0, 23, -995338651);\n\n    a = II(a, b, c, d, block[ 0]|0,  6, -198630844);\n    d = II(d, a, b, c, block[ 7]|0, 10,  1126891415);\n    c = II(c, d, a, b, block[14]|0, 15, -1416354905);\n    b = II(b, c, d, a, block[ 5]|0, 21, -57434055);\n    a = II(a, b, c, d, block[12]|0,  6,  1700485571);\n    d = II(d, a, b, c, block[ 3]|0, 10, -1894986606);\n    c = II(c, d, a, b, block[10]|0, 15, -1051523);\n    b = II(b, c, d, a, block[ 1]|0, 21, -2054922799);\n    a = II(a, b, c, d, block[ 8]|0,  6,  1873313359);\n    d = II(d, a, b, c, block[15]|0, 10, -30611744);\n    c = II(c, d, a, b, block[ 6]|0, 15, -1560198380);\n    b = II(b, c, d, a, block[13]|0, 21,  1309151649);\n    a = II(a, b, c, d, block[ 4]|0,  6, -145523070);\n    d = II(d, a, b, c, block[11]|0, 10, -1120210379);\n    c = II(c, d, a, b, block[ 2]|0, 15,  718787259);\n    b = II(b, c, d, a, block[ 9]|0, 21, -343485551);\n\n    hash[0] = (a + aa) >>> 0;\n    hash[1] = (b + bb) >>> 0;\n    hash[2] = (c + cc) >>> 0;\n    hash[3] = (d + dd) >>> 0;\n};\n\n/**\n * MD5 message-digest algorithm\n */\nexport class MD5 {\n    private hash  = new Uint32Array([1732584193, -271733879, -1732584194, 271733878]);\n    private block = new Uint32Array(16);\n    private block8: Uint8Array;\n    private byteCount = 0;\n\n    constructor() {\n        this.block8 = new Uint8Array(this.block.buffer, this.block.byteOffset, this.block.byteLength);\n    }\n\n    /**\n     * Dynamic version of MD5.update that accepts different types to binary data as parameters.\n     * \n     * @param data Data to hash\n     * @see MD5.update\n     */\n    dynamicUpdate(data: Uint8Array | DataView | ArrayBuffer): void {\n        if (data instanceof DataView)\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        else if (data instanceof ArrayBuffer)\n            data = new Uint8Array(data);\n\n        if (!(data instanceof Uint8Array))\n            throw new Error(`Expected a Uint8Array, a DataView or an ArrayBuffer. Received ${data.constructor.name}`);\n\n        return this.update(data);\n    }\n\n    /**\n     * Process an array of bytes to hash.\n     * \n     * @param data Bytes to hash\n     */\n    update(data: Uint8Array): void {\n        const avail  = (BLOCK_SIZE - (this.byteCount & 0x3f))|0;\n        let   length = data.length;\n\n        this.byteCount += length;\n\n        if (avail > length) {\n            memcpy(this.block8, BLOCK_SIZE - avail, data, 0, length);\n            return;\n        }\n\n        memcpy(this.block8, BLOCK_SIZE - avail, data, 0, avail);\n        this.transformHelper();\n\n        let offset = avail;\n        length -= avail;\n\n        while (length >= BLOCK_SIZE) {\n            memcpy(this.block8, 0, data, offset, BLOCK_SIZE);\n            this.transformHelper();\n            offset += BLOCK_SIZE;\n            length -= BLOCK_SIZE;\n        }\n\n        memcpy(this.block8, 0, data, offset, length);\n    }\n\n    /**\n     * Produce the hash as a sequence of 16 bytes.\n     */\n    toUint8Array(): Uint8Array {\n        const offset  = this.byteCount & 0x3f;\n        let   p       = offset;\n        let   padding = 56 - (offset + 1);\n\n        const block8  = this.block8.slice(0);\n        const block   = new Uint32Array(block8.buffer);\n        const hash    = this.hash.slice(0);\n\n        block8[p++] = 0x80;\n        if (padding < 0) {\n            bzero(block8, p, padding + 8);\n\n            if (!isLittleEndian)\n                le32_to_cpu_uint32array(block);\n\n            transform(block, hash);\n            p       = 0;\n            padding = 56;\n        }\n\n        bzero(block8, p, padding);\n        block[14] = this.byteCount << 3;\n        block[15] = this.byteCount >>> 29;\n\n        if (!isLittleEndian) {\n            le32_to_cpu_uint32array(block.subarray(0, BLOCK_LENGTH - 2));\n            transform(block, hash);\n            cpu_to_le32_uint32array(hash);\n        }\n        else {\n            transform(block, hash);\n        }\n        \n        return new Uint8Array(hash.buffer);\n    }\n\n    /**\n     * Produce the hash as string in hexadecimal format.\n     */\n    toString(): string {\n        let   hex        = \"\";\n        const hash       = this.toUint8Array();\n        const hashLength = hash.byteLength;\n\n        for (let i = 0; i < hashLength; i++) {\n            hex += ((hash[i] >>> 4)  & 0xF).toString(16);\n            hex += ((hash[i] >>> 0)  & 0xF).toString(16);\n        }\n\n        return hex;\n    }\n\n    private transformHelper() {\n        if (!isLittleEndian)\n            le32_to_cpu_uint32array(this.block);\n\n        return transform(this.block, this.hash);\n    }\n\n    static process(data: Uint8Array | DataView | ArrayBuffer): string {\n        const md5 = new MD5();\n        md5.dynamicUpdate(data);\n        return md5.toString();\n    }\n}\n","content_without_annotations":"/*\n * Copyright (c) 2018 Princess Rosella. All rights reserved.\n *\n * @LICENSE_HEADER_START@\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * @LICENSE_HEADER_END@\n */\n\nexport const BLOCK_SIZE   = 64;\nexport const BLOCK_LENGTH = 16;\n\nconst isLittleEndian = new Uint8Array(new Uint32Array([0x12345678]).buffer)[0] === 0x78;\n\nconst rotl = function(n, b) {\n    return (n << b) | (n >>> (32 - b));\n};\n\nconst swab32s = function(n) {\n    return (rotl(n, 8) & 0x00FF00FF) | (rotl(n, 24) & 0xFF00FF00);\n};\n\nconst le32_to_cpu_uint32array = function(array) {\n    if (isLittleEndian)\n        return;\n\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\n\nconst cpu_to_le32_uint32array = function(array) {\n    if (isLittleEndian)\n        return;\n\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\n\nconst memcpy = function(dest, destOffset, src, srcOffset, length) {\n    dest.set(src.subarray(srcOffset, srcOffset + length), destOffset);\n};\n\nconst bzero = function(dest, offset, length) {\n    while (length--)\n        dest[offset++] = 0;\n}\n\nconst FF = function(a, b, c, d, x, s, t) {\n    const n = a + (b & c | ~b & d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst GG = function(a, b, c, d, x, s, t) {\n    const n = a + (b & d | c & ~d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst HH = function(a, b, c, d, x, s, t) {\n    const n = a + (b ^ c ^ d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst II = function(a, b, c, d, x, s, t) {\n    const n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst transform = function(block, hash) {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    const dd = hash[3];\n    let   a  = aa;\n    let   b  = bb;\n    let   c  = cc;\n    let   d  = dd;\n\n    a = FF(a, b, c, d, block[ 0],  7, -680876936);\n    d = FF(d, a, b, c, block[ 1], 12, -389564586);\n    c = FF(c, d, a, b, block[ 2], 17,  606105819);\n    b = FF(b, c, d, a, block[ 3], 22, -1044525330);\n    a = FF(a, b, c, d, block[ 4],  7, -176418897);\n    d = FF(d, a, b, c, block[ 5], 12,  1200080426);\n    c = FF(c, d, a, b, block[ 6], 17, -1473231341);\n    b = FF(b, c, d, a, block[ 7], 22, -45705983);\n    a = FF(a, b, c, d, block[ 8],  7,  1770035416);\n    d = FF(d, a, b, c, block[ 9], 12, -1958414417);\n    c = FF(c, d, a, b, block[10], 17, -42063);\n    b = FF(b, c, d, a, block[11], 22, -1990404162);\n    a = FF(a, b, c, d, block[12],  7,  1804603682);\n    d = FF(d, a, b, c, block[13], 12, -40341101);\n    c = FF(c, d, a, b, block[14], 17, -1502002290);\n    b = FF(b, c, d, a, block[15], 22,  1236535329);\n\n    a = GG(a, b, c, d, block[ 1]|0,  5, -165796510);\n    d = GG(d, a, b, c, block[ 6]|0,  9, -1069501632);\n    c = GG(c, d, a, b, block[11]|0, 14,  643717713);\n    b = GG(b, c, d, a, block[ 0]|0, 20, -373897302);\n    a = GG(a, b, c, d, block[ 5]|0,  5, -701558691);\n    d = GG(d, a, b, c, block[10]|0,  9,  38016083);\n    c = GG(c, d, a, b, block[15]|0, 14, -660478335);\n    b = GG(b, c, d, a, block[ 4]|0, 20, -405537848);\n    a = GG(a, b, c, d, block[ 9]|0,  5,  568446438);\n    d = GG(d, a, b, c, block[14]|0,  9, -1019803690);\n    c = GG(c, d, a, b, block[ 3]|0, 14, -187363961);\n    b = GG(b, c, d, a, block[ 8]|0, 20,  1163531501);\n    a = GG(a, b, c, d, block[13]|0,  5, -1444681467);\n    d = GG(d, a, b, c, block[ 2]|0,  9, -51403784);\n    c = GG(c, d, a, b, block[ 7]|0, 14,  1735328473);\n    b = GG(b, c, d, a, block[12]|0, 20, -1926607734);\n\n    a = HH(a, b, c, d, block[ 5]|0,  4, -378558);\n    d = HH(d, a, b, c, block[ 8]|0, 11, -2022574463);\n    c = HH(c, d, a, b, block[11]|0, 16,  1839030562);\n    b = HH(b, c, d, a, block[14]|0, 23, -35309556);\n    a = HH(a, b, c, d, block[ 1]|0,  4, -1530992060);\n    d = HH(d, a, b, c, block[ 4]|0, 11,  1272893353);\n    c = HH(c, d, a, b, block[ 7]|0, 16, -155497632);\n    b = HH(b, c, d, a, block[10]|0, 23, -1094730640);\n    a = HH(a, b, c, d, block[13]|0,  4,  681279174);\n    d = HH(d, a, b, c, block[ 0]|0, 11, -358537222);\n    c = HH(c, d, a, b, block[ 3]|0, 16, -722521979);\n    b = HH(b, c, d, a, block[ 6]|0, 23,  76029189);\n    a = HH(a, b, c, d, block[ 9]|0,  4, -640364487);\n    d = HH(d, a, b, c, block[12]|0, 11, -421815835);\n    c = HH(c, d, a, b, block[15]|0, 16,  530742520);\n    b = HH(b, c, d, a, block[ 2]|0, 23, -995338651);\n\n    a = II(a, b, c, d, block[ 0]|0,  6, -198630844);\n    d = II(d, a, b, c, block[ 7]|0, 10,  1126891415);\n    c = II(c, d, a, b, block[14]|0, 15, -1416354905);\n    b = II(b, c, d, a, block[ 5]|0, 21, -57434055);\n    a = II(a, b, c, d, block[12]|0,  6,  1700485571);\n    d = II(d, a, b, c, block[ 3]|0, 10, -1894986606);\n    c = II(c, d, a, b, block[10]|0, 15, -1051523);\n    b = II(b, c, d, a, block[ 1]|0, 21, -2054922799);\n    a = II(a, b, c, d, block[ 8]|0,  6,  1873313359);\n    d = II(d, a, b, c, block[15]|0, 10, -30611744);\n    c = II(c, d, a, b, block[ 6]|0, 15, -1560198380);\n    b = II(b, c, d, a, block[13]|0, 21,  1309151649);\n    a = II(a, b, c, d, block[ 4]|0,  6, -145523070);\n    d = II(d, a, b, c, block[11]|0, 10, -1120210379);\n    c = II(c, d, a, b, block[ 2]|0, 15,  718787259);\n    b = II(b, c, d, a, block[ 9]|0, 21, -343485551);\n\n    hash[0] = (a + aa) >>> 0;\n    hash[1] = (b + bb) >>> 0;\n    hash[2] = (c + cc) >>> 0;\n    hash[3] = (d + dd) >>> 0;\n};\n\n/**\n * MD5 message-digest algorithm\n */\nexport class MD5 {\n    private hash  = new Uint32Array([1732584193, -271733879, -1732584194, 271733878]);\n    private block = new Uint32Array(16);\n    private block8;\n    private byteCount = 0;\n\n    constructor() {\n        this.block8 = new Uint8Array(this.block.buffer, this.block.byteOffset, this.block.byteLength);\n    }\n\n    /**\n     * Dynamic version of MD5.update that accepts different types to binary data as parameters.\n     * \n     * @param data Data to hash\n     * @see MD5.update\n     */\n    dynamicUpdate(data) {\n        if (data instanceof DataView)\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        else if (data instanceof ArrayBuffer)\n            data = new Uint8Array(data);\n\n        if (!(data instanceof Uint8Array))\n            throw new Error(`Expected a Uint8Array, a DataView or an ArrayBuffer. Received ${data.constructor.name}`);\n\n        return this.update(data);\n    }\n\n    /**\n     * Process an array of bytes to hash.\n     * \n     * @param data Bytes to hash\n     */\n    update(data) {\n        const avail  = (BLOCK_SIZE - (this.byteCount & 0x3f))|0;\n        let   length = data.length;\n\n        this.byteCount += length;\n\n        if (avail > length) {\n            memcpy(this.block8, BLOCK_SIZE - avail, data, 0, length);\n            return;\n        }\n\n        memcpy(this.block8, BLOCK_SIZE - avail, data, 0, avail);\n        this.transformHelper();\n\n        let offset = avail;\n        length -= avail;\n\n        while (length >= BLOCK_SIZE) {\n            memcpy(this.block8, 0, data, offset, BLOCK_SIZE);\n            this.transformHelper();\n            offset += BLOCK_SIZE;\n            length -= BLOCK_SIZE;\n        }\n\n        memcpy(this.block8, 0, data, offset, length);\n    }\n\n    /**\n     * Produce the hash as a sequence of 16 bytes.\n     */\n    toUint8Array() {\n        const offset  = this.byteCount & 0x3f;\n        let   p       = offset;\n        let   padding = 56 - (offset + 1);\n\n        const block8  = this.block8.slice(0);\n        const block   = new Uint32Array(block8.buffer);\n        const hash    = this.hash.slice(0);\n\n        block8[p++] = 0x80;\n        if (padding < 0) {\n            bzero(block8, p, padding + 8);\n\n            if (!isLittleEndian)\n                le32_to_cpu_uint32array(block);\n\n            transform(block, hash);\n            p       = 0;\n            padding = 56;\n        }\n\n        bzero(block8, p, padding);\n        block[14] = this.byteCount << 3;\n        block[15] = this.byteCount >>> 29;\n\n        if (!isLittleEndian) {\n            le32_to_cpu_uint32array(block.subarray(0, BLOCK_LENGTH - 2));\n            transform(block, hash);\n            cpu_to_le32_uint32array(hash);\n        }\n        else {\n            transform(block, hash);\n        }\n        \n        return new Uint8Array(hash.buffer);\n    }\n\n    /**\n     * Produce the hash as string in hexadecimal format.\n     */\n    toString() {\n        let   hex        = \"\";\n        const hash       = this.toUint8Array();\n        const hashLength = hash.byteLength;\n\n        for (let i = 0; i < hashLength; i++) {\n            hex += ((hash[i] >>> 4)  & 0xF).toString(16);\n            hex += ((hash[i] >>> 0)  & 0xF).toString(16);\n        }\n\n        return hex;\n    }\n\n    private transformHelper() {\n        if (!isLittleEndian)\n            le32_to_cpu_uint32array(this.block);\n\n        return transform(this.block, this.hash);\n    }\n\n    static process(data) {\n        const md5 = new MD5();\n        md5.dynamicUpdate(data);\n        return md5.toString();\n    }\n}\n","dynamism_density":0.0006785795,"dynamism_heuristic":3,"estimated_tokens":4421,"ext":"ts","fun_ann_density":0.0144763628,"function_parameters":46,"function_signatures":0,"function_usages":16,"functions":18,"hexsha":"6098211daafdab1fe8de0c09c0ecd62b337844c8","lang":"TypeScript","loc":209,"loc_per_function":9.1111111111,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"ddfae1ee439a5e7238e23a5f2c66f80d94aab651","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"princess-rosella/spu-md5","max_forks_repo_path":"lib/index.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"ddfae1ee439a5e7238e23a5f2c66f80d94aab651","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"princess-rosella/spu-md5","max_issues_repo_path":"lib/index.ts","max_line_length":121,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"ddfae1ee439a5e7238e23a5f2c66f80d94aab651","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"princess-rosella/spu-md5","max_stars_repo_path":"lib/index.ts","max_stars_repo_stars_event_max_datetime":"2021-12-31T03:11:45.000Z","max_stars_repo_stars_event_min_datetime":"2021-12-31T03:11:45.000Z","metric":0.2387452822,"predefined_density":0.4363636364,"predefined_types":48,"prop_ann_density":0.0009047727,"property_declarations":4,"size":10563,"trivial_density":0.0,"trivial_types":0,"type_definitions":1,"typedef_density":0.0002261932,"var_ann_density":0.0095001131,"variable_declarations":42},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/*\n * Copyright (c) 2018 Princess Rosella. All rights reserved.\n *\n * @LICENSE_HEADER_START@\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * @LICENSE_HEADER_END@\n */\nexport const BLOCK_SIZE = 64;\nexport const BLOCK_LENGTH = 16;\nconst isLittleEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 120;\nconst rotl = function (n: number, b: number) {\n    return (n << b) | (n >>> (32 - b));\n};\nconst rotl32 = function (n: number, b: number) {\n    return (n <<, b: number);\n};\nconst rotl64 = function (n: number, b: number) {\n    return (n << b) | (n >>> (32 - b));\n};\nconst rotl_32 = functio): (a: Uint32Array, b: Uint32Array) => void {\n    for (let i = 0; i < b.length; i++) {\n        a[i] = b[i];\n    }\n} {\n    return (n << b) | (n >>> (32 - b));\n};\nconst swab32s = function (n: number, b: number): number {\n    let x = (n << b) | (n >>> (32 - b));\n    return x;\n};\nconst swab64s = function (n: number, b: numbe): number {\n    let x = (n << b) | (n >>> (32 - b));\n    return x;\n};\nconst swab32 = function (n: number, b: number): number {\n    return swa {\n    return (rotl(n, 8) & 16711935) | (rotl(n, 24) & 4278255360);\n};\nconst le32_to_cpu_uint32array = function (array: Uint32Array, off: number, count: number) {\n    for (let i = 0; i < count; i++)\n        array[off+i] = (i >>> 24) & 0xff;): = 0;\n};\nconst le64_to_cpu_uint64array = function (array: Uint32Array, off: number, count: number) {\n    for (let i = 0; i {\n    if (isLittleEndian)\n        return;\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\nconst cpu_to_le32_uint32array = function (array: Uint32Array, off: number, count: number) {\n    for (let i = 0; i < count; i++)\n        array[off+i] = swab32s(array[off+i]);): = 0;\n};\nconst cpu_to_le64_uint64array = function (array: Uint32Array, off: number, count: number) {\n    for (let i = 0; i {\n    if (isLittleEndian)\n        return;\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\nconst memcpy = function (dest: Uint32Array, destOffset: number, src: Uint32Array, srcOffset: number, count: number) {\n    for (let i = 0; i < count; i++)\n        dest[destOffset+i, destOffset: = src[srcOffset+i];\n};\nconst memcpy_huge = function (dest: Uint32Array, destOffset: number, src: Uint32Array, srcOffset: number, count: number) {, src: = 0; count = 0; destOffset = 0; srcOffset = 0; }\nconst memcpy_huge32 = function (dest: Uint32Array, destOffset: number, src: Uint, srcOffset: number, count: number) {\n    for (let i = 0; i < count; i++)\n        dest[destOffset+i] = src[srcOffset+i];\n};\nconst memcpy_huge64, length: number;\nconst memcpy_huge32_huge64 = function (dest: Uint32Array, destOffset: number, src: Uint32Array, srcOffset: number, count: number) {\n    fo): number {\n    dest[destOffset + count-1] = src[srcOffset + count-1];\n    return count-1;\n};\nconst memcpy_huge32_huge32 = function (dest: Uin {\n    dest.set(src.subarray(srcOffset, srcOffset + length), destOffset);\n};\nconst bzero = function (dest: Uint32Array, count: number) {\n    for (let i = 0; i < count; i++)\n        dest[i] = 0;\n};\nconst bzero_huge = function (dest: Uint, offset: number, count: number) {\n    for (let i = 0; i < count; i++)\n        dest[offset+i] = 0;\n};\nconst bzero_huge_huge = function (dest, length: number, offset: number, count: number) {\n    for (let i = 0; i < count; i++)\n        dest[offset+i] = 0;\n};\nconst bzero_huge32, lengt): number {\n    for (let i = 0; i < count; i++)\n        dest[i] = 0;\n    return count;\n};\nconst bzero_huge64, lengt: number;\ncons {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FF = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return FF(a, b, c, d, x, s, t) ^ FF(b, b: = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0, a: a = 0, b: b, c: 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0) ^ FF(c: c = 0, d: d = 0, x:, d: 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s =, x: 0, s = 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0,, s: 0, t: t = 0, a: a = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s =, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0) ^ FF): number {\n    return FF(a, b, c, d, x, s, t) ^ FF(b, b: = 0, c: c = 0, d: d = 0, x: x = {\n    const n = a + (b & c | ~b & d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst GG = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return GG(a, b, c, d, x, s, t) ^ GG, b: = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0, a: a = 0, b: b, c: 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d: d =, d: 0, x: x = 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x =, x: 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s =, s: 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t =, t: 0, a: a = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t =): number {\n    return GG(a, b, c, d, x, s, t) ^ GG, b: b = 0, c: c = 0, d: d = 0, x: x {\n    const n = a + (b & d | c & ~d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst HH = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return HH(a, b, c, d, x, s, t) ^ HH(b, b: = 0, c: c = 0, d: d = 0, x: x = {\n    const n = a + (b ^ c ^ d) + (x >>> 0) + t;\n    return ((, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0) ^ FF(b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x:, x: 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s =, s: 0, t: t = 0)) ^ FF(b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t:, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0, b:): number {\n    return HH(a, b, c, d, x, s, t) ^ HH(b, b: b = 0, c: c = 0, d: d = 0, x: x {\n    const n = a + (b ^ c ^ d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst II = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return II(a, b, c, d, x, s, t) ^ II(b, b: b = 0, c: c = 0, d: d = 0, x: x {\n    const n = a + (b & c | ~b & d) + (x >>> 0) + t;, c: c = 0, d: d = 0, x: x = 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d:, d: d = 0, x: x = 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x:, x: 0, s: s = 0, t: t = 0, b: b = 0, c: c = 0, d: d = 0, x: x = 0, s: s =, s: 0, t: t = 0;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst F = function (a: number, b: number, c: number,, t: number, b: number, c: number, d: number, x: number, s: number, t: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    return F(a, b, c, t, b, c, d, x, s, t, b, c, d, x, s, t) ^ F(b, b: b = 0 {\n    const n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst transform = function (block: any, hash: number) {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    const dd = hash[3];\n    let a = aa;\n    let b = b, hash: number;\n    let c = cc;\n    let d = dd;\n    a = FF(a, b, c, d, block[0], 7, -680876936);\n    d = FF): number;\n    b = BB(b, c, d, block[1], 12, -198630844);\n    c = CC(c, d, block[2], 17, {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    const dd = hash[3];\n    let a = aa;\n    let b = bb;\n    let c = cc;\n    let d = dd;\n    a = FF(a, b, c, d, block[0], 7, -680876936);\n    d = FF(d, a, b, c, block[1], 12, -389564586);\n    c = FF(c, d, a, b, block[2], 17, 606105819);\n    b = FF(b, c, d, a, block[3], 22, -1044525330);\n    a = FF(a, b, c, d, block[4], 7, -176418897);\n    d = FF(d, a, b, c, block[5], 12, 1200080426);\n    c = FF(c, d, a, b, block[6], 17, -1473231341);\n    b = FF(b, c, d, a, block[7], 22, -45705983);\n    a = FF(a, b, c, d, block[8], 7, 1770035416);\n    d = FF(d, a, b, c, block[9], 12, -1958414417);\n    c = FF(c, d, a, b, block[10], 17, -42063);\n    b = FF(b, c, d, a, block[11], 22, -1990404162);\n    a = FF(a, b, c, d, block[12], 7, 1804603682);\n    d = FF(d, a, b, c, block[13], 12, -40341101);\n    c = FF(c, d, a, b, block[14], 17, -1502002290);\n    b = FF(b, c, d, a, block[15], 22, 1236535329);\n    a = GG(a, b, c, d, block[1] | 0, 5, -165796510);\n    d = GG(d, a, b, c, block[6] | 0, 9, -1069501632);\n    c = GG(c, d, a, b, block[11] | 0, 14, 643717713);\n    b = GG(b, c, d, a, block[0] | 0, 20, -373897302);\n    a = GG(a, b, c, d, block[5] | 0, 5, -701558691);\n    d = GG(d, a, b, c, block[10] | 0, 9, 38016083);\n    c = GG(c, d, a, b, block[15] | 0, 14, -660478335);\n    b = GG(b, c, d, a, block[4] | 0, 20, -405537848);\n    a = GG(a, b, c, d, block[9] | 0, 5, 568446438);\n    d = GG(d, a, b, c, block[14] | 0, 9, -1019803690);\n    c = GG(c, d, a, b, block[3] | 0, 14, -187363961);\n    b = GG(b, c, d, a, block[8] | 0, 20, 1163531501);\n    a = GG(a, b, c, d, block[13] | 0, 5, -1444681467);\n    d = GG(d, a, b, c, block[2] | 0, 9, -51403784);\n    c = GG(c, d, a, b, block[7] | 0, 14, 1735328473);\n    b = GG(b, c, d, a, block[12] | 0, 20, -1926607734);\n    a = HH(a, b, c, d, block[5] | 0, 4, -378558);\n    d = HH(d, a, b, c, block[8] | 0, 11, -2022574463);\n    c = HH(c, d, a, b, block[11] | 0, 16, 1839030562);\n    b = HH(b, c, d, a, block[14] | 0, 23, -35309556);\n    a = HH(a, b, c, d, block[1] | 0, 4, -1530992060);\n    d = HH(d, a, b, c, block[4] | 0, 11, 1272893353);\n    c = HH(c, d, a, b, block[7] | 0, 16, -155497632);\n    b = HH(b, c, d, a, block[10] | 0, 23, -1094730640);\n    a = HH(a, b, c, d, block[13] | 0, 4, 681279174);\n    d = HH(d, a, b, c, block[0] | 0, 11, -358537222);\n    c = HH(c, d, a, b, block[3] | 0, 16, -722521979);\n    b = HH(b, c, d, a, block[6] | 0, 23, 76029189);\n    a = HH(a, b, c, d, block[9] | 0, 4, -640364487);\n    d = HH(d, a, b, c, block[12] | 0, 11, -421815835);\n    c = HH(c, d, a, b, block[15] | 0, 16, 530742520);\n    b = HH(b, c, d, a, block[2] | 0, 23, -995338651);\n    a = II(a, b, c, d, block[0] | 0, 6, -198630844);\n    d = II(d, a, b, c, block[7] | 0, 10, 1126891415);\n    c = II(c, d, a, b, block[14] | 0, 15, -1416354905);\n    b = II(b, c, d, a, block[5] | 0, 21, -57434055);\n    a = II(a, b, c, d, block[12] | 0, 6, 1700485571);\n    d = II(d, a, b, c, block[3] | 0, 10, -1894986606);\n    c = II(c, d, a, b, block[10] | 0, 15, -1051523);\n    b = II(b, c, d, a, block[1] | 0, 21, -2054922799);\n    a = II(a, b, c, d, block[8] | 0, 6, 1873313359);\n    d = II(d, a, b, c, block[15] | 0, 10, -30611744);\n    c = II(c, d, a, b, block[6] | 0, 15, -1560198380);\n    b = II(b, c, d, a, block[13] | 0, 21, 1309151649);\n    a = II(a, b, c, d, block[4] | 0, 6, -145523070);\n    d = II(d, a, b, c, block[11] | 0, 10, -1120210379);\n    c = II(c, d, a, b, block[2] | 0, 15, 718787259);\n    b = II(b, c, d, a, block[9] | 0, 21, -343485551);\n    hash[0] = (a + aa) >>> 0;\n    hash[1] = (b + bb) >>> 0;\n    hash[2] = (c + cc) >>> 0;\n    hash[3] = (d + dd) >>> 0;\n};\n/**\n * MD5 message-digest algorithm\n */\nexport class MD5 {\n    private hash: Uint32Array;\n    private block: Uint32Array;\n    private block8: Uint8Array;\n    constructor() {\n        this.hash = new Uint32Array(16);\n        this.block = new Uint3 = new Uint32Array([1732584193, -271733879, -1732584194, 271733878]);\n    private block: Uint32Array;\n    private block8: Uint8Array;\n    private byteCount = 0;\n    constructor(data: Uint8Array) {\n        this.hash = new Uint32Array(16);\n        if (dat = new Uint32Array(16);\n    private block8: Uint8Array;\n    private block: Uint32Array;\n    private hash: Uint32Array;\n    /**\n     * Compute the MD5 hash of the given data.\n     *\n     * @param data Data to hash\n     * @return;\n    private byteCount: number;\n     *\n     * @param data Data to hash\n     * @return Hash result\n     */\n    public update(data: Uint8Array) {\n        if (data instanceof DataView)\n            data = new Uint8Array(data.buffer = 0;\n    constructor() {\n        this.block8 = new Uint8Array(this.block.buffer, this.block.byteOffset, this.block.byteLength);\n    }\n    /**\n     * Dynamic version of MD5.update that accepts different types to binary data as parameters.\n     *\n     * @param data Data to hash\n     * @see MD5.update\n     */\n    dynamicUpdate(data: ArrayBuffer | Uint8Array | Uint32Array | DataView) {\n        if (data instanceof ArrayBuffer)\n            data = new Uint8Array(data);\n        else if (data instanceof Uint8Array)\n            data = new Uint8Array(dat): else if (data instanceof Uint32Array)\n            data = new Uint32Array(dat): else if (data instanceof DataView)\n            data = new Uint8Array(dat.buffer);\n        else if (data instanceof DataView)\n            dat {\n        if (data instanceof DataView)\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        else if (data instanceof ArrayBuffer)\n            data = new Uint8Array(data);\n        if (!(data instanceof Uint8Array))\n            throw new Error(`Expected a Uint8Array, a DataView or an ArrayBuffer. Received ${data.constructor.name}`);\n        return this.update(data);\n    }\n    /**\n     * Process an array of bytes to hash.\n     *\n     * @param data Bytes to hash\n     */\n    update(data: Uint8Array | ArrayBuffer | Uint32Array | DataView) {\n        if (data instanceof ArrayBuffer)\n            data = new Uint8Array(data);\n        else if (data instanceof Uint8Array)\n            data = new Uint8Array(dat): else if (data instanceof Uint32Array)\n            data = new Uint32Array(dat);\n        else if (data instanceof DataView)\n            dat {\n        if (data instanceof DataView)\n            data = new Uint8Array(data.buffe {\n        const avail = (BLOCK_SIZE - (this.byteCount & 63)) | 0;\n        let length = data.length;\n        this.byteCount += length;\n        if (avail > length) {\n            memcpy(this.block8, BLOCK_SIZE - avail, data, 0, length);\n            return;\n        }\n        memcpy(this.block8, BLOCK_SIZE - avail, data, 0, avail);\n        this.transformHelper();\n        let offset = avail;\n        length -= avail;\n        while (length >= BLOCK_SIZE) {\n            memcpy(this.block8, 0, data, offset, BLOCK_SIZE);\n            this.transformHelper();\n            offset += BLOCK_SIZE;\n            length -= BLOCK_SIZE;\n        }\n        memcpy(this.block8, 0, data, offset, length);\n    }\n    /**\n     * Produce the hash as a sequence of 16 bytes.\n     */\n    toUint8Array(): Uint8Array {\n        this.transformHelper();\n        const block8 = this.block8.slice(0);\n        le32_to_cpu_uint32array(block8);\n        transform(block8, this.has {\n        const offset = this.byteCount & 63;\n        let p = offset;\n        let padding = 56 - (offset + 1);\n        const block8 = this.block8.slice(0);\n        const block = new Uint32Array(block8.buffer);\n        const hash = this.hash.slice(0);\n        block8[p++] = 128;\n        if (padding < 0) {\n            bzero(block8, p, padding + 8);\n            if (!isLittleEndian)\n                le32_to_cpu_uint32array(block);\n            transform(block, hash);\n            p = 0;\n            padding = 56;\n        }\n        bzero(block8, p, padding);\n        block[14] = this.byteCount << 3;\n        block[15] = this.byteCount >>> 29;\n        if (!isLittleEndian) {\n            le32_to_cpu_uint32array(block.subarray(0, BLOCK_LENGTH - 2));\n            transform(block, hash);\n            cpu_to_le32_uint32array(hash);\n        }\n        else {\n            transform(block, hash);\n        }\n        return new Uint8Array(hash.buffer);\n    }\n    /**\n     * Produce the hash as string in hexadecimal format.\n     */\n    toString(): string {\n        let hex = \"\";\n        const hash = this.toUint8Array();\n        const hashLength = hash.byteLength;\n        for (let i = 0; i < hashLength; i++) {\n            hex += ((hash[i] >>> 4) & 15).toString(16);\n            hex += ((hash[i] >>> 0) & 15).toString(16);\n        }\n        return hex;\n    }\n    private transformHelper(): void {\n        if (!isLittleEndian)\n            le32_to_cpu_uint32array(this.block);\n        return transform(this.block, this.hash);\n    }\n    static process(data: Uint8Array, isLittleEndian: boolean): MD5 {\n        const md5 = new MD5();\n        md5.process(data, isLittleEndian);\n        return md5;\n    }\n    static update(data: Uint8Array, isLittleEndian: boolean): MD5 {\n        const md5 = new MD5();\n        md5.dynamicUpdate(data);\n        return md5.toString();\n    }\n}\n","score":215,"fallbacked":false,"num_type_errors":729},{"code":"/*\n * Copyright (c) 2018 Princess Rosella. All rights reserved.\n *\n * @LICENSE_HEADER_START@\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * @LICENSE_HEADER_END@\n */\nexport const BLOCK_SIZE = 64;\nexport const BLOCK_LENGTH = 16;\nconst isLittleEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 120;\nconst rotl = function (n: number, b: number) {\n    return (n << b) | (n >>> (32 - b));\n};\nconst rotl32s = function (n) {\n    return (rotl(n, 8, b: 32) & 4278255360);\n};\nconst le32_to_cpu_uint32array = function (array) {\n    if (isLittleEndian)\n        return;\n    fo): {\n        for (let i = 0; i < array.length; i++)\n            array[i] = le32_to_cpu_uint32(array[i]);\n    }\n};\nconst le32 {\n    return (n << b) | (n >>> (32 - b));\n};\nconst swab32s = function (n: number) {\n    return (swab(n, 8, b: 32) & 16711935);\n};\nconst swab = function (n: number, b: number, destOffse): number {\n    return (swab32s(n) & 16711935) | (swab32s(n) >>> (32 - b));\n};\nconst swab32 {\n    return (rotl(n, 8) & 16711935) | (rotl(n, 24) & 4278255360);\n};\nconst le32_to_cpu_uint32array = function (array: number[], destOffse: number) {\n    if (isLittleEndian)\n        return;\n    for (let i = 0; i < array.length; i++)\n        array[i] = le32_to_cpu): {\n        for (let i = 0; i < array.length; i++)\n            array[i] = swab(array[i], 32, destOffse + i * 4);\n    }\n};\ncons {\n    if (isLittleEndian)\n        return;\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\nconst cpu_to_le32_uint32array = function (array: number[], destOffse: number) {\n    if (!isLittleEndian)\n        return;\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32({\n            a): {\n                for (let i = 0; i < array.length; i++)\n                    array[i] = le32({\n                        b: array[i],\n                        a: 32\n                    }) >>> 0;\n            } {\n    if (isLittleEndian)\n        return;\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\nconst memcpy = function (dest: number[], src: number[], srcOffset: number, length: number) {\n    for (let i = 0; i < length; i++)\n        dest[destOffse + i] = src[srcOffset + i];\n}, destOffset: number) {\n    return function (dest: number[], src: number[], srcOffset: number, length: number) {\n        return memcpy(dest, src, srcOffset, length);\n    };\n};\nconst memcpy_to, src: number[], srcOffset: number, length: number = 0;\nconst le32 {\n    return {\n        b: (b = 0),\n        a: {\n            b: (a = 0),\n            c: (, srcOffset: number, length: number) {\n                return src[srcOffset + length - 1] >>> 0;\n            } {\n                c: (a = 0),\n                b: (b = 0),\n                a: (a, length: number) {\n                    return src[srcOffset + length - 1] >>> 0;\n                } {\n                    c: (a = 0),\n                    b: (b = 0),\n                    a: (a, b =): any {\n                        c: (a = 0),\n                        b: (b = 0),\n                        a: (a, b =): number | undefined {\n                            b: 0,\n                            a: 0,\n                            c: ( {\n    dest.set(src.subarray(srcOffset, srcOffset + length), destOffset);\n};\nconst bzero = function (dest: number[], src: number[], srcOffset: number, length: number) {\n    for (let i = 0; i < length; i++)\n        dest[destOffset + i] = 0;\n};\nconst bzero, offset: number = 0, length: number = 0;\nconst le32 {\n    c: (c = 0),\n    b: (b = 0),\n    a: (a = 0) {\n        return a, length: 1, bzero(a, b, c, d), c >>> 0, b >>> 0, a >>> 0;\n    } {\n        b: (b = 0),\n        a: (a = 0),): any {\n            a: 0,\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0,\n            a: (a = 0),\n            b: (b = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FF = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return (a + b + c + d + x + s) >>> 0;\n};\ncons, b: bzero(a, b, c, d), c >>> 0, b >>> 0, a >>> 0, b >>> 0, a >>> 0, b >>> 0;\n    } {\n        b: (b, c: number) {\n            return a + b + c;\n        } {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0,\n            c: 0,\n            d:, d: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0,\n            a: 0,, x: 0, s: 0, t: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0,\n            a: 0,\n            b: 0,\n            c: 0, s: 0, t: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0,\n            a: 0,\n            b: 0,\n            c: 0, s: 0, t: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0,\n            a: 0,\n            b: 0,\n            c: 0,\n            x: 0,\n            s:): any {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0, {\n    const n = a + (b & c | ~b & d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst GG = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return (a + b + c + d + x + s + t) >>> 0;\n}, b: (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return (a + b + c + d + x + s + t) >>>, c: 0, b: 0, a: 0, b: 0, a: 0, b: 0, a: 0, b: 0, a: 0, b: 0, x:, d: 0, s: 0, t: 0\n} {\n    b: (a, b: number, c: number, d: number, x: number, s: number, t: number) {\n        return (a, x: number, s: number, t: number) {\n            return GG(a, b, c, d, x, s, t);\n        } {\n            b: 0,\n            c: 0,\n            d:, s: 0, t: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0,\n            a, t: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0): any {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0,\n            c: 0,\n            d: 0\n        } {\n            b: 0, {\n    const n = a + (b & d | c & ~d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst HH = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return (a + b + c + d + x + s + t) >>> 0;\n}, b: (a, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return (a, x: number, s: number, t: number) {\n        return HH, c: 0, b: 0, a: 0, b: 0, a: 0, b: 0, a: 0, b: 0, a: 0, b: 0, x:,, d: 0, s: 0, t: 0\n};\nconst II = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    retur, x: number, s: number, t: number;\n};\nconst transform = function (block, hash) {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    const d, s: number;\n    for (d = 0; d < 8; d++) {\n        for (s = 0; s < 8; s++) {\n            const d1 = d + 1 & 7;\n            const, t: number, z: number;\n            const d2 = d + 2 & 7;\n            const, t: number, z: number;\n            const d3 = d + 3 & 7;\n            const, t: number): any {\n            t: number;\n            z: number;\n            const n: number, m: number;\n            const, t: number, z: number, m: number, n: number;\n            const n: number, m: numbe {\n    const n = a + (b ^ c ^ d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst II = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return (a + b + c + d + x + s + t) >>> 0;\n}, b: (a, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return (a, x: number, s: number, t: number) {\n        return II, c: 0, b: 0, a: 0, b: 0, a: 0, b: 0, a: 0, b: 0, a: 0, b: 0, x:,, d: 0, s: 0, t: 0\n};\nconst transform = function (block, hash) {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    cons, x: number, s: number, t: number;\n    for (s = 0; s < 8; s++) {\n        for (t = 0; t < 8; t++) {\n            const s1 = s +, s: number, t: number;\n            const s2 = s + 1 & 7;\n            const, t: number, z: number;\n            const s3 = s + 2 & 7;\n            const, t: number, t: number, z: number;\n            const s4 = s + 3 & 7;\n            const, t: number, t: number, z: number;\n            const s5 = s + 4 & 7;\n            const): any {\n            t: number;\n            z: number;\n            const n: number, m: number;\n            const, t: number, z: number, m: number, n: number;\n            const n: number, m: numbe {\n    const n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst transform = function (block: number[], hash: number[]) {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    const dd = hash[3];\n    let a = aa;\n    let b = b, hash: number[] | any;\n    let c = cc;\n    let d: number;\n    c = 0, d = 0;\n    for (let i = 0; i < 8; i++) {\n        for (let): any {\n            let n: number, m: number;\n            const, t: number, z: number;\n            const n: number, m: number;\n            const n: number, m: number;\n            n = a + ( {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    const dd = hash[3];\n    let a = aa;\n    let b = bb;\n    let c = cc;\n    let d = dd;\n    a = FF(a, b, c, d, block[0], 7, -680876936);\n    d = FF(d, a, b, c, block[1], 12, -389564586);\n    c = FF(c, d, a, b, block[2], 17, 606105819);\n    b = FF(b, c, d, a, block[3], 22, -1044525330);\n    a = FF(a, b, c, d, block[4], 7, -176418897);\n    d = FF(d, a, b, c, block[5], 12, 1200080426);\n    c = FF(c, d, a, b, block[6], 17, -1473231341);\n    b = FF(b, c, d, a, block[7], 22, -45705983);\n    a = FF(a, b, c, d, block[8], 7, 1770035416);\n    d = FF(d, a, b, c, block[9], 12, -1958414417);\n    c = FF(c, d, a, b, block[10], 17, -42063);\n    b = FF(b, c, d, a, block[11], 22, -1990404162);\n    a = FF(a, b, c, d, block[12], 7, 1804603682);\n    d = FF(d, a, b, c, block[13], 12, -40341101);\n    c = FF(c, d, a, b, block[14], 17, -1502002290);\n    b = FF(b, c, d, a, block[15], 22, 1236535329);\n    a = GG(a, b, c, d, block[1] | 0, 5, -165796510);\n    d = GG(d, a, b, c, block[6] | 0, 9, -1069501632);\n    c = GG(c, d, a, b, block[11] | 0, 14, 643717713);\n    b = GG(b, c, d, a, block[0] | 0, 20, -373897302);\n    a = GG(a, b, c, d, block[5] | 0, 5, -701558691);\n    d = GG(d, a, b, c, block[10] | 0, 9, 38016083);\n    c = GG(c, d, a, b, block[15] | 0, 14, -660478335);\n    b = GG(b, c, d, a, block[4] | 0, 20, -405537848);\n    a = GG(a, b, c, d, block[9] | 0, 5, 568446438);\n    d = GG(d, a, b, c, block[14] | 0, 9, -1019803690);\n    c = GG(c, d, a, b, block[3] | 0, 14, -187363961);\n    b = GG(b, c, d, a, block[8] | 0, 20, 1163531501);\n    a = GG(a, b, c, d, block[13] | 0, 5, -1444681467);\n    d = GG(d, a, b, c, block[2] | 0, 9, -51403784);\n    c = GG(c, d, a, b, block[7] | 0, 14, 1735328473);\n    b = GG(b, c, d, a, block[12] | 0, 20, -1926607734);\n    a = HH(a, b, c, d, block[5] | 0, 4, -378558);\n    d = HH(d, a, b, c, block[8] | 0, 11, -2022574463);\n    c = HH(c, d, a, b, block[11] | 0, 16, 1839030562);\n    b = HH(b, c, d, a, block[14] | 0, 23, -35309556);\n    a = HH(a, b, c, d, block[1] | 0, 4, -1530992060);\n    d = HH(d, a, b, c, block[4] | 0, 11, 1272893353);\n    c = HH(c, d, a, b, block[7] | 0, 16, -155497632);\n    b = HH(b, c, d, a, block[10] | 0, 23, -1094730640);\n    a = HH(a, b, c, d, block[13] | 0, 4, 681279174);\n    d = HH(d, a, b, c, block[0] | 0, 11, -358537222);\n    c = HH(c, d, a, b, block[3] | 0, 16, -722521979);\n    b = HH(b, c, d, a, block[6] | 0, 23, 76029189);\n    a = HH(a, b, c, d, block[9] | 0, 4, -640364487);\n    d = HH(d, a, b, c, block[12] | 0, 11, -421815835);\n    c = HH(c, d, a, b, block[15] | 0, 16, 530742520);\n    b = HH(b, c, d, a, block[2] | 0, 23, -995338651);\n    a = II(a, b, c, d, block[0] | 0, 6, -198630844);\n    d = II(d, a, b, c, block[7] | 0, 10, 1126891415);\n    c = II(c, d, a, b, block[14] | 0, 15, -1416354905);\n    b = II(b, c, d, a, block[5] | 0, 21, -57434055);\n    a = II(a, b, c, d, block[12] | 0, 6, 1700485571);\n    d = II(d, a, b, c, block[3] | 0, 10, -1894986606);\n    c = II(c, d, a, b, block[10] | 0, 15, -1051523);\n    b = II(b, c, d, a, block[1] | 0, 21, -2054922799);\n    a = II(a, b, c, d, block[8] | 0, 6, 1873313359);\n    d = II(d, a, b, c, block[15] | 0, 10, -30611744);\n    c = II(c, d, a, b, block[6] | 0, 15, -1560198380);\n    b = II(b, c, d, a, block[13] | 0, 21, 1309151649);\n    a = II(a, b, c, d, block[4] | 0, 6, -145523070);\n    d = II(d, a, b, c, block[11] | 0, 10, -1120210379);\n    c = II(c, d, a, b, block[2] | 0, 15, 718787259);\n    b = II(b, c, d, a, block[9] | 0, 21, -343485551);\n    hash[0] = (a + aa) >>> 0;\n    hash[1] = (b + bb) >>> 0;\n    hash[2] = (c + cc) >>> 0;\n    hash[3] = (d + dd) >>> 0;\n};\n/**\n * MD5 message-digest algorithm\n */\nexport class MD5 {\n    private hash: Uint32Array;\n    constructor() {\n        this.hash = new Uint32Array(16);\n        this.block = new Uint32Array(16);\n        this.block8 = new Uint8Array(this = new Uint32Array([1732584193, -271733879, -1732584194, 271733878]);\n    private block: Uint32Array;\n    private hash: Uint32Array;\n    private block8: Uint8Array;\n    private byteCount = 0;\n    private blockCount = 0;\n    private blockIndex = 0;\n    constructor( = new Uint32Array(16);\n    private block8: Uint8Array;\n    private blockCount: number;\n    private blockIndex: number;\n    private hash: Uint32Array;\n    private block: Uint32Array;\n    private block8: Uint8Array;\n    private byteCount;\n    private byteCount: number;\n    private blockCount;\n    private blockIndex;\n    private hash;\n    private block;\n    private block8;\n    private blockCount;\n    private blockIndex;\n    private hash;\n    private block;\n    private block8;\n    privat = 0;\n    constructor() {\n        this.block8 = new Uint8Array(this.block.buffer, this.block.byteOffset, this.block.byteLength);\n    }\n    /**\n     * Dynamic version of MD5.update that accepts different types to binary data as parameters.\n     *\n     * @param data Data to hash\n     * @see MD5.update\n     */\n    dynamicUpdate(data: Uint8Array): MD5 {\n        const dataLen = data.length;\n        if (dataLen === 0)\n            return this;\n        const bytes = new Uint8Array(this.block.length + dataLen);\n        bytes): MD5;\n        bytes[0] = this.byteCount;\n        bytes[1] = this.blockCount;\n        bytes[2] = this.blockIndex;\n        bytes[3] = this.hash[0];\n        byte {\n        if (data instanceof DataView)\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        else if (data instanceof ArrayBuffer)\n            data = new Uint8Array(data);\n        if (!(data instanceof Uint8Array))\n            throw new Error(`Expected a Uint8Array, a DataView or an ArrayBuffer. Received ${data.constructor.name}`);\n        return this.update(data);\n    }\n    /**\n     * Process an array of bytes to hash.\n     *\n     * @param data Bytes to hash\n     */\n    update(data: Uint8Array): MD5 {\n        const dataLen = data.length;\n        if (dataLen === 0)\n            return this;\n        const bytes = new Uint8Array(this.block.length + dataLen);\n        bytes)): MD5;\n        bytes[0] = this.byteCount;\n        bytes[1] = this.blockCount;\n        bytes[2] = this.blockIndex;\n        bytes[3] = this.hash[0];\n        byt {\n        const avail = (BLOCK_SIZE - (this.byteCount & 63)) | 0;\n        let length = data.length;\n        this.byteCount += length;\n        if (avail > length) {\n            memcpy(this.block8, BLOCK_SIZE - avail, data, 0, length);\n            return;\n        }\n        memcpy(this.block8, BLOCK_SIZE - avail, data, 0, avail);\n        this.transformHelper();\n        let offset = avail;\n        length -= avail;\n        while (length >= BLOCK_SIZE) {\n            memcpy(this.block8, 0, data, offset, BLOCK_SIZE);\n            this.transformHelper();\n            offset += BLOCK_SIZE;\n            length -= BLOCK_SIZE;\n        }\n        memcpy(this.block8, 0, data, offset, length);\n    }\n    /**\n     * Produce the hash as a sequence of 16 bytes.\n     */\n    toUint8Array(): Uint8Array {\n        return new Uint8Array(this.hash.buffer);\n    }\n    /**\n     * Update the hash with the next data block.\n     *\n     * @param data Block of data to hash\n     */\n    private transformHelpe {\n        const offset = this.byteCount & 63;\n        let p = offset;\n        let padding = 56 - (offset + 1);\n        const block8 = this.block8.slice(0);\n        const block = new Uint32Array(block8.buffer);\n        const hash = this.hash.slice(0);\n        block8[p++] = 128;\n        if (padding < 0) {\n            bzero(block8, p, padding + 8);\n            if (!isLittleEndian)\n                le32_to_cpu_uint32array(block);\n            transform(block, hash);\n            p = 0;\n            padding = 56;\n        }\n        bzero(block8, p, padding);\n        block[14] = this.byteCount << 3;\n        block[15] = this.byteCount >>> 29;\n        if (!isLittleEndian) {\n            le32_to_cpu_uint32array(block.subarray(0, BLOCK_LENGTH - 2));\n            transform(block, hash);\n            cpu_to_le32_uint32array(hash);\n        }\n        else {\n            transform(block, hash);\n        }\n        return new Uint8Array(hash.buffer);\n    }\n    /**\n     * Produce the hash as string in hexadecimal format.\n     */\n    toString(): string {\n        let hex = \"\";\n        const hash = this.toUint8Array();\n        const hashLength = hash.byteLength;\n        for (let i = 0; i < hashLength; i++) {\n            hex += ((hash {\n        let hex = \"\";\n        const hash = this.toUint8Array();\n        const hashLength = hash.byteLength;\n        for (let i = 0; i < hashLength; i++) {\n            hex += ((hash[i] >>> 4) & 15).toString(16);\n            hex += ((hash[i] >>> 0) & 15).toString(16);\n        }\n        return hex;\n    }\n    private transformHelper(): Uint8Array {\n        if (!isLittleEndian)\n            le32_to_cpu_uint32array(this.block);\n        return transform(this.block, this.hash);\n    }\n    static process(data: Uint8Array): string {\n        const md5 = new MD5();\n        md5.dynamicUpdate(data);\n        return md5.toString();\n    }\n    static processSync(data: Uint8Array): string {\n        const md5 = new MD5();\n        md5.dynamicUpdate(data);\n        return md5.toString();\n    }\n}\n","score":206,"fallbacked":false,"num_type_errors":893},{"code":"/*\n * Copyright (c) 2018 Princess Rosella. All rights reserved.\n *\n * @LICENSE_HEADER_START@\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * @LICENSE_HEADER_END@\n */\nexport const BLOCK_SIZE = 64;\nexport const BLOCK_LENGTH = 16;\nconst isLittleEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 120;\nconst rotl = function (n: number, b: number) {\n    return (n << b) | (n >>> (32 - b));\n};\nconst rotl32s = function (n: number, b: number) {\n    return (n <, b: number) => {\n        return ((n << b) | (n >>> (32 - b))) >>> 0;\n    };\n};\nconst rotl32 = function (n: number, b: number) {\n    return): number => {\n        return rotl(n, b);\n    };\n};\nconst rotl64 = function (n: number, b: number) {\n    return rotl(n, b) | rotl(n, {\n    return (n << b) | (n >>> (32 - b));\n};\nconst swab32s = function (n: number, b: number) {\n    return (n >>> b) | (n << (32 - b));\n};\nconst swab32 = function (n: number, b: number) {\n    return (n >>>): number => {\n        return swab32s(n, b);\n    };\n};\nconst swab64 = function (n: number, b: number) {\n    return swab32(n, b);\n} {\n    return (rotl(n, 8) & 16711935) | (rotl(n, 24) & 4278255360);\n};\nconst le32_to_cpu_uint32array = function (array: Array<number>, offs: number, length: number) {\n    let a = new Uint32Array(length / 4);\n    for (let i = 0; i < a.length; i++) {\n        a): Array<number> => {\n            return [\n                array[offs + 0],\n                array[offs + 1],\n                array[offs + 2],\n                array[offs + 3],\n            ];\n        };\n    }\n}; {\n    if (isLittleEndian)\n        return;\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\nconst cpu_to_le32_uint32array = function (array: Array<number>, offs: number, length: number) {\n    let a = new Uint32Array(length / 4);\n    for (let i = 0; i < a.length; i++) {\n        a)): Array<number> => {\n            return [\n                array[offs + 3],\n                array[offs + 2],\n                array[offs + 1],\n                array[offs + 0],\n            ];\n        };\n    }\n}; {\n    if (isLittleEndian)\n        return;\n    for (let i = 0; i < array.length; i++)\n        array[i] = swab32s(array[i]);\n};\nconst memcpy = function (dest: number[], src: number[], srcOffset: number, length: number) {\n    for (let i = 0; i < length; i++)\n        dest[i + srcOffset] = src[i];\n};\nconst memcp, destOffset: number, src: number[], srcOffset: number, length: number {\n    return (destOffset = 0): number => {\n        return memcpy(dest, src, srcOffset, length);\n    };\n};\nconst memcpy, src: number[], srcOffset: number, length: number {\n    return (srcOffset = 0): number => {\n        return memcpy(src, dest, destOffset, length);\n    };\n};\nconst memcpy, dest: number[], srcOffset: number, length: number {\n    return (srcOffset = 0): number => {\n        return memcpy(src, dest, srcOffset, length);\n    };\n};\nconst memcpy, src: number[], srcOffset: number, length: number {\n    return (destOffset = 0): number => {\n        return memcpy(src, dest, srcOffset, length);\n    };\n};\nconst memcpy, destOffset: number, src: number[], srcOffset: numbe): number => {\n    for (let i = 0; i < length; i++)\n        dest[destOffset++] = src[i];\n};\nconst memcpy, destOffset: number, src: number[], srcOffset: number {\n    dest.set(src.subarray(srcOffset, srcOffset + length), destOffset);\n};\nconst bzero = function (dest: number[], offset: number, length: number) {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FD = function (dest: number[], offset: number, length: number) {\n    for, offset: number;\n    return (offset = 0): number => {\n        return dest[offset];\n    };\n};\nconst FD: number, offset: number, length: number {\n    return (destOffset = 0): number =>, length: number => {\n        return (destOffset = 0): number => {\n            return FD(dest, destOffset, length);\n        };\n    };\n};\nconst FF = function (a, b, c, d, x,): number => {\n    return a * b * c * d + x;\n};\nconst FF: number, a: number, b: number, c: number, d: number, x: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FF = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return FF(a, b, c, d, x, s, t);\n};\nconst, b: number, c: number, d: number, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[destOffset++] = 0;\n};\nconst FF, c: number, d: number, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FF, c: number,, d: number, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FF, c: number,, d: number,, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FF, c: number,, d: number, x: number,, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FF, c: number,, d: number, x: number,, s: number,, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst FF, c: number,, d: number,, x: number, s: number, t: number {): number => {\n    return FF(a, b, c, d, x);\n};\nconst FF = function (a: number, b: number, c: number, d: number, x: number, s: number, {\n    const n = a + (b & c | ~b & d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst GG = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return GG(a, b, c, d, x, s, t);\n};\ncons, b: number, c: number, d: number, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[destOffset++] = 0;\n};\nconst G, c: number, d: number, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst G, c: number,, d: number,, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst GG, c: number,, d: number, x: number,, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst HH, c: number, d: number, x: number,, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst HH, c: number, d: number, x: number, s: number,, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst II = function (a: number, b: number, c: number, d: number, x: numbe): number {\n    return II(a, b, c, d, x);\n};\nconst II = function (a: number, b: number, c: number, d: number, x: number, {\n    const n = {\n    const n = a + (b & d | c & ~d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst HH = function (a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return HH(a, b, c, d, x, s, t);\n};\nconst H, b: number, c: number, d: number, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[destOffset++] = 0;\n};\nconst HH, c: number, d: number, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst II, b: number,, d: number, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst II, b: number, c: number,, x: number, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst II, b: number, c: number, d: number,, s: number, t: number {\n    return (destOffset = {\n    while (length--)\n        dest[offset++] = 0;\n};\nconst II, b: number, c: number, d: number, x: number,, t: number {\n    return II(a, b, c, d, x, s, t);\n};\nconst II, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    return II(a, b, c, d, x);\n};\nconst II, b: number, c: number, d: number, x: number, t: number {\n    return II(a, b {\n    const n = a + (b ^ c ^ d) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst II = function (a: number, b: number, c: number, d: number, x: number, {\n    const n = a + (b & c | d & ~c) + (x >>> 0) + t;\n    return ((n <, b: number, c: number, d: number, x: number, s: number, t: number) => number {\n    return II(a, b, c, d, x, s, t);\n};\nconst II,, c: number, d: number, x: number, s: number, t: number {\n    return II(a, b, c, d);\n};\nconst II, b: number, c: number, d: number {\n    cons, d: number, x: number, s: number, t: number {\n    return II(a, b, c, d, x, s, t);\n};\nconst II, b: number, c: number, d: number, x: number, s: number, t: number {\n    return II(a, b, c, d, x, s);\n};\nconst II, b: number, c: number, d: number {\n    cons, d: numbe, s: number, t: number {\n    return II(a, b, c, d);\n};\nconst II, b: number, c: number {\n    cons, d: number, x: number {\n    return II(a,, t: number {\n    return II(a, b, c);\n};\nconst II, b: number, c: number {\n    cons, d: number, x: number {\n    return II(a, b, c);\n};): number {\n    return II(a, b, c);\n};\nconst II, b: number, c: number {\n    cons, d: number, x: number {\n    return II(a, b, c, x); {\n    const n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\n    return ((n << s) | (n >>> (32 - s))) + b;\n};\nconst transform = function (block: Uint8Array): number {\n    const hash = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0, hash: [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,): number {\n    let result = 0;\n    for (let i = 0, j = 0, l = block.length; i < l; i += 4) {\n        j = transform(block.slice(i {\n    const aa = hash[0];\n    const bb = hash[1];\n    const cc = hash[2];\n    const dd = hash[3];\n    let a = aa;\n    let b = bb;\n    let c = cc;\n    let d = dd;\n    a = FF(a, b, c, d, block[0], 7, -680876936);\n    d = FF(d, a, b, c, block[1], 12, -389564586);\n    c = FF(c, d, a, b, block[2], 17, 606105819);\n    b = FF(b, c, d, a, block[3], 22, -1044525330);\n    a = FF(a, b, c, d, block[4], 7, -176418897);\n    d = FF(d, a, b, c, block[5], 12, 1200080426);\n    c = FF(c, d, a, b, block[6], 17, -1473231341);\n    b = FF(b, c, d, a, block[7], 22, -45705983);\n    a = FF(a, b, c, d, block[8], 7, 1770035416);\n    d = FF(d, a, b, c, block[9], 12, -1958414417);\n    c = FF(c, d, a, b, block[10], 17, -42063);\n    b = FF(b, c, d, a, block[11], 22, -1990404162);\n    a = FF(a, b, c, d, block[12], 7, 1804603682);\n    d = FF(d, a, b, c, block[13], 12, -40341101);\n    c = FF(c, d, a, b, block[14], 17, -1502002290);\n    b = FF(b, c, d, a, block[15], 22, 1236535329);\n    a = GG(a, b, c, d, block[1] | 0, 5, -165796510);\n    d = GG(d, a, b, c, block[6] | 0, 9, -1069501632);\n    c = GG(c, d, a, b, block[11] | 0, 14, 643717713);\n    b = GG(b, c, d, a, block[0] | 0, 20, -373897302);\n    a = GG(a, b, c, d, block[5] | 0, 5, -701558691);\n    d = GG(d, a, b, c, block[10] | 0, 9, 38016083);\n    c = GG(c, d, a, b, block[15] | 0, 14, -660478335);\n    b = GG(b, c, d, a, block[4] | 0, 20, -405537848);\n    a = GG(a, b, c, d, block[9] | 0, 5, 568446438);\n    d = GG(d, a, b, c, block[14] | 0, 9, -1019803690);\n    c = GG(c, d, a, b, block[3] | 0, 14, -187363961);\n    b = GG(b, c, d, a, block[8] | 0, 20, 1163531501);\n    a = GG(a, b, c, d, block[13] | 0, 5, -1444681467);\n    d = GG(d, a, b, c, block[2] | 0, 9, -51403784);\n    c = GG(c, d, a, b, block[7] | 0, 14, 1735328473);\n    b = GG(b, c, d, a, block[12] | 0, 20, -1926607734);\n    a = HH(a, b, c, d, block[5] | 0, 4, -378558);\n    d = HH(d, a, b, c, block[8] | 0, 11, -2022574463);\n    c = HH(c, d, a, b, block[11] | 0, 16, 1839030562);\n    b = HH(b, c, d, a, block[14] | 0, 23, -35309556);\n    a = HH(a, b, c, d, block[1] | 0, 4, -1530992060);\n    d = HH(d, a, b, c, block[4] | 0, 11, 1272893353);\n    c = HH(c, d, a, b, block[7] | 0, 16, -155497632);\n    b = HH(b, c, d, a, block[10] | 0, 23, -1094730640);\n    a = HH(a, b, c, d, block[13] | 0, 4, 681279174);\n    d = HH(d, a, b, c, block[0] | 0, 11, -358537222);\n    c = HH(c, d, a, b, block[3] | 0, 16, -722521979);\n    b = HH(b, c, d, a, block[6] | 0, 23, 76029189);\n    a = HH(a, b, c, d, block[9] | 0, 4, -640364487);\n    d = HH(d, a, b, c, block[12] | 0, 11, -421815835);\n    c = HH(c, d, a, b, block[15] | 0, 16, 530742520);\n    b = HH(b, c, d, a, block[2] | 0, 23, -995338651);\n    a = II(a, b, c, d, block[0] | 0, 6, -198630844);\n    d = II(d, a, b, c, block[7] | 0, 10, 1126891415);\n    c = II(c, d, a, b, block[14] | 0, 15, -1416354905);\n    b = II(b, c, d, a, block[5] | 0, 21, -57434055);\n    a = II(a, b, c, d, block[12] | 0, 6, 1700485571);\n    d = II(d, a, b, c, block[3] | 0, 10, -1894986606);\n    c = II(c, d, a, b, block[10] | 0, 15, -1051523);\n    b = II(b, c, d, a, block[1] | 0, 21, -2054922799);\n    a = II(a, b, c, d, block[8] | 0, 6, 1873313359);\n    d = II(d, a, b, c, block[15] | 0, 10, -30611744);\n    c = II(c, d, a, b, block[6] | 0, 15, -1560198380);\n    b = II(b, c, d, a, block[13] | 0, 21, 1309151649);\n    a = II(a, b, c, d, block[4] | 0, 6, -145523070);\n    d = II(d, a, b, c, block[11] | 0, 10, -1120210379);\n    c = II(c, d, a, b, block[2] | 0, 15, 718787259);\n    b = II(b, c, d, a, block[9] | 0, 21, -343485551);\n    hash[0] = (a + aa) >>> 0;\n    hash[1] = (b + bb) >>> 0;\n    hash[2] = (c + cc) >>> 0;\n    hash[3] = (d + dd) >>> 0;\n};\n/**\n * MD5 message-digest algorithm\n */\nexport class MD5 {\n    private hash: Uint32Array;\n    /**\n     * Calculates the MD5 hash of the data provided.\n     *\n     * @param data Data to hash\n     */\n    static hash(data: Uint8Array): Uint32Array {\n        const md = new Uint32Array([1732584193, -271733879, -1732584194, 271733878]);\n    private block: Uint32Array;\n    private block8;\n    private byteCount = 0;\n    constructor() {\n        this.block = new Uint32Array(64);\n    }\n    /**\n     * Updates the MD5 hash with the provide = new Uint32Array(16);\n    private block8: Uint32Array;\n     *\n     * @param data Data to hash\n     */\n    update(data: Uint8Array): void {\n        for (let i = 0; i < 16; i++) {\n            this.bloc;\n    private byteCount: number;\n            this.hash[i] = (this.block[i] | 0) + (data[i] | 0) | 0;\n        }\n    }\n    /**\n     * Dynamic version of MD5.updat = 0;\n    constructor() {\n        this.block8 = new Uint8Array(this.block.buffer, this.block.byteOffset, this.block.byteLength);\n    }\n    /**\n     * Dynamic version of MD5.update that accepts different types to binary data as parameters.\n     *\n     * @param data Data to hash\n     * @see MD5.update\n     */\n    dynamicUpdate(data: Uint8Array | Uint32Array): void {\n        if (data instanceof Uint8Array) {\n            this.update(data);\n        } else if (data instanceof Uint32Array) {\n            this.block = new Uint3): void;\n            this.block = data;\n    }\n    /**\n     * Updates the MD5 hash with the provided data.\n     *\n     * @param data Data to hash\n     */\n    update(data: Uint8Array): Uint32Arra {\n        if (data instanceof DataView)\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        else if (data instanceof ArrayBuffer)\n            data = new Uint8Array(data);\n        if (!(data instanceof Uint8Array))\n            throw new Error(`Expected a Uint8Array, a DataView or an ArrayBuffer. Received ${data.constructor.name}`);\n        return this.update(data);\n    }\n    /**\n     * Process an array of bytes to hash.\n     *\n     * @param data Bytes to hash\n     */\n    update(data: Uint8Array | Uint32Array): Uint32Array {\n        let hash: Uint32Array | Uint8Array = this.hash;\n        if (data instanceof Uint8Array) {\n            let data8 = data;\n            has): void;\n            hash = new Uint32Array(BLOCK_SIZE);\n            for (let i = 0; i < BLOCK_SIZE; ++i) {\n                has = hash[i] = ((hash[i] | {\n        const avail = (BLOCK_SIZE - (this.byteCount & 63)) | 0;\n        let length = data.length;\n        this.byteCount += length;\n        if (avail > length) {\n            memcpy(this.block8, BLOCK_SIZE - avail, data, 0, length);\n            return;\n        }\n        memcpy(this.block8, BLOCK_SIZE - avail, data, 0, avail);\n        this.transformHelper();\n        let offset = avail;\n        length -= avail;\n        while (length >= BLOCK_SIZE) {\n            memcpy(this.block8, 0, data, offset, BLOCK_SIZE);\n            this.transformHelper();\n            offset += BLOCK_SIZE;\n            length -= BLOCK_SIZE;\n        }\n        memcpy(this.block8, 0, data, offset, length);\n    }\n    /**\n     * Produce the hash as a sequence of 16 bytes.\n     */\n    toUint8Array(): Uint8Array {\n        let p = 0;\n        let padding = 56 - (this.byteCount & 63);\n        if (padding <= 0) {\n            return hash;\n        }\n        let block8 = thi {\n        const offset = this.byteCount & 63;\n        let p = offset;\n        let padding = 56 - (offset + 1);\n        const block8 = this.block8.slice(0);\n        const block = new Uint32Array(block8.buffer);\n        const hash = this.hash.slice(0);\n        block8[p++] = 128;\n        if (padding < 0) {\n            bzero(block8, p, padding + 8);\n            if (!isLittleEndian)\n                le32_to_cpu_uint32array(block);\n            transform(block, hash);\n            p = 0;\n            padding = 56;\n        }\n        bzero(block8, p, padding);\n        block[14] = this.byteCount << 3;\n        block[15] = this.byteCount >>> 29;\n        if (!isLittleEndian) {\n            le32_to_cpu_uint32array(block.subarray(0, BLOCK_LENGTH - 2));\n            transform(block, hash);\n            cpu_to_le32_uint32array(hash);\n        }\n        else {\n            transform(block, hash);\n        }\n        return new Uint8Array(hash.buffer);\n    }\n    /**\n     * Produce the hash as string in hexadecimal format.\n     */\n    toString(): string {\n        let hex = \"\";\n        const hash = this.toUint8Array();\n        const hashLength = hash.byteLength;\n        for (let i = 0; i < hashLength; i++) {\n            hex += ((hash {\n        let hex = \"\";\n        const hash = this.toUint8Array();\n        const hashLength = hash.byteLength;\n        for (let i = 0; i < hashLength; i++) {\n            hex += ((hash[i] >>> 4) & 15).toString(16);\n            hex += ((hash[i] >>> 0) & 15).toString(16);\n        }\n        return hex;\n    }\n    private transformHelper(): number {\n        const hash = this.toUint8Array();\n        const hashLength = hash.byteLength;\n        let p = 0;\n        for (let i = 0; i < hashLength; i++) {\n            const b {\n        if (!isLittleEndian)\n            le32_to_cpu_uint32array(this.block);\n        return transform(this.block, this.hash);\n    }\n    static process(data: Uint8Array, isLittleEndian: boolean): void {\n        const hash = new MD5();\n        hash.dynamicUpdate(data);\n        if (hash.byteCount < BLOCK_LENGTH)\n            hash.block[14] = hash.byteCount << 3;\n        if ( {\n        const md5 = new MD5();\n        md5.dynamicUpdate(data);\n        return md5.toString();\n    }\n}\n","score":219,"fallbacked":false,"num_type_errors":963}]}
{"dataset_elem":{"alphanum_fraction":0.584493519,"avg_line_length":23.6704545455,"content":"interface JSNode {\n  x: number;\n  y: number;\n  weight: number;\n  passable: boolean;\n}\n\ninterface PathResult {\n  path: JSNode[];\n  processed: JSNode[];\n}\n\n// For use to compare performance with web assembly only.\n// Not used for more than comparing at this time.\nexport class JSUniverse {\n  public readonly width: number;\n\n  public readonly height: number;\n\n  private readonly nodes: JSNode[][] = [];\n\n  public constructor(width: number, height: number) {\n    for (let y = 0; y < height; y++) {\n      this.nodes.push([]);\n      for (let x = 0; x < width; x++) {\n        this.nodes[y].push({\n          x,\n          y,\n          weight: 0,\n          passable: true\n        });\n      }\n    }\n\n    this.width = width;\n    this.height = height;\n  }\n\n  public bfs(startX: number, startY: number, endX: number, endY: number): PathResult {\n    const result: PathResult = {\n      path: [],\n      processed: []\n    };\n\n    const frontier: JSNode[] = [];\n\n    const startNode = this.nodes[startY][startX];\n    const endNode = this.nodes[endY][endX];\n\n    const visited = new Set<JSNode>();\n    const cameFrom = new Map<JSNode, JSNode>();\n\n    visited.add(startNode);\n    frontier.unshift(startNode);\n\n    while (frontier.length > 0) {\n      const current = frontier.pop();\n\n      if (!current) {\n        throw new Error('Invalid');\n      }\n\n      result.processed.push(current);\n\n      if (current === endNode) {\n        return this.constructPath(result, cameFrom, endNode);\n      }\n\n      for (const neighbor of this.getNeighbors(current.x, current.y)) {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          cameFrom.set(neighbor, current);\n          frontier.unshift(neighbor);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  public dijkstra(startX: number, startY: number, endX: number, endY: number): PathResult {\n    const result: PathResult = {\n      path: [],\n      processed: []\n    };\n\n    const frontier = this.nodes.flat();\n\n    const startNode = this.nodes[startY][startX];\n    const endNode = this.nodes[endY][endX];\n\n    const times = new Map<JSNode, number>();\n    const cameFrom = new Map<JSNode, JSNode>();\n\n    times.set(startNode, 0);\n\n    while (frontier.length > 0) {\n      const index = this.getClosestNode(frontier, times);\n      const current = frontier[index];\n      frontier.splice(index, 1);\n\n      result.processed.push(current);\n\n      if (current === endNode) {\n        return this.constructPath(result, cameFrom, endNode);\n      }\n\n      for (const neighbor of this.getNeighbors(current.x, current.y)) {\n        const prevTime = times.get(current) ?? Number.MAX_SAFE_INTEGER;\n        const newTime = prevTime + neighbor.weight + 1;\n\n        if (newTime < (times.get(neighbor) ?? Number.MAX_SAFE_INTEGER)) {\n          times.set(neighbor, newTime);\n          cameFrom.set(neighbor, current);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private getClosestNode(nodes: JSNode[], times: Map<JSNode, number>): number {\n    let currClosetsIndex = 0;\n\n    for (let i = 0; i < nodes.length; i++) {\n      if (\n        (times.get(nodes[currClosetsIndex]) ?? Number.MAX_SAFE_INTEGER) >\n        (times.get(nodes[i]) ?? Number.MAX_SAFE_INTEGER)\n      ) {\n        currClosetsIndex = i;\n      }\n    }\n\n    return currClosetsIndex;\n  }\n\n  private getNeighbors(x: number, y: number): JSNode[] {\n    const res: JSNode[] = [];\n\n    if (y > 0 && this.nodes[y - 1][x].passable) {\n      res.push(this.nodes[y - 1][x]);\n    }\n\n    if (y < this.height - 1 && this.nodes[y + 1][x].passable) {\n      res.push(this.nodes[y + 1][x]);\n    }\n\n    if (x > 0 && this.nodes[y][x - 1].passable) {\n      res.push(this.nodes[y][x - 1]);\n    }\n\n    if (x < this.width - 1 && this.nodes[y][x + 1].passable) {\n      res.push(this.nodes[y][x + 1]);\n    }\n\n    return res;\n  }\n\n  private constructPath(result: PathResult, cameFrom: Map<JSNode, JSNode>, endNode: JSNode): PathResult {\n    let current = endNode;\n    result.path.push(current);\n\n    let next = cameFrom.get(current);\n\n    while (next) {\n      current = next;\n      result.path.push(current);\n      next = cameFrom.get(current);\n    }\n\n    result.path.reverse();\n\n    return result;\n  }\n}\n","content_without_annotations":"interface JSNode {\n  x;\n  y;\n  weight;\n  passable;\n}\n\ninterface PathResult {\n  path;\n  processed;\n}\n\n// For use to compare performance with web assembly only.\n// Not used for more than comparing at this time.\nexport class JSUniverse {\n  public readonly width;\n\n  public readonly height;\n\n  private readonly nodes = [];\n\n  public constructor(width, height) {\n    for (let y = 0; y < height; y++) {\n      this.nodes.push([]);\n      for (let x = 0; x < width; x++) {\n        this.nodes[y].push({\n          x,\n          y,\n          weight: 0,\n          passable: true\n        });\n      }\n    }\n\n    this.width = width;\n    this.height = height;\n  }\n\n  public bfs(startX, startY, endX, endY) {\n    const result = {\n      path: [],\n      processed: []\n    };\n\n    const frontier = [];\n\n    const startNode = this.nodes[startY][startX];\n    const endNode = this.nodes[endY][endX];\n\n    const visited = new Set<JSNode>();\n    const cameFrom = new Map<JSNode, JSNode>();\n\n    visited.add(startNode);\n    frontier.unshift(startNode);\n\n    while (frontier.length > 0) {\n      const current = frontier.pop();\n\n      if (!current) {\n        throw new Error('Invalid');\n      }\n\n      result.processed.push(current);\n\n      if (current === endNode) {\n        return this.constructPath(result, cameFrom, endNode);\n      }\n\n      for (const neighbor of this.getNeighbors(current.x, current.y)) {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          cameFrom.set(neighbor, current);\n          frontier.unshift(neighbor);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  public dijkstra(startX, startY, endX, endY) {\n    const result = {\n      path: [],\n      processed: []\n    };\n\n    const frontier = this.nodes.flat();\n\n    const startNode = this.nodes[startY][startX];\n    const endNode = this.nodes[endY][endX];\n\n    const times = new Map<JSNode, number>();\n    const cameFrom = new Map<JSNode, JSNode>();\n\n    times.set(startNode, 0);\n\n    while (frontier.length > 0) {\n      const index = this.getClosestNode(frontier, times);\n      const current = frontier[index];\n      frontier.splice(index, 1);\n\n      result.processed.push(current);\n\n      if (current === endNode) {\n        return this.constructPath(result, cameFrom, endNode);\n      }\n\n      for (const neighbor of this.getNeighbors(current.x, current.y)) {\n        const prevTime = times.get(current) ?? Number.MAX_SAFE_INTEGER;\n        const newTime = prevTime + neighbor.weight + 1;\n\n        if (newTime < (times.get(neighbor) ?? Number.MAX_SAFE_INTEGER)) {\n          times.set(neighbor, newTime);\n          cameFrom.set(neighbor, current);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private getClosestNode(nodes, times) {\n    let currClosetsIndex = 0;\n\n    for (let i = 0; i < nodes.length; i++) {\n      if (\n        (times.get(nodes[currClosetsIndex]) ?? Number.MAX_SAFE_INTEGER) >\n        (times.get(nodes[i]) ?? Number.MAX_SAFE_INTEGER)\n      ) {\n        currClosetsIndex = i;\n      }\n    }\n\n    return currClosetsIndex;\n  }\n\n  private getNeighbors(x, y) {\n    const res = [];\n\n    if (y > 0 && this.nodes[y - 1][x].passable) {\n      res.push(this.nodes[y - 1][x]);\n    }\n\n    if (y < this.height - 1 && this.nodes[y + 1][x].passable) {\n      res.push(this.nodes[y + 1][x]);\n    }\n\n    if (x > 0 && this.nodes[y][x - 1].passable) {\n      res.push(this.nodes[y][x - 1]);\n    }\n\n    if (x < this.width - 1 && this.nodes[y][x + 1].passable) {\n      res.push(this.nodes[y][x + 1]);\n    }\n\n    return res;\n  }\n\n  private constructPath(result, cameFrom, endNode) {\n    let current = endNode;\n    result.path.push(current);\n\n    let next = cameFrom.get(current);\n\n    while (next) {\n      current = next;\n      result.path.push(current);\n      next = cameFrom.get(current);\n    }\n\n    result.path.reverse();\n\n    return result;\n  }\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":1204,"ext":"ts","fun_ann_density":0.01910299,"function_parameters":17,"function_signatures":0,"function_usages":3,"functions":6,"hexsha":"67c92204927aafe048bd5e567c068990724074a8","lang":"TypeScript","loc":131,"loc_per_function":17.3333333333,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"143315e1d0158bf32933ec58724a7b7e44c1bcfa","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"rob893/algo-visualizer","max_forks_repo_path":"app/src/services/JSUniverse.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"143315e1d0158bf32933ec58724a7b7e44c1bcfa","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"rob893/algo-visualizer","max_issues_repo_path":"app/src/services/JSUniverse.ts","max_line_length":105,"max_stars_count":3.0,"max_stars_repo_head_hexsha":"143315e1d0158bf32933ec58724a7b7e44c1bcfa","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"rob893/algo-visualizer","max_stars_repo_path":"app/src/services/JSUniverse.ts","max_stars_repo_stars_event_max_datetime":"2022-02-14T00:02:13.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-29T20:51:18.000Z","metric":0.2842241164,"predefined_density":0.375,"predefined_types":21,"prop_ann_density":0.0074750831,"property_declarations":9,"size":4166,"trivial_density":0.0,"trivial_types":0,"type_definitions":3,"typedef_density":0.0024916944,"var_ann_density":0.0199335548,"variable_declarations":24},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"interface JSNode {\n    x: number;\n    y: number;\n    weight: number;\n    passable: boolean;\n}\ninterface JSUniverse {\n    width: number;\n    height: number;\n    nodes: JSNode[];\n}\ninterface JSNodeQueue {;\n    y: number;\n    x: number;\n    weight: number;\n    passable: boolean;\n}\ninterface JSUniverse {\n    width: number;\n    height: number;\n    nodes: JSNodeQueue[];\n}\ninterface JSNodeQueue;\n    weight: number;\n    x: number;\n    y: number;\n    passable: boolean;\n}\ninterface JSUniverse {\n    width: number;\n    height: number;\n    nodes: JSNodeQueue[];\n}\ninterface JSNodeQueue;\n    passable: boolean;\ninterface JSUniverse {\n    width: number;\n    height: number;\n    nodes: JSNodeQueue[];\n}\ninterface JSUniverse {\n    width: number;\n    height: number;\n    nodes: JSNodeQueue[];;\n}\ninterface PathResult {\n    path: number[];\n    processed: number[];\n}\ninterface PathResult {\n    path: number[];\n    processed: number[];\n}\ninterface JSUniverse {\n    width: number;\n    height: number;\n    nodes: JSNode[];\n};\n    processed: number[];\n    path: number[];\n}\ninterface JSUniverse {\n    width: number;\n    height: number;\n    nodes: JSNode[];\n};\ninterface JSUniverse {\n    width: number;\n    height: number;\n    nodes;\n}\n// For use to compare performance with web assembly only.\n// Not used for more than comparing at this time.\nexport class JSUniverse {\n    public readonly width: number;\n    public readonly height: number;\n    private readonly nodes: JSNode[];\n    public constructor(width, height) {\n        for (let y = 0; y < height; y++) {\n            this.nodes.push([]);;\n    public readonly height: number;\n    public readonly width: number;\n    public constructor(width, height) {\n        for (let y = 0; y < height; y++) {\n            this.nodes.push([]);;\n    public readonly height: number;;\n    private readonly nodes: JSNode[];\n}\n    }\n}\n    private processed: number[];\n    private path: number[];\n}\ninterface JSNode {\n    x: number;\n    y: number;\n    weight: number;\n    passable: boolean; = [];\n    public constructor(width: number, height: number);\n    public constructor(width: number, height: number);\n    public constructor(node: JSNode);\n    public constructor(x: number, y: number);\n    public constructor(x: number, y: numbe, height: number);\n    public constructor(x: number, y: number, height: number);\n    public constructor(x: number, y: number, weight: number);\n    public constructor(node: JSNode);\n    public constructor(x: numbe) {\n        for (let y = 0; y < height; y++) {\n            this.nodes.push([]);\n            for (let x = 0; x < width; x++) {\n                this.nodes[y].push({\n                    x,\n                    y,\n                    weight: 0,\n                    passable: true\n                });\n            }\n        }\n        this.width = width;\n        this.height = height;\n    }\n    public bfs(startX: number, startY: number, endX: number, endY: number, callback) {\n        const visited = new Set<JSNode>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        const queue = new Queue, startY: number;\n        const queueLen = 0;\n        let current = this.nodes[startY][startX];\n        queue.enqueue(current);\n        cameFrom.set(current, null);\n        while (queueLen < width * height), endX: number, endY: number, callback(current: JSNode);\n        let currentNode: JSNode, nextNode: JSNode;\n        while (queue.size > 0) {\n            currentNode = queue.dequeue();\n            visited.add, endY: number, endX: number;\n            if (currentNode.x === endX && currentNode.y === endY) {\n                callback(current);\n                return;\n            }\n            for (let y = 0; y < height; y++): {\n                for (let x = 0; x < width; x++) {\n                    if (this.nodes[y][x].weight === 0 && this.nodes[y][x].passable) {\n                        const nextNode {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const startNode = this.nodes[startY][startX];\n        const endNode = this.nodes[endY][endX];\n        const visited = new Set<JSNode>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        visited.add(startNode);\n        frontier.unshift(startNode);\n        while (frontier.length > 0) {\n            const current = frontier.pop();\n            if (!current) {\n                throw new Error(\"Invalid\");\n            }\n            result.processed.push(current);\n            if (current === endNode) {\n                return this.constructPath(result, cameFrom, endNode);\n            }\n            for (const neighbor of this.getNeighbors(current.x, current.y)) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    cameFrom.set(neighbor, current);\n                    frontier.unshift(neighbor);\n                }\n            }\n        }\n        return result;\n    }\n    public dijkstra(startX: number, startY: number, endX: number, endY: number, callback: (currentNode: JSNode) => void) {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];, startY: number, startX: number, endY: number, endX: number;\n        const startNode = this.nodes[startY][startX];\n        const endNode = this.nodes[endY][endX];\n        const visited = new Se, endX: number, endY: number;\n        const cameFrom = new Map<JSNode, JSNode>();\n        frontier.unshift(startNode);\n        while (frontier.length > 0) {\n            const index = this.getCloses, endY: number, endX: number;\n            if (index === 0) {\n                throw new Error(\"Cannot find path\");\n            }\n            if (index > 0) {\n                endY = frontier[index - 1].y): number;\n                endX = frontier[index - 1].x);\n            } else {\n                endY = endNode.y;\n                endX = endNode.x;\n            }\n            if (endY === endX) {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = this.nodes.flat();\n        const startNode = this.nodes[startY][startX];\n        const endNode = this.nodes[endY][endX];\n        const times = new Map<JSNode, number>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        times.set(startNode, 0);\n        while (frontier.length > 0) {\n            const index = this.getClosestNode(frontier, times);\n            const current = frontier[index];\n            frontier.splice(index, 1);\n            result.processed.push(current);\n            if (current === endNode) {\n                return this.constructPath(result, cameFrom, endNode);\n            }\n            for (const neighbor of this.getNeighbors(current.x, current.y)) {\n                const prevTime = times.get(current) ?? Number.MAX_SAFE_INTEGER;\n                const newTime = prevTime + neighbor.weight + 1;\n                if (newTime < (times.get(neighbor) ?? Number.MAX_SAFE_INTEGER)) {\n                    times.set(neighbor, newTime);\n                    cameFrom.set(neighbor, current);\n                }\n            }\n        }\n        return result;\n    }\n    private getClosestNode(nodes: Node[], times: Map<JSNode, number>) {\n        let closestIndex = 0;\n        let minDistance = Number.MAX_SAFE_INTEGER;\n        for (let i = 0; i < nodes.length; i++, times: Map<JSNode, number>) {\n            if ((times.get(nodes[i])?? Number.MAX_SAFE_INTEGER) < minDistance) {\n                minDistance = times.get(nodes[i])?? Number.MAX): number;\n                closestIndex = i;\n            }\n        }\n        return closestIndex;\n    }\n    private getFrontierNodes(path: NodePath[]) {\n        let frontier = [];\n        for (const node of path) {\n            if ( {\n        let currClosetsIndex = 0;\n        for (let i = 0; i < nodes.length; i++) {\n            if ((times.get(nodes[currClosetsIndex]) ?? Number.MAX_SAFE_INTEGER) >\n                (times.get(nodes[i]) ?? Number.MAX_SAFE_INTEGER)) {\n                currClosetsIndex = i;\n            }\n        }\n        return currClosetsIndex;\n    }\n    private getNeighbors(x: number, y: number) {\n        const res = [];\n        if (y > 0) {\n            res.push(this.nodes[y - 1][x]);\n        }\n        if (y < this.height -, y: number) {\n            res.push(this.nodes[y + 1][x]);\n        }\n        if (x > 0) {\n            res.push(this.nodes[y][x - 1]);\n        }\n        i): number {\n            if (res.length === 0) {\n                return undefined;\n            }\n            return res[Math.floor(Math.random() * res.length)];\n        }\n    }\n}\n    }\n    }\n    } {\n        const res = [];\n        if (y > 0 && this.nodes[y - 1][x].passable) {\n            res.push(this.nodes[y - 1][x]);\n        }\n        if (y < this.height - 1 && this.nodes[y + 1][x].passable) {\n            res.push(this.nodes[y + 1][x]);\n        }\n        if (x > 0 && this.nodes[y][x - 1].passable) {\n            res.push(this.nodes[y][x - 1]);\n        }\n        if (x < this.width - 1 && this.nodes[y][x + 1].passable) {\n            res.push(this.nodes[y][x + 1]);\n        }\n        return res;\n    }\n    private constructPath(result: PathResult) {\n        const endNode = result.path[result.path.length - 1];\n        let current = endNode;\n        let cameFrom: Map<Node | undefined, Node | undefined> = new Map<Node, cameFrom: Node>();\n        for (let i = 0; i < this.nodes.length; i++) {\n            cameFrom.set(this.nodes[i], undefined);\n        }\n        cameFrom.set(current, undefined);\n        resul, endNode: Node = this.getNeighbors(current.x, current.y);\n        if (!resul) {\n            return undefined;\n        }\n        result.path = [];\n        result.path.push(current);\n        while (resul)): {\n            if (resul.passable) {\n                if (!cameFrom.has(resul)) {\n                    cameFrom.set(resul, undefined);\n                }\n                result.path.push(resul);\n                const nex {\n        let current = endNode;\n        result.path.push(current);\n        let next = cameFrom.get(current);\n        while (next) {\n            current = next;\n            result.path.push(current);\n            next = cameFrom.get(current);\n        }\n        result.path.reverse();\n        return result;\n    }\n}\n","score":213,"fallbacked":false,"num_type_errors":303},{"code":"interface JSNode {\n    x: number;\n    y: number;\n    weight: number;\n    passable: boolean;\n}\nexport class JSUniverse {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        thi;\n    y: number;\n    x: number;\n    weight: number;\n    passable: boolean;\n}\nexport class JSUniverse {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        t;\n    weight: number;\n    passable: boolean;\n}\nexport class JSUniverse {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        const width = 500;\n        const heigh;\n    passable: boolean;\n}\nexport class JSUniverse {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        const width = 500;\n        const heigh;\n        weight: numbe;\n}\ninterface PathResult {\n    path: {\n        x: number;\n        y: number;\n    };\n}\nexport class JSUniverse {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    const width = 5;\n    processed: boolean;\n}\nexport class JSUniverse {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    const width = 500;\n    const heigh;\n    processed: boolea;\n}\n// For use to compare performance with web assembly only.\n// Not used for more than comparing at this time.\nexport class JSUniverse {\n    public readonly width: number;\n    public readonly height: number;\n    public readonly nodes = [];\n    public constructor(width, height) {\n        for (let y = 0; y < height; y++) {\n            this.nodes.push([]);\n            for;\n    public readonly height: number;\n            for (let x = 0; x < width; x++) {\n                this.nodes[y].push({\n                    x,\n                    y,\n                    weight: 0,\n                    passable: true\n                });\n            };\n    private readonly nodes: number[];\n    private readonly width: number;\n    private readonly height: number;\n    private constructor(width: number, height: number);\n    public bfs(startX, startY, endX, endY): PathResult {\n        const result = [];\n    public constructor(width: number, height: number);\n    public bfs(startX, startY, endX, endY);\n    private readonly startX: number;\n    private readonly startY: number;\n    private readonly endX: number;\n    private readonly endY: numbe, height: number;\n    }\n}\n}\n\n// TODO: Add more tests here.\n\n// TODO: Add more tests here.\n\n// TODO: Add more tests here.\n\n// TODO: Add more tests here.) {\n        for (let y = 0; y < height; y++) {\n            this.nodes.push([]);\n            for (let x = 0; x < width; x++) {\n                this.nodes[y].push({\n                    x,\n                    y,\n                    weight: 0,\n                    passable: true\n                });\n            }\n        }\n        this.width = width;\n        this.height = height;\n    }\n    public bfs(startX: number, startY: number, endX: number, endY: number): PathResult {\n        const result = [];\n    public constructor(width: number, height: number);\n    public bfs(startX:  number, startY: number, startY: number, endX: number, endY: number);\n    public bfs(startX: number, startY: number, endX: number, endY: number) {\n        const result = [];\n    public constructor(width: number, heigh, endX: number, endY: number);\n    public bfs(startX: number, startY: number, endX: number, endY: number);\n    public bfs(startX: number, startY: number, endX: number, end, endY: number);\n    public bfs(startX: number, startY: number, endX: number, endY: number) {\n        const result = [];\n    public constructor(width: number, heigh, endX: number, endY): PathResult {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const startNode = this.nodes[startY][startX];\n        const endNode = this.nodes[endY][en {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const startNode = this.nodes[startY][startX];\n        const endNode = this.nodes[endY][endX];\n        const visited = new Set<JSNode>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        visited.add(startNode);\n        frontier.unshift(startNode);\n        while (frontier.length > 0) {\n            const current = frontier.pop();\n            if (!current) {\n                throw new Error(\"Invalid\");\n            }\n            result.processed.push(current);\n            if (current === endNode) {\n                return this.constructPath(result, cameFrom, endNode);\n            }\n            for (const neighbor of this.getNeighbors(current.x, current.y)) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    cameFrom.set(neighbor, current);\n                    frontier.unshift(neighbor);\n                }\n            }\n        }\n        return result;\n    }\n    public dijkstra(startX: number, startY: number, endX: number, endY: number) {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const startNode = this.nodes[startY][start, startY: startY];\n        const endNode = this.nodes[endY][endX];\n        const times = new Map<JSNode, number>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        times.set(startNod, endX: endY: 0);\n        while (frontier.length > 0) {\n            const current = frontier.pop();\n            if (!current) {\n                throw new Error(\"Invalid\");\n            }\n            result.processed.push(curren, endY: endX: 0);\n            if (current === endNode) {\n                return this.constructPath(result, cameFrom, endNode);\n            }\n            for (const neighbor of this.getNeighbors(current.x, current.): {\n                if (!times.has(neighbor)) {\n                    times.set(neighbor, times.get(current) + 1);\n                    cameFrom.set(neighbor, current);\n                    frontier.unshift(neighbor);\n                } {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = this.nodes.flat();\n        const startNode = this.nodes[startY][startX];\n        const endNode = this.nodes[endY][endX];\n        const times = new Map<JSNode, number>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        times.set(startNode, 0);\n        while (frontier.length > 0) {\n            const index = this.getClosestNode(frontier, times);\n            const current = frontier[index];\n            frontier.splice(index, 1);\n            result.processed.push(current);\n            if (current === endNode) {\n                return this.constructPath(result, cameFrom, endNode);\n            }\n            for (const neighbor of this.getNeighbors(current.x, current.y)) {\n                const prevTime = times.get(current) ?? Number.MAX_SAFE_INTEGER;\n                const newTime = prevTime + neighbor.weight + 1;\n                if (newTime < (times.get(neighbor) ?? Number.MAX_SAFE_INTEGER)) {\n                    times.set(neighbor, newTime);\n                    cameFrom.set(neighbor, current);\n                }\n            }\n        }\n        return result;\n    }\n    private getClosestNode(nodes: JSNode[], times: Map<JSNode, number>) {\n        let currClosetsIndex = 0;\n        for (let i = 0; i < nodes.length; i++) {\n            if ((times.get(nodes, times: number)?? Number.MAX_SAFE_INTEGER) >\n                (times.get(nodes[currClosetsIndex])?? Number.MAX_SAFE_INTEGER)) {\n                currClosetsIndex = i;\n            }\n        }\n        return cur): number;\n    }\n    private constructPath(result: PathResult, cameFrom: Map<JSNode, JSNode>, endNode: JSNode) {\n        const path = [];\n        for (let i = result.processed.length - {\n        let currClosetsIndex = 0;\n        for (let i = 0; i < nodes.length; i++) {\n            if ((times.get(nodes[currClosetsIndex]) ?? Number.MAX_SAFE_INTEGER) >\n                (times.get(nodes[i]) ?? Number.MAX_SAFE_INTEGER)) {\n                currClosetsIndex = i;\n            }\n        }\n        return currClosetsIndex;\n    }\n    private getNeighbors(x: number, y: number) {\n        const res = [];\n        if (y > 0) {\n            res.push(this.nodes[y - 1][x]);\n        }\n        if (y < this.height -, y: number) {\n            res.push(this.nodes[y + 1][x]);\n        }\n        if (x > 0) {\n            res.push(this.nodes[y][x - 1]);\n        }\n        i): number {\n            if (x > 0) {\n                if (this.nodes[y][x - 1].passable) {\n                    res.push(this.nodes[y][x - 1]);\n                }\n            } {\n        const res = [];\n        if (y > 0 && this.nodes[y - 1][x].passable) {\n            res.push(this.nodes[y - 1][x]);\n        }\n        if (y < this.height - 1 && this.nodes[y + 1][x].passable) {\n            res.push(this.nodes[y + 1][x]);\n        }\n        if (x > 0 && this.nodes[y][x - 1].passable) {\n            res.push(this.nodes[y][x - 1]);\n        }\n        if (x < this.width - 1 && this.nodes[y][x + 1].passable) {\n            res.push(this.nodes[y][x + 1]);\n        }\n        return res;\n    }\n    private constructPath(result: PathResult, cameFrom: Map<JSNode, JSNode>, endNode: JSNode) {\n        const path = [];\n        path.push(endNode);\n        let current = endNode;\n        while (current.parent) {\n            path.unshift(current, endNode: current.parent);\n            current = current.parent;\n        }\n        path.reverse();\n        return path;\n    }\n    private getPathResult(endNode: JSNode): PathResult {\n        const result = new PathResult();\n        result.path = [];\n        result.cameFrom = new Map<JSNode, JSNode>();\n        result.cost = 0;\n        result.costFrom = endNode {\n        let current = endNode;\n        result.path.push(current);\n        let next = cameFrom.get(current);\n        while (next) {\n            current = next;\n            result.path.push(current);\n            next = cameFrom.get(current);\n        }\n        result.path.reverse();\n        return result;\n    }\n}\n","score":388,"fallbacked":false,"num_type_errors":408},{"code":"interface JSNode {\n    x: number;\n    y: number;\n    weight: number;\n    passable: boolean;\n}\n// An array of JSNodes.\nexport class JSUniverse {\n    public readonly width;\n    public readonly height;\n    private readonly nodes: J;\n    y: number;\n    x: number;\n    weight: number;\n    passable: boolean;\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.nodes = [];\n        for (le;\n    weight: number;\n    passable: boolean;\n    }\n    public bfs(startX, startY, endX, endY) {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const star;\n    passable: boolean;\n    const queue = [startNode];\n    while (queue.length > 0) {\n    const currentNode = queue.pop();\n    if (currentNode === endNode) {\n    break;\n    }\n    if (currentNode.passabl;\n}\ninterface PathResult {\n    path: JSNode[];\n    processed: JSNode[];\n}\n// An array of JSNodes.\nconst pathResult: PathResult = result;\n}\n}\n}\n}\n}\n}\n}\n}\n}\n};\n    processed: JSNode[];\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n};\n}\n// For use to compare performance with web assembly only.\n// Not used for more than comparing at this time.\nexport class JSUniverse {\n    public readonly width: number;\n    public readonly height: number;\n    private readonly nodes: JSNode[];\n    y: number;\n    x: number;\n    weight: number;\n    passable: boolean;\n    constructor(width: number, height: number);\n    public readonly height: number;\n    public bfs(startX, startY, endX, endY) {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const star;\n        let currentWeight =;\n    private readonly nodes: JSNode[];\n    y: number;\n    x: number;\n    weight: number;\n    passable: boolean;\n    constructor(width: number, height: number);\n    public bfs(startX, startY, endX, endY = [];\n    public constructor(width: number, height: number);\n    private readonly nodes: JSNode[];\n    public addNode(node: JSNode) {\n        this.nodes[node.y].push(node);\n    }\n    public addEdge(node: JSNode, height: number, weight: number) {\n        let parentX = node.x;\n        let parentY = node.y;\n        while (parentX >= 0 && parentX < this.width && parentY >= 0 && parentY) {\n        for (let y = 0; y < height; y++) {\n            this.nodes.push([]);\n            for (let x = 0; x < width; x++) {\n                this.nodes[y].push({\n                    x,\n                    y,\n                    weight: 0,\n                    passable: true\n                });\n            }\n        }\n        this.width = width;\n        this.height = height;\n    }\n    public bfs(startX: number, startY: number, endX: number, endY = []) {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const star;\n        let currentWeight =;\n    private readonl, startY: number, startX: number, endX: number, endY: number, currentWeight: number, height: number, width: number, nodes: JSNode[];\n    y: number;\n    x: number;\n    weight: number;, endX: number, endY: number;\n    constructor(width: number, height: number);\n    public bfs(startX, startY, endX, endY = []) {\n        const result = {\n            path: [],\n            processed: []\n        }, endY: number, startX: number, endX: number, currentWeight: number, height: number, width: number, nodes: JSNode[];\n        const frontier = [];\n        let currentWeight =;\n        let endY: number, startX): {\n            if (endY && endX) {\n                endY = endY[0];\n                endX = endX[0];\n            }\n            if (endY < 0 || endY >= height || endX < {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const startNode = this.nodes[startY][startX];\n        const endNode = this.nodes[endY][endX];\n        const visited = new Set<JSNode>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        visited.add(startNode);\n        frontier.unshift(startNode);\n        while (frontier.length > 0) {\n            const current = frontier.pop();\n            if (!current) {\n                throw new Error(\"Invalid\");\n            }\n            result.processed.push(current);\n            if (current === endNode) {\n                return this.constructPath(result, cameFrom, endNode);\n            }\n            for (const neighbor of this.getNeighbors(current.x, current.y)) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    cameFrom.set(neighbor, current);\n                    frontier.unshift(neighbor);\n                }\n            }\n        }\n        return result;\n    }\n    public dijkstra(startX: number, startY: number, endX: number, endY: number) {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = [];\n        const startNode = this.nodes[startY][start, startY: number];\n        const endNode = this.nodes[endY][endX];\n        const times = new Map<JSNode, number>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        times.set(startNod, endX: number);\n        while (frontier.length > 0) {\n            const index = this.getClosestNode(frontier, times);\n            const current = frontier[index];\n            if (current === endNode) {\n                return thi, endY: number, endX: number;\n            }\n            frontier.splice(index, 1);\n            for (const neighbor of this.getNeighbors(current.x, current.y)) {\n                if (!times.has(neighbor))): {\n                    times.set(neighbor, current.time + 1);\n                    cameFrom.set(neighbor, current);\n                } else {\n                    if (times.get(neighbor) < times.get(current)) {\n                        times.se {\n        const result = {\n            path: [],\n            processed: []\n        };\n        const frontier = this.nodes.flat();\n        const startNode = this.nodes[startY][startX];\n        const endNode = this.nodes[endY][endX];\n        const times = new Map<JSNode, number>();\n        const cameFrom = new Map<JSNode, JSNode>();\n        times.set(startNode, 0);\n        while (frontier.length > 0) {\n            const index = this.getClosestNode(frontier, times);\n            const current = frontier[index];\n            frontier.splice(index, 1);\n            result.processed.push(current);\n            if (current === endNode) {\n                return this.constructPath(result, cameFrom, endNode);\n            }\n            for (const neighbor of this.getNeighbors(current.x, current.y)) {\n                const prevTime = times.get(current) ?? Number.MAX_SAFE_INTEGER;\n                const newTime = prevTime + neighbor.weight + 1;\n                if (newTime < (times.get(neighbor) ?? Number.MAX_SAFE_INTEGER)) {\n                    times.set(neighbor, newTime);\n                    cameFrom.set(neighbor, current);\n                }\n            }\n        }\n        return result;\n    }\n    private getClosestNode(nodes: Node[] | undefined, times: Map<JSNode, number>) {\n        let closestNodeIndex = 0;\n        for (let i = 0; i < nodes.length; i++) {\n            if ((times.get(node, times: any)?? Number.MAX_SAFE_INTEGER) >\n                (times.get(nodes[closestNodeIndex])?? Number.MAX_SAFE_INTEGER)) {\n                closestNodeIndex = i;\n            }\n        }\n        return closestNodeIndex;): number;\n    }\n    private constructPath(path: Path, cameFrom: Map<JSNode, JSNode>, target: JSNode) {\n        path.nodes = path.nodes.map((v, i) => {\n            if {\n        let currClosetsIndex = 0;\n        for (let i = 0; i < nodes.length; i++) {\n            if ((times.get(nodes[currClosetsIndex]) ?? Number.MAX_SAFE_INTEGER) >\n                (times.get(nodes[i]) ?? Number.MAX_SAFE_INTEGER)) {\n                currClosetsIndex = i;\n            }\n        }\n        return currClosetsIndex;\n    }\n    private getNeighbors(x: number, y: number): Node[] {\n        const res = [];\n        if (y > 0) {\n            if (this.nodes[y - 1][x].passable) {\n                res.push(this.nodes, y: y - 1, x: x);\n            }\n        }\n        if (y < this.height - 1) {\n            if (this.nodes[y + 1][x].passable) {\n                res.push(thi): res.push(nodes[y + 1][x]);\n            }\n        }\n        if (x > 0) {\n            if (this.nodes[y][x - 1].passable) {\n                res.push(thi {\n        const res = [];\n        if (y > 0 && this.nodes[y - 1][x].passable) {\n            res.push(this.nodes[y - 1][x]);\n        }\n        if (y < this.height - 1 && this.nodes[y + 1][x].passable) {\n            res.push(this.nodes[y + 1][x]);\n        }\n        if (x > 0 && this.nodes[y][x - 1].passable) {\n            res.push(this.nodes[y][x - 1]);\n        }\n        if (x < this.width - 1 && this.nodes[y][x + 1].passable) {\n            res.push(this.nodes[y][x + 1]);\n        }\n        return res;\n    }\n    private constructPath(result: Result, cameFrom: Map<JSNode, JSNode>, target: JSNode) {\n        result.path = [];\n        this.constructPath(result, cameFrom, target);\n    }\n    private getPathFromNode(startNode: J, cameFrom: Map<JSNode, JSNode>, target: JSNode) {\n        const result = {\n            path: [startNode],\n            closed: new Set(),\n        };\n        this.constructPath(result, cameFrom, target);\n        return resul, endNode: {};\n    }\n    private getPathFromNodeWithCost(startNode: J, cameFrom: Map<JSNode, JSNode>, target: JSNode) {\n        const result = {\n            path: [startNode],\n            closed: ne): Result {\n            path: [],\n            closed: new Set(),\n            } {\n            path: result.path.slice(),\n            closed: result.closed,\n        };\n    }\n    private reversePath(result: Result) {\n        let current = endNode;\n        result.path.push(current);\n        let next = cameFrom.get(current);\n        while (next) {\n            current = next;\n            result.path.push(current);\n            next = cameFrom.get(current);\n        }\n        result.path.reverse();\n        return result;\n    }\n}\n","score":317,"fallbacked":false,"num_type_errors":455}]}
{"dataset_elem":{"alphanum_fraction":0.6232394366,"avg_line_length":37.1904761905,"content":"//why? look @ http://www.ngiam.net/NRIC/NRIC_numbers.pdf deeper.\nconst offsetMap = new Map([\n  [\"T\", 4],\n  [\"G\", 4],\n  [\"M\", 3],\n]);\n\n/**\n *\n * @param idToCheck {string} identification number to check\n * @returns {boolean} validation results\n */\nexport const validate = (idToCheck: string): boolean => {\n  //short circuit evaulation\n  if (idToCheck.length !== 9) {\n    return false;\n  }\n\n  const { valid } = tryGetChecksum(idToCheck); // sum them up\n  return valid;\n};\n\nexport const generate = (partialSeedId?: string) => {\n  const legalStartingCharacters = [\"S\", \"T\", \"F\", \"G\", \"M\"];\n  if (partialSeedId) {\n    const hasLegalStartingCharacter = legalStartingCharacters.some((legalStartingCharacter) =>\n      partialSeedId.charAt(0).toUpperCase().startsWith(legalStartingCharacter),\n    );\n    if (!hasLegalStartingCharacter) {\n      throw new Error(\"Invalid start character\");\n    } else {\n      const containsNumbersOnlyAfterFirst = !isNaN(Number(partialSeedId.substring(1, partialSeedId.length)));\n      if (!containsNumbersOnlyAfterFirst) {\n        throw new Error(\"Invalid seed id\");\n      }\n    }\n  }\n  const startChar =\n    (partialSeedId && partialSeedId.charAt(0)) || legalStartingCharacters[Math.floor(Math.random() * 4)];\n  let generatedId: string[] = (partialSeedId && partialSeedId.substring(1, partialSeedId.length).split(\"\")) || [];\n  while (generatedId.length !== 7) {\n    generatedId.push(Math.floor(Math.random() * 10) + \"\");\n  }\n\n  const { checksum } = tryGetChecksum(startChar + generatedId.join(\"\"));\n\n  return `${startChar}${generatedId.join(\"\")}${checksum}`.toUpperCase();\n};\n/**\n *\n * @param idDigits {string[]} identification number to check\n * @returns weight\n */\nconst getWeights = (idDigits: string[]): number => {\n  let weights = [2, 7, 6, 5, 4, 3, 2]; // read: http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n  return idDigits\n    .map((value, idx) => parseInt(value, 10) * weights[idx]) // multiply each digit with their respective weights\n    .reduce((prev: number, idDigit: number) => prev + idDigit);\n};\nconst tryGetChecksum = (idDigits: string): { checksum?: string; valid: boolean } => {\n  // checksum tables\n  const ST = [\"J\", \"Z\", \"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"B\", \"A\"];\n  const FG = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"M\", \"L\", \"K\"];\n  const M = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"J\", \"L\", \"K\"];\n\n  const id = idDigits.split(\"\");\n  let [startChar, ...idArray] = id;\n  const endChar = idArray.length === 8 ? idArray.pop()!.toUpperCase() : \"\";\n  //add offset by century prefix if required\n  const weight = (offsetMap.get(startChar.toUpperCase()) || 0) + getWeights(idArray);\n  const remainder = weight % 11;\n\n  startChar = startChar.toUpperCase();\n  if (startChar === \"S\" || startChar === \"T\") {\n    return { checksum: ST[remainder], valid: ST[remainder] === endChar };\n  } else if (startChar === \"F\" || startChar === \"G\") {\n    return { checksum: FG[remainder], valid: FG[remainder] === endChar };\n  } else if (startChar === \"M\") {\n    return { checksum: M[remainder], valid: M[remainder] === endChar };\n  } else {\n    return { checksum: undefined, valid: false };\n  }\n};\n","content_without_annotations":"//why? look @ http://www.ngiam.net/NRIC/NRIC_numbers.pdf deeper.\nconst offsetMap = new Map([\n  [\"T\", 4],\n  [\"G\", 4],\n  [\"M\", 3],\n]);\n\n/**\n *\n * @param idToCheck {string} identification number to check\n * @returns {boolean} validation results\n */\nexport const validate = (idToCheck) => {\n  //short circuit evaulation\n  if (idToCheck.length !== 9) {\n    return false;\n  }\n\n  const { valid } = tryGetChecksum(idToCheck); // sum them up\n  return valid;\n};\n\nexport const generate = (partialSeedId?) => {\n  const legalStartingCharacters = [\"S\", \"T\", \"F\", \"G\", \"M\"];\n  if (partialSeedId) {\n    const hasLegalStartingCharacter = legalStartingCharacters.some((legalStartingCharacter) =>\n      partialSeedId.charAt(0).toUpperCase().startsWith(legalStartingCharacter),\n    );\n    if (!hasLegalStartingCharacter) {\n      throw new Error(\"Invalid start character\");\n    } else {\n      const containsNumbersOnlyAfterFirst = !isNaN(Number(partialSeedId.substring(1, partialSeedId.length)));\n      if (!containsNumbersOnlyAfterFirst) {\n        throw new Error(\"Invalid seed id\");\n      }\n    }\n  }\n  const startChar =\n    (partialSeedId && partialSeedId.charAt(0)) || legalStartingCharacters[Math.floor(Math.random() * 4)];\n  let generatedId = (partialSeedId && partialSeedId.substring(1, partialSeedId.length).split(\"\")) || [];\n  while (generatedId.length !== 7) {\n    generatedId.push(Math.floor(Math.random() * 10) + \"\");\n  }\n\n  const { checksum } = tryGetChecksum(startChar + generatedId.join(\"\"));\n\n  return `${startChar}${generatedId.join(\"\")}${checksum}`.toUpperCase();\n};\n/**\n *\n * @param idDigits {string[]} identification number to check\n * @returns weight\n */\nconst getWeights = (idDigits) => {\n  let weights = [2, 7, 6, 5, 4, 3, 2]; // read: http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n  return idDigits\n    .map((value, idx) => parseInt(value, 10) * weights[idx]) // multiply each digit with their respective weights\n    .reduce((prev, idDigit) => prev + idDigit);\n};\nconst tryGetChecksum = (idDigits) => {\n  // checksum tables\n  const ST = [\"J\", \"Z\", \"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"B\", \"A\"];\n  const FG = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"M\", \"L\", \"K\"];\n  const M = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"J\", \"L\", \"K\"];\n\n  const id = idDigits.split(\"\");\n  let [startChar, ...idArray] = id;\n  const endChar = idArray.length === 8 ? idArray.pop()!.toUpperCase() : \"\";\n  //add offset by century prefix if required\n  const weight = (offsetMap.get(startChar.toUpperCase()) || 0) + getWeights(idArray);\n  const remainder = weight % 11;\n\n  startChar = startChar.toUpperCase();\n  if (startChar === \"S\" || startChar === \"T\") {\n    return { checksum: ST[remainder], valid: ST[remainder] === endChar };\n  } else if (startChar === \"F\" || startChar === \"G\") {\n    return { checksum: FG[remainder], valid: FG[remainder] === endChar };\n  } else if (startChar === \"M\") {\n    return { checksum: M[remainder], valid: M[remainder] === endChar };\n  } else {\n    return { checksum: undefined, valid: false };\n  }\n};\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":948,"ext":"ts","fun_ann_density":0.0168776371,"function_parameters":9,"function_signatures":0,"function_usages":2,"functions":7,"hexsha":"ca95641b386ab877b6192cfe0a801386bd5872da","lang":"TypeScript","loc":62,"loc_per_function":7.4285714286,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"deb92034dcb7440a62f3ca7140d70477dddad7fd","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"murugaratham/nricvalidator","max_forks_repo_path":"src/index.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"deb92034dcb7440a62f3ca7140d70477dddad7fd","max_issues_repo_issues_event_max_datetime":"2022-03-30T11:14:33.000Z","max_issues_repo_issues_event_min_datetime":"2022-03-30T11:14:33.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"murugaratham/nricvalidator","max_issues_repo_path":"src/index.ts","max_line_length":114,"max_stars_count":null,"max_stars_repo_head_hexsha":"deb92034dcb7440a62f3ca7140d70477dddad7fd","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"murugaratham/nricvalidator","max_stars_repo_path":"src/index.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2820397159,"predefined_density":0.2972972973,"predefined_types":11,"prop_ann_density":0.0,"property_declarations":0,"size":3124,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0221518987,"variable_declarations":21},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"//why? look @ http://www.ngiam.net/NRIC/NRIC_numbers.pdf deeper.\nconst offsetMap = new Map([\n    [\"T\", 4],\n    [\"G\", 4],\n    [\"M\", 3],\n]);\n/**\n *\n * @param idToCheck {string} identification number to check\n * @returns {boolean} validation results\n */\nexport const validate = (idToCheck: string) => {\n    //short circuit evaulation\n    if (idToCheck.length!== 9) {\n        return false;\n    }\n    const { valid } = tryGetChecksum(idToCheck); // sum them up\n    return valid): boolean;\n};\n/**\n *\n * @param idToCheck {string} identification number to check\n * @returns checksum\n */\nexport const getChecksum = (idToCheck: string) => {\n    const { checksum } = tryGe => {\n    //short circuit evaulation\n    if (idToCheck.length !== 9) {\n        return false;\n    }\n    const { valid } = tryGetChecksum(idToCheck); // sum them up\n    return valid;\n};\nexport const generate = (partialSeedId?: string, count: number = 1) => {\n    let generatedId = \"\";\n    let countLeft = count;\n    do {\n        const { checksum } = tryGe => {\n            //short circuit evaulation\n            if (idToCheck): {\n                return false;\n            }\n            const { valid } = tryGetChecksum(idToCheck); // sum them up\n            return valid;\n        };\n        const { checksum } = tryGe;\n        const firstChar = checksum.charAt(0) => {\n    const legalStartingCharacters = [\"S\", \"T\", \"F\", \"G\", \"M\"];\n    if (partialSeedId) {\n        const hasLegalStartingCharacter = legalStartingCharacters.some((legalStartingCharacter: string) => partialSeedId.charAt(0).toUpperCase().startsWith(legalStartingCharacter));\n        if (!hasLegalStartingCharacter) {\n            throw new Error(\"Invalid start character\");\n        }\n        else {\n            const containsNumbersOnlyAfterFirst): boolean = partialSeedId.charAt(1, 10).toUpperCase().indexOf(\"0\") === -1;\n            if (!containsNumbersOnlyAfterFirst) {\n                throw new Error(\"Invalid seed id\");\n            }\n        }\n    } => partialSeedId.charAt(0).toUpperCase().startsWith(legalStartingCharacter));\n        if (!hasLegalStartingCharacter) {\n            throw new Error(\"Invalid start character\");\n        }\n        else {\n            const containsNumbersOnlyAfterFirst = !isNaN(Number(partialSeedId.substring(1, partialSeedId.length)));\n            if (!containsNumbersOnlyAfterFirst) {\n                throw new Error(\"Invalid seed id\");\n            }\n        }\n    }\n    const startChar = (partialSeedId && partialSeedId.charAt(0)) || legalStartingCharacters[Math.floor(Math.random() * 4)];\n    let generatedId = (partialSeedId && partialSeedId.substring(1, partialSeedId.length).split(\"\")) || [];\n    while (generatedId.length !== 7) {\n        generatedId.push(Math.floor(Math.random() * 10) + \"\");\n    }\n    const { checksum } = tryGetChecksum(startChar + generatedId.join(\"\"));\n    return `${startChar}${generatedId.join(\"\")}${checksum}`.toUpperCase();\n};\n/**\n *\n * @param idDigits {string[]} identification number to check\n * @returns weight\n */\nconst getWeights = (idDigits: string[]): number[] => {\n    return idDigits.map((digit, idx) => {\n        let weight = 1;\n        if (idx % 2 === 0) {\n            weight += Math.floor(idx / 2); => {\n    let weights = [2, 7, 6, 5, 4, 3, 2]; // read: http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n    return idDigits\n        .map((value: string, idx) => parseInt(value, 10) * weights[idx]) // multiply each digit with their respective weights\n      .reduce((prev, idDigit) => prev + idDigit);\n};\n        } else {\n            weight +, idx: http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n            weight += idDigits.length - idx - 1; => {\n    let weights = [7, 6, 5, 4,): http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n    return idDigits\n       .map((value: string, idx) => parseInt(value, 10) * weights[idx]) // multiply each digi => parseInt(value, 10) * weights[idx]) // multiply each digit with their respective weights\n        .reduce((prev: number, idDigit: string) => prev + parseInt(idDigit, 10));\n};\n        }\n    });\n};\n/**\n * Checks if the number is valid\n * @param number {string} identification number\n *, idDigit: string\n * @returns {boolean}\n */\nconst isValidNumber = (idDigits: string, idChar = \"A\") => {\n    const weight = getWeights(idDigits);\n    const checksum = idDigits.slice(-1)): string;\n    const checksumCalc = calculateChecksum(idChar + checksum);\n    if (checksumCalc === weight.join(\"\").toUpperCase()) {\n        return true;\n    } else {\n        return false;\n    }\n};\n/**\n * => prev + idDigit);\n};\nconst tryGetChecksum = (idDigits: string, idChar = \"A\"): string => {\n    let weight = getWeights(idDigits);\n    const checksum = idDigits.slice(-1): string;\n    const checksumCalc = calculateChecksum(idChar + checksum);\n    return checksu): string;\n};\nconst tryGetChecksum2 = (idDigits: string, idChar = \"A\") => {\n    const weight = getWeights(idDigits);\n    const checksum = idDigits.slice(-1): string;\n    retur => {\n    // checksum tables\n    const ST = [\"J\", \"Z\", \"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"B\", \"A\"];\n    const FG = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"M\", \"L\", \"K\"];\n    const M = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"J\", \"L\", \"K\"];\n    const id = idDigits.split(\"\");\n    let [startChar, ...idArray] = id;\n    const endChar = idArray.length === 8 ? idArray.pop()!.toUpperCase() : \"\";\n    //add offset by century prefix if required\n    const weight = (offsetMap.get(startChar.toUpperCase()) || 0) + getWeights(idArray);\n    const remainder = weight % 11;\n    startChar = startChar.toUpperCase();\n    if (startChar === \"S\" || startChar === \"T\") {\n        return { checksum: ST[remainder], valid: ST[remainder] === endChar };\n    }\n    else if (startChar === \"F\" || startChar === \"G\") {\n        return { checksum: FG[remainder], valid: FG[remainder] === endChar };\n    }\n    else if (startChar === \"M\") {\n        return { checksum: M[remainder], valid: M[remainder] === endChar };\n    }\n    else {\n        return { checksum: undefined, valid: false };\n    }\n};\n","score":381,"fallbacked":false,"num_type_errors":58},{"code":"//why? look @ http://www.ngiam.net/NRIC/NRIC_numbers.pdf deeper.\nconst offsetMap = new Map([\n    [\"T\", 4],\n    [\"G\", 4],\n    [\"M\", 3],\n]);\n/**\n *\n * @param idToCheck {string} identification number to check\n * @returns {boolean} validation results\n */\nexport const validate = (idToCheck: string): number => {\n    if (idToCheck.length!== 9) {\n        throw new Error(\"Invalid id\");\n    }\n    const { checksum } = tryGetChecksum(idToCheck); // sum them up\n    if (checksum!== i): {\n        throw new Error(\"Checksum mismatch\");\n    }\n    return checksum;\n};\nexport const tryGetChecksum = (idToCheck) => {\n    const lastTwoDigits = idToCheck.substring(idToCheck.length - 2); => {\n    //short circuit evaulation\n    if (idToCheck.length !== 9) {\n        return false;\n    }\n    const { valid } = tryGetChecksum(idToCheck); // sum them up\n    return valid;\n};\nexport const generate = (partialSeedId?: string): { startChar: string, generatedId: string, checksum: number } => {\n    const legalStartingCharacters = [\"S\", \"T\", \"F\", \"G\", \"M\"];\n    if (partialSeedId) {\n        const hasLegalStartingCharacter = legalStartingCharacters.some((legalStartingCharacter: string) => partialSeedId.charAt(0).toUpperCase().startsWith(legalStartingCharacter));\n        if (!hasLegalStartingCharacter) {\n            throw new Error(\"Invalid start character\");\n        }\n        else {\n            const containsNumbersOnlyAfterFirst): boolean =!isNaN(Number(partialSeedId.substring(1, partialSeedId.length)));\n            if (!containsNumbersOnlyAfterFirst) {\n                throw new Error(\"Invalid seed id\");\n            }\n        }\n    }\n    const startCha => partialSeedId.charAt(0).toUpperCase().startsWith(legalStartingCharacter));\n        if (!hasLegalStartingCharacter) {\n            throw new Error(\"Invalid start character\");\n        }\n        else {\n            const containsNumbersOnlyAfterFirst = !isNaN(Number(partialSeedId.substring(1, partialSeedId.length)));\n            if (!containsNumbersOnlyAfterFirst) {\n                throw new Error(\"Invalid seed id\");\n            }\n        }\n    }\n    const startChar = (partialSeedId && partialSeedId.charAt(0)) || legalStartingCharacters[Math.floor(Math.random() * 4)];\n    let generatedId = (partialSeedId && partialSeedId.substring(1, partialSeedId.length).split(\"\")) || [];\n    while (generatedId.length !== 7) {\n        generatedId.push(Math.floor(Math.random() * 10) + \"\");\n    }\n    const { checksum } = tryGetChecksum(startChar + generatedId.join(\"\"));\n    return `${startChar}${generatedId.join(\"\")}${checksum}`.toUpperCase();\n};\n/**\n *\n * @param idDigits {string[]} identification number to check\n * @returns weight\n */\nconst getWeights = (idDigits: string[]): number => {\n    if (!idDigits ||!idDigits.length) {\n        return 0;\n    }\n    // check if the first digit is not 1\n    if (idDigits[0]!== \"1\")): {\n        throw new Error(\"Invalid start character\");\n    }\n    let weights = [10, 12, 13, 14, 15, 16, 17, 18, => {\n    let weights = [2, 7, 6, 5, 4, 3, 2]; // read: http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n    return idDigits\n        .map((value: string): number => parseInt(value, 10)) // convert string to number (e.g. 14)\n       .reduce((prev, idDigit) => prev + idDigit);\n}, 100];\n    retur, idx: number = 0;\n    while (idx < idDigits.length) {\n        let digit = idDigits[idx];\n        weights[idx] = weights[idx] * 10 - digit.charCodeAt(0) + 1): 0;\n        idx += 1;\n    }\n    return weights[idDigits.length - 1];\n};\nconst legalStartingCharacters = [\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \" => parseInt(value, 10) * weights[idx]) // multiply each digit with their respective weights\n        .reduce((prev: number, digit: string): number => prev + digit.charCodeAt(0));\n];\nconst tryGetChecksum = (idDigits: string) => {\n    // checksum tables\n    const ST = [\"J\", \"Z\", \"I\",, idDigit: \"A\", \"D\", \"K\", \"S\", \"T\", \"G\", \"P\", \"O\", \"L\", \"H\", \"R\", \"F\", \"V\", \"Y\"];\n    const FG = [\"X\"): => {\n        let weights = [2, 7, 6, 5, 4, 3, 2]; // read: http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n        retur => prev + idDigit);\n};\nconst tryGetChecksum = (idDigits: string) => {\n    // checksum tables\n    const ST = [\"J\", \"Z\", \"I\",, idDigit: \"A\", \"D\", \"K\", \"S\", \"T\", \"G\", \"P\", \"O\",): => {\n        let weights = [2, 7, 6, 5, 4, 3, 2]; // read: http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n        re => {\n    // checksum tables\n    const ST = [\"J\", \"Z\", \"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"B\", \"A\"];\n    const FG = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"M\", \"L\", \"K\"];\n    const M = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"J\", \"L\", \"K\"];\n    const id = idDigits.split(\"\");\n    let [startChar, ...idArray] = id;\n    const endChar = idArray.length === 8 ? idArray.pop()!.toUpperCase() : \"\";\n    //add offset by century prefix if required\n    const weight = (offsetMap.get(startChar.toUpperCase()) || 0) + getWeights(idArray);\n    const remainder = weight % 11;\n    startChar = startChar.toUpperCase();\n    if (startChar === \"S\" || startChar === \"T\") {\n        return { checksum: ST[remainder], valid: ST[remainder] === endChar };\n    }\n    else if (startChar === \"F\" || startChar === \"G\") {\n        return { checksum: FG[remainder], valid: FG[remainder] === endChar };\n    }\n    else if (startChar === \"M\") {\n        return { checksum: M[remainder], valid: M[remainder] === endChar };\n    }\n    else {\n        return { checksum: undefined, valid: false };\n    }\n};\n","score":356,"fallbacked":false,"num_type_errors":72},{"code":"//why? look @ http://www.ngiam.net/NRIC/NRIC_numbers.pdf deeper.\nconst offsetMap = new Map([\n    [\"T\", 4],\n    [\"G\", 4],\n    [\"M\", 3],\n]);\n/**\n *\n * @param idToCheck {string} identification number to check\n * @returns {boolean} validation results\n */\nexport const validate = (idToCheck: string) => {\n    if (idToCheck.length!== 9) {\n        throw new Error(\"Invalid NRIC\");\n    }\n    const { valid, checksum } = tryGetChecksum(idToCheck); // sum them up\n    return valid): boolean => {\n        return valid && checksum;\n    };\n};\n/**\n *\n * @param idToCheck {string} identification number to check\n * @returns {boolean} validation results\n */\nexport const isNRIC = (i => {\n    //short circuit evaulation\n    if (idToCheck.length !== 9) {\n        return false;\n    }\n    const { valid } = tryGetChecksum(idToCheck); // sum them up\n    return valid;\n};\nexport const generate = (partialSeedId?: string) => {\n    if (partialSeedId) {\n        const offset = offsetMap.get(partialSeedId.charAt(0).toUpperCase()) || 0;\n        if (offset > 8) {\n            throw new Error(\"Invali): offset must be 0-8\");\n        }\n        return generate(partialSeedId.substring(offset, 9));\n    }\n    const digits = Math.floor(Math.random() * 90000) + => {\n    const legalStartingCharacters = [\"S\", \"T\", \"F\", \"G\", \"M\"];\n    if (partialSeedId) {\n        const hasLegalStartingCharacter = legalStartingCharacters.some((legalStartingCharacter: string) => partialSeedId.charAt(0).toUpperCase().startsWith(legalStartingCharacter));\n        if (!hasLegalStartingCharacter) {\n            throw new Error(\"Invalid start character\");\n        }\n        else {\n            const containsNumbersOnlyAfterFirst): boolean =!isNaN(Number(partialSeedId.substring(1, partialSeedId.length)));\n            if (!containsNumbersOnlyAfterFirst) {\n                throw new Error(\"Invalid seed id\");\n            }\n        }\n    }\n    const startCha => partialSeedId.charAt(0).toUpperCase().startsWith(legalStartingCharacter));\n        if (!hasLegalStartingCharacter) {\n            throw new Error(\"Invalid start character\");\n        }\n        else {\n            const containsNumbersOnlyAfterFirst = !isNaN(Number(partialSeedId.substring(1, partialSeedId.length)));\n            if (!containsNumbersOnlyAfterFirst) {\n                throw new Error(\"Invalid seed id\");\n            }\n        }\n    }\n    const startChar = (partialSeedId && partialSeedId.charAt(0)) || legalStartingCharacters[Math.floor(Math.random() * 4)];\n    let generatedId = (partialSeedId && partialSeedId.substring(1, partialSeedId.length).split(\"\")) || [];\n    while (generatedId.length !== 7) {\n        generatedId.push(Math.floor(Math.random() * 10) + \"\");\n    }\n    const { checksum } = tryGetChecksum(startChar + generatedId.join(\"\"));\n    return `${startChar}${generatedId.join(\"\")}${checksum}`.toUpperCase();\n};\n/**\n *\n * @param idDigits {string[]} identification number to check\n * @returns weight\n */\nconst getWeights = (idDigits: string[]): number[] => {\n    if (!Array.isArray(idDigits)) {\n        throw new Error(\"Parameter idDigits is not an array\");\n    }\n    let weights = [2, 7, 6, 5,): number[];\n    return idDigits\n       .map((value, idx) => parseInt(value, 10)) // convert each digit to number\n       .reduce((prev, idDigit) => prev + idDigit * weights[idx]); // ad => {\n    let weights = [2, 7, 6, 5, 4, 3, 2]; // read: http://www.ngiam.net/NRIC/NRIC_numbers.pdf\n    return idDigits\n        .map((value: string, idx: number) => {\n            let weight = 0;\n            if (idx < 3) {\n                weight = weights[idx];\n            }\n            else if (idx === 3) {\n                weight = (idDigit, idx: number) => idDigit.substr(0, 3) === \"W\"\n                  ? idDigit.substr(3, 1) === \"9\"\n                      ? 1\n                        : 3\n                    : idDigit === \"X\"): 3;\n            }\n            else if (idx === 4) {\n                weight = (idDigit, idx: number) => idDigit.substr(0, 3) === \"W\"\n                 ? idDigit.substr(3, => parseInt(value, 10) * weights[idx]) // multiply each digit with their respective weights\n        .reduce((prev: number, idDigit: string) => prev + idDigit * weights[idx + 1]): 1;\n            }\n            else if (idx === 5) {\n                weight = (idDigit, idx: number) => idDigit, idDigit: => idDigit === \"X\"? 1 : 3;\n            }\n            else if (idx === 6) {\n                weight = (idDigit, idx: number) => idDigit === \"X\"? 1 : 7;): 7;\n            }\n            else if (idx === 7) {\n                weight = 5;\n            }\n            else if (idx === 8) {\n                weight = (idDigit, idx: number) => idDigit === \"X\" => prev + idDigit);\n};\nconst tryGetChecksum = (idDigits: string): boolean => {\n    let checksum = 0;\n    let weights = [1, 3, 7, 9, 2, 4, 6, 8];\n    let id = idDigits.split(\"\").revers): string;\n    if (id.length!== 17) {\n        return false;\n    }\n    for (let idx = 0; idx < 16; idx++) {\n        checksum += id.charAt(idx) === \" => {\n    // checksum tables\n    const ST = [\"J\", \"Z\", \"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"B\", \"A\"];\n    const FG = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"M\", \"L\", \"K\"];\n    const M = [\"X\", \"W\", \"U\", \"T\", \"R\", \"Q\", \"P\", \"N\", \"J\", \"L\", \"K\"];\n    const id = idDigits.split(\"\");\n    let [startChar, ...idArray] = id;\n    const endChar = idArray.length === 8 ? idArray.pop()!.toUpperCase() : \"\";\n    //add offset by century prefix if required\n    const weight = (offsetMap.get(startChar.toUpperCase()) || 0) + getWeights(idArray);\n    const remainder = weight % 11;\n    startChar = startChar.toUpperCase();\n    if (startChar === \"S\" || startChar === \"T\") {\n        return { checksum: ST[remainder], valid: ST[remainder] === endChar };\n    }\n    else if (startChar === \"F\" || startChar === \"G\") {\n        return { checksum: FG[remainder], valid: FG[remainder] === endChar };\n    }\n    else if (startChar === \"M\") {\n        return { checksum: M[remainder], valid: M[remainder] === endChar };\n    }\n    else {\n        return { checksum: undefined, valid: false };\n    }\n};\n","score":372,"fallbacked":false,"num_type_errors":83}]}
{"dataset_elem":{"alphanum_fraction":0.5421777694,"avg_line_length":27.8894736842,"content":"export type EffectOptions = {\n    scheduler?: (fn: Function) => void;\n    lazy?: boolean;\n};\nexport type EffectFunction<T> = {\n    (): T;\n    deps: Set<Function>[];\n    options?: EffectOptions;\n};\nexport type TriggerType = \"ADD\" | \"SET\" | \"DELETE\";\nexport type TriggrtFunction = (\n    target: Record<string, any>,\n    key: PropertyKey,\n    ITERATE_KEY?: symbol,\n    MAP_KEY_ITERATE_KEY?: symbol,\n    type?: TriggerType,\n    newVal?: any\n) => void;\n\nlet activeEffect: undefined | EffectFunction<any>;\nconst bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();\nconst effectStack: EffectFunction<any>[] = [];\n\nexport function effect<T>(fn: () => T, options?: EffectOptions) {\n    const effectFn: EffectFunction<T> = () => {\n        // 清除之前的effect\n        cleanup(effectFn);\n        activeEffect = effectFn;\n        // 压入栈中\n        effectStack.push(effectFn);\n        const res = fn();\n        effectStack.pop();\n        activeEffect = effectStack[effectStack.length - 1];\n        return res;\n    };\n    effectFn.deps = [] as Set<Function>[];\n    effectFn.options = options;\n    if (!options?.lazy) {\n        effectFn();\n    }\n    return effectFn;\n}\n\n/**\n * 清除之前的绑定，用于刷新绑定effect\n * 可解决分支切换问题、比如三元\n * @param effectFn\n */\nfunction cleanup<T>(effectFn: EffectFunction<T>) {\n    for (let index = 0; index < effectFn.deps.length; index++) {\n        const deps = effectFn.deps[index];\n        deps.delete(effectFn);\n    }\n    effectFn.deps.length = 0;\n}\n\nexport function track(target: Record<string, any>, key: PropertyKey) {\n    if (!activeEffect) return;\n    // data or props\n    let depsMap = bucket.get(target);\n    if (!depsMap) {\n        bucket.set(target, (depsMap = new Map()));\n    }\n    // 属性值对应的set，set里可能存在多个effect函数\n    let deps: Set<EffectFunction<any>> | undefined = depsMap.get(key);\n    if (!deps) {\n        depsMap.set(key, (deps = new Set()));\n    }\n    // 属性对应的effect函数、effect可能存在多个、同个则覆盖\n    deps.add(activeEffect);\n    // 将当前effect添加依赖的effect\n    activeEffect.deps.push(deps);\n}\n\nexport function trigger(\n    target: Record<string, any>,\n    key: PropertyKey,\n    ITERATE_KEY?: symbol,\n    MAP_KEY_ITERATE_KEY?: symbol,\n    type?: TriggerType,\n    newVal?: any\n) {\n    const depsMap = bucket.get(target);\n    if (!depsMap) return;\n    // 获取对应值的所有 effects\n    const effects: Set<EffectFunction<any>> | undefined = depsMap.get(key);\n\n    // 取得与ITERATE_KEY关联的副作用函数\n    let iterateEffects: Set<EffectFunction<any>> | undefined;\n    if (ITERATE_KEY) {\n        iterateEffects = depsMap.get(ITERATE_KEY);\n    }\n\n    let mapKeyIterateEffects: Set<EffectFunction<any>> | undefined;\n    if (MAP_KEY_ITERATE_KEY) {\n        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);\n    }\n\n    // 分支--防止无限循环\n    const effectsToRun = new Set<EffectFunction<any>>();\n\n    effects &&\n        effects.forEach(effectFn => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n\n    // set\n    if (\n        target instanceof Set &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")\n    ) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach(effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n\n    // map\n    if (\n        target instanceof Map &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")\n    ) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach(effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n\n    if (\n        target instanceof Map &&\n        (type === \"ADD\" || type === \"DELETE\")\n    ) {\n        MAP_KEY_ITERATE_KEY &&\n            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&\n            mapKeyIterateEffects.forEach(effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n\n    // array\n    if (type === \"ADD\" && Array.isArray(target)) {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach(effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (Array.isArray(target) && key === \"length\") {\n        depsMap.forEach((effects, key) => {\n            if ((key as number) >= (newVal as number)) {\n                effects.forEach(effectFn => {\n                    if (activeEffect !== effectFn) {\n                        effectsToRun.add(effectFn);\n                    }\n                });\n            }\n        });\n    }\n\n    // object\n    (type === \"ADD\" || type === \"DELETE\") &&\n        iterateEffects &&\n        iterateEffects.forEach(effectFn => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n\n    effectsToRun.forEach(effectFn => {\n        // 调度器执行\n        if (effectFn?.options?.scheduler) {\n            effectFn?.options.scheduler(effectFn);\n        } else {\n            effectFn();\n        }\n    });\n}\n","content_without_annotations":"export type EffectOptions = {\n    scheduler?;\n    lazy?;\n};\nexport type EffectFunction<T> = {\n    ();\n    deps;\n    options?;\n};\nexport type TriggerType = \"ADD\" | \"SET\" | \"DELETE\";\nexport type TriggrtFunction = (\n    target,\n    key,\n    ITERATE_KEY?,\n    MAP_KEY_ITERATE_KEY?,\n    type?,\n    newVal?\n) => void;\n\nlet activeEffect;\nconst bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();\nconst effectStack = [];\n\nexport function effect<T>(fn, options?) {\n    const effectFn = () => {\n        // 清除之前的effect\n        cleanup(effectFn);\n        activeEffect = effectFn;\n        // 压入栈中\n        effectStack.push(effectFn);\n        const res = fn();\n        effectStack.pop();\n        activeEffect = effectStack[effectStack.length - 1];\n        return res;\n    };\n    effectFn.deps = [] as Set<Function>[];\n    effectFn.options = options;\n    if (!options?.lazy) {\n        effectFn();\n    }\n    return effectFn;\n}\n\n/**\n * 清除之前的绑定，用于刷新绑定effect\n * 可解决分支切换问题、比如三元\n * @param effectFn\n */\nfunction cleanup<T>(effectFn) {\n    for (let index = 0; index < effectFn.deps.length; index++) {\n        const deps = effectFn.deps[index];\n        deps.delete(effectFn);\n    }\n    effectFn.deps.length = 0;\n}\n\nexport function track(target, key) {\n    if (!activeEffect) return;\n    // data or props\n    let depsMap = bucket.get(target);\n    if (!depsMap) {\n        bucket.set(target, (depsMap = new Map()));\n    }\n    // 属性值对应的set，set里可能存在多个effect函数\n    let deps = depsMap.get(key);\n    if (!deps) {\n        depsMap.set(key, (deps = new Set()));\n    }\n    // 属性对应的effect函数、effect可能存在多个、同个则覆盖\n    deps.add(activeEffect);\n    // 将当前effect添加依赖的effect\n    activeEffect.deps.push(deps);\n}\n\nexport function trigger(\n    target,\n    key,\n    ITERATE_KEY?,\n    MAP_KEY_ITERATE_KEY?,\n    type?,\n    newVal?\n) {\n    const depsMap = bucket.get(target);\n    if (!depsMap) return;\n    // 获取对应值的所有 effects\n    const effects = depsMap.get(key);\n\n    // 取得与ITERATE_KEY关联的副作用函数\n    let iterateEffects;\n    if (ITERATE_KEY) {\n        iterateEffects = depsMap.get(ITERATE_KEY);\n    }\n\n    let mapKeyIterateEffects;\n    if (MAP_KEY_ITERATE_KEY) {\n        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);\n    }\n\n    // 分支--防止无限循环\n    const effectsToRun = new Set<EffectFunction<any>>();\n\n    effects &&\n        effects.forEach(effectFn => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n\n    // set\n    if (\n        target instanceof Set &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")\n    ) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach(effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n\n    // map\n    if (\n        target instanceof Map &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")\n    ) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach(effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n\n    if (\n        target instanceof Map &&\n        (type === \"ADD\" || type === \"DELETE\")\n    ) {\n        MAP_KEY_ITERATE_KEY &&\n            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&\n            mapKeyIterateEffects.forEach(effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n\n    // array\n    if (type === \"ADD\" && Array.isArray(target)) {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach(effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (Array.isArray(target) && key === \"length\") {\n        depsMap.forEach((effects, key) => {\n            if ((key as number) >= (newVal as number)) {\n                effects.forEach(effectFn => {\n                    if (activeEffect !== effectFn) {\n                        effectsToRun.add(effectFn);\n                    }\n                });\n            }\n        });\n    }\n\n    // object\n    (type === \"ADD\" || type === \"DELETE\") &&\n        iterateEffects &&\n        iterateEffects.forEach(effectFn => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n\n    effectsToRun.forEach(effectFn => {\n        // 调度器执行\n        if (effectFn?.options?.scheduler) {\n            effectFn?.options.scheduler(effectFn);\n        } else {\n            effectFn();\n        }\n    });\n}\n","dynamism_density":0.0042342978,"dynamism_heuristic":6,"estimated_tokens":1417,"ext":"ts","fun_ann_density":0.0247000706,"function_parameters":21,"function_signatures":0,"function_usages":2,"functions":14,"hexsha":"be6ce21d863494461463ab50a0cb4150d8233268","lang":"TypeScript","loc":155,"loc_per_function":11.3571428571,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"4c252a3ac55d3ac28d5101b5d0bec4ffe233dfbb","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"KesionX/mini-vue","max_forks_repo_path":"src/reactivity/effect.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"4c252a3ac55d3ac28d5101b5d0bec4ffe233dfbb","max_issues_repo_issues_event_max_datetime":"2022-03-22T02:23:56.000Z","max_issues_repo_issues_event_min_datetime":"2022-03-21T17:21:51.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"KesionX/mini-vue","max_issues_repo_path":"src/reactivity/effect.ts","max_line_length":78,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"4c252a3ac55d3ac28d5101b5d0bec4ffe233dfbb","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"KesionX/ue3","max_stars_repo_path":"src/reactivity/effect.ts","max_stars_repo_stars_event_max_datetime":"2022-03-09T14:36:03.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-09T14:36:03.000Z","metric":0.2615786579,"predefined_density":0.2222222222,"predefined_types":12,"prop_ann_density":0.0028228652,"property_declarations":4,"size":5299,"trivial_density":0.3148148148,"trivial_types":17,"type_definitions":4,"typedef_density":0.0028228652,"var_ann_density":0.0105857445,"variable_declarations":15},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export type EffectOptions = {\n    scheduler?: Scheduler;\n    lazy?: boolean;\n};\nexport const isEffect = (fn: Function) => typeof fn === \"function\" && fn[Symbol.toStringTag] === \"EffectFunction\";\nexport const isEffectFunction = (fn: Functio;\n    lazy?: boolean) => isEffect(fn) && (fn.lazy === undefined || fn.lazy === lazy);\nexport interface EffectFunction<T> extends Function {\n    deps: Set<Function>;\n    options?;\n}\nexport function effec;\n};\nexport type EffectFunction<T> = {\n    ();\n    deps: Set<Function>;\n    options?;\n};\nexport interface EffectOptions {\n    scheduler?: Scheduler;\n    lazy?: boolean;\n};\nexport interface EffectInstance<T> {\n    deps: Set<Function>;\n    options?;\n    ru;\n    options?: EffectOptions;\n    init?(self: T): void;\n    onCleanup?(self: T): void;\n    update?(self: T, newVal: T): void;\n    cleanup?(self: T): void;\n    updateState?(self;\n};\nexport type TriggerType = \"ADD\" | \"SET\" | \"DELETE\";\nexport type TriggrtFunction = (target: any, key: PropertyKey, ITERATE_KEY?: PropertyKey, type?: \"ADD\" | \"SET\" | \"DELETE\" | undefined, newVal?: any) => void;\nexport function trigger(target: any, key, key: PropertyKey, ITERATE_KEY?: PropertyKey, type?: TriggerType, newVal?: any) {\n    const effectFn = (effect: EffectFunction<any>) => {\n        const deps = effect.deps;\n        let result: an, ITERATE_KEY?: any, run: Function, effectInstance: EffectInstance<any>;\n        if (deps.size) {\n            const newDeps = new Set(deps);\n            for (let key of deps) {\n                const depEffectFn = effectFn, MAP_KEY_ITERATE_KEY?: any;\n                if (isEffectFunction(depEffectFn)) {\n                    if (type === \"ADD\") {\n                        newDeps.add(depEffectFn);\n                    } else {\n                        if (ITERATE_KEY === key) {, type?: \"DELETE\"}\n                        else {\n                            newDeps.delete(depEffectFn);\n                        }\n                    }\n                } else {\n                    if (ITERATE_KEY === key) {, type?: \"DELETE\"}\n                    else {\n                        newDeps.delete, newVal?: any;\n                    }\n                }\n            }\n            deps.clear();\n            deps = newDeps;\n        }\n        if (!effectFn.options) {\n            effectFn.options = {};\n        }\n        if (!effectFn.options.lazy)) => void;\nlet activeEffect;\nconst bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();\nconst effectStack = [];\nexport function effect<T>(fn: EffectFunction<T>, deps?: Set<Function>) {\n    if (!effectStack.length) {\n        flushSync();\n    }\n    if (!deps) {\n        deps = new Set();\n    }\n    if (!effectFn.deps), options?: {lazy: true} {\n        deps.add(effectFn);\n    }\n    const entry = {\n        fn,\n        deps,\n        effect: effectFn,\n        type: \"ADD\",\n    };\n    const existingEffect = bucket.get): EffectFunction<any> => {\n        const existingEffect = bucket.get(effectFn);\n        if (existingEffect) {\n            deps.add(existingEffect);\n        }\n        return existingEffect;\n    };\n    if (!existingEffect) {\n    const effectFn = (): EffectFunction<any> => fn();\n    effectFn.deps = deps;\n    effectFn.options = {lazy: true};\n    effectFn.effect = effectFn;\n    bucket.set(effectFn, entry);\n    flushSync() => {\n        // 清除之前的effect\n        cleanup(effectFn);\n        activeEffect = effectFn;\n        // 压入栈中\n        effectStack.push(effectFn);\n        const res = fn();\n        effectStack.pop();\n        activeEffect = effectStack[effectStack.length - 1];\n        return res;\n    };\n    effectFn.deps = [] as Set<Function>[];\n    effectFn.options = options;\n    if (!options?.lazy) {\n        effectFn();\n    }\n    return effectFn;\n}\n/**\n * 清除之前的绑定，用于刷新绑定effect\n * 可解决分支切换问题、比如三元\n * @param effectFn\n */\nfunction cleanup<T>(effectFn: EffectFunction<any>) {\n    if (!effectStack.length) {\n        flushSync();\n    }\n    const index = effectStack.indexOf(effectFn);\n    if (index < 0) {\n        throw new Error(`[vue@$): effect ${effectFn.toString()} is not bound`);\n    }\n    // 移除绑定\n    depsMap.delete(key);\n    // 清除effectFn\n    cleanup(effectFn);\n}\n/**\n * 同步flush，用 {\n    for (let index = 0; index < effectFn.deps.length; index++) {\n        const deps = effectFn.deps[index];\n        deps.delete(effectFn);\n    }\n    effectFn.deps.length = 0;\n}\nexport function track(target: any, key: string): void {\n    if (isRef(target)) {\n        target.value = target;\n        return;\n    }\n    // 将属性值对应的set，set里可能存在多个effect函数\n    let depsMap = targe, key: string | Function;\n    if (!isRef(depsMap)) {\n        depsMap = new Map();\n        bucket.set(target, depsMap);\n    }\n    // 获取到set里的key\n    const deps = depsMap.get): void => {\n        depsMap.set(key, deps);\n    }\n    deps.add(target);\n}\nexport function activeEffect(target, key: string | Function) {\n    // data or props\n    let depsMap = bucke {\n    if (!activeEffect)\n        return;\n    // data or props\n    let depsMap = bucket.get(target);\n    if (!depsMap) {\n        bucket.set(target, (depsMap = new Map()));\n    }\n    // 属性值对应的set，set里可能存在多个effect函数\n    let deps = depsMap.get(key);\n    if (!deps) {\n        depsMap.set(key, (deps = new Set()));\n    }\n    // 属性对应的effect函数、effect可能存在多个、同个则覆盖\n    deps.add(activeEffect);\n    // 将当前effect添加依赖的effect\n    activeEffect.deps.push(deps);\n}\nexport function trigger(target: any, key: string | Function, newValue: any, oldValue: any) {\n    let depsMap = bucket.get(target);\n    if (!depsMap)\n        return;\n    let deps = depsMap.get(key);\n    i, key: string | Function, newValue: any, oldValue: any;\n    if (!deps)\n        return;\n    for (let i = 0; i < deps.length; i++) {\n        const dep = deps[i];\n        dep();, ITERATE_KEY?: any\n    }\n}\n\nexport function effect<T = any>(key: string | Function, effect: EffectFunction<T>): void {\n    // effect -> effect -> effect -> effect\n    if (typeof key === \"function\"), MAP_KEY_ITERATE_KEY?: any {\n        // effect -> effect\n        effect();\n    }\n    else {\n        const depsMap = bucket.get(key);\n        if (!depsMap) {\n            bucket.set(key, (depsMap = new Map()));\n        }, type?: any;\n        if (type) {\n            depsMap.set(type, (deps = new Set()));\n        }\n        else {\n            depsMap.set(key, (deps = new Set()));\n        }\n        deps.add(effect), newVal?: any\n    }\n}\n\nexport function watchEffect(key: string | Function, effect: WatchEffectFunction<any>, options?: WatchEffectOptions): WatchEffect {\n    const depsMap = bucket.get(key);\n    if (!dep): {\n        bucket.set(key, (depsMap = new Map()));\n    }\n    let deps = depsMap.get(effect);\n    if (!deps) {\n        depsMap.set(effect, (deps = new Set())); {\n    const depsMap = bucket.get(target);\n    if (!depsMap)\n        return;\n    // 获取对应值的所有 effects\n    const effects = depsMap.get(key);\n    // 取得与ITERATE_KEY关联的副作用函数\n    let iterateEffects;\n    if (ITERATE_KEY) {\n        iterateEffects = depsMap.get(ITERATE_KEY);\n    }\n    let mapKeyIterateEffects;\n    if (MAP_KEY_ITERATE_KEY) {\n        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);\n    }\n    // 分支--防止无限循环\n    const effectsToRun = new Set<EffectFunction<any>>();\n    effects &&\n        effects.forEach((effectFn: EffectFunction<any>) => {\n            if (effectsToRun.has(effectFn))\n                return;\n            effectsToRun.add(effectFn);\n            effectFn();\n        });\n    if (iterateEffects)\n        iterateEffects.forEach(): any;\n    if (mapKeyIterateEffects)\n        mapKeyIterateEffects.forEach((effectFn: WatchEffectFunction<any>) => {\n            if (activeEffect!== effectFn) {\n                effectsToRun.add(effectFn); => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n    // set\n    if (target instanceof Set &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach((effectFn: EffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    // map\n    if (target instanceof Map &&\n        (type === \"SET\" || typ): any {\n        MAP_KEY_ITERATE_KEY &&\n            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&\n            mapKeyIterateEffects.forEach((effectFn: WatchEffectFunction<an => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // map\n    if (target instanceof Map &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach((effectFn: EffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // array\n    if (Array.isArray(target) && type === \"AD): any {\n        ARRAY_ITERATE_KEY &&\n            (arrayIterateEffects = depsMap.get(ARRAY_ITERATE_KEY)) &&\n            arrayIterateEffects.forEach((effectFn: WatchEffectFunction<any>) => {\n                if => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (target instanceof Map &&\n        (type === \"ADD\" || type === \"DELETE\")) {\n        MAP_KEY_ITERATE_KEY &&\n            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&\n            mapKeyIterateEffects.forEach((effectFn: WatchEffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // array\n    if (Array.isArray(target) && type ===): any {\n        ARRAY_ITERATE_KEY &&\n            (arrayIterateEffects = depsMap.get(ARRAY_ITERATE_KEY)) &&\n            arrayIterateEffects.forEach((effectFn: WatchEffectFunction<any>) => {\n                if => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // array\n    if (type === \"ADD\" && Array.isArray(target)) {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach((effectFn: WatchEffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // array\n    if (type === \"DELETE\" && Array.isArray): any {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach((effectFn: WatchEffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (Array.isArray(target) && key === \"length\") {\n        depsMap.forEach((effects: WatchEffectFunctionMap) => {\n            if (effects.has(ARRAY_ITERATE_KEY)) {\n                effectsToRun.add(effects.get(ARRAY_ITERATE_KEY));\n            }\n        });\n    }\n    // object, key: string\n    if (type === \"ADD\" || type === \"DELETE\" || type === \"UPDATE\") {\n        // object\n        if (typeof key === \"object\") {\n            const objectEffects = depsMap.get(key);\n            objectEffect): WatchEffectFunction<any> {\n                return effectFn;\n            }\n        }\n        // key\n        const objectEffects = depsMap.get(key);\n        objectEffects &&\n            objectEffects.forEach((effectFn: WatchEffectFunction<any> => {\n            if ((key as number) >= (newVal as number)) {\n                effects.forEach((effectFn: WatchEffectFunction<any>) => {\n                    if (activeEffect!== effectFn) {\n                        effectsToRun.add(effectFn);\n                    }\n                });\n            } else {\n                effectsToRun.add(effectFn);\n            }\n        }))): any;\n    }\n    }\n    if (type === \"ADD\" || type === \"DELETE\") {\n        // key\n        depsMap.forEach((effects: WatchEffectFunctionMap) => {\n            if (effects.has(key)) { => {\n                    if (activeEffect !== effectFn) {\n                        effectsToRun.add(effectFn);\n                    }\n                });\n            }\n        });\n    }\n    // object\n    (type === \"ADD\" || type === \"DELETE\") &&\n        iterateEffects &&\n        iterateEffects.forEach((effectFn: WatchEffectFunction<any>): void => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n    effectsToRun.forEach((effectFn: WatchEffectFunction<any>) => {\n        if (effectFn?.options?.scheduler) {\n            effectFn?.options.scheduler(effectFn);\n        }\n        else {\n            effectFn();\n        }\n    });\n    return effectsToRun;): any;\n}\n\nexport function callWatchEffect(effectFn: WatchEffectFunction<any>, value: any): void {\n    // 处理依赖\n    const depsMap: WatchEffectFunctionMap = {};\n    if (effectFn => {\n        // 调度器执行\n        if (effectFn?.options?.scheduler) {\n            effectFn?.options.scheduler(effectFn);\n        }\n        else {\n            effectFn();\n        }\n    });\n}\n","score":266,"fallbacked":false,"num_type_errors":70},{"code":"export type EffectOptions = {\n    scheduler?: Scheduler<any>;\n    sync?: boolean;\n    lazy?: boolean;\n};\nexport type Effect<T> = (target: any, key: PropertyKey, ITERATE_KEY?, MAP_KEY_ITERATE_KEY?, typ;\n    lazy?: boolean;\n    scheduler?: Scheduler<any>;\n    sync?: boolean;\n) => T;\nexport type EffectArgs = [any, any, EffectOptions];\nexport type EffectFunction = (target: any, key: PropertyKey,;\n};\nexport type EffectFunction<T> = {\n    ();\n    deps: Effect<any>;\n};\nexport type EffectType = \"FUNCTION\" | \"SET\" | \"MAP\" | \"CALL\";\nexport type EffectWithType<T> = EffectFunction<T>;\nexport type EffectTypeOrEffectFunction;\n    options?: EffectOptions;\nexport type EffectTypeOrEffectFunctionOrEffectTypeOrEffectOptions = EffectType | EffectTypeOrEffectFunction | EffectOptions;\nexport type EffectTypeOrEffectFunctionOrEffectTypeOrEffectOptionsOrEffectType = EffectTyp;\n};\nexport type TriggerType = \"ADD\" | \"SET\" | \"DELETE\";\nexport type TriggrtFunction = (target: any, key: PropertyKey, ITERATE_KEY?, MAP_KEY_ITERATE_KEY?, type?, newVal?) => void;\nexport type TriggerOptions = {\n    type?: TriggerType;\n    scheduler?: Scheduler<any>;, key: PropertyKey, ITERATE_KEY?, MAP_KEY_ITERATE_KEY?, type?, newVal?, scheduler?: Scheduler<any>;\n    sync?: boolean;\n    lazy?: boolean;\n};\nexport type TriggrtFunctionArgs, ITERATE_KEY?: any;\nexport type TriggrtFunctionFunction = (target: any, key: PropertyKey, ITERATE_KEY?, MAP_KEY_ITERATE_KEY?, type?, newVal?) => void;\nexport type Trigg, MAP_KEY_ITERATE_KEY?: any;\nexport type TriggrtFunctionOptions = {\n    scheduler?: Scheduler<any>;\n    key?: PropertyKey, ITERATE_KEY?, MAP_KEY_ITERATE_KEY?, type?, newVal?, scheduler?: Scheduler<an, type?: TriggerType>;\n    lazy?: boolean;\n    sync?: boolean;\n};\nexport type TriggrtFunctionOptionsOrTriggrtFunctionOptions = TriggrtFunctionOptions | TriggrtFunctionFunction | Triggr, newVal?: any;\nexport type TriggrtFunctionOptionsOrTriggrtFunctionOptionsOrTriggrtFunctionOptionsOrTriggrtFunction = TriggrtFunctionOptions | TriggrtFunctionFunction | Triggr) => void;\nlet activeEffect;\nconst bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();\nconst effectStack = [];\nexport function effect<T>(fn: EffectFunction<any>, options?: EffectOptions) {\n    return effectFn(fn, options);\n}\nexport function effect<T>(fn: EffectFunction<any>, options?: EffectOptions): EffectFunction<any> {\n    if (, options?: EffectOptions) {\n        let key: PropertyKey;\n        if (options) {\n            key = options.key || options.ITERATE_KEY || options.MAP_KEY_ITERATE_KEY;\n            const map = bucket.get): EffectFunction<any> | EffectFunction<any>[] => {\n                if (!map) {\n                    map = new Map();\n                    bucket.set(this, map);\n                }\n                if (!map.has(key)) {\n                    const effec {\n    const effectFn = (): EffectFunction<any> | EffectFunction<any>[] => EffectFunction<any>;\n    effectFn.deps = new Set<EffectFunction<any>>();\n    effectFn.scheduler = options.scheduler;\n    effectFn.key = key => {\n        // 清除之前的effect\n        cleanup(effectFn);\n        activeEffect = effectFn;\n        // 压入栈中\n        effectStack.push(effectFn);\n        const res = fn();\n        effectStack.pop();\n        activeEffect = effectStack[effectStack.length - 1];\n        return res;\n    };\n    effectFn.deps = [] as Set<Function>[];\n    effectFn.options = options;\n    if (!options?.lazy) {\n        effectFn();\n    }\n    return effectFn;\n}\n/**\n * 清除之前的绑定，用于刷新绑定effect\n * 可解决分支切换问题、比如三元\n * @param effectFn\n */\nfunction cleanup<T>(effectFn: EffectFunction<any> | EffectFunction<any>[]): void {\n    if (!effectFn.deps.length) {\n        cleanup(effectFn);\n    }\n}\nfunction effectFn<T>(fn: EffectFunction<any>, option): EffectFunction<any> {\n    let effectFn = (this as any).effectFn;\n    if (!effectFn) {\n        effectFn = effectFn.bind(this);\n    }\n    effectFn.deps.push(fn); {\n    for (let index = 0; index < effectFn.deps.length; index++) {\n        const deps = effectFn.deps[index];\n        deps.delete(effectFn);\n    }\n    effectFn.deps.length = 0;\n}\nexport function track(target: any, key: string, ITERATE_KEY?: string, MAP_KEY?: string): EffectFunction<any> {\n    let map = target[MAP_KEY];\n    if (map) {\n        map = map.get(ke, key: any);\n    } else {\n        map = new WeakMap();\n        target[MAP_KEY] = map;\n    }\n    let { value } = map.get(key);\n    if (!value) {\n        value = new Set();\n        ma): any {\n            value.add(effectFn);\n        }\n        map.set(key, { value });\n    }\n    if (ITERATE_KEY) {\n        value = value.get(ITERATE_KEY);\n        if (!value {\n    if (!activeEffect)\n        return;\n    // data or props\n    let depsMap = bucket.get(target);\n    if (!depsMap) {\n        bucket.set(target, (depsMap = new Map()));\n    }\n    // 属性值对应的set，set里可能存在多个effect函数\n    let deps = depsMap.get(key);\n    if (!deps) {\n        depsMap.set(key, (deps = new Set()));\n    }\n    // 属性对应的effect函数、effect可能存在多个、同个则覆盖\n    deps.add(activeEffect);\n    // 将当前effect添加依赖的effect\n    activeEffect.deps.push(deps);\n}\nexport function trigger(target: any, key: string, ITERATE_KEY?: string, MAP_KEY?: string): void {\n    const depsMap = bucket.get(target);\n    if (!depsMap)\n        return;\n    const effects = depsMap.ge, key: any = ITERATE_KEY || MAP_KEY || '';\n    if (!effects)\n        return;\n    const effectsToRun = new Set<Effected>();\n    for (let i = 0; i < effects.size; i++, ITERATE_KEY?: any, MAP_KEY?: any) {\n        const deps = effects.get(i);\n        if (!deps)\n            continue;\n        for (let j = 0; j < deps.length; j++) {\n            const dep = dep, MAP_KEY_ITERATE_KEY?: any;\n            if (!activeEffect)\n                continue;\n            if (key === dep.key) {\n                effectsToRun.add(activeEffect);\n                activeEffect.deps.push(deps);\n                activeEffect = undefined;\n            } els, type?: any;\n            if (type === EffectType.Set && typeof dep.data === 'object') {\n                if (key === ITERATE_KEY) {\n                    // 迭代key，遍历effect\n                    const val = dep.dat, newVal?: any;\n                    if (newVal === dep.data)\n                        continue;\n                }\n                else if (key === MAP_KEY) {\n                    // map key，遍历effect\n                    const val = dep.data, newVal?: any;\n                    if (newVa): any {\n                        effectsToRun.add(activeEffect);\n                        activeEffect.deps.push(deps);\n                        activeEffect = undefined;\n                    }\n                }\n            }\n            else if (type === EffectType.Map && typeof dep.data == {\n    const depsMap = bucket.get(target);\n    if (!depsMap)\n        return;\n    // 获取对应值的所有 effects\n    const effects = depsMap.get(key);\n    // 取得与ITERATE_KEY关联的副作用函数\n    let iterateEffects;\n    if (ITERATE_KEY) {\n        iterateEffects = depsMap.get(ITERATE_KEY);\n    }\n    let mapKeyIterateEffects;\n    if (MAP_KEY_ITERATE_KEY) {\n        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);\n    }\n    // 分支--防止无限循环\n    const effectsToRun = new Set<EffectFunction<any>>();\n    effects &&\n        effects.forEach((effectFn: EffectFunction<any>) => {\n            if (effectsToRun.has(effectFn))\n                return;\n            effectsToRun.add(effectFn);\n            if (iterateEffects) {\n                effectsToRun.add(iterateEffects(effec): any);\n            }\n            if (mapKeyIterateEffects) {\n                effectsToRun.add(mapKeyIterateEffects(effec): any);\n            }\n        });\n    // map\n    if (target instanceof Map &&\n        (type === \"MA => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n    // set\n    if (target instanceof Set &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach((effectFn: EffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // queue\n    if (queue) {\n        effectsToRun.add(queu): any;\n    }\n    // 执行\n    effectsToRun.forEach((effectFn) => {\n        effectFn(target);\n    });\n}\nfunction effect(depsMap: Map<EffectKey, EffectFunction<any>>, effectFn => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // map\n    if (target instanceof Map &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach((effectFn: EffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // queue\n    if (queue) {\n        effectsToRun.add(qu): any;\n    }\n    // 执行\n    effectsToRun.forEach((effectFn) => {\n        effectFn(target);\n    });\n}\n// 1.5.8 版本开始，已废弃\nexport function effec => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (target instanceof Map &&\n        (type === \"ADD\" || type === \"DELETE\")) {\n        MAP_KEY_ITERATE_KEY &&\n            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&\n            mapKeyIterateEffects.forEach((effectFn: EffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // array\n    if (type === \"ADD\" && Array.isArray(targe): {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach((effectFn: EffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // array\n    if (type === \"ADD\" && Array.isArray(target)) {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach((effectFn: EffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (Array.isArray(target)) {\n        const lengthEffects = depsMa): EffectFunction<any>[] | undefined;\n        lengthEffects &&\n            lengthEffects.forEach((effectFn: EffectFunction<any>) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn); => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (Array.isArray(target) && key === \"length\") {\n        depsMap.forEach((effects: EffectFunction<any>[]): EffectFunction<any>[] => {\n            const lengthEffect = depsMap.get(\"length\");\n            if (lengthEffect) {\n                lengthEffect.forEach((effectFn: EffectFunction<any>) => {\n                    i, key: any;\n                    effectsToRun.add(effectFn);\n                });\n            }\n        });\n    }\n    // array\n    if (Array.isArray(target) && key === 0) {\n        depsMap.forEach((effects: EffectFunction): EffectFunction[] => {\n            const lengthEffect = depsMap.get(\"length\");\n            if (lengthEffect) {\n                lengthEffect.forEach((effectFn: EffectFunction) => {\n                    if (activeEffect!== effectFn) {\n                        effec => {\n            if ((key as number) >= (newVal as number)) {\n                effects.forEach((effectFn: EffectFunction) => {\n                    if (activeEffect!== effectFn) {\n                        effectsToRun.add(effectFn);\n                    }\n                });\n            }\n        }\n        });\n    }\n    // array\n    if (Array.isArray(target) &): EffectFunction[] => {\n        const lengthEffect = depsMap.get(\"length\");\n        if (lengthEffect) {\n            lengthEffect.forEach((effectFn: EffectFunction) => {\n                if (activeEffect!== effectFn) {\n                    effec => {\n                    if (activeEffect !== effectFn) {\n                        effectsToRun.add(effectFn);\n                    }\n                });\n            }\n        });\n    }\n    // object\n    (type === \"ADD\" || type === \"DELETE\") &&\n        iterateEffects &&\n        iterateEffects.forEach((effectFn: EffectFunction): EffectFunction[] => {\n            const lengthEffect = depsMap.get(\"length\");\n            if (lengthEffect) {\n                lengthEffect.forEach((effectFn: EffectFunction) => {\n                    if (activeEffect!== effectFn) {\n                        effec => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n    effectsToRun.forEach((effectFn: EffectFunction) => {\n            if (activeEffect!.options?.priority) {\n                effectsToRun.delete(effectFn);\n            }\n        });\n    }\n    });\n    // 依赖的 effect\n    effectsToRun.forEach(): EffectFunction[] => {\n        effectFn?.call(target, type, target, depsMap);\n    }\n}\n\nfunction flushEffects() {\n    effectsToRun.forEach((effectFn: EffectFunction) => {\n        // 调度器执行\n        if (effectFn?.options?.scheduler) {\n            effectFn?.options.scheduler(effectFn);\n        }\n        else {\n            effectFn();\n        }\n    });\n}\n","score":286,"fallbacked":false,"num_type_errors":312},{"code":"export type EffectOptions = {\n    scheduler?: (() => any) | undefined;\n};\nexport type EffectContext = {\n    effect?: EffectFunction<any>;\n    trigger?: TriggrtFunction;\n};\nexport type EffectTracker = {\n    (target: any, key;\n    lazy?: boolean,\n    options?: EffectOptions) => EffectContext;\n};\nexport type Effect = EffectFunction<any>;\nexport interface GetEffectTracker {\n    (target: any, key: PropertyKey): EffectTracker | undefined;\n};\n};\nexport type EffectFunction<T> = {\n    ();\n    deps: Set<Function>[];\n    options?: EffectOptions;\n};\nexport type EffectTrackerOptions = {\n    lazy?: boolean;\n    options?: EffectTrackerOptions;\n};\nexport interface EffectTrackerOptions {\n    lazy?: boolean;\n    scheduler?: (() => any) | undefined;\n};\nexport interface TriggrtFunction {\n    (key: PropertyKey) => void;;\n};\nexport type TriggerType = \"ADD\" | \"SET\" | \"DELETE\";\nexport type TriggrtFunction = (target: any, key: PropertyKey) => void;\nexport interface TriggrtFunctionOptions {\n    type?: TriggerType;\n    scheduler?: ((key: PropertyKey) => void) | undefined;\n};\nexport interface EffectTrackerWithSchedule, key: PropertyKey;\nexport interface EffectTrackerWithSchedule<T> extends EffectTracker, key: PropertyKey {\n    (target: T, key: PropertyKey, options?: EffectTrackerOptions): TriggrtFunction | undefined;\n};, ITERATE_KEY?: PropertyKey;\nexport interface TriggrtFunctionOptions {\n    type?: TriggerType;\n    scheduler?: ((key: PropertyKey) => void) | undefined;\n};\nexport interface TriggrtFunctionWithOptions<T>, MAP_KEY_ITERATE_KEY?: PropertyKey;\nexport interface TriggrtFunctionWithOptions<T>, MAP_KEY_ITERATE_KEY extends PropertyKey {\n    type?: TriggerType;\n    scheduler?: ((key: PropertyKey) => void) | undefined;\n}, type?: TriggerType;\nexport type EffectTracker = TriggrtFunction | TriggrtFunctionWithOptions<any>;\nexport interface EffectTrackerWithSchedule<T> extends EffectTracker, key: PropertyKey, TriggrtFunctionWithOptions, newVal?: any {\n    (target: T, key: PropertyKey, options?: EffectTrackerOptions): TriggrtFunctionWithOptions<any> | undefined;\n};\nexport interface TriggrtFunctionWithOptions<T>, MAP_KEY_ITE) => void;\nlet activeEffect;\nconst bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();\nconst effectStack = [];\nexport function effect<T>(fn: EffectFunction<any>, options?: EffectTrackerOptions): TriggrtFunctionWithOptions<T> {\n    const effectFn = () => {\n        const res = fn();\n        activeEffect = undefined;\n        effectStack.forEach(effect => effec, options?: EffectTrackerOptions);\n        return res;\n    };\n    effectFn.deps = new Set();\n    effectFn.options = options;\n    effectFn();\n    effectStack.push(effectFn);\n    return effectFn;\n}\nexport functio): EffectFunction<any> {\n    const effectFn = () => {\n        const deps = effectFn.deps;\n        let res = effectFn.result;\n        if (activeEffect === effectFn) {\n            if (deps.size) {\n    const effectFn = (): EffectFunction<any> => {\n    activeEffect = undefined;\n    effectStack.forEach(effect => effect(), options?: EffectTrackerOptions);\n    return res;\n    };\n    } else {\n    return res;\n    }\n    }\n    }; => {\n        // 清除之前的effect\n        cleanup(effectFn);\n        activeEffect = effectFn;\n        // 压入栈中\n        effectStack.push(effectFn);\n        const res = fn();\n        effectStack.pop();\n        activeEffect = effectStack[effectStack.length - 1];\n        return res;\n    };\n    effectFn.deps = [] as Set<Function>[];\n    effectFn.options = options;\n    if (!options?.lazy) {\n        effectFn();\n    }\n    return effectFn;\n}\n/**\n * 清除之前的绑定，用于刷新绑定effect\n * 可解决分支切换问题、比如三元\n * @param effectFn\n */\nfunction cleanup<T>(effectFn: EffectFunction<any>): void {\n    effectFn.deps.forEach(effect => effect());\n    effectFn.deps.length = 0;\n}\n/**\n * 清除所有绑定\n */\nexport function cleanup(): voi): void {\n    effectStack.forEach(effect => effect());\n    effectStack.length = 0;\n}\n/**\n * 防抖函数\n */\nexport function debounce(fn: EffectFunction<any>, delay: numbe {\n    for (let index = 0; index < effectFn.deps.length; index++) {\n        const deps = effectFn.deps[index];\n        deps.delete(effectFn);\n    }\n    effectFn.deps.length = 0;\n}\nexport function track(target: any, key: string | symbol, ITERATE_KEY?: string | symbol): EffectFunction<any> {\n    let depsMap = target[ITERATE_KEY];\n    if (!depsMap) {\n        depsMap = new Map(), key: symbol;\n        target[ITERATE_KEY] = depsMap;\n    }\n    const deps = depsMap.get(key);\n    if (!deps) {\n        deps = new Set(), depsMap.set(key, deps);): EffectFunction<any>;\n        target[ITERATE_KEY][key] = deps;\n    }\n    deps.add(effectFn);\n    return depsMap.get(key);\n}\nexport function effect<T>(fn: EffectFunctio {\n    if (!activeEffect)\n        return;\n    // data or props\n    let depsMap = bucket.get(target);\n    if (!depsMap) {\n        bucket.set(target, (depsMap = new Map()));\n    }\n    // 属性值对应的set，set里可能存在多个effect函数\n    let deps = depsMap.get(key);\n    if (!deps) {\n        depsMap.set(key, (deps = new Set()));\n    }\n    // 属性对应的effect函数、effect可能存在多个、同个则覆盖\n    deps.add(activeEffect);\n    // 将当前effect添加依赖的effect\n    activeEffect.deps.push(deps);\n}\nexport function trigger(target: any, key: string | symbol, ITERATE_KEY?: string | symbol): void {\n    const depsMap = bucket.get(target);\n    if (!depsMap)\n        return;\n    // 获取对应值的所有 effects\n    const effect, key: symbol;\n    if (ITERATE_KEY) {\n        key = ITERATE_KEY;\n        effect = depsMap.get(key);\n    }\n    else {\n        key = symbol;\n        effect = depsMap.get(symbol), ITERATE_KEY?: string | symbol;\n    }\n    if (!effect)\n        return;\n    // 执行effect\n    for (let i = 0; i < effect.deps.length; i++) {\n        const dep = effect.deps[i];\n        i, MAP_KEY_ITERATE_KEY?: string | symbol;\n        // 由于effect可能存在多个effect函数，所以需要在依赖收集器里过滤出effect函数\n        if (ITERATE_KEY) {\n            if (dep[MAP_KEY_ITERAT, type?: EffectFunctio])\n                continue;\n        }\n        if (key === dep[MAP_KEY_ITERATE_KEY]) {\n            dep[MAP_KEY_ITERATE_KEY] = undefined;\n            trigger(target, key,, newVal?: any): void;\n            continue;\n        }\n        dep[MAP_KEY_ITERATE_KEY] = key;\n        // 以当前key为依赖的effect函数\n        const effectFn: EffectFunction<any>;\n        if): EffectFunction<any> = dep[MAP_KEY_ITERATE_KEY] as EffectFunction<any>;\n        effectFn(newVal);\n    }\n}\nexport function effect<D, P>(fn: EffectFunction<D>, dep {\n    const depsMap = bucket.get(target);\n    if (!depsMap)\n        return;\n    // 获取对应值的所有 effects\n    const effects = depsMap.get(key);\n    // 取得与ITERATE_KEY关联的副作用函数\n    let iterateEffects;\n    if (ITERATE_KEY) {\n        iterateEffects = depsMap.get(ITERATE_KEY);\n    }\n    let mapKeyIterateEffects;\n    if (MAP_KEY_ITERATE_KEY) {\n        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);\n    }\n    // 分支--防止无限循环\n    const effectsToRun = new Set<EffectFunction<any>>();\n    effects &&\n        effects.forEach((effectFn: EffectFunction<any>, key: EffectKey) => {\n            if (activeEffect === effectFn) {\n                effectsToRun.add(effectFn);\n                return;\n            }\n            if (iterateEffects && iterateEffects[effectFn.typ): boolean {\n                effectsToRun.add(effectFn);\n                return;\n            }\n            if (mapKeyIterateEffects && mapKeyIterateEffects[effectFn.typ]): boolean {\n                effectsToRun.add(effectFn);\n                return => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n    // set\n    if (target instanceof Set &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach((effectFn: EffectFunction<any>, key: EffectKey) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // array\n    if (target instanceof Array &&): boolean {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach((effectFn: EffectFunction<any>, key: EffectKey) => {\n                if (activ => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // map\n    if (target instanceof Map &&\n        (type === \"SET\" || type === \"ADD\" || type === \"DELETE\")) {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach((effectFn: EffectFunction<any>, key: EffectKey) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // object\n    if (target instanceof Object &&): boolea): boolean {\n        ITERATE_KEY &&\n            (iterateEffects = depsMap.get(ITERATE_KEY)) &&\n            iterateEffects.forEach((effectFn: EffectFunction<any>, key: EffectKey) => {\n                if (activ => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (target instanceof Map &&\n        (type === \"ADD\" || type === \"DELETE\")) {\n        MAP_KEY_ITERATE_KEY &&\n            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&\n            mapKeyIterateEffects.forEach((effectFn: EffectFunction<any>, key: EffectKey) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (target instanceof Map &&\n        (type ===): boolea): boolean {\n        MAP_KEY_ITERATE_KEY &&\n            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&\n            mapKeyIterateEffects.forEach((effectFn: Effec => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    // array\n    if (type === \"ADD\" && Array.isArray(target)) {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach((effectFn: EffectFunction<any>, key: EffectKey) => {\n                if (activeEffect!== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (type === \"DELETE\" && Array.isArra): boolean {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach((effectFn: EffectFunction<any>, key: EffectKey) => {\n                if (activeEffect!== effectFn) { => {\n                if (activeEffect !== effectFn) {\n                    effectsToRun.add(effectFn);\n                }\n            });\n    }\n    if (Array.isArray(target) && key === \"length\") {\n        depsMap.forEach((effects: EffectMap, key: string) => {\n            if (key === \"length\") {\n                const lengthEffects = depsMap.get(\"length\");\n                lengthEffects &&\n                    lengthEffects.forEach((effectFn: EffectFunction<any>, key, key: EffectKey): boolean => {\n                        if (activeEffect!== effectFn) {\n                            effectsToRun.add(effectFn);\n                        }\n                    });\n            }\n        });\n    }\n    // Set\n    if (type === \"ADD\" && Set.isSet< => {\n            if ((key as number) >= (newVal as number)) {\n                effects.forEach((effectFn: EffectFunction<any>, key: EffectKey): boolean => {\n                    if (activeEffect!== effectFn) {\n                        effectsToRun.add(effectFn);\n                    }\n                });\n            }\n        });\n    if (type === \"DELETE\" &): boolean {\n            if ((key as number) <= (newVal as number)) {\n                effects.forEach((effectFn: EffectFunction<any>, key: EffectKey): boolean => {\n                    if (activeEffect!== effectFn) {\n                        effectsT => {\n                    if (activeEffect !== effectFn) {\n                        effectsToRun.add(effectFn);\n                    }\n                });\n            }\n        });\n    }\n    // object\n    (type === \"ADD\" || type === \"DELETE\") &&\n        iterateEffects &&\n        iterateEffects.forEach((effectFn: EffectFunction<any>, key: EffectKey): boolean => {\n            if (key in target) {\n                if (key === \"length\") {\n                    const lengthEffects = depsMap.get(\"length\");\n                    lengthEffects &&\n                        lengthEffects): boolean {\n                            if ((key as number) >= (newVal as number)) {\n                                effectsToRun.add(effectFn);\n                            }\n                        };\n                }\n                else if (key in target &&\n                    (key as number) >= (newVal a => {\n            if (activeEffect !== effectFn) {\n                effectsToRun.add(effectFn);\n            }\n        });\n    effectsToRun.forEach((effectFn: EffectFunction<any>): void => {\n        if (effectFn) {\n            const {\n                effect,\n                options,\n                name: fnName,\n                deps,\n            } = effectFn;\n            if (effect && fnName) {): any {\n                // effect执行\n                if (effectFn.options?.scheduler) {\n                    effectFn.options.scheduler(effectFn);\n                }\n                else {\n                    effectFn();\n                }\n            }\n        }\n    });\n}\n\nexpor => {\n        // 调度器执行\n        if (effectFn?.options?.scheduler) {\n            effectFn?.options.scheduler(effectFn);\n        }\n        else {\n            effectFn();\n        }\n    });\n}\n","score":278,"fallbacked":false,"num_type_errors":338}]}
{"dataset_elem":{"alphanum_fraction":0.6493817312,"avg_line_length":19.5859375,"content":"\nexport type CreateOneUserRequest = {\n    bodyAuthLevel: number,\n    bodyEmail: string,\n    bodyPassword: string,\n    bodyPhone: string,\n    bodyUserStatus: number,\n    bodyUsername: string,\n}\n\nexport const CreateOneUserRequestConvert = (\n    body: any,\n    query: any,\n    path: any,\n) => {\n  return {\n    bodyAuthLevel: parseInt(body.authLevel),\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n  };\n};\nexport type LoginUserRequest = {\n    bodyEmail: string,\n    bodyPassword: string,\n}\n\nexport const LoginUserRequestConvert = (\n    body: any,\n    query: any,\n    path: any,\n) => {\n  return {\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n  };\n};\nexport type LogoutUserRequest = {\n}\n\nexport const LogoutUserRequestConvert = (\n    body: any,\n    query: any,\n    path: any,\n) => {\n  return {\n  };\n};\nexport type DeleteOneUserRequest = {\n    pathId: number\n}\n\nexport const DeleteOneUserRequestConvert = (\n    body: any,\n    query: any,\n    path: any,\n) => {\n  return {\n    pathId: parseInt(path.id),\n  };\n};\nexport type ReadOneUserRequest = {\n    pathId: number\n}\n\nexport const ReadOneUserRequestConvert = (\n    body: any,\n    query: any,\n    path: any,\n) => {\n  return {\n    pathId: parseInt(path.id),\n  };\n};\nexport type UpdateOneUserRequest = {\n    pathId: number\n    bodyAuthLevel: number,\n    bodyEmail: string,\n    bodyPassword: string,\n    bodyPhone: string,\n    bodyUserStatus: number,\n    bodyUsername: string,\n}\n\nexport const UpdateOneUserRequestConvert = (\n    body: any,\n    query: any,\n    path: any,\n) => {\n  return {\n    pathId: parseInt(path.id),\n    bodyAuthLevel: parseInt(body.authLevel),\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n  };\n};\nexport type CreateManyUsersRequest = {\n    bodyAuthLevel: number,\n    bodyEmail: string,\n    bodyPassword: string,\n    bodyPhone: string,\n    bodyUserStatus: number,\n    bodyUsername: string,\n}\n\nexport const CreateManyUsersRequestConvert = (\n    body: any,\n    query: any,\n    path: any,\n) => {\n  const arrayBody = body.map((e: any) => {\n    return {\n      bodyAuthLevel: parseInt(e.authLevel),\n      bodyEmail: e.email,\n      bodyPassword: e.password,\n      bodyPhone: e.phone,\n      bodyUserStatus: parseInt(e.userStatus),\n      bodyUsername: e.username,\n    };\n  });\n  return arrayBody;\n};\n","content_without_annotations":"\nexport type CreateOneUserRequest = {\n    bodyAuthLevel,\n    bodyEmail,\n    bodyPassword,\n    bodyPhone,\n    bodyUserStatus,\n    bodyUsername,\n}\n\nexport const CreateOneUserRequestConvert = (\n    body,\n    query,\n    path,\n) => {\n  return {\n    bodyAuthLevel: parseInt(body.authLevel),\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n  };\n};\nexport type LoginUserRequest = {\n    bodyEmail,\n    bodyPassword,\n}\n\nexport const LoginUserRequestConvert = (\n    body,\n    query,\n    path,\n) => {\n  return {\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n  };\n};\nexport type LogoutUserRequest = {\n}\n\nexport const LogoutUserRequestConvert = (\n    body,\n    query,\n    path,\n) => {\n  return {\n  };\n};\nexport type DeleteOneUserRequest = {\n    pathId\n}\n\nexport const DeleteOneUserRequestConvert = (\n    body,\n    query,\n    path,\n) => {\n  return {\n    pathId: parseInt(path.id),\n  };\n};\nexport type ReadOneUserRequest = {\n    pathId\n}\n\nexport const ReadOneUserRequestConvert = (\n    body,\n    query,\n    path,\n) => {\n  return {\n    pathId: parseInt(path.id),\n  };\n};\nexport type UpdateOneUserRequest = {\n    pathId\n    bodyAuthLevel,\n    bodyEmail,\n    bodyPassword,\n    bodyPhone,\n    bodyUserStatus,\n    bodyUsername,\n}\n\nexport const UpdateOneUserRequestConvert = (\n    body,\n    query,\n    path,\n) => {\n  return {\n    pathId: parseInt(path.id),\n    bodyAuthLevel: parseInt(body.authLevel),\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n  };\n};\nexport type CreateManyUsersRequest = {\n    bodyAuthLevel,\n    bodyEmail,\n    bodyPassword,\n    bodyPhone,\n    bodyUserStatus,\n    bodyUsername,\n}\n\nexport const CreateManyUsersRequestConvert = (\n    body,\n    query,\n    path,\n) => {\n  const arrayBody = body.map((e) => {\n    return {\n      bodyAuthLevel: parseInt(e.authLevel),\n      bodyEmail: e.email,\n      bodyPassword: e.password,\n      bodyPhone: e.phone,\n      bodyUserStatus: parseInt(e.userStatus),\n      bodyUsername: e.username,\n    };\n  });\n  return arrayBody;\n};\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":692,"ext":"ts","fun_ann_density":0.0433526012,"function_parameters":22,"function_signatures":0,"function_usages":0,"functions":8,"hexsha":"061ff6d38d7937dfc5d58418015175ee872e76fe","lang":"TypeScript","loc":119,"loc_per_function":6.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"b35980067ccdb91b59cd6319d8441ac8cbb0f817","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"saqwxz/raspberry-iot-rola-dht22","max_forks_repo_path":"server/src/apiModules/user/user.parameters.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"b35980067ccdb91b59cd6319d8441ac8cbb0f817","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"saqwxz/raspberry-iot-rola-dht22","max_issues_repo_path":"server/src/apiModules/user/user.parameters.ts","max_line_length":46,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"b35980067ccdb91b59cd6319d8441ac8cbb0f817","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"saqwxz/raspberry-iot-rola-dht22","max_stars_repo_path":"server/src/apiModules/user/user.parameters.ts","max_stars_repo_stars_event_max_datetime":"2022-02-24T07:35:21.000Z","max_stars_repo_stars_event_min_datetime":"2022-02-24T07:35:21.000Z","metric":0.3193745528,"predefined_density":0.3770491803,"predefined_types":23,"prop_ann_density":0.0332369942,"property_declarations":23,"size":2507,"trivial_density":0.3606557377,"trivial_types":22,"type_definitions":7,"typedef_density":0.0101156069,"var_ann_density":0.0115606936,"variable_declarations":8},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export type CreateOneUserRequest = {\n    bodyAuthLevel: string;\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus: string;\n    bodyUsername;\n};\nexport const CreateOneUserRequestConvert = (body, query, path) => {\n    return {\n        bodyAuthLeve;\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n};\nexport type CreateManyUsersRequest =;\n    bodyPassword: string;\n    bodyPhone;\n    bodyUserStatus;\n    bodyUsername;\n};\nexport const CreateManyUsersRequestConvert = (body, query, path) => {\n    return {\n        bodyPassword: body.password,\n        bodyPhone: bod;\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n};\nexport type UpdateOneUserRequest = {\n    pathId;\n    bodyAuthLevel;\n    bodyEmail;\n    bodyPassword;\n    bodyUserStatus: string;\n    bodyUsername;\n};\nexport const UpdateOneUserRequestConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLevel);\n    bodyUsername: body.username,\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyUserStatus: parseInt(body.userStatus),\n};\nexport const UpdateOneUserRequestConvert = (body, query, path) =>;\n};\nexport const CreateOneUserRequestConvert = (body: CreateOneUserRequest, query: any, path: any) => {\n    return {\n        bodyAuthLeve: body.bodyAuthLeve,\n        bodyEmail: body.bodyEmail,\n        bodyPassword: body.bodyPassword,\n        bod, query: {\n            email: body.bodyEmail,\n            username: body.bodyUsername,\n        },\n        pathId: parseInt(path.id),\n    };\n};\nexport type CreateManyUsersResponse = {\n    bodyAuthLeve;\n    bod, path: {\n        id;\n    },\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus: string;\n    bodyUsername;\n};\nexport const CreateManyUsersResponseConvert = (body: CreateManyUsersResponse, query: an): void => {\n    return {\n        bodyAuthLeve: body.bodyAuthLeve,\n        bodyEmail: body.bodyEmail,\n        bodyPassword: body.bodyPassword,\n        bodyPhone: body.bodyPhone,\n        bodyUserStatus => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type LoginUserRequest = {\n    bodyEmail: string;\n    bodyPassword: string;\n};\nexport const LoginUserRequestConvert = (body, query, path) => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n    };\n};;\n    bodyPassword: string;\n    bodyEmail: string;\n};\nexport type LoginUserResponse = {\n    bod, path: {\n        id;\n    },\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus: string;\n    bod;\n};\nexport const LoginUserRequestConvert = (body: LoginUserRequest, query, path) => {\n    return {\n        bodyEmail: body.bodyEmail,\n        bodyPassword: body.bodyPassword,\n    };\n};\nexport type UpdatePasswordUserRequest = {\n    bodyEmail: string;\n    bod, query: {\n        method;\n    },\n    bodyPassword: string;\n};\nexport const UpdatePasswordUserRequestConvert = (body: UpdatePasswordUserRequest, query, path) => {\n    return {\n        bodyEmail: body.bodyEmail,\n        bodyPasswor, path: {\n            id;\n        },\n    };\n};\nexport type UpdateUserRequest = {\n    bodyEmail: string;\n    bod, query: {\n        method;\n    },\n    bodyPassword: string;\n    bodyPhone: string;\n};): {\n    bodyEmail;\n    bod;\n};\nexport const UpdateUserRequestConvert = (body: UpdateUserRequest, query, path) => {\n    return {\n        bodyEmail: body.bodyEmail,\n        bodyPassword: body.bodyPasswor => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n    };\n};\nexport type LogoutUserRequest = {};\nexport const LogoutUserRequestConvert = (body: LogoutUserRequest, query, path) => {\n    return {};\n};\nexport type CreateOneUserRequest = {\n    bodyEmail;\n    bod, query: {\n        method;\n    },\n    bodyPassword: string;\n};\nexport const Creat, query: {\n        method;\n    },\n    bodyPassword: string;\n};\nexport const CreateOneUserRequestConvert = (body, query, path) => {\n    return {\n        bodyEmail: body.bodyEmail,\n        bodyPassword: body.bod, path: {\n            id;\n        },\n    };\n};\nexport type CreateManyUserRequest = {\n    bodyEmail;\n    bod, query: {\n        method;\n    },\n    bodyPassword: string;\n};\nexport const CreateManyUserRequestConvert): {\n    bodyEmail;\n    bod;\n};\nexport type FindOneUserRequest = {\n    bodyEmail;\n    bod, query: {\n        method;\n    },\n    bodyPassword: string;\n};\nexport const FindOneUserRequestConver => {\n    return {};\n};\nexport type DeleteOneUserRequest = {\n    pathId: number;\n};\nexport const DeleteOneUserRequestConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type FindManyUserRequest = {\n    queryEmail;\n};\nexport const DeleteOneUserRequestConvert = (body: FindManyUserRequest, query, path) => {\n    return {\n        queryEmail: body.bod,\n    };\n};\nexport type FindOneUserResponse = {\n    bod, pathId: number;\n};\nexport const Fin, query: {\n        method;\n    },\n    bodyPassword: string;\n};\nexport const FindOneUserResponseConvert = (body, query, path) => {\n    return {\n        bod: body.bod,\n        pathId: body, path: {\n            id;\n        },\n    };\n};\nexport type FindManyUserResponse = {\n    bod, pathId: number;\n};\nexport const FindManyUserResponseConvert = (body, query, path) => {\n    retur): {\n        bod: body.bod,\n        pathId: body, path: {\n            id;\n        },\n    };\n};\nexport type FindOneUserResponse = {\n    bod, pathId: number;\n};\nexpor => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type ReadOneUserRequest = {\n    pathId: number;\n};\nexport const ReadOneUserRequestConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type UpdateManyUserRequest = {\n    bodyEmail;\n};\nexport const ReadOneUserRequestConvert = (body: UpdateManyUserRequest, query, path) => {\n    return {\n        bodyEmail: body.bodyEmail,\n    };\n};\nexport type UpdateManyUserResponse = {\n    bod,\n    pathId: number;\n};\nexport cons, query: {\n        method;\n    },\n    bodyEmail: string;\n};\nexport const UpdateManyUserResponseConvert = (body, query, path) => {\n    return {\n        bod: body.bod,\n        pathId: body, path: {\n            id;\n        },\n    };\n};\nexport type UpdateOneUserRequest = {\n    pathId;\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus;\n    bodyUsername;\n};\nexport const UpdateOneUserReques): {\n        bodyEmail: string;\n        bodyPassword: string;\n        bodyPhone: string;\n        bodyUserStatus: string;\n        bodyUsername: string;\n    };\n};\nexport type UpdateOneUserRequest = {\n    pathId;\n    bodyEmai => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type UpdateOneUserRequest = {\n    pathId: number;\n    bodyAuthLevel;\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus;\n    bodyUsername;\n};\nexport const UpdateOneUserRequestConvert = (body, query, path) => {\n    return {;\n    bodyAuthLevel: parseInt(body.authLevel),\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username;\n    bodyEmail: body.email,\n};\n};\nexport type UpdateOneUserResponse = {\n    bod,\n    pathId: number;\n};\nexport cons, query: {\n        method;\n    },\n    bodyEmail: string;\n    bodyPasswor;\n    bodyPassword: string;\n    bodyPhone: string;\n    bodyUserStatus: string;\n    bodyUsername: string;\n};\nexport const UpdateOneUserResponseConvert = (body, query, path) => {\n    return {\n        bod: body.;\n    bodyPhone: body.phone,\n    bodyUsername: body.username,\n};\n};\nexport type UpdateManyUserRequest = {\n    bodyAuthLevel;\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus;\n    bodyUsername;;\n    bodyUserStatus: string;\n    bodyUsername;\n};\nexport const UpdateManyUserRequestConvert = (body, query, path) => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bod;\n    bodyUsername: body.username,\n};\n};\nexport type UpdateManyUserResponse = {\n    bod,\n    pathIds: number[];\n};\nexport cons, query: {\n        method;\n    },\n    bodyAuthLevel: string;\n    bod;\n};\nexport const UpdateOneUserRequestConvert = (body: UpdateManyUserRequest, query: {\n        method;\n    }, path: {\n        id;\n    }) => {\n    return {\n        bodyAuthLevel: body.bodyAuthLevel,\n        bodyEmail: body.bodyEmail,\n        bodyPassword: bod, query: {\n            method;\n        },\n        bod;\n    bodyUsername: body.bodyUsername,\n};\n};\nexport type CreateUserResponse = {\n    bod,\n    pathId: number;\n};\nexport cons, query:, path: {\n        id;\n    },\n    bodyAuthLevel: string;\n    bod;\n};\nexport const CreateUserResponseConvert = (body, query, path) => {\n    return {\n        bod: body.;\nbodyUsername: bod): {\n        bod: body.bod,\n        pathId: body.pathId,\n        bodyAuthLevel: bod,\n    };\n};\nexport type CreateManyUsersResponse = {\n    bod,\n    pathIds: number[] => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type CreateManyUsersRequest = {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhone: string;\n    bodyUserStatus: number;\n    bodyUsername: string;\n};\nexport const CreateManyUsersRequestConvert = (body, query, path;\n    bodyEmail: string,\n    bodyPassword: string,\n    bodyPhone: string,\n    bodyUserStatus: number,\n    bodyUsername: string): CreateManyUsersRequest {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail;\n    bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n};\n};\nexport const CreateManyUsersRequestConvert = (body, query, pat;\n    bodyPhone: string,\n    bodyUserStatus: number,\n    bodyUsername: string): CreateManyUsersRequest {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password;\n    bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport const CreateManyUsersRequestConvert = (body, query, path) => {\n    const arrayBody = body.map((e) =>;\n    bodyUsername: e.username,\n    bodyPassword: e.password,\n    bodyPhone: e.phone,\n    bodyUserStatus: parseInt(e.userStatus),\n    bodyEmail: e.email,\n});\nreturn arrayBody;\n};\nexport const CreateManyUsersRequestConvert = (body: CreateManyUsersRequest, query: any, path: any) => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone, query: body.query,\n        bodyUsername: body.username,\n    };\n};\nexport const CreateManyUsersRequestConvert = (body: CreateManyUsersRequest, query: any, path: any) => {\n    return {\n        bodyAuthLeve, path: path,\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone, query: body.query,\n        bodyUsername: body.username,\n    };\n};\nexport const CreateManyUsersRequestConvert =): CreateManyUsersRequest => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseIn => {\n    const arrayBody = body.map((e: any) => {\n        return {\n            bodyAuthLevel: parseInt(e.authLevel),\n            bodyEmail: e.email,\n            bodyPassword: e.password,\n            bodyPhone: e.phone,\n            bodyUserStatus: parseInt(): number => {\n                return parseInt(e.userStatus);\n            },\n            bodyUsername: e.username,\n        };\n    });\n    return arrayBody;\n},\n};\nexport const CreateManyUsersRequestConvert = (body: CreateManyUser => {\n        return {\n            bodyAuthLevel: parseInt(e.authLevel),\n            bodyEmail: e.email,\n            bodyPassword: e.password,\n            bodyPhone: e.phone,\n            bodyUserStatus: parseInt(e.userStatus),\n            bodyUsername: e.username,\n        };\n    });\n    return arrayBody;\n};\n","score":411,"fallbacked":false,"num_type_errors":257},{"code":"export type CreateOneUserRequest = {\n    bodyAuthLevel: parseInt(body.authLevel),\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username;\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n};\nexport const CreateOneUserRequestConvert =;\n    bodyPassword: string;\n    bodyPhone: string;\n    bodyUserStatus: number;\n    bodyUsername: string;\n};\nexport const CreateOneUserRequestConvert = (body, query, path) => {\n    return {\n        bodyAuthLevel: parseInt(bod;\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n};\nexport type GetOneUserRequest = {\n    pathId;\n};\nexport const GetOneUserRequestConvert = (body;\n    bodyUserStatus: number,\n    bodyUsername: string,\n    pathId?: number,\n);\nexport type UpdateOneUserRequest = {\n    pathId;\n    bodyAuthLevel;\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus;;\n    bodyUsername: string;\n};\nexport const UpdateOneUserRequestConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail;\n};\nexport const CreateOneUserRequestConvert = (body: CreateOneUserRequest, query: any, query: any, path: any) => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatu, path: path.id,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport const LoginUserRequestConvert = (body: LoginUserRequest, query: any, path: any) =>): {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatu => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type LoginUserRequest = {\n    bodyEmail: string;\n    bodyPassword: string;\n};\nexport const LoginUserRequestConvert = (body, query, path) => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n    };\n};;\n    bodyPassword: string;\n    bodyPhone: string;\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyUsername: string;\n};\nexport type CreateOneUserRequest = {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n};\nexport const LoginUserRequestConvert = (body: CreateOneUserRequest, query: any, path: any) => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: bod, query: query, path: path.id,\n        bodyUsername: body.username,\n    };\n};\nexport type CreateOneUserRequestConvert = {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyPassword: string;\n    bod, path: {\n        id: string;\n    },\n    bodyUsername: string;\n};\nexport const CreateOneUserRequestConvert = (body, query, path) => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bod): {\n            bodyAuthLevel: parseInt(body.authLevel),\n            bodyEmail: body.email,\n            bodyPassword: body.password,\n            bodyPhone: body.phone,\n            bodyUserStatus: parseInt(body.userStatus),\n            bod => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n    };\n};\nexport type LogoutUserRequest = {};\nexport const LogoutUserRequestConvert = (body: LogoutUserRequest, query: any, path: any) => {\n    return {};\n};\nexport type CreateOneUserErrorResponse = {};\nexport const CreateOneUserErrorResponseConvert = (body: CreateOneUserErrorResponse, query: any, path, query: any, path: any) => {\n    return {};\n};\nexport type LoginUserErrorResponse = {};\nexport const LoginUserErrorResponseConvert = (body: LoginUserErrorResponse, query: any, path: any) => {\n    return {};, path: {\n        pathLogin: {\n            pathId: string;\n            pathUsername: string;\n        };\n    },\n    query: query,\n    path: path.pathId,\n};\nexport type CreateOneUserErrorResponse = {};\nexport const Creat): {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhone: string;\n    bodyUsername: string;\n    bodyUserStatus: number;\n};\nexport const Creat = (body, quer => {\n    return {};\n};\nexport type DeleteOneUserRequest = {\n    pathId: number;\n};\nexport const DeleteOneUserRequestConvert = (body: DeleteOneUserRequest, query: any, path) => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type GetOneUse;\n};\nexport const DeleteOneUserRequestConvert = (body: GetOneUse, query: any, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type GetOneUse;\n};\nexport const GetOneUseConvert = (bod, query: any, path) => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type UpdateOneUserErrorResponse = {};\nexport const UpdateOneUserErrorResponseConvert = (body: UpdateOneUserErrorResponse, quer, path: any) => {\n    return {};\n};\nexport type UpdateOneUserErrorResponse = {};\nexport const UpdateOneUserErrorResponseConvert = (body: UpdateOneUserErrorResponse, quer: any, path: any) => {\n    return {};\n}): {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhone: string;\n    bodyUsername: string;\n    bodyUserStatus: number;\n};\nexport const UpdateOneUserErrorResponseConvert = => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type ReadOneUserRequest = {\n    pathId: number;\n};\nexport const ReadOneUserRequestConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type UpdateOneUserRequest = {\n    pathId;\n};\nexport const ReadOneUserRequestConvert = (body: ReadOneUserRequest, query: any, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type UpdateManyUserRequest = {\n    pathId;\n};\nexport const UpdateMan, query: any, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type GetOneUserResponse = {\n    body: User;\n};\nexport const GetOneUserResponseConvert, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n        body: UserConvert(body, query, path),\n    };\n};\nexport type GetManyUserResponse = {\n    body: User[];\n};): {\n    body: User[];\n};\nexport const GetManyUserResponseConvert = (body: GetManyUserResponse, query: any, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n        bod => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type UpdateOneUserRequest = {\n    pathId: number;\n};\nexport const UpdateOneUserRequestConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail;\n    bodyAuthLevel: parseInt(body.authLevel),\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus;\n    bodyUsername;\n};\nexport const UpdateOneUserRequestConvert = (body: UpdateOneUserRequest, query: any, path;\n    bodyEmail: string,\n    bodyPassword: string,\n    bodyPhone: string,\n    bodyUserStatus: number,\n    bodyUsername: string) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body;\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n};\n};\nexport type CreateManyUsersResponse = {\n    body: User[];;\n    bodyPhone: string[];\n};\nexport const CreateManyUsersResponseConvert = (body: CreateManyUsersResponse, query: any, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n        bod => {;\n    bodyUserStatus: body.userStatus,\n    bodyUsername: body.username;\n    bodyEmail: body.email,\n    bodyPhone: body.phone;\n    return {\n        pathId: parseInt(path.id),\n    };\n};\n};\nexpor;\n    bodyUsername: string;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhone: string;\n    bodyUserStatus: number;\n}\nexport type UpdateOneUserRequest = {\n    pathId: number;\n};\nexport const UpdateOneUserReques;\n};\nexport const UpdateOneUserRequestConvert = (body: UpdateOneUserRequest, query: any, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPasswor, query: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type CreateManyUsersRequest = {\n    bodyAuthLevel: numbe, path: any;\n};\nexport const CreateManyUsersRequestConvert = (body: CreateManyUsersRequest, query: any, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseIn): User[];\n};\nexport type UpdateOneUserResponse = {\n    body: User;\n};\nexport const UpdateOneUserResponseConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.i => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type CreateManyUsersRequest = {\n    bodyAuthLevel: number, path: any;\n};\nexport const CreateManyUsersRequestConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLeve;\n    bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type UpdateManyUsersReques;\n    bodyPassword: string, path: any;\nexport const UpdateManyUsersRequesConvert = (body: UpdateManyUsersReques, query: any, path: any) => {\n    return {\n        pathId: parseInt(path.id),\n        bod;\n    bodyPhone: body.phone,\n        bodyPassword: body.password,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type UpdateManyUsersReques = {\n    bodyAuthLevel;\n    bodyUserStatus: number, path: any;\n};\nexport const UpdateManyUsersRequesConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.aut;\n    bodyUsername: body.username,\n    bodyUserStatus: parseInt(body.userStatus),\n    };\n};\nexport type UpdateManyUsersRequest = {\n    bodyAuthLevel: number, path: any;\n};\nexport const UpdateManyUsersRequestConvert;\n};\nexport const CreateManyUsersRequestConvert = (body: CreateManyUsersRequest, query: any, query: any, path: any) => {\n    return {\n        bodyAuthLevel: parseInt(query.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(quer): number,\n        bodyUsername: body.username,\n    };\n};\nexport type CreateManyUsersRequest = {\n    bodyAuthLevel: number, bodyEmail: string, bodyPassword: string, bodyPhone: string, bodyUserStatus: number => {\n    const arrayBody = body.map((e: CreateManyUsersRequest) => {\n        return {\n            bodyAuthLevel: parseInt(e.authLevel),\n            bodyEmail: e.email,\n            bodyPassword: e.password,\n            bodyPhone: e.phone,\n            bodyUserStatus): number,\n            bodyUsername: e.username,\n        };\n    });\n    return arrayBody;\n};\nexport const CreateManyUsersResponseConvert = (body: CreateManyUsersResponse, query: any, query: any, path: any => {\n        return {\n            bodyAuthLevel: parseInt(e.authLevel),\n            bodyEmail: e.email,\n            bodyPassword: e.password,\n            bodyPhone: e.phone,\n            bodyUserStatus: parseInt(e.userStatus),\n            bodyUsername: e.username,\n        };\n    });\n    return arrayBody;\n};\n","score":382,"fallbacked":false,"num_type_errors":291},{"code":"export type CreateOneUserRequest = {\n    bodyAuthLevel: parseInt(body.authLevel),\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username;\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username;\n    bodyEmail: body.email,\n    bodyPasswor;\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username;\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhon;\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhon;\n    bodyPhone: body.phon;\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhon;\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(bod;\n    bodyUsername: body.username,\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhon;\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.usernam;\n};\nexport const CreateOneUserRequestConvert = (body: { authLevel: number, email: string, password: string, phone: string, userStatus: number, username: string }) => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body, query: query, path: path,\n    };\n};\nexport const CreateOneUserRequest = (body: { authLevel: number, email: string, password: string, phone: string, userStatus: number, username: string }) => {, path: path};\nexport const CreateOneUserRequestConvert = (body: { authLevel: number, email: string, password: string, phone: string, userStatus: number, username: string }) => {\n    return {\n        bodyAuthLevel): {\n            bodyAuthLevel: parseInt(body.authLevel),\n            bodyEmail: body.email,\n            bodyPassword: body.password,\n            bodyPhone: body.phone,\n            bodyUserStatus: parseInt(body.userStatus),\n            bod => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type LoginUserRequest = {\n    bodyEmail: string,\n    bodyPassword: string,\n};\nexport const LoginUserRequestConvert = (body, query, path) => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n    };\n};;\n    bodyPassword: body.password,\n};\nexport const LoginUserRequest = (body: { email: string, password: string }) => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n    };\n};;\n};\nexport const LoginUserRequestConvert = (body: { email: string, password: string }) => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n    };\n};\nexport type AuthUserRequest = {\n    bodyEmail: string,\n    bodyPasswor, query: {\n        id: number,\n    },\n};\nexport const AuthUserRequestConvert = (body: { email: string, password: string }) => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password, path: 'auth',\n    };\n};\nexport type AuthUser = {\n    bodyEmail: string,\n    bodyPasswor: string,\n    bodyPhone: string,\n    bodyUsername: string,\n};\nexport const AuthUserConvert = (bod): AuthUser => {\n    return {\n        bodyEmail: bod.email,\n        bodyPassword: bod.password,\n        bodyPhone: bod.phone,\n        bodyUsername: bod.username,\n    };\n};\nexport typ => {\n    return {\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n    };\n};\nexport type LogoutUserRequest = {};\nexport const LogoutUserRequestConvert = (body: { }) => {\n    return {};\n};\nexport type DeleteOneUserResponse = {\n    body: number;\n};\nexport const DeleteOneUserResponseConvert = (body: {\n        body: number;\n    }) => {\n    return, query: {\n        id: number,\n    };\n};\nexport type UpdateOneUserRequest = {\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUsername;\n};\nexport const UpdateOneUserRequestConvert = (body: {\n        bod, path: string,\n    }) => {\n    return {\n        path: 'users',\n        bodyEmail: body.bodyEmail,\n        bodyPassword: body.bodyPassword,\n        bodyPhone: body.bodyPhone,\n        bodyUsername: body.bodyUsernam): {\n            bodyUsername: body.bodyUsername,\n            bodyEmail: body.bodyEmail,\n            bodyPassword: body.bodyPassword,\n            bodyPhone: body.bodyPhone,\n        };\n};\nexport type LoginUserRequest = {\n    bod => {\n    return {};\n};\nexport type DeleteOneUserRequest = {\n    pathId: number,\n};\nexport const DeleteOneUserRequestConvert = (body, pathId) => {\n    return {\n        pathId: parseInt(pathId.id),\n    };\n};\nexport type ReadAllUsersRequest = {};\nexport cons;\n};\nexport const DeleteOneUserRequestConvert = (body: {\n        pathId,\n    }) => {\n    return {\n        pathId: parseInt(pathId.id),\n    };\n};\nexport type UpdateOneUserRequest = {\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUsernam, query: {\n        id: number,\n    };\n};\nexport const UpdateOneUserRequestConvert = (body: {\n        bod, path: string, query:  {\n            id: number,\n        },\n    }) => {\n    return {\n        pat, path: 'users',\n        bodyEmail: body.bodyEmail,\n        bodyPassword: body.bodyPassword,\n        bodyPhone: body.bodyPhone,\n        bodyUsername: body.bodyUsernam,\n    };\n};\nexport type ReadAllUser): {\n    bodyUser: User;\n    query: {\n        id: number,\n    };\n};\nexport type ReadOneUserRequest = {\n    pathId: number,\n};\nexport const ReadOneUserRequestConvert = (body, pathId => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type ReadOneUserRequest = {\n    pathId: number,\n};\nexport type ReadAllUserCountRequest = {};\nexport cons;\n};\nexport const ReadOneUserRequestConvert = (body: {\n        pathId,\n    }) => {\n    return {\n        pathId: parseInt(pat;\n};\nexport const ReadOneUserRequestConvert = (body: {\n        pathId,\n    }) => {\n    return {\n        pathId: parseInt(pathId.id),\n    };\n};\nexport type ReadOneUserCountRequest = {};\nexport cons;\n};\nexport type ReadOneUserRequest, query: {\n    query: {\n        id: number,\n    };\n};\nexport const ReadOneUserCountRequestConvert = (body: {\n        pathId,\n    }) => {\n    return {\n        pathId: parseInt(path.id),, path: 'users',\n        query:  {\n            id: number,\n        },\n    };\n};\nexport type ReadAllUserCountRequest = {};\nexport cons;\n};\nexport type ReadAllUserCountRequest = {};\nexport cons;): {\n    body: {\n        body: User[];\n    };\n    query: {\n        page: number,\n        size: number,\n    };\n};\nexport type ReadAllUserCountRequest = {};\nexport cons;\n};\nexport type Rea => {\n    return {\n        pathId: parseInt(path.id),\n    };\n};\nexport type UpdateOneUserRequest = {\n    pathId: number,\n    bodyAuthLevel: number,\n    bodyEmail: string,\n    bodyPassword: string,\n    bodyPhone: string,\n    bodyUserStatus: number,\n    bodyUsername: string,\n};\nexport const UpdateOneUserRequestConvert =;\n    bodyAuthLevel: number;\n    bodyEmail;\n    bodyPassword;\n    bodyPhone;\n    bodyUserStatus;\n    bodyUsername: string;\n};\nexport const UpdateOneUserRequestConvert = (body, query) => {\n    return {\n        pathId: parseInt;\n    bodyEmail: body.email,\n    bodyPassword: body.password,\n    bodyPhone: body.phone,\n    bodyUserStatus: parseInt(body.userStatus),\n    bodyUsername: body.username,\n};\nexport type UpdateOneUserRequest = {;\n    bodyPassword: string;\n    bodyPhone: string;\n    bodyUsername: string;\n    bodyUserStatus: number;\n};\nexport cons;\n};\nexport type UpdateOneUserRequest = {\n    bodyPassword: string;\n    bodyPhone: string;\n    bod;\n    bodyPhone: string;\n};\nexport type UpdateOneUserRequest = {\n    bodyPassword: string;\n    bodyPhone: string;\n};\nexport type UpdateManyUserRequest = {\n    bodyAuthLevel;\n    bodyEmail;\n    bodyPassword;\n    bodyPhon;\n    bodyUserStatus: number;\n};\nexport const UpdateManyUserRequestConvert = {\n    bodyAuthLevel;\n    bodyEmail;\n    bodyPassword;\n    bodyPhon;\n    bodyUserStatus: number,\n};\nexport type UpdateManyUserRequest = {\n    bodyAuthLeve;\n    bodyUsername: string;\n};\nexport const UpdateManyUserRequestConvert = (body, query) => {\n    return {\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password;\n};\nexport const UpdateOneUserRequestConvert = (body: UpdateOneUserRequest, query: Query) => {\n    return {\n        pathId: parseInt(query.pathId),\n        bodyAuthLevel: parseInt(body.bodyAuthLevel),\n        bodyEmail: body.bodyEmail,\n        bodyPassword, query: body,\n    };\n};\nexport type UpdateManyUserRequest = {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhon: string;\n    bodyUserStatus: number;\n};\nexport typ, path: UpdateManyUserRequest = {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhon: string;\n    bodyUserStatus: number;\n};\nexport const UpdateManyUsersRequestConvert = (body): UpdateManyUserRequest => {\n    return {\n        bodyAuthLevel: parseInt(body.bodyAuthLevel),\n        bodyEmail: body.bodyEmail,\n        bodyPassword: body.bodyPassword,\n        bodyPhon: body.bodyPhon,\n        bod => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmail: body.email,\n        bodyPassword: body.password,\n        bodyPhone: body.phone,\n        bodyUserStatus: parseInt(body.userStatus),\n        bodyUsername: body.username,\n    };\n};\nexport type CreateManyUsersRequest = {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhon: string;\n    bodyUserStatus: number;\n    bodyUsername: string;\n};\nexport const CreateManyUsersRequestConvert = (body, query) =>;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhon: string;\n    bodyUserStatus: number;\n    bodyUsername: string;\n    bodyAuthLevel: number;\n    bodyUsername: string;\n};\nexport type CreateManyUsersRequestConvert;\n    bodyPassword: string;\n    bodyPhon: string;\n    bodyUserStatus: number;\n    bodyUsername: string;\n    bodyPhone: string;\n    bodyAuthLevel: number;\n    bodyUsername: string;\n    bodyUserStatus: number;\n    bodyUsername: string;\n};\nexport type UpdateManyUsersRequest = {\n    bodyAuthLevel: number;\n    bodyEmail: string;\n    bodyPassword: string;\n    bodyPhon: string;\n    bodyUserStatus: number;\n    bodyUsername: string;\n};\nexport const UpdateManyUsersRequestConvert = (body, query, path) => {\n    return {\n        pathId: parseInt(path.id),\n        bodyAuthLevel: parseInt(body.authLevel),\n        bodyEmai;\n};\nexport const CreateManyUsersRequestConvert = (body: CreateManyUsersRequest, query: string, query: string, path: string): UpdateManyUsersRequestConvert => {\n    const arrayBody = body.map((e: CreateManyUsersRequest): UpdateManyUsersRequestConvert => {\n        return {\n            bodyAuthLevel: parseInt(e.authLevel),\n            bodyEmail: e.email,\n            bodyPassword: e.password,\n            bodyPhon: e.phone,\n            bodyUserStatus => {\n        return {\n            bodyAuthLevel: parseInt(e.authLevel),\n            bodyEmail: e.email,\n            bodyPassword: e.password,\n            bodyPhone: e.phone,\n            bodyUserStatus: parseInt(e.userStatus),\n            bodyUsername: e.username,\n        };\n    });\n    return arrayBody;\n};\n","score":202,"fallbacked":false,"num_type_errors":307}]}
{"dataset_elem":{"alphanum_fraction":0.6224561404,"avg_line_length":21.4285714286,"content":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * 任务存放的数据结构\n * 类似小顶堆 将heap中最小的节点放在第一个\n * @flow strict\n */\n\nexport type Heap = Array<Node>\nexport type Node = {\n  id: number\n  sortIndex: number\n}\n\n/**\n * push一个任务\n * 先将任务放在队列末尾\n * 然后进行二分遍历，将最小的任务放在第一个\n */\nexport function push(heap: Heap, node: Node): void {\n  const index = heap.length\n\n  heap.push(node)\n  siftUp(heap, node, index)\n}\n\n// 查看小顶堆的第一个任务\nexport function peek(heap: Heap): Node | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\n// 推出第一个任务\nexport function pop(heap: Heap): Node | null {\n  if (heap.length === 0) {\n    return null\n  }\n\n  const first = heap[0]\n  const last = heap.pop() as Node\n\n  if (last !== first) {\n    heap[0] = last\n    siftDown(heap, last, 0)\n  }\n\n  return first\n}\n\n/**\n * 上浮元素\n * 确保队列的第一个始终是sortIndex最小的\n *\n * 之所以不将入队的node直接和head[0]进行比较\n * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历\n */\nfunction siftUp(heap: Heap, node: Node, i: number) {\n  let index = i\n\n  while (index > 0) {\n    // 获取队列中0到index的二分位置\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n\n    /**\n     * 如果中间位置的node和需要入队的node compare结果为正\n     * 则表明需要入队的node需要继续往前移动\n     * index为2或者1的时候 parentIndex会为0\n     * 这样就比较了需要入队的node和head[0]\n     */\n    if (compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      heap[index] = parent\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\n/**\n * 通过小顶堆寻找队列中最小的最小的\n * 确保队列的第一个始终是sortIndex最小的\n */\nfunction siftDown(heap: Heap, node: Node, i: number) {\n  let index = i\n\n  debugger\n  const length = heap.length\n  const halfLength = length >>> 1\n\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compare(left, node) < 0) {\n      // 先找到右子树中最小的\n      if (rightIndex < length && compare(right, left) < 0) {\n        heap[index] = right\n        heap[rightIndex] = node\n        index = rightIndex\n      } else {\n        // 右子树中最小的找到以后 再来比较左子树\n        heap[index] = left\n        heap[leftIndex] = node\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compare(right, node) < 0) {\n      heap[index] = right\n      heap[rightIndex] = node\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n\n// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id\nfunction compare(a: Node, b: Node) {\n  // Compare sort index first, then task id.\n  const diff = a.sortIndex - b.sortIndex\n\n  return diff !== 0 ? diff : a.id - b.id\n}\n","content_without_annotations":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * 任务存放的数据结构\n * 类似小顶堆 将heap中最小的节点放在第一个\n * @flow strict\n */\n\nexport type Heap = Array<Node>\nexport type Node = {\n  id\n  sortIndex\n}\n\n/**\n * push一个任务\n * 先将任务放在队列末尾\n * 然后进行二分遍历，将最小的任务放在第一个\n */\nexport function push(heap, node) {\n  const index = heap.length\n\n  heap.push(node)\n  siftUp(heap, node, index)\n}\n\n// 查看小顶堆的第一个任务\nexport function peek(heap) {\n  return heap.length === 0 ? null : heap[0]\n}\n\n// 推出第一个任务\nexport function pop(heap) {\n  if (heap.length === 0) {\n    return null\n  }\n\n  const first = heap[0]\n  const last = heap.pop() as Node\n\n  if (last !== first) {\n    heap[0] = last\n    siftDown(heap, last, 0)\n  }\n\n  return first\n}\n\n/**\n * 上浮元素\n * 确保队列的第一个始终是sortIndex最小的\n *\n * 之所以不将入队的node直接和head[0]进行比较\n * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历\n */\nfunction siftUp(heap, node, i) {\n  let index = i\n\n  while (index > 0) {\n    // 获取队列中0到index的二分位置\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n\n    /**\n     * 如果中间位置的node和需要入队的node compare结果为正\n     * 则表明需要入队的node需要继续往前移动\n     * index为2或者1的时候 parentIndex会为0\n     * 这样就比较了需要入队的node和head[0]\n     */\n    if (compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      heap[index] = parent\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\n/**\n * 通过小顶堆寻找队列中最小的最小的\n * 确保队列的第一个始终是sortIndex最小的\n */\nfunction siftDown(heap, node, i) {\n  let index = i\n\n  debugger\n  const length = heap.length\n  const halfLength = length >>> 1\n\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compare(left, node) < 0) {\n      // 先找到右子树中最小的\n      if (rightIndex < length && compare(right, left) < 0) {\n        heap[index] = right\n        heap[rightIndex] = node\n        index = rightIndex\n      } else {\n        // 右子树中最小的找到以后 再来比较左子树\n        heap[index] = left\n        heap[leftIndex] = node\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compare(right, node) < 0) {\n      heap[index] = right\n      heap[rightIndex] = node\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n\n// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  const diff = a.sortIndex - b.sortIndex\n\n  return diff !== 0 ? diff : a.id - b.id\n}\n","dynamism_density":0.0010040161,"dynamism_heuristic":1,"estimated_tokens":996,"ext":"ts","fun_ann_density":0.0180722892,"function_parameters":12,"function_signatures":0,"function_usages":5,"functions":6,"hexsha":"f6127d3ca25913df8797295ddc538560f5ecbd34","lang":"TypeScript","loc":72,"loc_per_function":9.1666666667,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"05cc4106d3380e2dda5c327f4828145ba1bb6747","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"awefeng/fe-demo","max_forks_repo_path":"src/views/minHeap/minHeap.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"05cc4106d3380e2dda5c327f4828145ba1bb6747","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"awefeng/fe-demo","max_issues_repo_path":"src/views/minHeap/minHeap.ts","max_line_length":76,"max_stars_count":3.0,"max_stars_repo_head_hexsha":"05cc4106d3380e2dda5c327f4828145ba1bb6747","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"awefeng/fe-demo","max_stars_repo_path":"src/views/minHeap/minHeap.ts","max_stars_repo_stars_event_max_datetime":"2022-03-28T09:09:46.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-04T05:55:34.000Z","metric":0.2624370344,"predefined_density":0.1470588235,"predefined_types":5,"prop_ann_density":0.0020080321,"property_declarations":2,"size":2850,"trivial_density":0.0,"trivial_types":0,"type_definitions":2,"typedef_density":0.0020080321,"var_ann_density":0.0140562249,"variable_declarations":14},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * 任务存放的数据结构\n * 类似小顶堆 将heap中最小的节点放在第一个\n * @flow strict\n */\nexport type Heap = Array<Node>;\nexport type Node = {\n    id: string;\n    sortIndex: number;\n    key: string | number | boolean | null;\n    type: string;\n    /**\n     * 任务状态\n     * 0-初始状态\n     * 1- 已经完成的任务;\n    sortIndex: number;\n    */\n    status: number;\n    /**\n     * 任务是否完成\n     */\n    done: boolean;\n    /**\n     * 任务是否被取消\n     */\n    cancel: boolean;\n    /**\n     * 任务是否被抛;\n};\n/**\n * push一个任务\n * 先将任务放在队列末尾\n * 然后进行二分遍历，将最小的任务放在第一个\n */\nexport function push(heap: Heap, node: Node): void {\n    heap.push(node);\n    siftUp(heap, node, heap.length - 1);\n}\n/**\n * 将任务从队列移除\n * 从队列的第一个元素开, node: 任务\n */\nexport function pop(heap: Heap, node: Node): Node {\n    if (heap.length === 0) {\n        return null;\n    }\n    const last = heap[0] as Node;\n    heap[): Node;\n    }\n    const first = heap[0] as Node;\n    heap[0] = last;\n    siftDown(heap, last, 0);\n    return first;\n}\n/**\n * 将节点的 sortInde {\n    const index = heap.length;\n    heap.push(node);\n    siftUp(heap, node, index);\n}\n// 查看小顶堆的第一个任务\nexport function peek(heap: Heap): Node {\n//     if (heap.length === 0) {\n//         return null;\n//     }\n//     const index = heap.length - 1;\n//     const node = heap[index]): Node;\n//     if (node.sortIndex > index) {\n//         siftDown(heap, node, index);\n//     }\n//     return node;\n// }\n/**\n * 二分查找 {\n    return heap.length === 0 ? null : heap[0];\n}\n// 推出第一个任务\nexport function pop(heap: Heap, node: Node): Node {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0] as Node;\n    heap[0] = node;\n    siftDown(hea): Node;\n}\n */\nfunction siftDown(heap: Heap, node: Node, index: number) {\n    let childIndex = 2 * index + 1;\n    if (childIndex < heap.length) { {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    const last = heap.pop() as Node;\n    if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n    }\n    return first;\n}\n/**\n * 上浮元素\n * 确保队列的第一个始终是sortIndex最小的\n *\n * 之所以不将入队的node直接和head[0]进行比较\n * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历\n */\nfunction siftUp(heap: Heap, node: Node, index: number) {\n    const rootIndex = 0;\n    while (index > rootIndex) {\n    const parentIndex = (index - 1) >>> 1;\n    const parent = heap[paren, node: ] as Node;\n    if (compare(node, parent) >= 0) {\n        return;\n    }\n    heap[parentIndex] = node;\n    heap[index] = parent;\n    index = parentIndex;\n}, i: number;\n}\n/**\n * 取出最小元素\n * @param heap\n */\nfunction extractMin(heap: Heap) {\n    const min = heap[0];\n    heap[0] = heap.pop() as Nod): Node;\n    siftDown(heap, min, 0);\n    return min;\n}\nexport function heapSort(heap: Heap): Heap {\n    for (let i = heap.length / 2; i >= 0 {\n    let index = i;\n    while (index > 0) {\n        // 获取队列中0到index的二分位置\n        const parentIndex = (index - 1) >>> 1;\n        const parent = heap[parentIndex];\n        /**\n         * 如果中间位置的node和需要入队的node compare结果为正\n         * 则表明需要入队的node需要继续往前移动\n         * index为2或者1的时候 parentIndex会为0\n         * 这样就比较了需要入队的node和head[0]\n         */\n        if (compare(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            heap[index] = parent;\n            index = parentIndex;\n        }\n        else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\n/**\n * 通过小顶堆寻找队列中最小的最小的\n * 确保队列的第一个始终是sortIndex最小的\n */\nfunction siftDown(heap: Heap, node: Node, i: number) {\n    let index = i;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while (index < halfLength) {\n        // 获取队列中, node: index的二分位置\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[righ, i: ];\n        // 如果left或right节点的compare结果为负，则退出\n        if (leftIndex >= length || compare(left, node) < 0) {\n            return;\n        }\n        else if (rightIndex < length && compar): {\n            if (compare(node, right) < 0) {\n                heap[nodeIndex] = right;\n            }\n            else {\n                heap[nodeIndex] = left;\n            }\n            nodeIndex = rightIndex;\n            index {\n    let index = i;\n    debugger;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while (index < halfLength) {\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (compare(left, node) < 0) {\n            // 先找到右子树中最小的\n            if (rightIndex < length && compare(right, left) < 0) {\n                heap[index] = right;\n                heap[rightIndex] = node;\n                index = rightIndex;\n            }\n            else {\n                // 右子树中最小的找到以后 再来比较左子树\n                heap[index] = left;\n                heap[leftIndex] = node;\n                index = leftIndex;\n            }\n        }\n        else if (rightIndex < length && compare(right, node) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n        }\n        else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\n// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id\nfunction compare(a: ITaskNode, b: ITaskNode): number {\n    return a.id - b.id;\n}\nfunction compare(a: ITaskNode, b: ITaskNode): number {\n    return a.sortIndex - b.sortIndex;\n}\nfunction compare(a: ITaskNode, b: ITaskNode): number {\n    // Compare sort index first, then task id.\n    const diff = a.sortIndex - b.sortIndex;\n    return diff !== 0 ? diff : a.id - b.id;\n}\n","score":254,"fallbacked":false,"num_type_errors":50},{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * 任务存放的数据结构\n * 类似小顶堆 将heap中最小的节点放在第一个\n * @flow strict\n */\nexport type Heap = Array<Node>;\nexport type Node = {\n    id: number;\n    sortIndex: number;\n    children: Heap;\n};\n/**\n * 将子节点添加到父节点的子节点中\n */\nfunction addChildren(heap: Heap, index: number, children: Heap) {\n    fo;\n    sortIndex: number;\n    // 数组是升序的\n    if (children.length > 0) {\n        const childIndex = index << 1;\n        const child = children[0];\n        addChildren(heap, childIndex, child;\n};\n/**\n * push一个任务\n * 先将任务放在队列末尾\n * 然后进行二分遍历，将最小的任务放在第一个\n */\nexport function push(heap: Heap, node: Node) {\n    const index = heap.length;\n    heap.push(node);\n    // 二分查找，将最小的放在第一个\n    const left = index << 1;\n    const right = index, node: Node;\n    sortIndex: number;\n    if (left < heap.length) {\n        node: Node;\n        node = heap[left];\n        sortIndex = node.sortIndex;\n    } else {\n        sortIndex = node.sor): number;\n    }\n    if (right < heap.length) {\n        node: Node;\n        node = heap[right];\n        sortIndex = node.sortIndex;\n    } else {\n        sortIndex = node.sor: number; {\n    const index = heap.length;\n    heap.push(node);\n    siftUp(heap, node, index);\n}\n// 查看小顶堆的第一个任务\nexport function peek(heap: Heap): Node | undefined {\n    if (heap.length === 0) {\n        return undefined;\n    }\n    const first = heap[0];\n    return first;\n}\n/**\n * 将任务放在队列末尾): 小顶堆\n * 非递归实现\n */\nfunction siftDown(heap: Heap, node: Node, i: number) {\n    let index = i;\n    while ((index = index << 1) < heap {\n    return heap.length === 0 ? null : heap[0];\n}\n// 推出第一个任务\nexport function pop(heap: Heap): Node | undefined {\n    if (heap.length === 0) {\n        return undefined;\n    }\n    const last = heap[heap.length - 1] as Node;\n    if (last.sortIndex > node.sor): {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n    }\n    return last;\n}\n/**\n * 将任务放在队列末尾): 大顶堆\n * {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    const last = heap.pop() as Node;\n    if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n    }\n    return first;\n}\n/**\n * 上浮元素\n * 确保队列的第一个始终是sortIndex最小的\n *\n * 之所以不将入队的node直接和head[0]进行比较\n * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历\n */\nfunction siftUp(heap: Heap, node: Node, i: number) {\n    let index = i;\n    while (index > 0) {\n        // 获取队列中0到index的二分位置\n        const parentIndex = (index - 1) >>, node: Node;\n        node = heap[index];\n        const parentNode = heap[parentIndex];\n        if (compare(node, parentNode) < 0) {\n            heap[index] = parentNode;\n            siftUp(heap, parentNode, inde, i: number);\n        } else {\n            break;\n        }\n        index = parentIndex;\n    }\n}\n/**\n * 最小堆\n * 非递归实现\n */\nfunction minHeapify(heap: Heap, index: numbe): void {\n    const leftChildIndex = 2 * index + 1;\n    const rightChildIndex = 2 * index + 2;\n    const leftNode = heap[leftChildIndex] as Node;\n    const rightNode = hea {\n    let index = i;\n    while (index > 0) {\n        // 获取队列中0到index的二分位置\n        const parentIndex = (index - 1) >>> 1;\n        const parent = heap[parentIndex];\n        /**\n         * 如果中间位置的node和需要入队的node compare结果为正\n         * 则表明需要入队的node需要继续往前移动\n         * index为2或者1的时候 parentIndex会为0\n         * 这样就比较了需要入队的node和head[0]\n         */\n        if (compare(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            heap[index] = parent;\n            index = parentIndex;\n        }\n        else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\n/**\n * 通过小顶堆寻找队列中最小的最小的\n * 确保队列的第一个始终是sortIndex最小的\n */\nfunction siftDown(heap: Heap, node: Node, i: number) {\n    let index = i;\n    while (index * 2 + 1 < heap.length) {\n        const leftIndex = index * 2 + 1;\n        const left, node: Node;\n        node = heap[leftIndex];\n        if (leftIndex + 1 < heap.length && compare(node, heap[leftIndex + 1]) < 0) {\n            left = heap[leftIndex +, i: number];\n        }\n        else {\n            left = heap[leftIndex];\n        }\n        if (compare(node, left) < 0) {\n            heap[index] = left;\n            index = leftIndex;\n        }\n        else): {\n            break;\n        }\n    }\n}\n/**\n * 最小堆\n * 非递归实现\n */\nfunction buildMinHeap(nodes: Node[]): void {\n    let i = nodes.length - 1 {\n    let index = i;\n    debugger;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while (index < halfLength) {\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (compare(left, node) < 0) {\n            // 先找到右子树中最小的\n            if (rightIndex < length && compare(right, left) < 0) {\n                heap[index] = right;\n                heap[rightIndex] = node;\n                index = rightIndex;\n            }\n            else {\n                // 右子树中最小的找到以后 再来比较左子树\n                heap[index] = left;\n                heap[leftIndex] = node;\n                index = leftIndex;\n            }\n        }\n        else if (rightIndex < length && compare(right, node) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n        }\n        else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\n// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id\nfunction compare(a: Node, b: Node): number {\n    if (a.sortIndex === b.sortIndex) {\n        return a.id - b.id;\n    }\n    else {\n        return a.sortIndex - b.sortIndex;, b: a;\n    }\n}\n\nfunction buildMinHeap(nodes: Node[]): void {\n    // Build heap.\n    for (let i = Math.floor(nodes.length / 2) - 1; i >=): {\n        heap.push(nodes[i]);\n    }\n    // Heapify the heap.\n    for (let i = heap.length - 1; i > 0; i--) {\n        heapify(i, nodes); {\n    // Compare sort index first, then task id.\n    const diff = a.sortIndex - b.sortIndex;\n    return diff !== 0 ? diff : a.id - b.id;\n}\n","score":305,"fallbacked":false,"num_type_errors":61},{"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * 任务存放的数据结构\n * 类似小顶堆 将heap中最小的节点放在第一个\n * @flow strict\n */\nexport type Heap = Array<Node>;\nexport type Node = {\n    id: number;\n    sortIndex: number;\n};\n/**\n * 二分查找法\n * 时间复杂度：O(logN)\n * 空间复杂度：O(1)\n * @param hea;\n    sortIndex: 元素的排序索引\n */\nexport function binarySearch(heap: Heap, item: Node, startIndex = 0) {\n    const length = heap.length;\n    let index: number | null;\n    if (startIndex < length);\n};\n/**\n * push一个任务\n * 先将任务放在队列末尾\n * 然后进行二分遍历，将最小的任务放在第一个\n */\nexport function push(heap: Heap, node: Node) {\n    const index = heap.length;\n    heap.push(node);\n    /**\n     * 找到插入位置\n     * 确保队列的第一个始终是sortIndex最小的\n     */\n    le, node: Node;\n    if (index > 0) {\n        // 确定index为奇数情况\n        if (compare(node, heap[index - 1]) < 0) {\n            heap[index] = node;): ;\n            siftDown(heap, node, index);\n            return;\n        }\n    }\n    /**\n     * 将最小的任务放在第一个\n     * 确保队列的第一个始终是sortIndex最小的\n     */\n    le {\n    const index = heap.length;\n    heap.push(node);\n    siftUp(heap, node, index);\n}\n// 查看小顶堆的第一个任务\nexport function peek(heap: Heap) {\n    return heap[0];\n}\n/**\n * 将node插入到指定位置\n * 1. 确保节点的sortIndex最小\n * 2. 将node放在队列末尾\n *): 如果节点已经在队列中，那么直接返回\n */\nexport function insert(heap: Heap, node: Node) {\n    const index = heap.length;\n    if (index > 0) {\n        if (compare(node {\n    return heap.length === 0 ? null : heap[0];\n}\n// 推出第一个任务\nexport function pop(heap: Heap) {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    const last = heap.pop() as Node;\n    if (last!== first) {\n        heap): ;\n        heap[0] = last;\n        siftDown(heap, last, 0);\n    }\n    return first;\n}\n/**\n * 交换两个元素\n * 1. 将node从队列中移除 {\n    if (heap.length === 0) {\n        return null;\n    }\n    const first = heap[0];\n    const last = heap.pop() as Node;\n    if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n    }\n    return first;\n}\n/**\n * 上浮元素\n * 确保队列的第一个始终是sortIndex最小的\n *\n * 之所以不将入队的node直接和head[0]进行比较\n * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历\n */\nfunction siftUp(heap: Heap, node: Node, i: number) {\n    const index = i;\n    while (index > 0) {\n        const parentIndex = (index - 1) >>> 1;\n        const parent = heap[parentIndex], node: Node = heap[index];\n        // 如果当前节点比上一个节点大，则将当前节点与上一个节点交换位置\n        if (compare(node, parent) < 0) {\n            heap[parentIndex] = nod, i: number;\n            siftDown(heap, node, index);\n        }\n        index = parentIndex;\n    }\n}\nfunction siftDown(heap: Heap, node: Node, i: number) {\n    const index = i): void {\n        const left = 2 * i + 1;\n        const right = 2 * i + 2;\n        const largestChildIndex = left;\n        if (right < heap.length && compare(heap[largestChildInde {\n    let index = i;\n    while (index > 0) {\n        // 获取队列中0到index的二分位置\n        const parentIndex = (index - 1) >>> 1;\n        const parent = heap[parentIndex];\n        /**\n         * 如果中间位置的node和需要入队的node compare结果为正\n         * 则表明需要入队的node需要继续往前移动\n         * index为2或者1的时候 parentIndex会为0\n         * 这样就比较了需要入队的node和head[0]\n         */\n        if (compare(parent, node) > 0) {\n            // The parent is larger. Swap positions.\n            heap[parentIndex] = node;\n            heap[index] = parent;\n            index = parentIndex;\n        }\n        else {\n            // The parent is smaller. Exit.\n            return;\n        }\n    }\n}\n/**\n * 通过小顶堆寻找队列中最小的最小的\n * 确保队列的第一个始终是sortIndex最小的\n */\nfunction siftDown(heap: Heap, node: Node, i: number): void {\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n    const largestChildIndex = left;\n    if (right < hea, node: Node, heap: Heap): void {\n        // 如果右子树中最小的节点比自己小，则需要交换位置\n        if (compare(heap[largestChildIndex], node) > 0) {\n            heap[largestChil, i: number];\n            siftDown(heap, node, largestChildIndex);\n        }\n    }\n}\n}\nfunction heapSort(arr: number[]): number[] {\n    // 生成最小堆\n    const heap: Heap = createHea): Heap {\n        let index = 0;\n        for (let i = arr.length - 1; i >= 0; i--) {\n            siftDown(heap, arr[index], index);\n            index++;\n        }\n        retur {\n    let index = i;\n    debugger;\n    const length = heap.length;\n    const halfLength = length >>> 1;\n    while (index < halfLength) {\n        const leftIndex = (index + 1) * 2 - 1;\n        const left = heap[leftIndex];\n        const rightIndex = leftIndex + 1;\n        const right = heap[rightIndex];\n        // If the left or right node is smaller, swap with the smaller of those.\n        if (compare(left, node) < 0) {\n            // 先找到右子树中最小的\n            if (rightIndex < length && compare(right, left) < 0) {\n                heap[index] = right;\n                heap[rightIndex] = node;\n                index = rightIndex;\n            }\n            else {\n                // 右子树中最小的找到以后 再来比较左子树\n                heap[index] = left;\n                heap[leftIndex] = node;\n                index = leftIndex;\n            }\n        }\n        else if (rightIndex < length && compare(right, node) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n        }\n        else {\n            // Neither child is smaller. Exit.\n            return;\n        }\n    }\n}\n// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id\nfunction compare(a: HeapNode, b: HeapNode) {\n    return a.sortIndex - b.sortIndex;\n}\n}\nfunction siftDown(heap: Heap, node: HeapNode, sortIndex: number) {\n    // Find th, b: th是当前节点的索引, b是父节点索引\n    let th = sortIndex;\n    let b = parentIndex(sortIndex);\n    if (b < 0) {\n        return;\n    }\n    else if (compare(nod): = 0) {\n        return;\n    }\n    else if (compare(nod, heap[b]) >= 0) {\n        return;\n    }\n    else {\n        heap[th] = heap[b];\n        heap[b {\n    // Compare sort index first, then task id.\n    const diff = a.sortIndex - b.sortIndex;\n    return diff !== 0 ? diff : a.id - b.id;\n}\n","score":321,"fallbacked":false,"num_type_errors":95}]}
{"dataset_elem":{"alphanum_fraction":0.5418147358,"avg_line_length":30.476534296,"content":"\n/**\n * Add integers, wrapping at 2^32.\n * This uses 16-bit operations internally to work around bugs in interpreters.\n *\n * @param {number} x First integer\n * @param {number} y Second integer\n * @returns {number} Sum\n */\nfunction safeAdd(x: number, y: number) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xffff);\n}\n\n/**\n * Bitwise rotate a 32-bit number to the left.\n *\n * @param {number} num 32-bit number\n * @param {number} cnt Rotation count\n * @returns {number} Rotated number\n */\nfunction bitRotateLeft(num: number, cnt: number) {\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} q q\n * @param {number} a a\n * @param {number} b b\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5cmn(q: number, a: any, b: any, x: any, s: any, t: any) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ff(a: number, b: number, c: number, d: number, x: any, s: number, t: number) {\n  return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5gg(a: number, b: number, c: number, d: number, x: any, s: number, t: number) {\n  return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5hh(a: number, b: number, c: number, d: number, x: any, s: number, t: number) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ii(a: number, b: number, c: number, d: number, x: any, s: number, t: number) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\n/**\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n *\n * @param {Array} x Array of little-endian words\n * @param {number} len Bit length\n * @returns {Array<number>} MD5 Array\n */\nfunction binlMD5(x: any, len: number) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  let i, olda, oldb, oldc, oldd;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (i = 0; i < x.length; i += 16) {\n    olda = a;\n    oldb = b;\n    oldc = c;\n    oldd = d;\n\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n  return [a, b, c, d];\n}\n\n/**\n * Convert an array of little-endian words to a string\n *\n * @param {Array<number>} input MD5 Array\n * @returns {string} MD5 string\n */\nfunction binl2rstr(input: string | any[]) {\n  let i;\n  let output = '';\n  const length32 = input.length * 32;\n  for (i = 0; i < length32; i += 8) {\n    output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff);\n  }\n  return output;\n}\n\n/**\n * Convert a raw string to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n *\n * @param {string} input Raw input string\n * @returns {Array<number>} Array of little-endian words\n */\nfunction rstr2binl(input: string) {\n  let i;\n  const output: any[] = [];\n  output[(input.length >> 2) - 1] = undefined;\n  for (i = 0; i < output.length; i += 1) {\n    output[i] = 0;\n  }\n  const length8 = input.length * 8;\n  for (i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;\n  }\n  return output;\n}\n\n/**\n * Calculate the MD5 of a raw string\n *\n * @param {string} s Input string\n * @returns {string} Raw MD5 string\n */\nfunction rstrMD5(s: string) {\n  return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n}\n\nfunction str2rstrUTF8(input: string | number | boolean) {\n  return unescape(encodeURIComponent(input));\n}\n\nfunction rawMD5(s: string) {\n  return rstrMD5(str2rstrUTF8(s));\n}\n\nfunction rstr2hex(input: string) {\n  const hexTab = '0123456789abcdef';\n  let output = '';\n  let x, i;\n  for (i = 0; i < input.length; i += 1) {\n    x = input.charCodeAt(i);\n    output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f);\n  }\n  return output;\n}\n\n/**\n * Encodes input string as Hex encoded string\n *\n * @param {string} s Input string\n * @returns {string} Hex encoded string\n */\nexport function hexMD5(s: string) {\n  return rstr2hex(rawMD5(s));\n}\n","content_without_annotations":"\n/**\n * Add integers, wrapping at 2^32.\n * This uses 16-bit operations internally to work around bugs in interpreters.\n *\n * @param {number} x First integer\n * @param {number} y Second integer\n * @returns {number} Sum\n */\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xffff);\n}\n\n/**\n * Bitwise rotate a 32-bit number to the left.\n *\n * @param {number} num 32-bit number\n * @param {number} cnt Rotation count\n * @returns {number} Rotated number\n */\nfunction bitRotateLeft(num, cnt) {\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} q q\n * @param {number} a a\n * @param {number} b b\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\n/**\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n *\n * @param {Array} x Array of little-endian words\n * @param {number} len Bit length\n * @returns {Array<number>} MD5 Array\n */\nfunction binlMD5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  let i, olda, oldb, oldc, oldd;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (i = 0; i < x.length; i += 16) {\n    olda = a;\n    oldb = b;\n    oldc = c;\n    oldd = d;\n\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n  return [a, b, c, d];\n}\n\n/**\n * Convert an array of little-endian words to a string\n *\n * @param {Array<number>} input MD5 Array\n * @returns {string} MD5 string\n */\nfunction binl2rstr(input) {\n  let i;\n  let output = '';\n  const length32 = input.length * 32;\n  for (i = 0; i < length32; i += 8) {\n    output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff);\n  }\n  return output;\n}\n\n/**\n * Convert a raw string to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n *\n * @param {string} input Raw input string\n * @returns {Array<number>} Array of little-endian words\n */\nfunction rstr2binl(input) {\n  let i;\n  const output = [];\n  output[(input.length >> 2) - 1] = undefined;\n  for (i = 0; i < output.length; i += 1) {\n    output[i] = 0;\n  }\n  const length8 = input.length * 8;\n  for (i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;\n  }\n  return output;\n}\n\n/**\n * Calculate the MD5 of a raw string\n *\n * @param {string} s Input string\n * @returns {string} Raw MD5 string\n */\nfunction rstrMD5(s) {\n  return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n}\n\nfunction str2rstrUTF8(input) {\n  return unescape(encodeURIComponent(input));\n}\n\nfunction rawMD5(s) {\n  return rstrMD5(str2rstrUTF8(s));\n}\n\nfunction rstr2hex(input) {\n  const hexTab = '0123456789abcdef';\n  let output = '';\n  let x, i;\n  for (i = 0; i < input.length; i += 1) {\n    x = input.charCodeAt(i);\n    output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f);\n  }\n  return output;\n}\n\n/**\n * Encodes input string as Hex encoded string\n *\n * @param {string} s Input string\n * @returns {string} Hex encoded string\n */\nexport function hexMD5(s) {\n  return rstr2hex(rawMD5(s));\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":4316,"ext":"ts","fun_ann_density":0.0143651529,"function_parameters":47,"function_signatures":0,"function_usages":14,"functions":15,"hexsha":"93e4c92cb6fa4c1a76b92200a9db5527df477966","lang":"TypeScript","loc":151,"loc_per_function":8.0666666667,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-01-05T03:43:01.000Z","max_forks_repo_forks_event_min_datetime":"2022-01-05T03:43:01.000Z","max_forks_repo_head_hexsha":"2933e5ab7a64c8be8e7fdf5f212cd6f9b00be57e","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"xwchris/mona","max_forks_repo_path":"packages/mona-commands/mona-build/src/utils/md5.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"2933e5ab7a64c8be8e7fdf5f212cd6f9b00be57e","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"xwchris/mona","max_issues_repo_path":"packages/mona-commands/mona-build/src/utils/md5.ts","max_line_length":90,"max_stars_count":null,"max_stars_repo_head_hexsha":"2933e5ab7a64c8be8e7fdf5f212cd6f9b00be57e","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"xwchris/mona","max_stars_repo_path":"packages/mona-commands/mona-build/src/utils/md5.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2202174535,"predefined_density":0.4698795181,"predefined_types":39,"prop_ann_density":0.0,"property_declarations":0,"size":8442,"trivial_density":0.1445783133,"trivial_types":12,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0048656163,"variable_declarations":21},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * Add integers, wrapping at 2^32.\n * This uses 16-bit operations internally to work around bugs in interpreters.\n *\n * @param {number} x First integer\n * @param {number} y Second integer\n * @returns {number} Sum\n */\nfunction safeAdd(x: number, y: number) {\n    return (x ^ y) + ((x & y) >> 1);\n}\n/**\n * Add integers, wrapping at 2^32.\n * This uses 16-bi, y: y = x + (2^32 - 1)\n * This uses 16-bit operations internally to work around bugs in interpreters.\n *\n * @param {number} x First integer\n * @param {numbe): number} 2^32\n * @returns {number} Sum\n */\nfunction safeAdd2(x: number, y: number) {\n    return (x ^ y) + ((x & y) >> 1); {\n    const lsw = (x & 65535) + (y & 65535);\n    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 65535);\n}\n/**\n * Bitwise rotate a 32-bit number to the left.\n *\n * @param {number} num 32-bit number\n * @param {number} cnt Rotation count\n * @returns {number} Rotated number\n */\nfunction bitRotateLeft(num: number, cnt: number) {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\n/**\n * Bitwise rotate a 32-bit number to the right.\n *\n * @para, cnt: Rotation count\n * @param {number} num 32-bit number\n * @returns {number} Rotated number\n */\nfunction bitRotateRight(num: number, cnt: number) {\n    return (num >>> cnt): number;\n}\n/**\n * Add integers, wrapping at 2^32.\n * This uses 16-bit operations internally to work around bugs in interpreters.\n *\n * @param {number} x First intege {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} q q\n * @param {number} a a\n * @param {number} b b\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5cmn(q: number, a: number, b: number, x: number, s: number, t: number) {\n    return safeAdd(safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, a: q)), s), b);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} q q\n * @param {number} a a\n * @param {number} b b\n *, b: number\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5gg(q: number, a, x: number, s: number, t: number) {\n    return md5cmn(q, a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {numbe, s: number} q q\n * @param {number} a a\n * @param {number} b b\n *, b: number\n * @param {number} x x\n * @param {number} s s\n * @param, t: t\n * @returns {number} Result\n */\nfunction md5hh(q: number, a: number, b: number, x: number, s: number, t: number) {\n    return md5cmn(): number;\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number, s: number} q q\n * @param {number} a a\n * @param {number} b b\n *, {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ff(a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return md5cmn(b & c | (b & d) | (c & d),, b: number): number;\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param, c: number\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction m, d: number, b: number, x: number, s: number, t: number) {\n    return md5cmn(b | c | d, a, b, x, s, t);\n}\n/**\n * Basic operatio, x: x, s: s, t: t\n *\n * @param {number} q q\n * @param {number} a a\n * @param {number} b b\n * @param {number} x x\n *, s: number\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ggx(q: number, a: number, b: number, x: number, s: number, t: numbe, t: number) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a): number\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @para {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5gg(a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return md5cmn(b | c | d, a, b, x, s, t), b: number;\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number, c: number} d d\n * @param {number, d: number} x x\n * @param {number, s: number} s s\n * @param {number, t: number} t t\n * @returns {number, d: number, b: number, x: number, s: number, t: number} Result\n */\nfunction md5gh(a: number, b: number, c: number, d: number, x: number, s: numbe, x: number, s: number, t: number) {\n    return md5cmn(b | c | d, a, b, x, s, t), b: number;\n}\n/**\n * Basic operation the algorithm uses, s: number, x: number, t: number\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number, d: number}, t: number\n * @param {number, s: number} x x\n * @param {number} s s\n * @returns {number, b: number, x: number, s: number} Result\n */\nfunction md5h): [number, number, number, number, number] {\n    return md5cmn((b & c) | (d & ~c), a, b, x, s, t), b: number;\n}\n/** {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5hh(a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return md5cmn(b | c | d, a, b, x, s, t), b: number;\n}\n/**\n * Basic operation the algorithm uses, s: number, x: number, t: number\n *\n * @param {number} a a\n * @param {number} b b\n * @param, c: number\n * @param {number, d: number}, t: number\n * @param {number, s: number} x x\n * @param {number} s s\n * @returns {number} Result\n */\nfunction m, d: number, b: number, c: number, x: number, s: number, t: number) {\n    return md5cmn((b & c) | (d & ~c), a, b, x, s,, x: number), b: number;\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n *, s: number\n * @param {number, x: number}, t: number\n * @param {number, b: number} x b\n * @returns {number} Result\n */\nfunction mxd(a: number, b: numbe, t: number, b: number, x: number, s: number) {\n    return md5cmn((b & x) | (~b & s), a, b, x, s, t), b: number;\n}\n/*): [number, number, number, number, number] */\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ii(a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t), b: number;\n}\n/**\n * Basic operation the algorithm uses, s: number, x: number, t: number\n *\n * @param {number} a a\n * @param {number} b b\n * @param, c: number\n * @param {number, d: number}, t: number\n * @param {number, x: number}, b: number\n * @returns {number} Result\n */\nfunction md5ixd(a: number, d: number, b: number, c: number, x: number, s: number, t: number) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t), b: number, x: number;\n}\n/**\n * Basic operation the algorithm uses, s: number, x: number, t: number\n *\n * @param {number} a a\n * @param {number} b b\n * @param, s: number, x: number, t: number\n * @param {number, b: number}, x b\n * @returns {number} Result\n */\nfunction md5isxb(a: number, b: number, x: numbe, t: number, s: number, x: number) {\n    return md5cmn(b ^ x, a, b, x, s, t), b: number;\n}\n/**\n * Basic operation the algorithm uses, s): number, x: number, b: number, d: number\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n/**\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n *\n * @param {Array} x Array of little-endian words\n * @param {number} len Bit length\n * @returns {Array<number>} MD5 Array\n */\nfunction binlMD5(x: Array<number>, len: number) {\n    if (len <= 0) {\n        return x;\n    }\n    let a: number, b: number, c: number, d: number, xl: number, xh: numbe, len: number, r: number, s: number, t: number;\n    for (r = 0; r < 16; r++) {\n        xl = x[r];\n        xh = xl >>> 16;\n        fo): (c = md5cmn(xh, xl, xh, x[r + 1], 7, -1272252783);\n        for (s = 0; s < len; {\n    /* append padding */\n    x[len >> 5] |= 128 << len % 32;\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\n    let i, olda, oldb, oldc, oldd;\n    let a = 1732584193;\n    let b = -271733879;\n    let c = -1732584194;\n    let d = 271733878;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return [a, b, c, d];\n}\n/**\n * Convert an array of little-endian words to a string\n *\n * @param {Array<number>} input MD5 Array\n * @returns {string} MD5 string\n */\nfunction binl2rstr(input: Array<number>) {\n    let i;\n    let output = \"\";\n    for (i = 0; i < input.length * 4; i++) {\n        if (i % 16 === 0) {\n            output +): string {\n            }\n        }\n        const word = input[i >> 2] >>> (i % 4) * 8 & 255;\n        output += word.toString(16);\n    }\n    return output; {\n    let i;\n    let output = \"\";\n    const length32 = input.length * 32;\n    for (i = 0; i < length32; i += 8) {\n        output += String.fromCharCode((input[i >> 5] >>> i % 32) & 255);\n    }\n    return output;\n}\n/**\n * Convert a raw string to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n *\n * @param {string} input Raw input string\n * @returns {Array<number>} Array of little-endian words\n */\nfunction rstr2binl(input: string) {\n    const output = [];\n    for (let i = 0; i < input.length * 32; i += 8) {\n        output[i >> 5] = input.charCodeAt(i /): 0;\n    }\n    return output;\n}\n/**\n * Calculate the MD5 of an array of little-endian words\n *\n * @param {Array<number>} x MD5 Array\n * @returns {Array<number> {\n    let i;\n    const output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n    }\n    const length8 = input.length * 8;\n    for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;\n    }\n    return output;\n}\n/**\n * Calculate the MD5 of a raw string\n *\n * @param {string} s Input string\n * @returns {string} Raw MD5 string\n */\nfunction rstrMD5(s: string) {\n    return binl2rstr(rstr2binl(rawMD5(s)));\n}\n/**\n * Encode a string using UTF-8 and return the result as a hex string\n *\n * @para): {string} s Input string\n * @returns {string} Hex encoded string\n */\nfunction rstr2hex(s: string) {\n    return rstr2hex(rawMD5(s));\n}\nfunction binl {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n}\nfunction str2rstrUTF8(input: string) {\n    let output = \"\";\n    for (let i = 0; i < input.length; i++) {\n        const c = input.charCodeAt(i);\n        if (c < 128) {\n            output +): = \"00\";\n        } else if (c < 2048) {\n            output += \":\";\n        } else if ((c & 0xFC00) === 0xD800 && (i + {\n    return unescape(encodeURIComponent(input));\n}\nfunction rawMD5(s: string): string {\n    return rstrMD5(s);\n}\nfunction binlMD5(input: string, length8) {\n    let output = \"\";\n    for (let i = 0; i < length8;): {\n        if (i % 16 === 0) {\n            output += rstr2hex(output);\n        }\n        const x = input.charCodeAt(i);\n        if (x < 128) {\n            output + {\n    return rstrMD5(str2rstrUTF8(s));\n}\nfunction rstr2hex(input: string) {\n    return rstr2hex(rawMD5(input));\n}\nfunction binl2rstr(input: string): string {\n    return binl2rstr(binl2rstr(input));\n}\nfunction binlMD5(input: string, length8) {\n    let output = \"\";\n    for (let i = 0; {\n    const hexTab = \"0123456789abcdef\";\n    let output = \"\";\n    let x, i;\n    for (i = 0; i < input.length; i += 1) {\n        x = input.charCodeAt(i);\n        output += hexTab.charAt((x >>> 4) & 15) + hexTab.charAt(x & 15);\n    }\n    return output;\n}\n/**\n * Encodes input string as Hex encoded string\n *\n * @param {string} s Input string\n * @returns {string} Hex encoded string\n */\nexport function hexMD5(s: string): string {\n    return rstr2hex(rawMD5(s));\n}\nfunction binlMD5(input: string, length8) {\n    let output = \"\";\n    for (let i = 0; i < length {\n    return rstr2hex(rawMD5(s));\n}\n","score":169,"fallbacked":false,"num_type_errors":307},{"code":"/**\n * Add integers, wrapping at 2^32.\n * This uses 16-bit operations internally to work around bugs in interpreters.\n *\n * @param {number} x First integer\n * @param {number} y Second integer\n * @returns {number} Sum\n */\nfunction safeAdd(x: number, y: number): number {\n    const lsw = x + y;\n    const msw = x - y;\n    return lsw < 0? msw + 2147483647 :, y: lsw;\n}\n/**\n * Bitwise rotate a 32-bit number to the right.\n *\n * @param {number} num 32-bit number\n * @param {number} cnt Rotation count): count in the range 0 to 3\n * @returns {number} Rotated number\n */\nfunction bitRotateRight(num, cnt) {\n    return (num >> cnt) | (num << (32 - cnt)); {\n    const lsw = (x & 65535) + (y & 65535);\n    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 65535);\n}\n/**\n * Bitwise rotate a 32-bit number to the left.\n *\n * @param {number} num 32-bit number\n * @param {number} cnt Rotation count\n * @returns {number} Rotated number\n */\nfunction bitRotateLeft(num: number, cnt) {\n    return bitRotateRight(num, cnt);\n}\n/**\n * Compute the SHA-512 of an array of big-endian words, and a bit length.\n *\n * @param {Arra, cnt: number} Array of big-endian words\n * @param {number} cnt Bit length of the resulting hash\n * @returns {number} Hash value\n */\nfunction sha512(data: number[], cnt: number): number): number {\n    let lsw: number = 0;\n    let msw: number = 0;\n    for (let i = 0; i < cnt; i += 8) {\n        lsw = safeAdd(safeAd {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} q q\n * @param {number} a a\n * @param {number} b b\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5cmn(q: number, a: number, b: number, x: number, s: number, t: number) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t), a: a, b: b, x: x, s: s, t: t;\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b, b: b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @return, x: x\n */\nfunction md5cmn(a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return md5cmn((b & c, s: number), a, b, x, s, t), a: a, b: b, x: x, s: s, t: t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @para, t: t t\n * @param {number} q q\n * @param {number} a a\n * @param {number} b b\n * @param {number} x x\n * @param {number} s s\n *): number\n */\nfunction safeAdd(a: number, b: number) {\n    return a + b;\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @para {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ff(a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return md5cmn((b & c) | (~b & d), a, b, x, b: b, 0: s, 1: t)\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {numbe, c: c\n * @param {numbe, d: d} d\n * @param {numbe, x: x} x\n * @param {number} s s\n * @param {number} t t\n * @return, d: d\n */\nfunction md5gg(a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return md5cmn((b & d), x: x, b: b, c: c, s: s, t: t)\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b, s: s\n * @param {number} t t\n * @param {number} q q\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @return, t: t\n */\nfunction md5hh(a: number, b: number, s: number, t: number, q: number, x: number) {\n    return md5cmn((q & s), x: x,): t\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} x x\n * @param {number} {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5gg(a: number, b: number, c: number, d: number, x: number, s: number, t: number) {\n    return md5cmn((b & d), a: a, b: b, c: c, b: b: b, x: x, s: s, 0: t)\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b, c: c\n * @param {number} d d\n * @param {number} x x\n * @param {number} q q\n * @param {number} s s\n * @param {number} t t\n * @return, d: d\n */\nfunction md5hh(a: number, b: number, c: number, d: number, x: number, q: number) {\n    return md5cmn((q & c), x: x,, x: x, q: q, c: c, b: b)\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @para, s: s\n * @param {number} t t\n * @param {number} q q\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @retur, t: t\n */\nfunction md5ii(a: number, b: number, s: number, t: number, x: number) {\n    return md5cmn(b ^ x ^ t, a, b, x,): t\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @para, s: s\n * @param {number} t {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5hh(a: number, b: number, c: number, d: number, x: number, q: number, s: number) {\n    return md5cmn((q & c), x: x,, x: x, q: q, b: b)\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @para, s: s\n * @param {number}, c: c\n * @param {number} d d\n * @param {number} x x\n * @param {number} q q\n * @param {number} s s\n * @param {number} t t\n * @return, d: d\n */\nfunction md5ii(a: number, b: number, s: number, t: number, x: number, c: number) {\n    return md5cmn(b ^ x ^ t, a,, x: x, c: c, b: b)\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @para, s:, s: s\n * @param {number} q q\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction m, t: number, x: number, q: number, b: number, s: number) {\n    return md5cmn(q ^ b ^ x, a, b, x, s, t)\n}\n/**\n * Basic operatio): t: t\n *\n * @param {number} a a\n * @param {number} b b\n * @para, s: s\n * @param {number}, q q\n * @param {number} x x {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ii(a: number, b: number, c: number, d: number, x: number, q: number, s: number) {\n    return md5cmn((q & c), x: x,, x: x, q: q, b: b)\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number, c: c\n * @param {number} d d\n * @param {number} x x\n * @param {number}, q q\n * @param {number} s s\n * @param {number} t t\n * @return, d: d\n */\nfunction md5ii(a: number, b: number, c: number, d: number, x: number, q: number, s: number, t: number) {\n    return md5cmn(, x: x,, x: x, q: q, b: b, s: s, t: t)\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param, s: s\n * @param {number} q q\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction, t: number, x: number, q: number, b: number, s: number) {\n    return md5cmn(q ^ b ^ x, a, b, x, s, t)\n}\n/**\n * Basic operatio): t: t\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number}, q q\n * @param {number} x {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n/**\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n *\n * @param {Array} x Array of little-endian words\n * @param {number} len Bit length\n * @returns {Array<number>} MD5 Array\n */\nfunction binlMD5(x: Array<number>, len: number) {\n    /* append padding */\n    x[len >> 5] |= 128 << len % 32;\n    x[(((len + 64) >>> 9) <<, len: number) >>> 0] = len;\n    let i, olda, oldb, oldc, oldd;\n    let a = 1732584193;\n    let b = -271): number, b: number, c: number, d: number, x: number, s: number, t: number;\n    let l = x.length;\n    let W = new Array(80);\n    for (i = {\n    /* append padding */\n    x[len >> 5] |= 128 << len % 32;\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\n    let i, olda, oldb, oldc, oldd;\n    let a = 1732584193;\n    let b = -271733879;\n    let c = -1732584194;\n    let d = 271733878;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return [a, b, c, d];\n}\n/**\n * Convert an array of little-endian words to a string\n *\n * @param {Array<number>} input MD5 Array\n * @returns {string} MD5 string\n */\nfunction binl2rstr(input: Array<number>): string {\n    let i;\n    let output = \"\";\n    for (i = 0; i < input.length * 8; i += 8) {\n        output += String.fromCharCode((input[i >): input[i] >>> 0);\n        output += String.fromCharCode((input[i + 7] >>> 0) & 255);\n    }\n    return output;\n}\n/**\n * Convert a string to an arra {\n    let i;\n    let output = \"\";\n    const length32 = input.length * 32;\n    for (i = 0; i < length32; i += 8) {\n        output += String.fromCharCode((input[i >> 5] >>> i % 32) & 255);\n    }\n    return output;\n}\n/**\n * Convert a raw string to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n *\n * @param {string} input Raw input string\n * @returns {Array<number>} Array of little-endian words\n */\nfunction rstr2binl(input: string): Array<number> {\n    let i;\n    const length8 = input.length * 8;\n    const output = Array(length8);\n    let x = 0;\n    for (i = 0; i < lengt): {\n        x = input.charCodeAt(i) | (input.charCodeAt(i + 1) << 8) | (input.charCodeAt(i + 2) << 16) | (input.charCodeAt(i + {\n    let i;\n    const output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n    }\n    const length8 = input.length * 8;\n    for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;\n    }\n    return output;\n}\n/**\n * Calculate the MD5 of a raw string\n *\n * @param {string} s Input string\n * @returns {string} Raw MD5 string\n */\nfunction rstrMD5(s: string): string {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n}\nfunction binlMD5(x: Array<number>, length8): Array<number> {\n    const a = 1732584193;\n    const b = -271733879;\n    let c = -17325841 {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n}\nfunction str2rstrUTF8(input: string): string {\n    const output = \"\";\n    for (let i = 0; i < input.length; i++) {\n        output += String.fromCharCode(input.charCodeAt(i) & 255);\n    }\n    retur): string;\n    return output;\n}\nfunction binl2rstr(input: Array<number>): string {\n    let i;\n    const length8 = input.length * 8;\n    const output = [];\n    for ( {\n    return unescape(encodeURIComponent(input));\n}\nfunction rawMD5(s: string): string {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n}\nfunction rstr2MD5(s: string): string {\n    retur): string {\n    return rstrMD5(str2rstrUTF8(s));\n}\nfunction rstr2hex(input) {\n    const hexTab = \"0123456789abcdef\";\n    le {\n    return rstrMD5(str2rstrUTF8(s));\n}\nfunction rstr2hex(input: string): string {\n    const rstr = input;\n    let i;\n    const output = [];\n    output[(rstr.length >> 2) - 1] = undefined;\n    for (i = 0; i < output): {\n        output[i] = 0;\n    }\n    let x;\n    for (i = 0; i < rstr.length; i++) {\n        x = rstr.charCodeAt(i);\n        if (x < {\n    const hexTab = \"0123456789abcdef\";\n    let output = \"\";\n    let x, i;\n    for (i = 0; i < input.length; i += 1) {\n        x = input.charCodeAt(i);\n        output += hexTab.charAt((x >>> 4) & 15) + hexTab.charAt(x & 15);\n    }\n    return output;\n}\n/**\n * Encodes input string as Hex encoded string\n *\n * @param {string} s Input string\n * @returns {string} Hex encoded string\n */\nexport function hexMD5(s: string): string {\n    return rstr2hex(rawMD5(s));\n}\nfunction rawMD5(s: string): string {\n    return rstr2rstr(rstrMD5(str2rstrUTF): string);\n}\nfunction rstr2MD5(s: string): string {\n    retur): string {\n    return rstrMD5(str2rstrUTF8(s));\n}\nfunction rstr2hex(inpu {\n    return rstr2hex(rawMD5(s));\n}\n","score":185,"fallbacked":false,"num_type_errors":366},{"code":"/**\n * Add integers, wrapping at 2^32.\n * This uses 16-bit operations internally to work around bugs in interpreters.\n *\n * @param {number} x First integer\n * @param {number} y Second integer\n * @returns {number} Sum\n */\nfunction safeAdd(x: number, y: number): number {\n    return (x + y + 1) >>> 0;\n}\n/**\n * Bitwise rotate a 32-bit number to the right.\n *\n * @param {numbe, y: number} Rotate count, Integer\n * @returns {number} Rotated Integer\n */\nfunction rotateRight(x: number, cnt: number): number {\n    cnt = cnt % 32;\n    if (cnt < 0): cnt += 32;\n    return x << cnt | x >>> (32 - cnt);\n}\n/**\n * Rotate left 32 bits.\n *\n * @param {number} x Integer to rotate\n * @para {\n    const lsw = (x & 65535) + (y & 65535);\n    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 65535);\n}\n/**\n * Bitwise rotate a 32-bit number to the left.\n *\n * @param {number} num 32-bit number\n * @param {number} cnt Rotation count\n * @returns {number} Rotated number\n */\nfunction bitRotateLeft(num: number, cnt: number): number {\n    cnt = cnt % 32;\n    if (cnt < 0): cnt += 32;\n    return num >> cnt | num << (32 - cnt);\n}\n/**, cnt: number, x: number, y: number, z: number */\nfunction md5gg(cnt: number, x: number, y: number, z: number): number {\n    return rotateRight(safeAdd(safeAdd(rotat): safeAdd(safeAdd(z)), x), rotateRight(safeAdd(safeAdd(z)), y));\n}\n/**\n * Add two 32-bit numbers.\n *\n * @param {number} x First intege {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} q q\n * @param {number} a a\n * @param {number} b b\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5cmn(q: number, a: number, b: number, x: number, s: number, t: number): number {\n    return safeAdd(md5gg(a, b, x, s, t), q);\n}\n/**, a: number, b: number, x: number, s: number, t: number, q: number */\nfunction md5ggg(a: number, b: number, x: number, s: number, t: number,, b: number): number {\n    return md5cmn((b & s) | (~b & t), a, b, x, s, t);\n}\n/**\n * Add two 32-bit numbers.\n *, x: number, s: number, t: number, q: number\n */\nfunction md5ggg(x: number, s: number, t: number, q: number): number {\n    return md5ggg(x,, s: number, t: number,, b: number): number {\n        return md5ggg(x,, s: number, t: number,, b: number);\n    }\n}\n/**\n * Add two 32-bit numbers, t: number, x: number, s: number, q: number\n */\nfunction md5ggggg(x: number, s: number, q: number): number {\n    return md5ggg(x, s, q): number {\n        return md5ggggg(x, s, q);\n    }\n}\n/**\n * Add two 32-bit numbers, x: number, s: number, q: number\n */\nfunction md {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ff(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    return safeAdd(md5gg(a, b, x, s, t), c);, b: number, x: number, s: number, t: number {\n        return md5ff(a, b, c, d, x, s: number, t: number);\n    }\n}\n/**\n * Add two, c: number, b: number, x: number, s: number, t: number, q: number\n */\nfunction md5ggg(c: number, b: number, x: number, s: number, t: number, d: number): number {\n    return safeAdd(md5gg(c, b, x, s, t), d);\n}\n/**\n * Add two, c: number, b: number, x: number, s: number, x: number, s: number, q: number\n */\nfunction md5ggggg(c: number, b: number, x: number, s: number, q: number): number {\n    return safeAdd(md5gg, s: number, x: number, b: number, c: number): number {\n        return md5gggg(c, b, x, s, q);\n    }\n}\n/**\n * Add two, c: number, b, t: number, x: number, s: number, q: number\n */\nfunction md5ggg(c: number, b: number, x: number, s: number, q: number): number {\n    return safeAdd(m): number {\n        return md5gggg(c, b, x, s, q);\n    }\n}\n/**\n * Add two 32-bit numbers, x: number, s: number, q: number\n */ {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5gg(a: number, b: number, x: number, s: number, t: number): number {\n    return md5cmn(b ^ x ^ s, a, b, x, s, t);\n}\n/**\n * Basi, b: number, c: number, d: number, x: number, s: number, t: number, q: number\n */\nfunction md5gggg(b: number, c: number, d: number, x: number, c: number, q: number): number {\n    return md5gg(b: number, c: number, d: number, x: number, s: number, t: number, q: number);\n}\n/**\n * Bas, d: number, x: number, s: number, q: number\n */\nfunction md5gggg(d: number, x: number, s: number, q: number): number {\n    return md5gg(d: number, x: number, s: number, q: number): number {\n        return md5gggg(d: number, x: number, s: number, q: number);\n    }\n}\n/**\n * Basic operation the algorithm uses., s: number, q: number\n */\nfunction md5ggggg(d: number, x: number, s: number, q: number): number {\n    return md5gg(d: number, x: number, s: numbe, t: number, q: number): number {\n        return md5gggg(d: number, x: number, s: number, q: number);\n    }\n}\n/**\n * Bas, b: number, c: number): number, d: number, x: number, s: number, q: number\n */\nfunction md5ggggg(b: number, c: number): number {\n    return md5gg(b: number, c: numbe {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5hh(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    return md5cmn(b ^ x ^ t, a, b, x, s,, b: number);\n}\n/**\n * Bas, b: number, c: number, d: number): number, x: number, s: number, q: number\n */\nfunction md5hh(b: number, c, c: number, d: number, x: number, q: number): number {\n    return md5hh(b: number, c: number, d: number, x: number, s: number, q: number);\n}\n/*, d: number, x: number, s: number, q: number */\nfunction md5hhh(b: number, c: number, d: number, x: number, s: number, q: number): number {\n    return m, x: number, s: number, q: number, b: number, c: number, d: number {\n    return md5hh(b: number, c: number, d: number, x: number, s: number, q, s: number);\n}\nfunction md5hhhh(c: number, d: number, x: number, q: number): number {\n    return md5hh(c: number, d: number, x: number, q: numbe, t: number, q: number): number {\n    return md5cmn(q | ~b, a, b, x, s, t);\n}\n/**\n * Calculate the MD5 of an array of little-endian words, an): b: number, c: number, d: number\n *\n * @param {Array} x Array of little-endian words\n * @param {number} b B\n * @param {number} c C\n * @param {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n/**\n * Basic operation the algorithm uses.\n *\n * @param {number} a a\n * @param {number} b b\n * @param {number} c c\n * @param {number} d d\n * @param {number} x x\n * @param {number} s s\n * @param {number} t t\n * @returns {number} Result\n */\nfunction md5ii(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n    return md5cmn(b ^ c ^ d, a, b, x, s,, b: number);\n}\n/**\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n *\n * @param {Array} x Array of little-endian words\n * @param {number} le, c: Bit length\n * @returns {Array<number>} MD5 Array\n */\nfunction binlMD5(x: Array<number>, le: number) {\n    /* append padding */\n    x[le >> 5] |=, d: (len: number) => {\n        let l = x.length;\n        let v = 0;\n        for (let i = 0; i < l; i++) {\n            v |= x[i];\n        }\n        for, x: number, v: number {\n            return md5cmn(v, a, b, x, s, t);\n        }\n    };\n    x[((len + 64) >>> 9) << 4] = len;, s: number, t: number {\n        return md5cmn(v, a, b, x, s, t);\n    }\n}\n/**\n * Calculate the MD5 of a string, and a bit length.\n *, t: Bit length\n *\n * @param {string} s Input string\n * @param {number} c Bit length\n * @returns {Array<number>} MD5 Array\n */\nfunction binlMD5(s: string,): Array<number> {\n    /* append padding */\n    s = s.length + (s.length << 8) + (s.length << 16);\n    s = s + s;\n    let l = s.length {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n/**\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n *\n * @param {Array} x Array of little-endian words\n * @param {number} len Bit length\n * @returns {Array<number>} MD5 Array\n */\nfunction binlMD5(x: Array<number>, len: number) {\n    /* append padding */\n    x[len >> 5] |= 128 << len % 32;\n    x[(((len + 64) >>> 9) <<, len: number) {\n        let l = x.length;\n        let v = 0;\n        for (let i = 0; i < l; i++) {\n            v |= x[i];\n        }\n        return md5cmn): Array<number>;\n    }\n}\nfunction binlMD5(s: string): Array<number> {\n    return binlMD5(s.split(\"\").map(c => c.charCodeAt(0)));\n}\n/** {\n    /* append padding */\n    x[len >> 5] |= 128 << len % 32;\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\n    let i, olda, oldb, oldc, oldd;\n    let a = 1732584193;\n    let b = -271733879;\n    let c = -1732584194;\n    let d = 271733878;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return [a, b, c, d];\n}\n/**\n * Convert an array of little-endian words to a string\n *\n * @param {Array<number>} input MD5 Array\n * @returns {string} MD5 string\n */\nfunction binl2rstr(input: number[]): string {\n    let output: string = \"\";\n    for (let i = 0; i < input.length * 8; i += 8) {\n        if (i % 8 === 0) {\n            outpu): string = \"\";\n        }\n        if (input[i >> 5] >>> i % 32 === 0) {\n            outpu += String.fromCharCode((input[i >> 5] >>> (i % 32)) {\n    let i;\n    let output = \"\";\n    const length32 = input.length * 32;\n    for (i = 0; i < length32; i += 8) {\n        output += String.fromCharCode((input[i >> 5] >>> i % 32) & 255);\n    }\n    return output;\n}\n/**\n * Convert a raw string to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n *\n * @param {string} input Raw input string\n * @returns {Array<number>} Array of little-endian words\n */\nfunction rstr2binl(input: string): number[] {\n    let output: number[] = [];\n    let length8 = input.length * 8;\n    for (let i = 0; i < length8; i += 8) {\n        output[i >): number = 0;\n    }\n    for (let i = 0; i < length8; i += 8) {\n        const b8 = input.charCodeAt(i / 8);\n        if (b8 === 0 {\n    let i;\n    const output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        output[i] = 0;\n    }\n    const length8 = input.length * 8;\n    for (i = 0; i < length8; i += 8) {\n        output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;\n    }\n    return output;\n}\n/**\n * Calculate the MD5 of a raw string\n *\n * @param {string} s Input string\n * @returns {string} Raw MD5 string\n */\nfunction rstrMD5(s: string): string {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n}\nfunction binlMD5(x: number[], n: number)): number[] {\n    let a: number[] = [1732584193, -271733879, -1732584194, 271 {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));\n}\nfunction str2rstrUTF8(input: string): string {\n    let output: string = \"\";\n    for (let i = 0; i < input.length; i++) {\n        const charCode = input.charCodeAt(i);\n        if (charCode > 255): {\n            throw \"String too long for rstrMD5\";\n        }\n        output += rstr2hex(charCode.toString(16));\n    }\n    return output;\n}\nfunction binl2rstr(x: number[ {\n    return unescape(encodeURIComponent(input));\n}\nfunction rawMD5(s: string): string {\n    return rstrMD5(str2rstrUTF8(s));\n}\nfunction binl2rstr(input: number[]): string {\n    let output: string = \"\";\n    let length8 = inpu): string {\n    let i;\n    const output = [];\n    output[(input.length >> 2) - 1] = undefined;\n    for (i = 0; i < output.length; i += 1) {\n        outpu {\n    return rstrMD5(str2rstrUTF8(s));\n}\nfunction rstr2hex(input: string): string {\n    let output: string = \"\";\n    let x, i;\n    for (i = 0; i < input.length; i++) {\n        x = input[i];\n        output += hexTab.charAt((): string)\n            + hexTab.charAt((x >>> 4) & 15)\n            + hexTab.charAt(x & 15);\n    }\n    return output;\n}\nfunction rstr2binl(input {\n    const hexTab = \"0123456789abcdef\";\n    let output = \"\";\n    let x, i;\n    for (i = 0; i < input.length; i += 1) {\n        x = input.charCodeAt(i);\n        output += hexTab.charAt((x >>> 4) & 15) + hexTab.charAt(x & 15);\n    }\n    return output;\n}\n/**\n * Encodes input string as Hex encoded string\n *\n * @param {string} s Input string\n * @returns {string} Hex encoded string\n */\nexport function hexMD5(s: string): string {\n    return rstr2hex(rawMD5(s));\n}\n/**\n * Encodes input string as Base64 encoded string\n *\n * @param {string} s Input string\n * @returns): Base64 encoded string\n */\nexport function base64MD5(s: string): string {\n    return btoa(rawMD5(s));\n}\nexport function rstr2hex(input: string): string {\n    return rstr2hex(rawMD5(s));\n}\n","score":112,"fallbacked":false,"num_type_errors":515}]}
{"dataset_elem":{"alphanum_fraction":0.5456039441,"avg_line_length":31.2051282051,"content":"/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport function getArea(p: number[]): number {\n    if (p.length < 6) return 0\n    const l = p.length - 2\n    let sum = 0\n    for (let i = 0; i < l; i += 2) sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3])\n    sum += (p[0] - p[l]) * (p[l + 1] + p[1])\n    return -sum * 0.5\n}\n\nexport function triangulate(p: number[]): number[] {\n    const n = p.length >> 1\n    if (n < 3) return []\n    const tgs = []\n    const avl = []\n    for (let i = 0; i < n; i++) avl.push(i)\n\n    let i = 0\n    let al = n\n    while (al > 3) {\n        const i0 = avl[(i + 0) % al]\n        const i1 = avl[(i + 1) % al]\n        const i2 = avl[(i + 2) % al]\n\n        const ax = p[2 * i0],\n            ay = p[2 * i0 + 1]\n        const bx = p[2 * i1],\n            by = p[2 * i1 + 1]\n        const cx = p[2 * i2],\n            cy = p[2 * i2 + 1]\n\n        let earFound = false\n        if (convex(ax, ay, bx, by, cx, cy)) {\n            earFound = true\n            for (let j = 0; j < al; j++) {\n                const vi = avl[j]\n                if (vi == i0 || vi == i1 || vi == i2) continue\n                if (pointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false\n                    break\n                }\n            }\n        }\n        if (earFound) {\n            tgs.push(i0, i1, i2)\n            avl.splice((i + 1) % al, 1)\n            al--\n            i = 0\n        } else if (i++ > 3 * al) break // no convex angles :(\n    }\n    tgs.push(avl[0], avl[1], avl[2])\n    return tgs\n}\n\nfunction pointInTriangle(\n    px: number,\n    py: number,\n    ax: number,\n    ay: number,\n    bx: number,\n    by: number,\n    cx: number,\n    cy: number\n): boolean {\n    const v0x = cx - ax\n    const v0y = cy - ay\n    const v1x = bx - ax\n    const v1y = by - ay\n    const v2x = px - ax\n    const v2y = py - ay\n\n    const dot00 = v0x * v0x + v0y * v0y\n    const dot01 = v0x * v1x + v0y * v1y\n    const dot02 = v0x * v2x + v0y * v2y\n    const dot11 = v1x * v1x + v1y * v1y\n    const dot12 = v1x * v2x + v1y * v2y\n\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01)\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom\n\n    // Check if point is in triangle\n    return u >= 0 && v >= 0 && u + v < 1\n}\n\nfunction convex(ax: number, ay: number, bx: number, by: number, cx: number, cy: number): boolean {\n    return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0\n}\n","content_without_annotations":"/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport function getArea(p) {\n    if (p.length < 6) return 0\n    const l = p.length - 2\n    let sum = 0\n    for (let i = 0; i < l; i += 2) sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3])\n    sum += (p[0] - p[l]) * (p[l + 1] + p[1])\n    return -sum * 0.5\n}\n\nexport function triangulate(p) {\n    const n = p.length >> 1\n    if (n < 3) return []\n    const tgs = []\n    const avl = []\n    for (let i = 0; i < n; i++) avl.push(i)\n\n    let i = 0\n    let al = n\n    while (al > 3) {\n        const i0 = avl[(i + 0) % al]\n        const i1 = avl[(i + 1) % al]\n        const i2 = avl[(i + 2) % al]\n\n        const ax = p[2 * i0],\n            ay = p[2 * i0 + 1]\n        const bx = p[2 * i1],\n            by = p[2 * i1 + 1]\n        const cx = p[2 * i2],\n            cy = p[2 * i2 + 1]\n\n        let earFound = false\n        if (convex(ax, ay, bx, by, cx, cy)) {\n            earFound = true\n            for (let j = 0; j < al; j++) {\n                const vi = avl[j]\n                if (vi == i0 || vi == i1 || vi == i2) continue\n                if (pointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false\n                    break\n                }\n            }\n        }\n        if (earFound) {\n            tgs.push(i0, i1, i2)\n            avl.splice((i + 1) % al, 1)\n            al--\n            i = 0\n        } else if (i++ > 3 * al) break // no convex angles :(\n    }\n    tgs.push(avl[0], avl[1], avl[2])\n    return tgs\n}\n\nfunction pointInTriangle(\n    px,\n    py,\n    ax,\n    ay,\n    bx,\n    by,\n    cx,\n    cy\n) {\n    const v0x = cx - ax\n    const v0y = cy - ay\n    const v1x = bx - ax\n    const v1y = by - ay\n    const v2x = px - ax\n    const v2y = py - ay\n\n    const dot00 = v0x * v0x + v0y * v0y\n    const dot01 = v0x * v1x + v0y * v1y\n    const dot02 = v0x * v2x + v0y * v2y\n    const dot11 = v1x * v1x + v1y * v1y\n    const dot12 = v1x * v2x + v1y * v2y\n\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01)\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom\n\n    // Check if point is in triangle\n    return u >= 0 && v >= 0 && u + v < 1\n}\n\nfunction convex(ax, ay, bx, by, cx, cy) {\n    return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":1184,"ext":"ts","fun_ann_density":0.0168918919,"function_parameters":16,"function_signatures":0,"function_usages":2,"functions":4,"hexsha":"8b4ef4c0e38eb2eda855d4ccf784520014bf67eb","lang":"TypeScript","loc":77,"loc_per_function":15.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"ddd39c5ef8b5edf945b90adc4b37b48e4d0b3ac5","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"pmndrs/p2-es","max_forks_repo_path":"src/math/polyk.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"ddd39c5ef8b5edf945b90adc4b37b48e4d0b3ac5","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"pmndrs/p2-es","max_issues_repo_path":"src/math/polyk.ts","max_line_length":98,"max_stars_count":33.0,"max_stars_repo_head_hexsha":"ddd39c5ef8b5edf945b90adc4b37b48e4d0b3ac5","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"pmndrs/p2-es","max_stars_repo_path":"src/math/polyk.ts","max_stars_repo_stars_event_max_datetime":"2022-03-16T05:36:49.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-01T19:59:57.000Z","metric":0.3062366286,"predefined_density":0.3636363636,"predefined_types":20,"prop_ann_density":0.0,"property_declarations":0,"size":3651,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0295608108,"variable_declarations":35},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n*/\nexport function getArea(p: number[], p2: number[], p3: number[]) {\n    let s = 0;\n    const n = p.length >> 1;\n    for (let i = 0; i < n; i++) {\n        const): number[] = [p[2 * i], p[2 * i + 1]];\n        const v1 = p2[2 * i], v2 = p2[2 * i + 1];\n        const v3 = {\n    if (p.length < 6)\n        return 0;\n    const l = p.length - 2;\n    let sum = 0;\n    for (let i = 0; i < l; i += 2)\n        sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);\n    sum += (p[0] - p[l]) * (p[l + 1] + p[1]);\n    return -sum * 0.5;\n}\nexport function triangulate(p: number[], p2: number[], p3: number[]) {\n    if (p.length < 3)\n        return [];\n    const tri = [];\n    const n = p.length >> 1;\n    const v1 = p2): number[] = [p[2 * i], p[2 * i + 1]];\n    const v2 = p2[2 * n], v3 = p2[2 * n + 1];\n    let sum = {\n    const n = p.length >> 1;\n    if (n < 3)\n        return [];\n    const tgs = [];\n    const avl = [];\n    for (let i = 0; i < n; i++)\n        avl.push(i);\n    let i = 0;\n    let al = n;\n    while (al > 3) {\n        const i0 = avl[(i + 0) % al];\n        const i1 = avl[(i + 1) % al];\n        const i2 = avl[(i + 2) % al];\n        const ax = p[2 * i0], ay = p[2 * i0 + 1];\n        const bx = p[2 * i1], by = p[2 * i1 + 1];\n        const cx = p[2 * i2], cy = p[2 * i2 + 1];\n        let earFound = false;\n        if (convex(ax, ay, bx, by, cx, cy)) {\n            earFound = true;\n            for (let j = 0; j < al; j++) {\n                const vi = avl[j];\n                if (vi == i0 || vi == i1 || vi == i2)\n                    continue;\n                if (pointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false;\n                    break;\n                }\n            }\n        }\n        if (earFound) {\n            tgs.push(i0, i1, i2);\n            avl.splice((i + 1) % al, 1);\n            al--;\n            i = 0;\n        }\n        else if (i++ > 3 * al)\n            break; // no convex angles :(\n    }\n    tgs.push(avl[0], avl[1], avl[2]);\n    return tgs;\n}\nfunction pointInTriangle(px: number, py: number, ax: number, ay: number, bx: number, by: number, cx: number, cy: number) {\n    const v0x = cx - ax;\n    const v0y = cy - a, py: number;\n    const v1x = bx - ax;\n    const v1y = by - ay;\n    const v2x = px - ax;\n    const v2y = py - ay;\n    const dot00 = v, ax: number;\n    const dot01 = v0x, v1x: number;\n    const dot02 = v0x * v2x + v0y * v2y, ax: number;\n    const dot11, ay: number;\n    const dot12 = v1x * v2x + v1y * v2y;\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01), bx: number;\n    const invDenom1 = 1 / (dot00 * dot01 - dot01 * dot01), invDenom2 = 1 / (dot00 * dot12 - dot01, by: number;\n    let t0, t1, t2;\n    if ((-dot00 > dot01 * dot02 && -dot00 > dot02 * dot01) ||\n        (dot00 > do, cx: number; dot01 > do && cx > bx && cx > bx))\n        return false;\n    if ((-dot00 > dot11 * dot02 && -dot00 > dot02 * dot11) |, cy: number)\n        return false;\n    t0 = (dot00 * dot11 - dot01 * dot01) * invDenom;\n    if (t0 < 0)\n        return false;\n    t1 =): number;\n    if (t0 > 1)\n        return false;\n    t2 = (dot00 * dot02 - dot01 * dot01) * invDenom;\n    if (t2 < 0 {\n    const v0x = cx - ax;\n    const v0y = cy - ay;\n    const v1x = bx - ax;\n    const v1y = by - ay;\n    const v2x = px - ax;\n    const v2y = py - ay;\n    const dot00 = v0x * v0x + v0y * v0y;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    // Check if point is in triangle\n    return u >= 0 && v >= 0 && u + v < 1;\n}\nfunction convex(ax: number, ay: number, bx: number, by: number, cx: number, cy: number): boolean {\n    return (ay - by) * (cx - bx) > 0 && (bx - ax) * (cy, ay: number) > 0 && (by - ay) * (cy - by) > 0;\n}\nfunction isInsideTriangle(ax: number, ay: number, bx: number, by: number, cx: number, cy: number): boolean {\n    return isInsideTriangle2(ax, ay, bx, by, cx, cy);\n}\nfunction isInsideTriangle2(ax: number, ay: number, bx, cx: number, cy: number): boolean {\n    const dot00 = ax - bx;\n    const dot01 = ay - by;\n    const dot02 = cx - bx;\n    if (dot00 > dot01 * do, cy: number)\n        return false;\n    if ((-dot00 > dot11 * dot02 && -dot00 > dot02 * dot11) |, cy: number)\n        return false;\n    t0 =): number;\n    if (t0 < 0)\n        return false;\n    t1 = (dot00 * dot11 - dot01 * dot01) * invDenom;\n    if (t1 < 0 {\n    return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;\n}\n","score":317,"fallbacked":false,"num_type_errors":121},{"code":"/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n*/\nexport function getArea(p: [number, number, number, number], q: [number, number, number]) {\n    if (p.length < 6 || q.length < 6)\n        return 0;\n    const area = -getArea2): number => {\n        const a = getArea2(p, q, q[0], q[1]);\n        return a;\n    };\n    return area(p, q);\n}\nexport function getArea2(p: [numbe {\n    if (p.length < 6)\n        return 0;\n    const l = p.length - 2;\n    let sum = 0;\n    for (let i = 0; i < l; i += 2)\n        sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);\n    sum += (p[0] - p[l]) * (p[l + 1] + p[1]);\n    return -sum * 0.5;\n}\nexport function triangulate(p: [number, number, number, number], q: [number, number, number]) {\n    if (p.length < 3 || q.length < 3)\n        return [];\n    const triangulate = (p: number[]): [number[], number[], number[], number[], number[], number[]] => {\n        const triangulate = (p: number[]): [number[], number[], number[], number[], number[], number[], number[]] => {\n            const v {\n    const n = p.length >> 1;\n    if (n < 3)\n        return [];\n    const tgs = [];\n    const avl = [];\n    for (let i = 0; i < n; i++)\n        avl.push(i);\n    let i = 0;\n    let al = n;\n    while (al > 3) {\n        const i0 = avl[(i + 0) % al];\n        const i1 = avl[(i + 1) % al];\n        const i2 = avl[(i + 2) % al];\n        const ax = p[2 * i0], ay = p[2 * i0 + 1];\n        const bx = p[2 * i1], by = p[2 * i1 + 1];\n        const cx = p[2 * i2], cy = p[2 * i2 + 1];\n        let earFound = false;\n        if (convex(ax, ay, bx, by, cx, cy)) {\n            earFound = true;\n            for (let j = 0; j < al; j++) {\n                const vi = avl[j];\n                if (vi == i0 || vi == i1 || vi == i2)\n                    continue;\n                if (pointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false;\n                    break;\n                }\n            }\n        }\n        if (earFound) {\n            tgs.push(i0, i1, i2);\n            avl.splice((i + 1) % al, 1);\n            al--;\n            i = 0;\n        }\n        else if (i++ > 3 * al)\n            break; // no convex angles :(\n    }\n    tgs.push(avl[0], avl[1], avl[2]);\n    return tgs;\n}\nfunction pointInTriangle(px: number, py: number, ax: number, ay: number, bx: number, by: number, cx: number, cy: number) {\n    const v0x = cx - ax;\n    const v0y = cy - a, py: number;\n    const v1x = bx - ax;\n    const v1y = by - ay;\n    const v2x = px - ax;\n    const v2y = py - ay;\n    const dot00 = v, ax: number;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot, ay: number;\n    if (dot00 >= 0) {\n        if (dot01 >= 0) {\n            if (dot02 >= 0)\n                return true;\n        }\n    }\n    else if (dot01, bx: number) {\n        ay = 0;\n    }\n    else if (dot02 >= 0) {\n        ay = 0;\n    }\n    else {\n        ay = -v0y * v2x + v0x, by: number;\n    }\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n    i, cx: number;\n    if (dot11 >= 0) {\n        if (dot12 >= 0)\n            return true;\n    }\n    else if (dot12 >= 0) {\n        cx = 0;\n    }, cy: number;\n    else if (dot00 >= 0) {\n        cx = 0;\n    }\n    else {\n        cx = -v0x * v1y + v0y * v1x, cy: number;): number;\n    }\n    return false;\n}\nfunction isClockWise(p: number[], q: number[], r: number[]) {\n    const v0x = q[0] - p[0];\n    const v0y {\n    const v0x = cx - ax;\n    const v0y = cy - ay;\n    const v1x = bx - ax;\n    const v1y = by - ay;\n    const v2x = px - ax;\n    const v2y = py - ay;\n    const dot00 = v0x * v0x + v0y * v0y;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    // Check if point is in triangle\n    return u >= 0 && v >= 0 && u + v < 1;\n}\nfunction convex(ax: number, ay: number, bx: number, by: number, cx: number, cy: number): boolean {\n    return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) <, ay: number;\n}\nfunction inTriangle(ax: number, ay: number, bx: number, bx: number, by: number, cx: number, cy: number): boolean {\n    return isClockWise([ax, ay], [bx, by], [cx, cy]) || isClockWise([ax, ay], [bx, by], by: number) || isClockWise([ax, ay], bx: number, by: number) || isClockWise([ax, ay], bx: by: number, cx: number, cy: number);\n}\nfunction isInsideTriangle, cx: number, cy: number, px: number, py: number, ax: number, ay: number, bx: number, by: number): boolean {\n    return isInsideTriangle(cx, cy, px, py, ax, ay, cy: number) || isInsideTriangle(cx, cy: number, px, py, bx: number, by: number) || isInsideTriangle(cx, cy: number, px: bx: number, by: number) || isInsideTriangl): boolean {\n    return inTriangle(ax, ay, bx: bx, by: by, cx: cx, cy: cy);\n}\nfunction isClockWise(v0: number[], v1: number[], v2: number[ {\n    return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;\n}\n","score":193,"fallbacked":false,"num_type_errors":185},{"code":"/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n*/\nexport function getArea(p: number[], q: number[], r: number[]) {\n    const area = getArea2D(p, q, r);\n    if (area === undefined)\n        return undefined;\n    return area;\n}\nexport function getArea2): number {\n    if (p.length < 4)\n        return undefined;\n    let i = 0;\n    let j = 1;\n    let k = p.length - 2;\n    let sum = p[0] {\n    if (p.length < 6)\n        return 0;\n    const l = p.length - 2;\n    let sum = 0;\n    for (let i = 0; i < l; i += 2)\n        sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);\n    sum += (p[0] - p[l]) * (p[l + 1] + p[1]);\n    return -sum * 0.5;\n}\nexport function triangulate(p: number[], q: number[], r: number[]): number[] | undefined {\n    if (p.length < 4)\n        return undefined;\n    const area = getArea2D(p, q, r);\n    if (area ==): undefined {\n        return undefined;\n    }\n    let n = q.length >> 1;\n    const tgs = [];\n    const avl = [];\n    for (let i = 0; i < n; i++)\n        avl {\n    const n = p.length >> 1;\n    if (n < 3)\n        return [];\n    const tgs = [];\n    const avl = [];\n    for (let i = 0; i < n; i++)\n        avl.push(i);\n    let i = 0;\n    let al = n;\n    while (al > 3) {\n        const i0 = avl[(i + 0) % al];\n        const i1 = avl[(i + 1) % al];\n        const i2 = avl[(i + 2) % al];\n        const ax = p[2 * i0], ay = p[2 * i0 + 1];\n        const bx = p[2 * i1], by = p[2 * i1 + 1];\n        const cx = p[2 * i2], cy = p[2 * i2 + 1];\n        let earFound = false;\n        if (convex(ax, ay, bx, by, cx, cy)) {\n            earFound = true;\n            for (let j = 0; j < al; j++) {\n                const vi = avl[j];\n                if (vi == i0 || vi == i1 || vi == i2)\n                    continue;\n                if (pointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false;\n                    break;\n                }\n            }\n        }\n        if (earFound) {\n            tgs.push(i0, i1, i2);\n            avl.splice((i + 1) % al, 1);\n            al--;\n            i = 0;\n        }\n        else if (i++ > 3 * al)\n            break; // no convex angles :(\n    }\n    tgs.push(avl[0], avl[1], avl[2]);\n    return tgs;\n}\nfunction pointInTriangle(px: number, py: number, ax: number, ay: number, bx: number, by: number, cx: number, cy: number) {\n    return (cx - ax) * (px - ax) + (cy - ay, py: number) - (ax - bx) * (cx - bx) - (ay - by) * (cy - by) < 0;\n}\nfunction convex(ax: number, ay: number, bx: number, by, ax: number, ay: number, bx: number, by: number, cx: number, cy: number) {\n    return pointInTriangle(ax, ay, bx, by, cx, cy);\n}\nfunction convexPoints(points, ay: number, bx: number, by: number, cx: number, cy: number) {\n    const n = points.length;\n    if (n == 0)\n        return false;\n    let tgs: number[] = [];\n    fo, bx: any;\n    for (let i = 0; i < n; i++) {\n        const p = points[i];\n        if (convex(ax, ay, bx, by, cx, cy)) {\n            tgs.pus, by: any;\n            bx: any;\n        }\n    }\n    if (tgs.length == 3)\n        return true;\n    return false;\n}\nfunction convexPoints_2(points, ay: number, bx: number, b, cx: number, cy: number) {\n    const n = points.length;\n    if (n == 0)\n        return false;\n    let tgs: number[] = [];\n    fo: any;\n    for (let i = 0, cy: any; i < n; i++) {\n        fo = points[i];\n        for (let j = i + 1; j < n; j++) {\n            bx = points[j];\n            if (convex(ax, a): any {\n                tgs.push(fo, bx);\n                break fo;\n            }\n        }\n    }\n    if (tgs.length == 3)\n        return true;\n    return false;\n}\nfunction convexPoint(points {\n    const v0x = cx - ax;\n    const v0y = cy - ay;\n    const v1x = bx - ax;\n    const v1y = by - ay;\n    const v2x = px - ax;\n    const v2y = py - ay;\n    const dot00 = v0x * v0x + v0y * v0y;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    // Check if point is in triangle\n    return u >= 0 && v >= 0 && u + v < 1;\n}\nfunction convex(ax: number, ay: number, bx: number, by: number, cx: number, ay: number) {\n    return convexPoint(ax, ay, bx, by, cx, ay);\n}\nfunction convexPoints(points {\n    const n = points.length;\n    if (n == 0)\n        return false;, bx: any;\n    let tgs: number[] = [];\n    fo: any;\n    for (let i = 0, bx: any; i < n; i++) {\n        fo = points[i];\n        for (let j =, by: any; j < n; j++) {\n            bx = points[j];\n            if (convex(ax, ay, bx, by, cx, cy): any {\n                tgs.push(fo, bx);\n                break fo, cx: any;\n            }\n        }\n    }\n    if (tgs.length == 3)\n        return true;\n    return false;\n}\nfunction convexPoints3D(points {\n    const n = points.length;\n    if (, cy: any, bx: any, by: any, cx: any) {\n        let tgs: number[] = [];\n        fo: any;\n        for (let i = 0, cy: any; i < n; i++) {): any {\n            fo = points[i];\n            for (let j =, bx: any; j < n; j++) {\n                bx = points[j];\n                if (convexPoint3D(fo, bx, cy): an {\n    return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;\n}\n","score":243,"fallbacked":false,"num_type_errors":191}]}
{"dataset_elem":{"alphanum_fraction":0.6123662307,"avg_line_length":24.2596153846,"content":"/* Types */\n\ntype Tx<T> = () => Promise<T>;\ntype Cx = () => Promise<unknown>;\n\nexport class ReadOnly<T> {\n  constructor(public tx: Tx<T>) {}\n}\n\nexport class Mutating<T> {\n  constructor(public tx: Tx<T>, public cx: Cx) {}\n}\n\nexport class Pivot<T> {\n  constructor(public tx: Tx<T>) {}\n}\n\ntype Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;\n\nexport type Workflow = Generator<Step<any>, void, any>;\n\n/* Constructors */\n\nexport const readOnly = <T>(tx: Tx<T>): ReadOnly<T> => new ReadOnly<T>(tx);\n\nexport const mutating = <T>(tx: Tx<T>, cx: Cx): Mutating<T> =>\n  new Mutating<T>(tx, cx);\n\nexport const pivot = <T>(tx: Tx<T>): Pivot<T> => new Pivot<T>(tx);\n\n/* Workflow executor */\n\nexport async function run(workflow: Workflow): Promise<void> {\n  // a list of compensating functions\n  let cxs: Cx[] = [];\n  // a number of pivot operations happened during the workflow\n  let nPivots: number = 0;\n  // should the workflow be unrolled\n  let unrollReason: unknown;\n\n  let next: IteratorResult<Step<unknown>>;\n  let res: unknown;\n\n  try {\n    next = workflow.next();\n  } catch (e) {\n    unrollReason = e;\n  }\n\n  while (!unrollReason && !next!.done) {\n    const flow = next!.value;\n\n    try {\n      // execute async operation\n      res = await flow.tx();\n    } catch (e1) {\n      // async exception caught\n      try {\n        // try rethrowing into workflow -- this acquires a next workflow step;\n        // compensating operation is not added, because the atomic forward\n        // operation didn't succeed, so nothing to compensate\n        next = workflow.throw(e1);\n        continue;\n      } catch (e2) {\n        // rethrowing didn't succeed, unroll\n        unrollReason = e2;\n        break;\n      }\n    }\n\n    // async operation succeeds, register its aftereffects\n    if (flow instanceof Mutating) {\n      cxs.push(flow.cx);\n    } else if (flow instanceof Pivot) {\n      nPivots++;\n    }\n\n    // try acquiring next workflow step\n    try {\n      next = workflow.next(res);\n      continue;\n    } catch (e) {\n      // caught a sync exception that is not caught inside workflow, unroll\n      unrollReason = e;\n      break;\n    }\n  }\n\n  // unroll if error happened\n  if (unrollReason) {\n    // workflow is not revertible if there were completed pivot operations\n    if (nPivots) {\n      throw unrollReason;\n    }\n\n    for (const cx of cxs.reverse()) {\n      // compensating function error means the state is unknown\n      // this can only be handled by a caller, so no try-catch\n      await cx();\n    }\n    throw unrollReason;\n  }\n}\n","content_without_annotations":"/* Types */\n\ntype Tx<T> = () => Promise<T>;\ntype Cx = () => Promise<unknown>;\n\nexport class ReadOnly<T> {\n  constructor(public tx) {}\n}\n\nexport class Mutating<T> {\n  constructor(public tx, public cx) {}\n}\n\nexport class Pivot<T> {\n  constructor(public tx) {}\n}\n\ntype Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;\n\nexport type Workflow = Generator<Step<any>, void, any>;\n\n/* Constructors */\n\nexport const readOnly = <T>(tx) => new ReadOnly<T>(tx);\n\nexport const mutating = <T>(tx, cx) =>\n  new Mutating<T>(tx, cx);\n\nexport const pivot = <T>(tx) => new Pivot<T>(tx);\n\n/* Workflow executor */\n\nexport async function run(workflow) {\n  // a list of compensating functions\n  let cxs = [];\n  // a number of pivot operations happened during the workflow\n  let nPivots = 0;\n  // should the workflow be unrolled\n  let unrollReason;\n\n  let next;\n  let res;\n\n  try {\n    next = workflow.next();\n  } catch (e) {\n    unrollReason = e;\n  }\n\n  while (!unrollReason && !next!.done) {\n    const flow = next!.value;\n\n    try {\n      // execute async operation\n      res = await flow.tx();\n    } catch (e1) {\n      // async exception caught\n      try {\n        // try rethrowing into workflow -- this acquires a next workflow step;\n        // compensating operation is not added, because the atomic forward\n        // operation didn't succeed, so nothing to compensate\n        next = workflow.throw(e1);\n        continue;\n      } catch (e2) {\n        // rethrowing didn't succeed, unroll\n        unrollReason = e2;\n        break;\n      }\n    }\n\n    // async operation succeeds, register its aftereffects\n    if (flow instanceof Mutating) {\n      cxs.push(flow.cx);\n    } else if (flow instanceof Pivot) {\n      nPivots++;\n    }\n\n    // try acquiring next workflow step\n    try {\n      next = workflow.next(res);\n      continue;\n    } catch (e) {\n      // caught a sync exception that is not caught inside workflow, unroll\n      unrollReason = e;\n      break;\n    }\n  }\n\n  // unroll if error happened\n  if (unrollReason) {\n    // workflow is not revertible if there were completed pivot operations\n    if (nPivots) {\n      throw unrollReason;\n    }\n\n    for (const cx of cxs.reverse()) {\n      // compensating function error means the state is unknown\n      // this can only be handled by a caller, so no try-catch\n      await cx();\n    }\n    throw unrollReason;\n  }\n}\n","dynamism_density":0.0027816412,"dynamism_heuristic":2,"estimated_tokens":719,"ext":"ts","fun_ann_density":0.0222531293,"function_parameters":9,"function_signatures":0,"function_usages":0,"functions":7,"hexsha":"6b2e48994d25dfb77d9f951487af828409217c22","lang":"TypeScript","loc":64,"loc_per_function":6.8571428571,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-01-01T22:08:42.000Z","max_forks_repo_forks_event_min_datetime":"2022-01-01T22:08:42.000Z","max_forks_repo_head_hexsha":"76f09b108bbfe81283d8e93691250859fd1ca00e","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"artemeknyazev/ts-experiments","max_forks_repo_path":"src/workflows/generator-based.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"76f09b108bbfe81283d8e93691250859fd1ca00e","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"artemeknyazev/ts-experiments","max_issues_repo_path":"src/workflows/generator-based.ts","max_line_length":78,"max_stars_count":2.0,"max_stars_repo_head_hexsha":"76f09b108bbfe81283d8e93691250859fd1ca00e","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"artemeknyazev/ts-experiments","max_stars_repo_path":"src/workflows/generator-based.ts","max_stars_repo_stars_event_max_datetime":"2022-01-31T17:22:24.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-01T22:08:39.000Z","metric":0.2766673231,"predefined_density":0.28,"predefined_types":7,"prop_ann_density":0.0,"property_declarations":0,"size":2523,"trivial_density":0.08,"trivial_types":2,"type_definitions":7,"typedef_density":0.0097357441,"var_ann_density":0.0125173853,"variable_declarations":9},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/* Types */\ntype Tx<T> = () => Promise<T>;\ntype Cx = () => Promise<unknown>;\nexport class ReadOnly<T> {\n    constructor(public tx: Tx<T>);\n    constructor(public cx: Cx);\n    readonly(): T;\n    readonly(cx: Cx): T;\n    readonly(tx: Tx<T>, cx: Cx): T;\n    readonly(tx: T) { }\n}\nexport class Mutating<T> {\n    constructor(public tx: Tx<T>);\n    constructor(public cx: Cx);\n    readonly(): T;\n    readonly(cx: Cx): T;\n    readonly(tx: Tx<T>, cx: Cx): T;\n    readonly(tx:, public cx: Cx): T;\n    readonly(tx: T) { }\n}\nexport class Pivot<T> {\n    constructor(public tx) { }\n}\ntype Step<T> = ReadOnly<T> | Mutating) { }\n}\nexport class Pivot<T> {\n    constructor(public tx: Tx<T>);\n}\nexport class Generator<T, E1, E2> {\n    constructor(public gen: Generator<Step<any>, E1, E2>);\n    readonly(): T;\n    readonly(value: E) { }\n}\ntype Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;\nexport type Workflow = Generator<Step<any>, void, any>;\n/* Constructors */\nexport const readOnly = <T>(tx: Tx<T>);\nexport const mutating = <T>(tx, cx) => new Mutating<T>(tx, cx);\nexport const pivot = <T>(tx) => new Pivot<T>(tx);\nexport cons): <T, E1, E2>(gen: Generator<Step<any>, E1, E2>);\nexport const workflow = (gen: Generator<Step<any>, void, any>);\nexport const readonly = <T>(t => new ReadOnly<T>(tx);\nexport const mutating = <T>(tx: Tx<T>);\nexport const pivot = <T>(tx: Tx<T>);\nexport const readonly = <T>(t => new ReadOnly<T>(tx);\nexport const mutating = <T>(tx: Tx<T>), cx: Cx = () => new Cx();\nexport const workflow = <T>(t => new Workflow(gen));\nexport const readonly = <T>(t => new ReadOnly<T>(tx);\nexport const mutating = <T>): <E1>(t => new Mutating<E1>(tx, cx));\nexport const readonly = <T>(tx: Tx<T>);\nexport const mutating = <T>(tx: Tx<T>): <E => new Mutating<T>(tx, cx);\nexport const pivot = <T>(tx: Tx<T>);\nexport const readonly = <T>(t => new ReadOnly<T>(tx);\nexport const mutating = <T>(tx: Tx<T>);\nexport const readonly = <T>(tx: Tx<T>)): <E1, E2>(gen: Generator<Step<any>, E1, E2>);\nexport const readonly = <T>(tx: Tx<T>);\nexport const mutating = <T>(tx: Tx<T>) => new Pivot<T>(tx);\n/* Workflow executor */\nexport async function run(workflow: Generator<Step<any>, void, any>, ctx?: any) {\n    // a list of compensating functions\n    let cxs = [];\n    // a number of pivot operations happened during the workflow\n    let nPivots = 0): void => {\n    // a list of compensating functions\n    let cxs = [];\n    // a number of pivot operations happened during the workflow\n    let nPivots = 0;\n    let unrollReason;\n    let next;\n    le {\n    // a list of compensating functions\n    let cxs = [];\n    // a number of pivot operations happened during the workflow\n    let nPivots = 0;\n    // should the workflow be unrolled\n    let unrollReason;\n    let next;\n    let res;\n    try {\n        next = workflow.next();\n    }\n    catch (e) {\n        unrollReason = e;\n    }\n    while (!unrollReason && !next!.done) {\n        const flow = next!.value;\n        try {\n            // execute async operation\n            res = await flow.tx();\n        }\n        catch (e1) {\n            // async exception caught\n            try {\n                // try rethrowing into workflow -- this acquires a next workflow step;\n                // compensating operation is not added, because the atomic forward\n                // operation didn't succeed, so nothing to compensate\n                next = workflow.throw(e1);\n                continue;\n            }\n            catch (e2) {\n                // rethrowing didn't succeed, unroll\n                unrollReason = e2;\n                break;\n            }\n        }\n        // async operation succeeds, register its aftereffects\n        if (flow instanceof Mutating) {\n            cxs.push(flow.cx);\n        }\n        else if (flow instanceof Pivot) {\n            nPivots++;\n        }\n        // try acquiring next workflow step\n        try {\n            next = workflow.next(res);\n            continue;\n        }\n        catch (e) {\n            // caught a sync exception that is not caught inside workflow, unroll\n            unrollReason = e;\n            break;\n        }\n    }\n    // unroll if error happened\n    if (unrollReason) {\n        // workflow is not revertible if there were completed pivot operations\n        if (nPivots) {\n            throw unrollReason;\n        }\n        for (const cx of cxs.reverse()) {\n            // compensating function error means the state is unknown\n            // this can only be handled by a caller, so no try-catch\n            await cx();\n        }\n        throw unrollReason;\n    }\n}\n","score":360,"fallbacked":false,"num_type_errors":187},{"code":"/* Types */\ntype Tx<T> = () => Promise<T>;\ntype Cx = () => Promise<unknown>;\nexport class ReadOnly<T> {\n    constructor(public tx: Tx<T>);\n    constructor(public cx: Cx);\n}\nexport class Mutating<T> {\n    constructor(public tx: Tx<T>, public cx: Cx);\n    constructor(public tx: Tx<T>)) { }\n}\nexport class Mutating<T> {\n    constructor(public tx: Tx<T>);\n    constructor(public cx: Cx);\n}\nexport class Pivot<T> {\n    constructor(public tx: Tx<T>);\n}\ntype Step<T> = ReadOnly<T> | Mutatin, public cx: CX<T>;\nexport type Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;\nexport interface CTX<T> {\n    readonly tx: Tx<T>;\n    readonly cx:) { }\n}\nexport class Pivot<T> {\n    constructor(public tx: Tx<T>);\n}\nexport interface CTX<T> {\n    readonly tx: Tx<T>;\n    readonly cx:readonly CTX<T>;\n}\n/* Workflow executor */\nexport interface CTX<T> {) { }\n}\ntype Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;\nexport type Workflow = Generator<Step<any>, void, any>;\n/* Constructors */\nexport const readOnly = <T>(tx: Tx<T>);\nexport const mutating = <T>(tx) => new Mutating<T>(tx);\nexport const pivot = <T>(tx) => new Pivot<T>(tx);\nexport const readWrite =): <CTX<T>>(tx: Tx<T>) => new CTX<T>(tx);\nexport const readonly = <T>(tx: Tx<T>);\nexport const readonly = <T>(tx: Tx<T>);\nexpor => new ReadOnly<T>(tx);\nexport const mutating = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonl, cx: CX<any>;\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonl): <CTX<any>> { }\nexport const mutating = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>) => new Mutating<T>(tx, cx);\nexport const pivot = <T>(tx: Tx<any>);\nexport const readonl = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexpor): void;\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = <T>(tx: Tx<any>);\nexport const readonly = => new Pivot<T>(tx);\n/* Workflow executor */\nexport async function run(workflow: Workflow, context: CTX<any>, callback: (err?: Error, res?: any) => void): Promise<any> {\n    // a list of compensating functions\n    let cxs = [];\n    // a number of pivot operation): if the workflow is a pivot,\n    // it should be executed immediately, because we don't need\n    // to wait for the result.\n    let nPivots = 0;\n    // should the workflow be unrolled\n    let unrollReaso {\n    // a list of compensating functions\n    let cxs = [];\n    // a number of pivot operations happened during the workflow\n    let nPivots = 0;\n    // should the workflow be unrolled\n    let unrollReason;\n    let next;\n    let res;\n    try {\n        next = workflow.next();\n    }\n    catch (e) {\n        unrollReason = e;\n    }\n    while (!unrollReason && !next!.done) {\n        const flow = next!.value;\n        try {\n            // execute async operation\n            res = await flow.tx();\n        }\n        catch (e1) {\n            // async exception caught\n            try {\n                // try rethrowing into workflow -- this acquires a next workflow step;\n                // compensating operation is not added, because the atomic forward\n                // operation didn't succeed, so nothing to compensate\n                next = workflow.throw(e1);\n                continue;\n            }\n            catch (e2) {\n                // rethrowing didn't succeed, unroll\n                unrollReason = e2;\n                break;\n            }\n        }\n        // async operation succeeds, register its aftereffects\n        if (flow instanceof Mutating) {\n            cxs.push(flow.cx);\n        }\n        else if (flow instanceof Pivot) {\n            nPivots++;\n        }\n        // try acquiring next workflow step\n        try {\n            next = workflow.next(res);\n            continue;\n        }\n        catch (e) {\n            // caught a sync exception that is not caught inside workflow, unroll\n            unrollReason = e;\n            break;\n        }\n    }\n    // unroll if error happened\n    if (unrollReason) {\n        // workflow is not revertible if there were completed pivot operations\n        if (nPivots) {\n            throw unrollReason;\n        }\n        for (const cx of cxs.reverse()) {\n            // compensating function error means the state is unknown\n            // this can only be handled by a caller, so no try-catch\n            await cx();\n        }\n        throw unrollReason;\n    }\n}\n","score":351,"fallbacked":false,"num_type_errors":212},{"code":"/* Types */\ntype Tx<T> = () => Promise<T>;\ntype Cx = () => Promise<unknown>;\nexport class ReadOnly<T> {\n    constructor(public tx: Tx<T>);\n    constructor(public cx);\n}\nexport class Mutating<T> {\n    constructor(public tx, public cx);\n    constructor(public cx);\n    constructor(public cx);\n    constructor(public cx);\n    constructo) { }\n}\nexport class Mutating<T> {\n    constructor(public tx: Tx<T>);\n    constructor(public cx);\n    constructor(public cx);\n    constructor(public cx);\n    constructor(public cx);\n    constructo) { }\n}\nexport class Pivot<T> {\n    constructor(public t, public cx: Cx<any>);\n    constructor(public t, public cx);\n    constructor(public t, public cx);\n    constructor(public t, public cx);\n    constructor(public t, public cx);\n    constructor(public t, public cx)) { }\n}\nexport class Pivot<T> {\n    constructor(public tx: Tx<any>);\n    constructor(public cx);\n    constructor(public cx);\n    constructor(public cx);\n    constructor(public cx);\n    constructor(public cx);\n    constructor(public cx);\n    constructo) { }\n}\nexpor) { }\n}\ntype Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;\nexport type Workflow = Generator<Step<any>, void, any>;\n/* Constructors */\nexport const readOnly = <T>(tx: Tx<T>);\nexport const mutating = <T>(tx, cx) => new Mutating<T>(tx, cx);\nexport const pivot = <T>(tx) => new Pivot<T>(tx);\nexport cons): <T>(tx) => new ReadOnly<T>(tx);\nexport const readOnly = <T>(tx: Tx<T>);\nexport const mutating = <T>(tx, cx) => new Mutating<T>(tx, c => new ReadOnly<T>(tx);\nexport const mutating = <T>(tx: Tx<any>);\nexport const pivot = <T>(tx) => new Pivot<T>(tx);\nexport const readOnly = <T>(tx: Tx<any>);\nexport const mutating = <T>(tx) => ne, cx: Cx<any>;\nexport const mutating = <T>(tx): <T>(tx, cx) => new Mutating<T>(tx, cx);\nexport const pivot = <T>(tx: Tx<any>);\nexport const readOnly = <T>(tx: Tx<any>);\nexport const mu => new Mutating<T>(tx, cx);\nexport const pivot = <T>(tx: Tx<any>);\nexport const mutating = <T>(tx: Tx<any>);\nexport const readOnly = <T>(tx: Tx<any>);\nexport const mutating = <T>(tx: Tx<any>);\nexpor): <T>(tx: Tx<any>);\nexport const run = <T>(tx: Tx<any>);\nexport const run = <T>(tx: Tx<any>);\nexport const run = <T>(tx: Tx<an => new Pivot<T>(tx);\n/* Workflow executor */\nexport async function run(workflow: Workflow<any>) {\n    // a list of compensating functions\n    let cxs = [];\n    // a number of pivot operations happened during the workflow\n    let nPivots = 0;\n    // should the workflow be unrolled\n    le): boolean {\n        if (!workflow.unrolled) {\n            if (workflow.unroll) {\n                // unroll workflow\n                workflow.unrolled = true;\n                // execute workflow\n                // first execute workflow\n                cxs = workflow.next() {\n    // a list of compensating functions\n    let cxs = [];\n    // a number of pivot operations happened during the workflow\n    let nPivots = 0;\n    // should the workflow be unrolled\n    let unrollReason;\n    let next;\n    let res;\n    try {\n        next = workflow.next();\n    }\n    catch (e) {\n        unrollReason = e;\n    }\n    while (!unrollReason && !next!.done) {\n        const flow = next!.value;\n        try {\n            // execute async operation\n            res = await flow.tx();\n        }\n        catch (e1) {\n            // async exception caught\n            try {\n                // try rethrowing into workflow -- this acquires a next workflow step;\n                // compensating operation is not added, because the atomic forward\n                // operation didn't succeed, so nothing to compensate\n                next = workflow.throw(e1);\n                continue;\n            }\n            catch (e2) {\n                // rethrowing didn't succeed, unroll\n                unrollReason = e2;\n                break;\n            }\n        }\n        // async operation succeeds, register its aftereffects\n        if (flow instanceof Mutating) {\n            cxs.push(flow.cx);\n        }\n        else if (flow instanceof Pivot) {\n            nPivots++;\n        }\n        // try acquiring next workflow step\n        try {\n            next = workflow.next(res);\n            continue;\n        }\n        catch (e) {\n            // caught a sync exception that is not caught inside workflow, unroll\n            unrollReason = e;\n            break;\n        }\n    }\n    // unroll if error happened\n    if (unrollReason) {\n        // workflow is not revertible if there were completed pivot operations\n        if (nPivots) {\n            throw unrollReason;\n        }\n        for (const cx of cxs.reverse()) {\n            // compensating function error means the state is unknown\n            // this can only be handled by a caller, so no try-catch\n            await cx();\n        }\n        throw unrollReason;\n    }\n}\n","score":449,"fallbacked":false,"num_type_errors":214}]}
{"dataset_elem":{"alphanum_fraction":0.6925207756,"avg_line_length":28.1821561338,"content":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier =\n  | CommunicationUserIdentifier\n  | PhoneNumberIdentifier\n  | MicrosoftTeamsUserIdentifier\n  | UnknownIdentifier;\n\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n  /**\n   * Id of the CommunicationUser as returned from the Communication Service.\n   */\n  communicationUserId: string;\n}\n\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n  /**\n   * Optional raw id of the phone number.\n   */\n  rawId?: string;\n  /**\n   * The phone number in E.164 format.\n   */\n  phoneNumber: string;\n}\n\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams user.\n   */\n  rawId?: string;\n\n  /**\n   * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n   */\n  microsoftTeamsUserId: string;\n\n  /**\n   * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n   */\n  isAnonymous?: boolean;\n\n  /**\n   * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?: \"public\" | \"dod\" | \"gcch\";\n}\n\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n  /**\n   * Id of the UnknownIdentifier.\n   */\n  id: string;\n}\n\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is CommunicationUserIdentifier => {\n  return typeof (identifier as any).communicationUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is PhoneNumberIdentifier => {\n  return typeof (identifier as any).phoneNumber === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is MicrosoftTeamsUserIdentifier => {\n  return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is UnknownIdentifier => {\n  return typeof (identifier as any).id === \"string\";\n};\n\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind =\n  | CommunicationUserKind\n  | PhoneNumberKind\n  | MicrosoftTeamsUserKind\n  | UnknownIdentifierKind;\n\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"communicationUser\";\n}\n\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"phoneNumber\";\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"microsoftTeamsUser\";\n}\n\n/**\n * IdentifierKind for UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"unknown\";\n}\n\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (\n  identifier: CommunicationIdentifier\n): CommunicationIdentifierKind => {\n  if (isCommunicationUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"communicationUser\" };\n  }\n  if (isPhoneNumberIdentifier(identifier)) {\n    return { ...identifier, kind: \"phoneNumber\" };\n  }\n  if (isMicrosoftTeamsUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsUser\" };\n  }\n  return { ...identifier, kind: \"unknown\" };\n};\n\n/**\n * Returns the rawId for a given CommunicationIdentifier. You can use the rawId for encoding the identifier and then use it as a key in a database.\n *\n * @param identifier - The identifier to be translated to its rawId.\n */\nexport const getIdentifierRawId = (identifier: CommunicationIdentifier): string => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return identifierKind.communicationUserId;\n    case \"microsoftTeamsUser\": {\n      const { microsoftTeamsUserId, rawId, cloud, isAnonymous } = identifierKind;\n      if (rawId) return rawId;\n      if (isAnonymous) return `8:teamsvisitor:${microsoftTeamsUserId}`;\n      switch (cloud) {\n        case \"dod\":\n          return `8:dod:${microsoftTeamsUserId}`;\n        case \"gcch\":\n          return `8:gcch:${microsoftTeamsUserId}`;\n        case \"public\":\n          return `8:orgid:${microsoftTeamsUserId}`;\n      }\n      return `8:orgid:${microsoftTeamsUserId}`;\n    }\n    case \"phoneNumber\": {\n      const { phoneNumber, rawId } = identifierKind;\n      if (rawId) return rawId;\n      // strip the leading +. We just assume correct E.164 format here because validation should only happen server-side, not client-side.\n      return `4:${phoneNumber.replace(/^\\+/, \"\")}`;\n    }\n    case \"unknown\": {\n      return identifierKind.id;\n    }\n  }\n};\n\n/**\n * Creates a CommunicationIdentifierKind from a given rawId. When storing rawIds use this function to restore the identifier that was encoded in the rawId.\n *\n * @param rawId - The rawId to be translated to its identifier representation.\n */\nexport const createIdentifierFromRawId = (rawId: string): CommunicationIdentifierKind => {\n  if (rawId.startsWith(\"4:\")) {\n    return { kind: \"phoneNumber\", phoneNumber: `+${rawId.substring(\"4:\".length)}` };\n  }\n\n  const segments = rawId.split(\":\");\n  if (segments.length < 3) return { kind: \"unknown\", id: rawId };\n\n  const prefix = `${segments[0]}:${segments[1]}:`;\n  const suffix = rawId.substring(prefix.length);\n\n  switch (prefix) {\n    case \"8:teamsvisitor:\":\n      return { kind: \"microsoftTeamsUser\", microsoftTeamsUserId: suffix, isAnonymous: true };\n    case \"8:orgid:\":\n      return {\n        kind: \"microsoftTeamsUser\",\n        microsoftTeamsUserId: suffix,\n        isAnonymous: false,\n        cloud: \"public\",\n      };\n    case \"8:dod:\":\n      return {\n        kind: \"microsoftTeamsUser\",\n        microsoftTeamsUserId: suffix,\n        isAnonymous: false,\n        cloud: \"dod\",\n      };\n    case \"8:gcch:\":\n      return {\n        kind: \"microsoftTeamsUser\",\n        microsoftTeamsUserId: suffix,\n        isAnonymous: false,\n        cloud: \"gcch\",\n      };\n    case \"8:acs:\":\n    case \"8:spool:\":\n    case \"8:dod-acs:\":\n    case \"8:gcch-acs:\":\n      return { kind: \"communicationUser\", communicationUserId: rawId };\n  }\n  return { kind: \"unknown\", id: rawId };\n};\n","content_without_annotations":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier =\n  | CommunicationUserIdentifier\n  | PhoneNumberIdentifier\n  | MicrosoftTeamsUserIdentifier\n  | UnknownIdentifier;\n\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n  /**\n   * Id of the CommunicationUser as returned from the Communication Service.\n   */\n  communicationUserId;\n}\n\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n  /**\n   * Optional raw id of the phone number.\n   */\n  rawId?;\n  /**\n   * The phone number in E.164 format.\n   */\n  phoneNumber;\n}\n\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams user.\n   */\n  rawId?;\n\n  /**\n   * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n   */\n  microsoftTeamsUserId;\n\n  /**\n   * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n   */\n  isAnonymous?;\n\n  /**\n   * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?;\n}\n\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n  /**\n   * Id of the UnknownIdentifier.\n   */\n  id;\n}\n\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (\n  identifier\n): identifier is CommunicationUserIdentifier => {\n  return typeof (identifier as any).communicationUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (\n  identifier\n): identifier is PhoneNumberIdentifier => {\n  return typeof (identifier as any).phoneNumber === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (\n  identifier\n): identifier is MicrosoftTeamsUserIdentifier => {\n  return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (\n  identifier\n): identifier is UnknownIdentifier => {\n  return typeof (identifier as any).id === \"string\";\n};\n\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind =\n  | CommunicationUserKind\n  | PhoneNumberKind\n  | MicrosoftTeamsUserKind\n  | UnknownIdentifierKind;\n\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind;\n}\n\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind;\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind;\n}\n\n/**\n * IdentifierKind for UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind;\n}\n\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (\n  identifier\n) => {\n  if (isCommunicationUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"communicationUser\" };\n  }\n  if (isPhoneNumberIdentifier(identifier)) {\n    return { ...identifier, kind: \"phoneNumber\" };\n  }\n  if (isMicrosoftTeamsUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsUser\" };\n  }\n  return { ...identifier, kind: \"unknown\" };\n};\n\n/**\n * Returns the rawId for a given CommunicationIdentifier. You can use the rawId for encoding the identifier and then use it as a key in a database.\n *\n * @param identifier - The identifier to be translated to its rawId.\n */\nexport const getIdentifierRawId = (identifier) => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return identifierKind.communicationUserId;\n    case \"microsoftTeamsUser\": {\n      const { microsoftTeamsUserId, rawId, cloud, isAnonymous } = identifierKind;\n      if (rawId) return rawId;\n      if (isAnonymous) return `8:teamsvisitor:${microsoftTeamsUserId}`;\n      switch (cloud) {\n        case \"dod\":\n          return `8:dod:${microsoftTeamsUserId}`;\n        case \"gcch\":\n          return `8:gcch:${microsoftTeamsUserId}`;\n        case \"public\":\n          return `8:orgid:${microsoftTeamsUserId}`;\n      }\n      return `8:orgid:${microsoftTeamsUserId}`;\n    }\n    case \"phoneNumber\": {\n      const { phoneNumber, rawId } = identifierKind;\n      if (rawId) return rawId;\n      // strip the leading +. We just assume correct E.164 format here because validation should only happen server-side, not client-side.\n      return `4:${phoneNumber.replace(/^\\+/, \"\")}`;\n    }\n    case \"unknown\": {\n      return identifierKind.id;\n    }\n  }\n};\n\n/**\n * Creates a CommunicationIdentifierKind from a given rawId. When storing rawIds use this function to restore the identifier that was encoded in the rawId.\n *\n * @param rawId - The rawId to be translated to its identifier representation.\n */\nexport const createIdentifierFromRawId = (rawId) => {\n  if (rawId.startsWith(\"4:\")) {\n    return { kind: \"phoneNumber\", phoneNumber: `+${rawId.substring(\"4:\".length)}` };\n  }\n\n  const segments = rawId.split(\":\");\n  if (segments.length < 3) return { kind: \"unknown\", id: rawId };\n\n  const prefix = `${segments[0]}:${segments[1]}:`;\n  const suffix = rawId.substring(prefix.length);\n\n  switch (prefix) {\n    case \"8:teamsvisitor:\":\n      return { kind: \"microsoftTeamsUser\", microsoftTeamsUserId: suffix, isAnonymous: true };\n    case \"8:orgid:\":\n      return {\n        kind: \"microsoftTeamsUser\",\n        microsoftTeamsUserId: suffix,\n        isAnonymous: false,\n        cloud: \"public\",\n      };\n    case \"8:dod:\":\n      return {\n        kind: \"microsoftTeamsUser\",\n        microsoftTeamsUserId: suffix,\n        isAnonymous: false,\n        cloud: \"dod\",\n      };\n    case \"8:gcch:\":\n      return {\n        kind: \"microsoftTeamsUser\",\n        microsoftTeamsUserId: suffix,\n        isAnonymous: false,\n        cloud: \"gcch\",\n      };\n    case \"8:acs:\":\n    case \"8:spool:\":\n    case \"8:dod-acs:\":\n    case \"8:gcch-acs:\":\n      return { kind: \"communicationUser\", communicationUserId: rawId };\n  }\n  return { kind: \"unknown\", id: rawId };\n};\n","dynamism_density":0.0044444444,"dynamism_heuristic":8,"estimated_tokens":1800,"ext":"ts","fun_ann_density":0.0077777778,"function_parameters":7,"function_signatures":0,"function_usages":4,"functions":7,"hexsha":"965e83a1049aa861ae1352eb63a9125c0484c287","lang":"TypeScript","loc":141,"loc_per_function":11.2857142857,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"e825fade0eafebf20a5128ef8466acc0d2bcc496","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"WeiJun428/azure-sdk-for-js","max_forks_repo_path":"sdk/communication/communication-common/src/identifierModels.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"e825fade0eafebf20a5128ef8466acc0d2bcc496","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"WeiJun428/azure-sdk-for-js","max_issues_repo_path":"sdk/communication/communication-common/src/identifierModels.ts","max_line_length":155,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"e825fade0eafebf20a5128ef8466acc0d2bcc496","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"WeiJun428/azure-sdk-for-js","max_stars_repo_path":"sdk/communication/communication-common/src/identifierModels.ts","max_stars_repo_stars_event_max_datetime":"2022-01-12T08:35:43.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-12T08:35:43.000Z","metric":0.2192267583,"predefined_density":0.2307692308,"predefined_types":9,"prop_ann_density":0.0066666667,"property_declarations":12,"size":7581,"trivial_density":0.1025641026,"trivial_types":4,"type_definitions":10,"typedef_density":0.0055555556,"var_ann_density":0.0072222222,"variable_declarations":13},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier = CommunicationUserIdentifier | PhoneNumberIdentifier | MicrosoftTeamsUserIdentifier | UnknownIdentifier;\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n    /**\n     * Id of the CommunicationUser as returned from the Communication Service.\n     */\n    communicationUserId: string;\n}\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifierResult {\n    /**\n     * The CommunicationUserIdentifier instance of the CommunicationUser.\n     */\n    communicationUserIdentifier: CommunicationUserIdentifier;;\n}\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n    /**\n     * Optional raw id of the phone number.\n     */\n    rawId?: string;\n    /**\n     * Id of the phone number.\n     */\n    id: string;\n}\n/**\n * Represents an Azure Communication User.\n */\nexport interface CommunicationUser {\n    /**\n     * Communication User identifier.\n     */;\n    /**\n     * The phone number in E.164 format.\n     */\n    phoneNumber: string;\n    /**\n     * The name of the Communication User.\n     */\n    name: string;\n}\n/**\n * Defines the properties of a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserIdentifierProperties {\n    /**\n     * A;\n}\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n    /**\n     * Optional raw id of the Microsoft Teams user.\n     */\n    rawId?: string;\n    /**\n     * Id of the Microsoft Teams user.\n     */\n    microsoftTeamsUserId: string;\n}\n/**\n * A user who is a guest of a Microsoft Teams Team.\n */\nexport interface MicrosoftTeam;\n    /**\n     * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n     */\n    microsoftTeamsUserId: string;\n}\n/**\n * An identifier that represents a Communication User.\n */\nexport interface CommunicationUserIdentifier {\n    /**\n     * Defines the properties of a CommunicationUserIdentifier.\n     */\n    properties: CommunicationUserIdentifierProperties;\n    /*;\n    /**\n     * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n     */\n    isAnonymous?: boolean;\n}\n/**\n * An identifier that represents a Microsoft Teams User.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n    /**\n     * Optional raw id of the Microsoft Teams user.\n     */\n    rawId?: string;\n    /**\n     * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n     */\n    cloud?: string;\n    /**\n     * An identifier that represents a Microsoft Teams User.\n     */\n    microsoftTeamsUserIdentifier: MicrosoftTeamsUserIdentifier;\n}\n/**\n * An identifier that represents a user.\n */\nexport interface UserIdentifie;\n}\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n    /**\n     * Id of the UnknownIdentifier.\n     */\n    id: string;\n    /**\n     * If the user has been deleted from the system, then the corresponding raw identifier won't exist.\n     */\n    rawId?: string;\n}\n/**\n * A user identifier that is not part of the core Use;\n}\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (identifier: identifier): identifier is CommunicationUserIdentifier => {\n    return typeof (identifier as any).communicationUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - Th): identifier is CommunicationUserIdentifier => {\n    return typeof (identifier as any).communicationUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (identifier: identifier): identifier is PhoneNumberIdentifier => {\n    return typeof (identifier as any).phoneNumber === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - Th): identifier is PhoneNumberIdentifier => {\n    return typeof (identifier as any).phoneNumber === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (identifier: identifier): identifier is MicrosoftTeamsUserIdentifier => {\n    return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier): identifier is MicrosoftTeamsUserIdentifier => {\n    return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (identifier: identifier): identifier is UnknownIdentifier => {\n    return typeof (identifier as any).id === \"string\";\n};\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n *): identifier is UnknownIdentifier => {\n    return typeof (identifier as any).id === \"string\";\n};\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind = CommunicationUserKind | PhoneNumberKind | MicrosoftTeamsUserKind | UnknownIdentifierKind;\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"communicationUser\";\n    /**\n     * The identifier.\n     */\n    id: string;\n}\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n    /**\n     * Th;\n}\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"phoneNumber\";\n    /**\n     * The identifier.\n     */\n    id: string;\n}\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n    /**;\n}\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"microsoftTeamsUser\";\n    /**\n     * The identifier.\n     */\n    id: string;\n}\n/**\n * IdentifierKind for a UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n    /**\n     * The identifie;\n}\n/**\n * IdentifierKind for UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"unknown\";\n}\n/**\n * The CommunicationIdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserIdentifierKind extends CommunicationIdentifierKind {\n    /**\n     * The identifier kind.\n     */\n    kind: \"communicationUser\";\n}\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (identifier: CommunicationIdentifier) => {\n    if (isCommunicationUserIdentifier(identifier)) {\n        return { kind: \"communicationUser\" };\n    }\n    if (isPhoneNumberIdentifier(identifier)) {\n        return { kind: \"phoneNumber\" };\n    }): {\n        return { kind: \"unknown\" };\n    }\n};\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationUserIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifie => {\n    if (isCommunicationUserIdentifier(identifier)) {\n        return { ...identifier, kind: \"communicationUser\" };\n    }\n    if (isPhoneNumberIdentifier(identifier)) {\n        return { ...identifier, kind: \"phoneNumber\" };\n    }\n    if (isMicrosoftTeamsUserIdentifier(identifier)) {\n        return { ...identifier, kind: \"microsoftTeamsUser\" };\n    }\n    return { ...identifier, kind: \"unknown\" };\n};\n/**\n * Returns the rawId for a given CommunicationIdentifier. You can use the rawId for encoding the identifier and then use it as a key in a database.\n *\n * @param identifier - The identifier to be translated to its rawId.\n */\nexport const getIdentifierRawId = (identifier: CommunicationIdentifier) => {\n    const identifierKind = getIdentifierKind(identifier);\n    switch (identifierKind.kind) {\n        case \"communicationUser\":\n            return identifierKind.communicationUserId;\n        case \"phoneNumber\":\n            return identifierKind.phoneNumbe): {\n                return identifierKind.phoneNumbe;\n            }\n        case \"microsoftTeamsUser\": {\n            const { microsoftTeamsUserId, rawId } = identifierKind;\n            if (rawId)\n                return rawId;\n            return microsof => {\n    const identifierKind = getIdentifierKind(identifier);\n    switch (identifierKind.kind) {\n        case \"communicationUser\":\n            return identifierKind.communicationUserId;\n        case \"microsoftTeamsUser\": {\n            const { microsoftTeamsUserId, rawId, cloud, isAnonymous } = identifierKind;\n            if (rawId)\n                return rawId;\n            if (isAnonymous)\n                return `8:teamsvisitor:${microsoftTeamsUserId}`;\n            switch (cloud) {\n                case \"dod\":\n                    return `8:dod:${microsoftTeamsUserId}`;\n                case \"gcch\":\n                    return `8:gcch:${microsoftTeamsUserId}`;\n                case \"public\":\n                    return `8:orgid:${microsoftTeamsUserId}`;\n            }\n            return `8:orgid:${microsoftTeamsUserId}`;\n        }\n        case \"phoneNumber\": {\n            const { phoneNumber, rawId } = identifierKind;\n            if (rawId)\n                return rawId;\n            // strip the leading +. We just assume correct E.164 format here because validation should only happen server-side, not client-side.\n            return `4:${phoneNumber.replace(/^\\+/, \"\")}`;\n        }\n        case \"unknown\": {\n            return identifierKind.id;\n        }\n    }\n};\n/**\n * Creates a CommunicationIdentifierKind from a given rawId. When storing rawIds use this function to restore the identifier that was encoded in the rawId.\n *\n * @param rawId - The rawId to be translated to its identifier representation.\n */\nexport const createIdentifierFromRawId = (rawId: string) => {\n    const matches = rawId.match(/^4:(\\d+)$/);\n    if (!matches)\n        return { kind: \"unknown\", id: rawId };\n    const [_, id] = matches;\n    if): any => {\n        if (typeof (any) === \"string\")\n            return { kind: \"phoneNumber\", phoneNumber: any };\n        return { kind: \"unknown\", id: any };\n    }\n    switch (id) {\n        case \" => {\n    if (rawId.startsWith(\"4:\")) {\n        return { kind: \"phoneNumber\", phoneNumber: `+${rawId.substring(\"4:\".length)}` };\n    }\n    const segments = rawId.split(\":\");\n    if (segments.length < 3)\n        return { kind: \"unknown\", id: rawId };\n    const prefix = `${segments[0]}:${segments[1]}:`;\n    const suffix = rawId.substring(prefix.length);\n    switch (prefix) {\n        case \"8:teamsvisitor:\":\n            return { kind: \"microsoftTeamsUser\", microsoftTeamsUserId: suffix, isAnonymous: true };\n        case \"8:orgid:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"public\",\n            };\n        case \"8:dod:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"dod\",\n            };\n        case \"8:gcch:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"gcch\",\n            };\n        case \"8:acs:\":\n        case \"8:spool:\":\n        case \"8:dod-acs:\":\n        case \"8:gcch-acs:\":\n            return { kind: \"communicationUser\", communicationUserId: rawId };\n    }\n    return { kind: \"unknown\", id: rawId };\n};\n","score":137,"fallbacked":false,"num_type_errors":38},{"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier = CommunicationUserIdentifier | PhoneNumberIdentifier | MicrosoftTeamsUserIdentifier | UnknownIdentifier;\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n    /**\n     * Id of the CommunicationUser as returned from the Communication Service.\n     */\n    communicationUserId: string;\n}\n/**\n * An object representing a user's identity, such as a phone number or an email address.\n */\nexport interface Identity {\n    /**\n     * An identifier of the identity.\n     */\n    identityId: strin;\n}\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n    /**\n     * Optional raw id of the phone number.\n     */\n    rawId?: string;\n    /**\n     * The phone number in E.164 format.\n     */\n    phoneNumber;\n}\n/**\n * An object representing a user's identity, such as a phone number or an email address.\n */\nexpor;\n    /**\n     * The phone number in E.164 format.\n     */\n    phoneNumber: string;\n}\n/**\n * An object representing a user's identity, such as a phone number or an email address.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n    /**\n     * An identifier of the identity.\n     */\n    identit;\n}\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n    /**\n     * Optional raw id of the Microsoft Teams user.\n     */\n    rawId?: string;\n    /**\n     * The identity of the user as returned by the Microsoft Teams SDK.\n     */\n    teamSasUserId: string;\n}\n/**\n * A communication user.\n */\nexport interface CommunicationUser {\n    /*;\n    /**\n     * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n     */\n    microsoftTeamsUserId: string;\n    /**\n     * An identifier of the identity.\n     */\n    identityId: string;\n    /**\n     * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymou;\n    /**\n     * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n     */\n    isAnonymous?: boolean;\n    /**\n     * The cloud that the CommunicationUser belongs to. If missing, the cloud is \"public\".\n     */\n    cloud?;\n}\n/**\n * An object representing a user's identity, such as a phone number o;\n    /**\n     * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n     */\n    cloud?: Cloud;\n}\n/**\n * The result of a call to the conversation service\n */\nexport interface Call {\n    /**\n     * The conversation context of the call.\n     */\n    conversationContext?: ConversationContext;\n    /**\n     * The resul;\n}\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n    /**\n     * Id of the UnknownIdentifier.\n     */\n    id: string;\n    /**\n     * The cloud that the UnknownIdentifier belongs to. If missing, the cloud is \"public\".\n     */\n    cloud?: Cloud;\n}\n/**\n * An identifier that refers to a single communication user.\n */;\n}\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (identifier: any): identifier is CommunicationUserIdentifier => {\n    return identifier instanceof CommunicationUserIdentifier;\n};\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to b): identifier is CommunicationUserIdentifier => {\n    return typeof (identifier as any).communicationUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (identifier: any): identifier is PhoneNumberIdentifier => {\n    return identifier instanceof PhoneNumberIdentifier;\n};\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be teste): identifier is PhoneNumberIdentifier => {\n    return typeof (identifier as any).phoneNumber === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (identifier: any): identifier is MicrosoftTeamsUserIdentifier => {\n    return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier): identifier is MicrosoftTeamsUserIdentifier => {\n    return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (identifier: any): identifier is UnknownIdentifier => {\n    return typeof (identifier as any).id === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifie): identifier is UnknownIdentifier => {\n    return typeof (identifier as any).id === \"string\";\n};\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind = CommunicationUserKind | PhoneNumberKind | MicrosoftTeamsUserKind | UnknownIdentifierKind;\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: CommunicationUserIdentifierKind.User;\n}\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: CommunicationUserIdentifie;\n}\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: CommunicationUserIdentifie;\n}\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: Communicatio;\n}\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: Communicatio;\n}\n/**\n * IdentifierKind for a UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: CommunicationUserIdentifie;;\n}\n/**\n * IdentifierKind for UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: UnknownIdentifierKind;\n}\n/**\n * @packageDocumentation\n * @module botbuilder-ai\n */\n/**\n * @packageDocumentation\n * @module botbuilder-ai\n */\n/**\n * An enum which describes the kin;\n}\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (identifier: unknown): CommunicationIdentifierKind | undefined => {\n    if (isCommunicationUserIdentifier(identifier)) {\n        return \"communicationUser\";\n    }\n    if (isPhoneNumberIdentifier(identifier)) {\n        return \"phoneNumber\";\n    }\n    if (isMicrosof): if (isMicrosoftTeamsUserIdentifier(identifier)) {\n        return \"microsoftTeamsUser\";\n    }\n    return undefined;\n};\n/**\n * Returns a raw identifier for a given CommunicationIdentifier.\n *\n * @param identifier - The identifie => {\n    if (isCommunicationUserIdentifier(identifier)) {\n        return { ...identifier, kind: \"communicationUser\" };\n    }\n    if (isPhoneNumberIdentifier(identifier)) {\n        return { ...identifier, kind: \"phoneNumber\" };\n    }\n    if (isMicrosoftTeamsUserIdentifier(identifier)) {\n        return { ...identifier, kind: \"microsoftTeamsUser\" };\n    }\n    return { ...identifier, kind: \"unknown\" };\n};\n/**\n * Returns the rawId for a given CommunicationIdentifier. You can use the rawId for encoding the identifier and then use it as a key in a database.\n *\n * @param identifier - The identifier to be translated to its rawId.\n */\nexport const getIdentifierRawId = (identifier: unknown): string | undefined => {\n    if (isCommunicationUserIdentifier(identifier)) {\n        return identifier.communicationUserId;\n    }\n    if (isPhoneNumberIdentifier(identifier)) {\n        return identifier.phoneNumber;\n    }\n    if (isMicrosof): if (isMicrosoftTeamsUserIdentifier(identifier)) {\n        return identifier.microsoftTeamsUserId;\n    }\n    return undefined;\n};\n/**\n * Gets the full identifier of a CommunicationIdentifier object,\n * that is the combination of the use => {\n    const identifierKind = getIdentifierKind(identifier);\n    switch (identifierKind.kind) {\n        case \"communicationUser\":\n            return identifierKind.communicationUserId;\n        case \"microsoftTeamsUser\": {\n            const { microsoftTeamsUserId, rawId, cloud, isAnonymous } = identifierKind;\n            if (rawId)\n                return rawId;\n            if (isAnonymous)\n                return `8:teamsvisitor:${microsoftTeamsUserId}`;\n            switch (cloud) {\n                case \"dod\":\n                    return `8:dod:${microsoftTeamsUserId}`;\n                case \"gcch\":\n                    return `8:gcch:${microsoftTeamsUserId}`;\n                case \"public\":\n                    return `8:orgid:${microsoftTeamsUserId}`;\n            }\n            return `8:orgid:${microsoftTeamsUserId}`;\n        }\n        case \"phoneNumber\": {\n            const { phoneNumber, rawId } = identifierKind;\n            if (rawId)\n                return rawId;\n            // strip the leading +. We just assume correct E.164 format here because validation should only happen server-side, not client-side.\n            return `4:${phoneNumber.replace(/^\\+/, \"\")}`;\n        }\n        case \"unknown\": {\n            return identifierKind.id;\n        }\n    }\n};\n/**\n * Creates a CommunicationIdentifierKind from a given rawId. When storing rawIds use this function to restore the identifier that was encoded in the rawId.\n *\n * @param rawId - The rawId to be translated to its identifier representation.\n */\nexport const createIdentifierFromRawId = (rawId: string): CommunicationIdentifierKind => {\n    if (rawId.startsWith(\"4:\")) {\n        const { phoneNumber, rawId } = createIdentifierFromRawId(rawId);\n        return {\n            kind: \"phoneNumber\",\n            phoneNumber,\n            ra): CommunicationIdentifierKind;\n    }\n    if (rawId.startsWith(\"8:dod:\")) {\n        const { microsoftTeamsUserId } = createIdentifierFromRawId(rawId);\n        return {\n            kind: \"microsoftTeamsUser\", => {\n    if (rawId.startsWith(\"4:\")) {\n        return { kind: \"phoneNumber\", phoneNumber: `+${rawId.substring(\"4:\".length)}` };\n    }\n    const segments = rawId.split(\":\");\n    if (segments.length < 3)\n        return { kind: \"unknown\", id: rawId };\n    const prefix = `${segments[0]}:${segments[1]}:`;\n    const suffix = rawId.substring(prefix.length);\n    switch (prefix) {\n        case \"8:teamsvisitor:\":\n            return { kind: \"microsoftTeamsUser\", microsoftTeamsUserId: suffix, isAnonymous: true };\n        case \"8:orgid:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"public\",\n            };\n        case \"8:dod:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"dod\",\n            };\n        case \"8:gcch:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"gcch\",\n            };\n        case \"8:acs:\":\n        case \"8:spool:\":\n        case \"8:dod-acs:\":\n        case \"8:gcch-acs:\":\n            return { kind: \"communicationUser\", communicationUserId: rawId };\n    }\n    return { kind: \"unknown\", id: rawId };\n};\n","score":157,"fallbacked":false,"num_type_errors":44},{"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier = CommunicationUserIdentifier | PhoneNumberIdentifier | MicrosoftTeamsUserIdentifier | UnknownIdentifier;\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n    /**\n     * Id of the CommunicationUser as returned from the Communication Service.\n     */\n    communicationUserId: string;\n    /**\n     * Optional raw id of the CommunicationUser.\n     */\n    rawId?;\n}\n/**\n * An Azure Communication user, which represents a user without a phone number or a Microsoft Teams user.\n */;\n}\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n    /**\n     * Optional raw id of the phone number.\n     */\n    rawId?: string;\n    /**\n     * Id of the phone number.\n     */\n    phoneNumber: string;\n}\n/**\n * The identity of the user.\n */\nexport interface Identity {\n    /**\n     * The user identity type.\n     */;\n    /**\n     * The phone number in E.164 format.\n     */\n    phoneNumber: string;\n    /**\n     * The user identity type as a string, e.g. \"phone\".\n     */\n    type?: IdentityType;\n}\n/**\n * The identity type of a CommunicationUserIdentifier.\n */\nexport enum Identit;\n}\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n    /**\n     * Optional raw id of the Microsoft Teams user.\n     */\n    rawId?: string;\n    /**\n     * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n     */\n    microsoftTeamsUserId: string;\n    /**\n     * True if th;\n    /**\n     * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n     */\n    microsoftTeamsUserId: string;\n}\n/**\n * The identity type of a CommunicationUserIdentifier.\n */\nexport enum IdentityType;\n/**\n * The identity type of a MicrosoftTeamsUserIdentifier.\n */\nexport enum MicrosoftTeamsIdentityType;;\n    /**\n     * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n     */\n    isAnonymous?: boolean;\n    /**\n     * True if the user is a Microsoft Teams bot, for example when joining a meeting with a share link. If missing, the user is not a Microsoft Teams bot.\n     */\n    isMicrosoftTeamsBot?: boolea;\n    /**\n     * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n     */\n    cloud?: CloudType;\n    /**\n     * The time at which the user was created, in milliseconds since the Unix epoch.\n     */\n    creationTime?: number;\n    /**\n     * The user's identity type.\n     */\n    identity?: IdentityType;;\n}\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n    /**\n     * Id of the UnknownIdentifier.\n     */\n    id: string;\n}\n/**\n * An identifier for a user in a Microsoft Teams account.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n    /**\n     * The user's identity type.\n     */\n    identityType?: IdentityType;;\n}\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (identifier: unknown): identifier is CommunicationUserIdentifier => {\n    return typeof (identifier as any).communicationUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - Th): identifier is CommunicationUserIdentifier => {\n    return typeof (identifier as any).communicationUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (identifier: unknown): identifier is PhoneNumberIdentifier => {\n    return typeof (identifier as any).phoneNumber === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - Th): identifier is PhoneNumberIdentifier => {\n    return typeof (identifier as any).phoneNumber === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (identifier: unknown): identifier is MicrosoftTeamsUserIdentifier => {\n    return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @para): identifier is MicrosoftTeamsUserIdentifier => {\n    return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (identifier: unknown): identifier is UnknownIdentifier => {\n    return typeof (identifier as any).id === \"string\";\n};\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n *): identifier is UnknownIdentifier => {\n    return typeof (identifier as any).id === \"string\";\n};\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind = CommunicationUserKind | PhoneNumberKind | MicrosoftTeamsUserKind | UnknownIdentifierKind;\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"communicationUser\";\n}\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"phoneNumber\";\n};\n}\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"phone\";\n}\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"microsoftTeamsUse;\n}\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"microsoftTeamsUser\";\n}\n/**\n * IdentifierKind for a UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"unknown\";\n}\n/*;\n}\n/**\n * IdentifierKind for UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"unknown\";\n}\n*/\n/**\n * An identifier kind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserIdentifier extends Identifier {\n    /**\n     * The identifier kind.\n     */\n    kind: \"communicationUser\";;\n}\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (identifier: CommunicationIdentifier): CommunicationIdentifierKind | undefined => {\n    if (isCommunicationUserIdentifier(identifier)) {\n        return \"communicationUser\";\n    }\n    if (isPhoneNumberIdentifier(identifier)) {\n        return \"phoneNumber\";\n    }\n    if (i): IdentifierKind {\n        return \"unknown\";\n    }\n};\nexport const getIdentifierKind = (identifier: CommunicationUserIdentifier): CommunicationIdentifierKind | undefined => {\n    if (isCommunicationUserIdentifier(identifier)) {\n        return \"communicationUser\" => {\n    if (isCommunicationUserIdentifier(identifier)) {\n        return { ...identifier, kind: \"communicationUser\" };\n    }\n    if (isPhoneNumberIdentifier(identifier)) {\n        return { ...identifier, kind: \"phoneNumber\" };\n    }\n    if (isMicrosoftTeamsUserIdentifier(identifier)) {\n        return { ...identifier, kind: \"microsoftTeamsUser\" };\n    }\n    return { ...identifier, kind: \"unknown\" };\n};\n/**\n * Returns the rawId for a given CommunicationIdentifier. You can use the rawId for encoding the identifier and then use it as a key in a database.\n *\n * @param identifier - The identifier to be translated to its rawId.\n */\nexport const getIdentifierRawId = (identifier: CommunicationIdentifier): string | undefined => {\n    const identifierKind = getIdentifierKind(identifier);\n    switch (identifierKind.kind) {\n        case \"communicationUser\":\n            return identifierKind.communicationUserId;\n        case \"phoneNumber\":\n            return identifie): PhoneNumberIdentifierRawId;\n        case \"microsoftTeamsUser\":\n            return identifierKind.microsoftTeamsUserId;\n        default:\n            return undefined;\n    }\n};\n/**\n * Return true if the identifier is a user identifier.\n * => {\n    const identifierKind = getIdentifierKind(identifier);\n    switch (identifierKind.kind) {\n        case \"communicationUser\":\n            return identifierKind.communicationUserId;\n        case \"microsoftTeamsUser\": {\n            const { microsoftTeamsUserId, rawId, cloud, isAnonymous } = identifierKind;\n            if (rawId)\n                return rawId;\n            if (isAnonymous)\n                return `8:teamsvisitor:${microsoftTeamsUserId}`;\n            switch (cloud) {\n                case \"dod\":\n                    return `8:dod:${microsoftTeamsUserId}`;\n                case \"gcch\":\n                    return `8:gcch:${microsoftTeamsUserId}`;\n                case \"public\":\n                    return `8:orgid:${microsoftTeamsUserId}`;\n            }\n            return `8:orgid:${microsoftTeamsUserId}`;\n        }\n        case \"phoneNumber\": {\n            const { phoneNumber, rawId } = identifierKind;\n            if (rawId)\n                return rawId;\n            // strip the leading +. We just assume correct E.164 format here because validation should only happen server-side, not client-side.\n            return `4:${phoneNumber.replace(/^\\+/, \"\")}`;\n        }\n        case \"unknown\": {\n            return identifierKind.id;\n        }\n    }\n};\n/**\n * Creates a CommunicationIdentifierKind from a given rawId. When storing rawIds use this function to restore the identifier that was encoded in the rawId.\n *\n * @param rawId - The rawId to be translated to its identifier representation.\n */\nexport const createIdentifierFromRawId = (rawId: string): CommunicationIdentifierKind => {\n    switch (rawId) {\n        case \"8:teamsvisitor:8:orgid:918f3f79-3573-43e2-b58): 8:teamsvisitor:8:orgid:918f3f79-3573-43e2-b58): 1:8:918f3f79-35 => {\n    if (rawId.startsWith(\"4:\")) {\n        return { kind: \"phoneNumber\", phoneNumber: `+${rawId.substring(\"4:\".length)}` };\n    }\n    const segments = rawId.split(\":\");\n    if (segments.length < 3)\n        return { kind: \"unknown\", id: rawId };\n    const prefix = `${segments[0]}:${segments[1]}:`;\n    const suffix = rawId.substring(prefix.length);\n    switch (prefix) {\n        case \"8:teamsvisitor:\":\n            return { kind: \"microsoftTeamsUser\", microsoftTeamsUserId: suffix, isAnonymous: true };\n        case \"8:orgid:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"public\",\n            };\n        case \"8:dod:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"dod\",\n            };\n        case \"8:gcch:\":\n            return {\n                kind: \"microsoftTeamsUser\",\n                microsoftTeamsUserId: suffix,\n                isAnonymous: false,\n                cloud: \"gcch\",\n            };\n        case \"8:acs:\":\n        case \"8:spool:\":\n        case \"8:dod-acs:\":\n        case \"8:gcch-acs:\":\n            return { kind: \"communicationUser\", communicationUserId: rawId };\n    }\n    return { kind: \"unknown\", id: rawId };\n};\n","score":112,"fallbacked":false,"num_type_errors":61}]}
{"dataset_elem":{"alphanum_fraction":0.5697194719,"avg_line_length":23.5339805825,"content":"/**\n * File Parser\n */\nexport class FileParser {\n  // Data for parsing\n  private readonly data: DataView;\n\n  // File pointer\n  private pointer: number;\n\n  /**\n   * Constructor\n   *\n   * @param dataView - Data to use for parsing\n   */\n  public constructor(dataView: DataView) {\n    this.data = dataView;\n    this.pointer = 0;\n  }\n\n  /**\n   * Move Pointer\n   *\n   * @param bytes - How many bytes to move by\n   */\n  public movePointer(bytes: number): number {\n    // Move the pointer negative and positive direction\n    this.pointer += bytes;\n    return this.pointer;\n  }\n\n  /**\n   * Read an integer from buffer\n   *\n   * @param bytes - Number of bytes to read\n   */\n  public readInt(bytes: number): number {\n    // Get integer from next bytes group (big-endian)\n    const clamp_bytes = Math.min(bytes, this.data.byteLength - this.pointer);\n\n    // EOF\n    if (clamp_bytes < 1) {\n      return -1;\n    }\n    let value = 0;\n    if (clamp_bytes > 1) {\n      for (let i = 1; i <= clamp_bytes - 1; i += 1) {\n        value += this.data.getUint8(this.pointer) * 256 ** (clamp_bytes - i);\n        this.pointer += 1;\n      }\n    }\n    value += this.data.getUint8(this.pointer);\n\n    this.pointer += 1;\n    return value;\n  }\n\n  /**\n   * Read a string from buffer\n   *\n   * @param bytes - Number of bytes to read\n   */\n  public readStr(bytes: number): string {\n    // Read as ASCII chars, the followoing bytes\n    let text = \"\";\n    for (let char = 1; char <= bytes; char += 1)\n      text += String.fromCharCode(this.readInt(1));\n    return text;\n  }\n\n  /**\n   * Read a variable length value\n   *\n   * @param bytes - Number of bytes to read\n   */\n  public readIntVLV(): number {\n    // Read a variable length value\n    let value = 0;\n    if (this.pointer >= this.data.byteLength) {\n      // EOF\n      return -1;\n    } else if (this.data.getUint8(this.pointer) < 128) {\n      // ...value in a single byte\n      value = this.readInt(1);\n    } else {\n      // ...value in multiple bytes\n      const FirstBytes: number[] = [];\n      while (this.data.getUint8(this.pointer) >= 128) {\n        FirstBytes.push(this.readInt(1) - 128);\n      }\n      const lastByte = this.readInt(1);\n      for (let dt = 1; dt <= FirstBytes.length; dt += 1) {\n        const num = FirstBytes[FirstBytes.length - dt];\n        if (typeof num === \"number\") {\n          value += num * 128 ** dt;\n        }\n      }\n      value += lastByte;\n    }\n    return value;\n  }\n}\n","content_without_annotations":"/**\n * File Parser\n */\nexport class FileParser {\n  // Data for parsing\n  private readonly data;\n\n  // File pointer\n  private pointer;\n\n  /**\n   * Constructor\n   *\n   * @param dataView - Data to use for parsing\n   */\n  public constructor(dataView) {\n    this.data = dataView;\n    this.pointer = 0;\n  }\n\n  /**\n   * Move Pointer\n   *\n   * @param bytes - How many bytes to move by\n   */\n  public movePointer(bytes) {\n    // Move the pointer negative and positive direction\n    this.pointer += bytes;\n    return this.pointer;\n  }\n\n  /**\n   * Read an integer from buffer\n   *\n   * @param bytes - Number of bytes to read\n   */\n  public readInt(bytes) {\n    // Get integer from next bytes group (big-endian)\n    const clamp_bytes = Math.min(bytes, this.data.byteLength - this.pointer);\n\n    // EOF\n    if (clamp_bytes < 1) {\n      return -1;\n    }\n    let value = 0;\n    if (clamp_bytes > 1) {\n      for (let i = 1; i <= clamp_bytes - 1; i += 1) {\n        value += this.data.getUint8(this.pointer) * 256 ** (clamp_bytes - i);\n        this.pointer += 1;\n      }\n    }\n    value += this.data.getUint8(this.pointer);\n\n    this.pointer += 1;\n    return value;\n  }\n\n  /**\n   * Read a string from buffer\n   *\n   * @param bytes - Number of bytes to read\n   */\n  public readStr(bytes) {\n    // Read as ASCII chars, the followoing bytes\n    let text = \"\";\n    for (let char = 1; char <= bytes; char += 1)\n      text += String.fromCharCode(this.readInt(1));\n    return text;\n  }\n\n  /**\n   * Read a variable length value\n   *\n   * @param bytes - Number of bytes to read\n   */\n  public readIntVLV() {\n    // Read a variable length value\n    let value = 0;\n    if (this.pointer >= this.data.byteLength) {\n      // EOF\n      return -1;\n    } else if (this.data.getUint8(this.pointer) < 128) {\n      // ...value in a single byte\n      value = this.readInt(1);\n    } else {\n      // ...value in multiple bytes\n      const FirstBytes = [];\n      while (this.data.getUint8(this.pointer) >= 128) {\n        FirstBytes.push(this.readInt(1) - 128);\n      }\n      const lastByte = this.readInt(1);\n      for (let dt = 1; dt <= FirstBytes.length; dt += 1) {\n        const num = FirstBytes[FirstBytes.length - dt];\n        if (typeof num === \"number\") {\n          value += num * 128 ** dt;\n        }\n      }\n      value += lastByte;\n    }\n    return value;\n  }\n}\n","dynamism_density":0.0014534884,"dynamism_heuristic":1,"estimated_tokens":688,"ext":"ts","fun_ann_density":0.0130813953,"function_parameters":4,"function_signatures":0,"function_usages":1,"functions":5,"hexsha":"e4d03cef3dbc28ce63d18957fd4779a2f080af09","lang":"TypeScript","loc":56,"loc_per_function":8.4,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"b041e90198d56453afc34ec4c90b2d277d316ca1","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"alegemaate/allegrots","max_forks_repo_path":"src/FileParser.ts","max_issues_count":2.0,"max_issues_repo_head_hexsha":"b041e90198d56453afc34ec4c90b2d277d316ca1","max_issues_repo_issues_event_max_datetime":"2022-03-31T23:01:09.000Z","max_issues_repo_issues_event_min_datetime":"2022-01-15T07:26:47.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"alegemaate/allegrots","max_issues_repo_path":"src/FileParser.ts","max_line_length":77,"max_stars_count":null,"max_stars_repo_head_hexsha":"b041e90198d56453afc34ec4c90b2d277d316ca1","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"alegemaate/allegrots","max_stars_repo_path":"src/FileParser.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2499671971,"predefined_density":0.4285714286,"predefined_types":9,"prop_ann_density":0.0029069767,"property_declarations":2,"size":2424,"trivial_density":0.0,"trivial_types":0,"type_definitions":1,"typedef_density":0.0014534884,"var_ann_density":0.0145348837,"variable_declarations":10},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * File Parser\n */\nexport class FileParser {\n    // Data for parsing\n    private readonly data: DataView;\n    private readonly pointer;\n    /**\n     * Constructor\n     *\n     * @param dataView - Data to use for parsing\n     */\n    public constructor(dataView) {\n        this.data = dataView;\n        this.pointer =;\n    // File pointer\n    private pointer: number;\n    }\n    /**\n     * Read a string from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readStr(bytes) {\n        // Read as ASCII chars, the followoing bytes\n        le;\n    /**\n     * Constructor\n     *\n     * @param dataView - Data to use for parsing\n     */\n    public constructor(dataView: DataView) {\n        this.data = dataView;\n        this.pointer = 0;\n    }\n    /**\n     * Read a integer from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readInt(byte) {\n        this.data = dataView;\n        this.pointer = 0;\n    }\n    /**\n     * Move Pointer\n     *\n     * @param bytes - How many bytes to move by\n     */\n    public movePointer(bytes: number) {\n        this.pointer = this.pointer + bytes;\n    }\n    /**\n     * Read a string from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readStr(bytes) {\n        /): number;\n        // Read as ASCII chars, the followoing bytes\n        le;\n    }\n}\n\n/**\n * Data File Reader\n */\nexport class DataFileReader {\n    private readonly data: DataView;\n    /**\n     * Constructor {\n        // Move the pointer negative and positive direction\n        this.pointer += bytes;\n        return this.pointer;\n    }\n    /**\n     * Read an integer from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readInt(bytes: number) {\n        return this.data.getInt32(this.pointer);\n    }\n    /**\n     * Read a string from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readStr(bytes): string {\n        return this.data.getString(this.pointer, bytes, 'ASCII');\n    }\n}\n\n/**\n * A class for parsing a CAD File\n */\nexport class CADParser {\n    private readonly data {\n        // Get integer from next bytes group (big-endian)\n        const clamp_bytes = Math.min(bytes, this.data.byteLength - this.pointer);\n        // EOF\n        if (clamp_bytes < 1) {\n            return -1;\n        }\n        let value = 0;\n        if (clamp_bytes > 1) {\n            for (let i = 1; i <= clamp_bytes - 1; i += 1) {\n                value += this.data.getUint8(this.pointer) * 256 ** (clamp_bytes - i);\n                this.pointer += 1;\n            }\n        }\n        value += this.data.getUint8(this.pointer);\n        this.pointer += 1;\n        return value;\n    }\n    /**\n     * Read a string from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readStr(bytes: number) {\n        // Read as ASCII chars, the followoing bytes\n        let text = \"\";\n        for (let char = 1; char <= bytes; char += 1)\n            text += String.fromCharCode(this.readInt(): 0);\n        return text;\n    }\n    /**\n     * Read a variable length value\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readIntVLV() {\n        // Read a variable length value\n        let value {\n        // Read as ASCII chars, the followoing bytes\n        let text = \"\";\n        for (let char = 1; char <= bytes; char += 1)\n            text += String.fromCharCode(this.readInt(1));\n        return text;\n    }\n    /**\n     * Read a variable length value\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readIntVLV(): string {\n        // Read a variable length value\n        let value {\n        // Read as ASCII chars, the followoing bytes\n        let text = \"\";\n        for (let char = 1; char <= bytes; char += 1)\n            tex {\n        // Read a variable length value\n        let value = 0;\n        if (this.pointer >= this.data.byteLength) {\n            // EOF\n            return -1;\n        }\n        else if (this.data.getUint8(this.pointer) < 128) {\n            // ...value in a single byte\n            value = this.readInt(1);\n        }\n        else {\n            // ...value in multiple bytes\n            const FirstBytes = [];\n            while (this.data.getUint8(this.pointer) >= 128) {\n                FirstBytes.push(this.readInt(1) - 128);\n            }\n            const lastByte = this.readInt(1);\n            for (let dt = 1; dt <= FirstBytes.length; dt += 1) {\n                const num = FirstBytes[FirstBytes.length - dt];\n                if (typeof num === \"number\") {\n                    value += num * 128 ** dt;\n                }\n            }\n            value += lastByte;\n        }\n        return value;\n    }\n}\n","score":381,"fallbacked":false,"num_type_errors":66},{"code":"/**\n * File Parser\n */\nexport class FileParser {\n    // Data for parsing\n    private readonly data: DataView;\n    // File pointer\n    private pointer;\n    /**\n     * Constructor\n     *\n     * @param dataView - Data to use for parsing\n     */\n    public constructor(dataView) {\n        this.data = dataView;\n        this;\n    // File pointer\n    private pointer: number;\n    }\n    /**\n     * Parse File\n     *\n     * @param bytes - Number of bytes to read from the file\n     */\n    public parse(bytes) {\n        // Parse Header\n        const header_bytes = this.readInt(;\n    /**\n     * Constructor\n     *\n     * @param dataView - Data to use for parsing\n     */\n    public constructor(dataView: DataView) {\n        this.data = dataView;\n        this.pointer = 0;\n    }\n    /**\n     * Move Pointer\n     *\n     * @param bytes - How many bytes to move by\n     */\n    public movePointer(bytes) {\n        this.data = dataView;\n        this.pointer = 0;\n    }\n    /**\n     * Move Pointer\n     *\n     * @param bytes - How many bytes to move by\n     */\n    public movePointer(bytes: number) {\n        this.pointer = this.pointer + bytes;\n    }\n    /**\n     * Read the string at the current pointer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readStr(bytes)): string {\n        // Move the pointer negative and positive direction\n        this.pointer += bytes;\n        // Read the string\n        return this.data.getUint8(this.pointer).toString(16).padStart(2, '0'); {\n        // Move the pointer negative and positive direction\n        this.pointer += bytes;\n        return this.pointer;\n    }\n    /**\n     * Read an integer from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readInt(bytes: number): number {\n        // Move the pointer negative and positive direction\n        this.pointer += bytes;\n        // Read integer\n        const value = this.data.getUint8(this.pointer) | this.data.getUint8(this.pointe): 0;\n        this.pointer += 1;\n        // Move the pointer negative and positive direction\n        this.pointer += bytes;\n        // Read integer\n        return value;\n    }\n    /**\n     * Read an integer from buffer\n     *\n     * {\n        // Get integer from next bytes group (big-endian)\n        const clamp_bytes = Math.min(bytes, this.data.byteLength - this.pointer);\n        // EOF\n        if (clamp_bytes < 1) {\n            return -1;\n        }\n        let value = 0;\n        if (clamp_bytes > 1) {\n            for (let i = 1; i <= clamp_bytes - 1; i += 1) {\n                value += this.data.getUint8(this.pointer) * 256 ** (clamp_bytes - i);\n                this.pointer += 1;\n            }\n        }\n        value += this.data.getUint8(this.pointer);\n        this.pointer += 1;\n        return value;\n    }\n    /**\n     * Read a string from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readStr(bytes: number): string {\n        // Read as ASCII chars, the followoing bytes\n        let text = \"\";\n        for (let char = 1; char <= bytes; char += 1)\n            text += String.fromCharCode(this.data): string;\n        return text;\n    }\n    /**\n     * Read a variable length value\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readIntVLV() {\n        // Read a variable length value\n        let value {\n        // Read as ASCII chars, the followoing bytes\n        let text = \"\";\n        for (let char = 1; char <= bytes; char += 1)\n            text += String.fromCharCode(this.readInt(1));\n        return text;\n    }\n    /**\n     * Read a variable length value\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readIntVLV(): number {\n        // Read a variable length value\n        let value {\n        // Read as ASCII chars, the followoing bytes\n        let text = \"\";\n        for (let char = 1; char <= bytes; char += 1)\n            tex {\n        // Read a variable length value\n        let value = 0;\n        if (this.pointer >= this.data.byteLength) {\n            // EOF\n            return -1;\n        }\n        else if (this.data.getUint8(this.pointer) < 128) {\n            // ...value in a single byte\n            value = this.readInt(1);\n        }\n        else {\n            // ...value in multiple bytes\n            const FirstBytes = [];\n            while (this.data.getUint8(this.pointer) >= 128) {\n                FirstBytes.push(this.readInt(1) - 128);\n            }\n            const lastByte = this.readInt(1);\n            for (let dt = 1; dt <= FirstBytes.length; dt += 1) {\n                const num = FirstBytes[FirstBytes.length - dt];\n                if (typeof num === \"number\") {\n                    value += num * 128 ** dt;\n                }\n            }\n            value += lastByte;\n        }\n        return value;\n    }\n}\n","score":433,"fallbacked":false,"num_type_errors":77},{"code":"/**\n * File Parser\n */\nexport class FileParser {\n    // Data for parsing\n    private readonly data: DataView;\n    // Current file pointer\n    private pointer;\n    /**\n     * Constructor\n     *\n     * @param dataView - Data to use for parsing\n     */\n    public constructor(dataView) {\n        this.data = dataView;\n        thi;\n    // File pointer\n    private pointer: number;\n    }\n    /**\n     * Read a string from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readStr(bytes) {\n        // Read as ASCII chars, the followoing bytes\n        le;\n    /**\n     * Constructor\n     *\n     * @param dataView - Data to use for parsing\n     */\n    public constructor(dataView: DataView) {\n        this.data = dataView;\n        this.pointer = 0;\n    }\n    /**\n     * Move Pointer\n     *\n     * @param bytes - How many bytes to move by\n     */\n    public movePointer(bytes) {\n        this.data = dataView;\n        this.pointer = 0;\n    }\n    /**\n     * Move Pointer\n     *\n     * @param bytes - How many bytes to move by\n     */\n    public movePointer(bytes: number): number {\n        // Move the pointer negative and positive direction\n        this.pointer += bytes;\n        return this.pointer;\n    }\n    /**\n     * Read an integer from buffer\n     *\n     * @param bytes - Number of bytes to read\n     * {\n        // Move the pointer negative and positive direction\n        this.pointer += bytes;\n        return this.pointer;\n    }\n    /**\n     * Read an integer from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readInt(bytes: number): number {\n        // Get integer from next bytes group (big-endian)\n        const clamp_bytes = Math.min(bytes, this.data.byteLength - this.pointer);\n        // EOF\n        if (clamp_bytes <): {\n            return -1;\n        }\n        let value = 0;\n        for (let i = 0; i < clamp_bytes; i += 1) {\n            value += this.data.getUint8(this.pointer++ {\n        // Get integer from next bytes group (big-endian)\n        const clamp_bytes = Math.min(bytes, this.data.byteLength - this.pointer);\n        // EOF\n        if (clamp_bytes < 1) {\n            return -1;\n        }\n        let value = 0;\n        if (clamp_bytes > 1) {\n            for (let i = 1; i <= clamp_bytes - 1; i += 1) {\n                value += this.data.getUint8(this.pointer) * 256 ** (clamp_bytes - i);\n                this.pointer += 1;\n            }\n        }\n        value += this.data.getUint8(this.pointer);\n        this.pointer += 1;\n        return value;\n    }\n    /**\n     * Read a string from buffer\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readStr(bytes: number): string {\n        // Read as ASCII chars, the followoing bytes\n        let text = \"\";\n        for (let char = 1; char <= bytes; char += 1)\n            text += String.fromCharCode(this.readInt): string;\n        return text;\n    }\n    /**\n     * Read a variable length value\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readIntVLV() {\n        // Read a variable length value\n        let value {\n        // Read as ASCII chars, the followoing bytes\n        let text = \"\";\n        for (let char = 1; char <= bytes; char += 1)\n            text += String.fromCharCode(this.readInt(1));\n        return text;\n    }\n    /**\n     * Read a variable length value\n     *\n     * @param bytes - Number of bytes to read\n     */\n    public readIntVLV(): number {\n        // Read a variable length value\n        let value = 0;\n        if (this.pointer >= this.data.byteLength) {\n            // EOF\n            return -1;\n        }\n        else if (this.data.getUint {\n        // Read a variable length value\n        let value = 0;\n        if (this.pointer >= this.data.byteLength) {\n            // EOF\n            return -1;\n        }\n        else if (this.data.getUint8(this.pointer) < 128) {\n            // ...value in a single byte\n            value = this.readInt(1);\n        }\n        else {\n            // ...value in multiple bytes\n            const FirstBytes = [];\n            while (this.data.getUint8(this.pointer) >= 128) {\n                FirstBytes.push(this.readInt(1) - 128);\n            }\n            const lastByte = this.readInt(1);\n            for (let dt = 1; dt <= FirstBytes.length; dt += 1) {\n                const num = FirstBytes[FirstBytes.length - dt];\n                if (typeof num === \"number\") {\n                    value += num * 128 ** dt;\n                }\n            }\n            value += lastByte;\n        }\n        return value;\n    }\n}\n","score":450,"fallbacked":false,"num_type_errors":82}]}
{"dataset_elem":{"alphanum_fraction":0.6704929102,"avg_line_length":38.9736842105,"content":"\nconst imageFormats = [\"png\", \"jpg\", \"jpeg\", \"webp\"];\nconst videoFormats = [\"mp4\", \"m4v\"];\nconst audioFormats = [\"aac\", \"mp3\", \"weba\", \"mpeg\"];\nconst threeDFormats = [\"glb\", \"gltf\"];\nconst compressedFormats = [\"zip\", \"rar\", \"tar\", \"gzip\", \"gz\", \"bz2\", \"7z\"];\nconst gifFormats = [\"gif\"];\nconst pdfFormats = [\"pdf\"];\nexport const extensionWhitelist = [...imageFormats, ...videoFormats, ...audioFormats, ...threeDFormats, ...compressedFormats, ...gifFormats, ...pdfFormats];\nexport const disallowedFileExtensions = [\"php\", \"php3\", \"php4\", \"phtml\", \"pl\", \"py\", \"jsp\", \"asp\", \"htm\", \"shtml\", \"sh\", \"cg\"];\n\nexport const allowedMimeTypes = {\n  IMAGE: [\"image/png\", \"image/jpg\", \"image/jpeg\", \"image/webp\"],\n  VIDEO: [\"video/mp4\", \"video/mpeg\", \"video/x-m4v\"],\n  AUDIO: [\"audio/aac\", \"audio/mp3\", \"audio/mpeg\"],\n  COMPRESSED: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n  THREED: [\"model/gltf+binary\", \"model/gltf+json\"],\n  GIF: [\"image/gif\"],\n  OTHER: [\"application/pdf\"],\n  PDF: [\"application/pdf\"],\n  SPRITE: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n  SCORM: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n};\n\nexport enum FileType {\n  IMAGE = \"IMAGE\",\n  GIF = \"GIF\",\n  VIDEO = \"VIDEO\",\n  AUDIO = \"AUDIO\",\n  THREED = \"THREED\",\n  COMPRESSED = \"COMPRESSED\",\n  PDF = \"PDF\",\n  SCORM = \"SCORM\",\n  SPRITE = \"SPRITE\",\n  OTHER = \"OTHER\",\n}\n\nexport const getFileType = (path: string): FileType => {\n  const extension = getExtension(path);\n  if (imageFormats.includes(extension)) {\n    return FileType.IMAGE;\n  } else if (videoFormats.includes(extension)) {\n    return FileType.VIDEO;\n  } else if (audioFormats.includes(extension)) {\n    return FileType.AUDIO;\n  } else if (threeDFormats.includes(extension)) {\n    return FileType.THREED;\n  } else if (compressedFormats.includes(extension)) {\n    return FileType.COMPRESSED;\n  } else if (gifFormats.includes(extension)) {\n    return FileType.GIF;\n  } else if (pdfFormats.includes(extension)) {\n    return FileType.PDF;\n  } else {\n    return FileType.OTHER;\n  }\n}\n\nexport const getExtension = (path: string): string => {\n  // remove any query params that may be in the url\n  const q = path.split(\"?\");\n  if (q.length >= 2) {\n    path = q[0];\n  }\n  const fullFileName: string = path.substring(path.lastIndexOf(\"/\") + 1);\n  return fullFileName.substring(fullFileName.lastIndexOf(\".\") + 1).toLowerCase();\n}\n\nexport function getFilenameWithoutExtension(path: string): string {\n  const fileName: string = path.substring(path.lastIndexOf(\"/\") + 1);\n  return fileName.substring(0, fileName.lastIndexOf(\".\"));\n}\n\nexport function getFolderPathWithoutFilename(folderPath: string): string {\n  return folderPath.substring(0, folderPath.lastIndexOf(\"/\"));\n}","content_without_annotations":"\nconst imageFormats = [\"png\", \"jpg\", \"jpeg\", \"webp\"];\nconst videoFormats = [\"mp4\", \"m4v\"];\nconst audioFormats = [\"aac\", \"mp3\", \"weba\", \"mpeg\"];\nconst threeDFormats = [\"glb\", \"gltf\"];\nconst compressedFormats = [\"zip\", \"rar\", \"tar\", \"gzip\", \"gz\", \"bz2\", \"7z\"];\nconst gifFormats = [\"gif\"];\nconst pdfFormats = [\"pdf\"];\nexport const extensionWhitelist = [...imageFormats, ...videoFormats, ...audioFormats, ...threeDFormats, ...compressedFormats, ...gifFormats, ...pdfFormats];\nexport const disallowedFileExtensions = [\"php\", \"php3\", \"php4\", \"phtml\", \"pl\", \"py\", \"jsp\", \"asp\", \"htm\", \"shtml\", \"sh\", \"cg\"];\n\nexport const allowedMimeTypes = {\n  IMAGE: [\"image/png\", \"image/jpg\", \"image/jpeg\", \"image/webp\"],\n  VIDEO: [\"video/mp4\", \"video/mpeg\", \"video/x-m4v\"],\n  AUDIO: [\"audio/aac\", \"audio/mp3\", \"audio/mpeg\"],\n  COMPRESSED: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n  THREED: [\"model/gltf+binary\", \"model/gltf+json\"],\n  GIF: [\"image/gif\"],\n  OTHER: [\"application/pdf\"],\n  PDF: [\"application/pdf\"],\n  SPRITE: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n  SCORM: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n};\n\nexport enum FileType {\n  IMAGE = \"IMAGE\",\n  GIF = \"GIF\",\n  VIDEO = \"VIDEO\",\n  AUDIO = \"AUDIO\",\n  THREED = \"THREED\",\n  COMPRESSED = \"COMPRESSED\",\n  PDF = \"PDF\",\n  SCORM = \"SCORM\",\n  SPRITE = \"SPRITE\",\n  OTHER = \"OTHER\",\n}\n\nexport const getFileType = (path) => {\n  const extension = getExtension(path);\n  if (imageFormats.includes(extension)) {\n    return FileType.IMAGE;\n  } else if (videoFormats.includes(extension)) {\n    return FileType.VIDEO;\n  } else if (audioFormats.includes(extension)) {\n    return FileType.AUDIO;\n  } else if (threeDFormats.includes(extension)) {\n    return FileType.THREED;\n  } else if (compressedFormats.includes(extension)) {\n    return FileType.COMPRESSED;\n  } else if (gifFormats.includes(extension)) {\n    return FileType.GIF;\n  } else if (pdfFormats.includes(extension)) {\n    return FileType.PDF;\n  } else {\n    return FileType.OTHER;\n  }\n}\n\nexport const getExtension = (path) => {\n  // remove any query params that may be in the url\n  const q = path.split(\"?\");\n  if (q.length >= 2) {\n    path = q[0];\n  }\n  const fullFileName = path.substring(path.lastIndexOf(\"/\") + 1);\n  return fullFileName.substring(fullFileName.lastIndexOf(\".\") + 1).toLowerCase();\n}\n\nexport function getFilenameWithoutExtension(path) {\n  const fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n  return fileName.substring(0, fileName.lastIndexOf(\".\"));\n}\n\nexport function getFolderPathWithoutFilename(folderPath) {\n  return folderPath.substring(0, folderPath.lastIndexOf(\"/\"));\n}","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":881,"ext":"ts","fun_ann_density":0.0090805902,"function_parameters":4,"function_signatures":0,"function_usages":1,"functions":4,"hexsha":"e4d360f3d4c1039bdb46a42d9a95cd24139f5154","lang":"TypeScript","loc":68,"loc_per_function":6.75,"max_forks_count":2.0,"max_forks_repo_forks_event_max_datetime":"2022-03-25T05:25:54.000Z","max_forks_repo_forks_event_min_datetime":"2022-02-28T10:42:13.000Z","max_forks_repo_head_hexsha":"e2d3cacb7a34f83777a2aa333dc93397b153f6ae","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"gmetrixr/gdash","max_forks_repo_path":"src/namespaces/pathUtils.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"e2d3cacb7a34f83777a2aa333dc93397b153f6ae","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"gmetrixr/gdash","max_issues_repo_path":"src/namespaces/pathUtils.ts","max_line_length":156,"max_stars_count":null,"max_stars_repo_head_hexsha":"e2d3cacb7a34f83777a2aa333dc93397b153f6ae","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"gmetrixr/gdash","max_stars_repo_path":"src/namespaces/pathUtils.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2503864922,"predefined_density":0.375,"predefined_types":9,"prop_ann_density":0.0,"property_declarations":0,"size":2962,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0181611805,"variable_declarations":16},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"const imageFormats = [\"png\", \"jpg\", \"jpeg\", \"webp\"];\nconst videoFormats = [\"mp4\", \"m4v\"];\nconst audioFormats = [\"aac\", \"mp3\", \"weba\", \"mpeg\"];\nconst threeDFormats = [\"glb\", \"gltf\"];\nconst compressedFormats = [\"zip\", \"rar\", \"tar\", \"gzip\", \"gz\", \"bz2\", \"7z\"];\nconst gifFormats = [\"gif\"];\nconst pdfFormats = [\"pdf\"];\nexport const extensionWhitelist = [...imageFormats, ...videoFormats, ...audioFormats, ...threeDFormats, ...compressedFormats, ...gifFormats, ...pdfFormats];\nexport const disallowedFileExtensions = [\"php\", \"php3\", \"php4\", \"phtml\", \"pl\", \"py\", \"jsp\", \"asp\", \"htm\", \"shtml\", \"sh\", \"cg\"];\nexport const allowedMimeTypes = {\n    IMAGE: [\"image/png\", \"image/jpg\", \"image/jpeg\", \"image/webp\"],\n    VIDEO: [\"video/mp4\", \"video/mpeg\", \"video/x-m4v\"],\n    AUDIO: [\"audio/aac\", \"audio/mp3\", \"audio/mpeg\"],\n    COMPRESSED: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n    THREED: [\"model/gltf+binary\", \"model/gltf+json\"],\n    GIF: [\"image/gif\"],\n    OTHER: [\"application/pdf\"],\n    PDF: [\"application/pdf\"],\n    SPRITE: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n    SCORM: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n};\nexport enum FileType {\n    IMAGE = \"IMAGE\",\n    GIF = \"GIF\",\n    VIDEO = \"VIDEO\",\n    AUDIO = \"AUDIO\",\n    THREED = \"THREED\",\n    COMPRESSED = \"COMPRESSED\",\n    PDF = \"PDF\",\n    SCORM = \"SCORM\",\n    SPRITE = \"SPRITE\",\n    OTHER = \"OTHER\"\n}\nexport const getFileType = (path: string) => {\n    const extension = getExtension(path);\n    if (imageFormats.includes(extension)) {\n        return FileType.IMAGE;\n    }\n    else if (videoFormats.includes(extension)) {\n        return FileType.VIDEO): FileType;\n    }\n    else if (audioFormats.includes(extension)) {\n        return FileType.AUDIO;\n    }\n    else if (threeDFormats.includes(extension)) {\n        return FileType.THREED;\n    }\n    else i => {\n    const extension = getExtension(path);\n    if (imageFormats.includes(extension)) {\n        return FileType.IMAGE;\n    }\n    else if (videoFormats.includes(extension)) {\n        return FileType.VIDEO;\n    }\n    else if (audioFormats.includes(extension)) {\n        return FileType.AUDIO;\n    }\n    else if (threeDFormats.includes(extension)) {\n        return FileType.THREED;\n    }\n    else if (compressedFormats.includes(extension)) {\n        return FileType.COMPRESSED;\n    }\n    else if (gifFormats.includes(extension)) {\n        return FileType.GIF;\n    }\n    else if (pdfFormats.includes(extension)) {\n        return FileType.PDF;\n    }\n    else {\n        return FileType.OTHER;\n    }\n};\nexport const getExtension = (path: string) => {\n    if (path.indexOf(\".\") === -1) {\n        return \"\";\n    }\n    else {\n        return path.substring(path.lastIndexOf(\".\") + 1, path.length).toLowerCase();\n    }\n};\nexpor): string => {\n    const fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    return fileName.substring(fileName.lastIndexOf(\".\") + 1).toLowerCase();\n};\nexport const getFilePath = (path: string, fileType => {\n    // remove any query params that may be in the url\n    const q = path.split(\"?\");\n    if (q.length >= 2) {\n        path = q[0];\n    }\n    const fullFileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    return fullFileName.substring(fullFileName.lastIndexOf(\".\") + 1).toLowerCase();\n};\nexport function getFilenameWithoutExtension(path: string): string {\n    const fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    return fileName;\n}\nexport function getFilenameFromPath(path: string) {\n    const fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    return fileName.substring(0, fileName.lastIndexOf(\".\"));\n}\nexport function getFolderPathWithoutFilename(folderPath: string): string {\n    return folderPath.substring(0, folderPath.lastIndexOf(\"/\"));\n}\nexport function getFolderPath(folderPath: string): string {\n    return folderPath.substring(0, folderPath.lastIndexOf(\"/\"));\n}\n","score":361,"fallbacked":false,"num_type_errors":8},{"code":"const imageFormats = [\"png\", \"jpg\", \"jpeg\", \"webp\"];\nconst videoFormats = [\"mp4\", \"m4v\"];\nconst audioFormats = [\"aac\", \"mp3\", \"weba\", \"mpeg\"];\nconst threeDFormats = [\"glb\", \"gltf\"];\nconst compressedFormats = [\"zip\", \"rar\", \"tar\", \"gzip\", \"gz\", \"bz2\", \"7z\"];\nconst gifFormats = [\"gif\"];\nconst pdfFormats = [\"pdf\"];\nexport const extensionWhitelist = [...imageFormats, ...videoFormats, ...audioFormats, ...threeDFormats, ...compressedFormats, ...gifFormats, ...pdfFormats];\nexport const disallowedFileExtensions = [\"php\", \"php3\", \"php4\", \"phtml\", \"pl\", \"py\", \"jsp\", \"asp\", \"htm\", \"shtml\", \"sh\", \"cg\"];\nexport const allowedMimeTypes = {\n    IMAGE: [\"image/png\", \"image/jpg\", \"image/jpeg\", \"image/webp\"],\n    VIDEO: [\"video/mp4\", \"video/mpeg\", \"video/x-m4v\"],\n    AUDIO: [\"audio/aac\", \"audio/mp3\", \"audio/mpeg\"],\n    COMPRESSED: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n    THREED: [\"model/gltf+binary\", \"model/gltf+json\"],\n    GIF: [\"image/gif\"],\n    OTHER: [\"application/pdf\"],\n    PDF: [\"application/pdf\"],\n    SPRITE: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n    SCORM: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n};\nexport enum FileType {\n    IMAGE = \"IMAGE\",\n    GIF = \"GIF\",\n    VIDEO = \"VIDEO\",\n    AUDIO = \"AUDIO\",\n    THREED = \"THREED\",\n    COMPRESSED = \"COMPRESSED\",\n    PDF = \"PDF\",\n    SCORM = \"SCORM\",\n    SPRITE = \"SPRITE\",\n    OTHER = \"OTHER\"\n}\nexport const getFileType = (path: string): FileType => {\n    const extension = getExtension(path);\n    if (imageFormats.includes(extension)) {\n        return FileType.IMAGE;\n    }\n    else if (videoFormats.includes(extension)) {\n        return FileType.VIDE): FileType.VIDEO;\n    }\n    else if (audioFormats.includes(extension)) {\n        return FileType.AUDIO;\n    }\n    else if (threeDFormats.includes(extension)) {\n        return FileType.THREED;\n    } => {\n    const extension = getExtension(path);\n    if (imageFormats.includes(extension)) {\n        return FileType.IMAGE;\n    }\n    else if (videoFormats.includes(extension)) {\n        return FileType.VIDEO;\n    }\n    else if (audioFormats.includes(extension)) {\n        return FileType.AUDIO;\n    }\n    else if (threeDFormats.includes(extension)) {\n        return FileType.THREED;\n    }\n    else if (compressedFormats.includes(extension)) {\n        return FileType.COMPRESSED;\n    }\n    else if (gifFormats.includes(extension)) {\n        return FileType.GIF;\n    }\n    else if (pdfFormats.includes(extension)) {\n        return FileType.PDF;\n    }\n    else {\n        return FileType.OTHER;\n    }\n};\nexport const getExtension = (path: string) => {\n    if (path.indexOf(\".\") === -1) {\n        return \"\";\n    }\n    return path.substring(path.lastIndexOf(\".\") + 1);\n};\nexport const isImage = (path: string) =>): boolean => imageFormats.includes(getExtension(path));\nexport const isVideo = (path: string) => videoFormats.includes(getExtension(path));\nexport const isCompressed = (path: string) => compressedFormats.includes(getExtensio => {\n    // remove any query params that may be in the url\n    const q = path.split(\"?\");\n    if (q.length >= 2) {\n        path = q[0];\n    }\n    const fullFileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    return fullFileName.substring(fullFileName.lastIndexOf(\".\") + 1).toLowerCase();\n};\nexport function getFilenameWithoutExtension(path: string): string {\n    const fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    const extension = fileName.substring(fileName.lastIndexOf(\".\") + 1);\n    return fileName.substring(0, fileName.lastIndexOf(\".\"));\n} {\n    const fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    return fileName.substring(0, fileName.lastIndexOf(\".\"));\n}\nexport function getFolderPathWithoutFilename(folderPath: string): string {\n    return folderPath.substring(0, folderPath.lastIndexOf(\"/\") + 1);\n}\nexport function getFolder(folderPath: string): string {\n    return folderPath.substring(0, folderPath.lastIndexOf(\"/\"));\n}\n","score":267,"fallbacked":false,"num_type_errors":14},{"code":"const imageFormats = [\"png\", \"jpg\", \"jpeg\", \"webp\"];\nconst videoFormats = [\"mp4\", \"m4v\"];\nconst audioFormats = [\"aac\", \"mp3\", \"weba\", \"mpeg\"];\nconst threeDFormats = [\"glb\", \"gltf\"];\nconst compressedFormats = [\"zip\", \"rar\", \"tar\", \"gzip\", \"gz\", \"bz2\", \"7z\"];\nconst gifFormats = [\"gif\"];\nconst pdfFormats = [\"pdf\"];\nexport const extensionWhitelist = [...imageFormats, ...videoFormats, ...audioFormats, ...threeDFormats, ...compressedFormats, ...gifFormats, ...pdfFormats];\nexport const disallowedFileExtensions = [\"php\", \"php3\", \"php4\", \"phtml\", \"pl\", \"py\", \"jsp\", \"asp\", \"htm\", \"shtml\", \"sh\", \"cg\"];\nexport const allowedMimeTypes = {\n    IMAGE: [\"image/png\", \"image/jpg\", \"image/jpeg\", \"image/webp\"],\n    VIDEO: [\"video/mp4\", \"video/mpeg\", \"video/x-m4v\"],\n    AUDIO: [\"audio/aac\", \"audio/mp3\", \"audio/mpeg\"],\n    COMPRESSED: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n    THREED: [\"model/gltf+binary\", \"model/gltf+json\"],\n    GIF: [\"image/gif\"],\n    OTHER: [\"application/pdf\"],\n    PDF: [\"application/pdf\"],\n    SPRITE: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n    SCORM: [\"application/zip\", \"application/vnd.rar\", \"application/x-tar\", \"application/gzip\", \"application/x-bzip2\", \"application/x-7z-compressed\"],\n};\nexport enum FileType {\n    IMAGE = \"IMAGE\",\n    GIF = \"GIF\",\n    VIDEO = \"VIDEO\",\n    AUDIO = \"AUDIO\",\n    THREED = \"THREED\",\n    COMPRESSED = \"COMPRESSED\",\n    PDF = \"PDF\",\n    SCORM = \"SCORM\",\n    SPRITE = \"SPRITE\",\n    OTHER = \"OTHER\"\n}\nexport const getFileType = (path: string) => {\n    if (!path) {\n        return FileType.OTHER;\n    }\n    const extension = getExtension(path);\n    if (imageFormats.includes(extension)) {\n        return FileType.IMAGE;\n    }\n    else if): if (videoFormats.includes(extension)) {\n        return FileType.VIDEO;\n    }\n    else if (audioFormats.includes(extension)) {\n        return FileType.AUDIO;\n    }\n    else if (threeDFormats.includes(extension) => {\n    const extension = getExtension(path);\n    if (imageFormats.includes(extension)) {\n        return FileType.IMAGE;\n    }\n    else if (videoFormats.includes(extension)) {\n        return FileType.VIDEO;\n    }\n    else if (audioFormats.includes(extension)) {\n        return FileType.AUDIO;\n    }\n    else if (threeDFormats.includes(extension)) {\n        return FileType.THREED;\n    }\n    else if (compressedFormats.includes(extension)) {\n        return FileType.COMPRESSED;\n    }\n    else if (gifFormats.includes(extension)) {\n        return FileType.GIF;\n    }\n    else if (pdfFormats.includes(extension)) {\n        return FileType.PDF;\n    }\n    else {\n        return FileType.OTHER;\n    }\n};\nexport const getExtension = (path: string) => {\n    if (!path) {\n        return \"\";\n    }\n    return path.substr(path.lastIndexOf(\".\") + 1);\n};\nexport const isZip = (path: string) => {\n    const extension = getExtensio): boolean => {\n        return path.endsWith(\".zip\") || path.endsWith(\".zip.gz\") || path.endsWith(\".zip.bz2\");\n    };\n    return extension(path);\n};\nexport const isZipArchive = (path => {\n    // remove any query params that may be in the url\n    const q = path.split(\"?\");\n    if (q.length >= 2) {\n        path = q[0];\n    }\n    const fullFileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    return fullFileName.substring(fullFileName.lastIndexOf(\".\") + 1).toLowerCase();\n};\nexport function getFilenameWithoutExtension(path: string) {\n    if (!path) {\n        return \"\";\n    }\n    const extension = getExtension(path);\n    if (extension === \"zip\") {\n        return getFilenameWithoutExtension(path as any);\n    }\n    else if (extensio): boolean {\n        return getFilenameWithoutExtension(path as any);\n    }\n    else {\n        const fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n        return fileName.substring(0, fileName.length - getExtension(pat {\n    const fileName = path.substring(path.lastIndexOf(\"/\") + 1);\n    return fileName.substring(0, fileName.lastIndexOf(\".\"));\n}\nexport function getFolderPathWithoutFilename(folderPath: string): string {\n    return folderPath.substring(0, folderPath.lastIndexOf(\"/\"));\n}\n","score":406,"fallbacked":false,"num_type_errors":26}]}
{"dataset_elem":{"alphanum_fraction":0.5619834711,"avg_line_length":23.1123595506,"content":"/**\n * 过滤表情\n * @param name\n * @returns\n */\nexport const filterEmoji = (name) => {\n  const str = name.replace(\n    /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi,\n    \"\"\n  );\n  return str;\n};\n\n/**\n * 过滤税号\n * @param num\n * @returns\n */\nexport const isNumber = (num: string) =>\n  /^[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/.test(num);\n\n/**\n * 验证手机号\n * @param phone\n * @returns\n */\nexport const isPhone = (phone: any) => /^[1][0-9]{10}$/.test(phone);\n\n/**\n * 验证邮箱\n * @param email\n * @returns\n */\nexport const isEmail = (email: string) =>\n  /^([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+\\.[a-zA-Z]{2,3}$/.test(\n    email\n  );\n\n/**\n * 验证是否存在特殊符号或者表情\n * @param value\n * @param tips\n * @returns\n */\nexport const hasEmoji = function (value: string, tips = \"\") {\n  let char =\n    /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi;\n  if (char.test(value)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * 获取数组索引值\n * @param param0\n * @returns\n */\nexport const getIndexArr = function ({\n  id = \"\",\n  productTree = [],\n  idKey = \"id\",\n  childrenKey = \"child\",\n}: {\n  id: string;\n  productTree?: Array<any>;\n  idKey?: string;\n  childrenKey?: string;\n}) {\n  let indexArr: number[] = [];\n  let fn: (arr: Array<any>) => boolean = (arr) =>\n    arr.some((elem: any, index) => {\n      if (elem[idKey] == id) {\n        indexArr.push(index);\n        return true;\n      } else if (\n        elem[childrenKey] &&\n        elem[childrenKey] instanceof Array &&\n        elem[childrenKey].length\n      ) {\n        return fn(elem[childrenKey]) && indexArr.push(index);\n      }\n      return false;\n    });\n  fn(productTree);\n  indexArr.reverse();\n  return indexArr;\n};\n","content_without_annotations":"/**\n * 过滤表情\n * @param name\n * @returns\n */\nexport const filterEmoji = (name) => {\n  const str = name.replace(\n    /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi,\n    \"\"\n  );\n  return str;\n};\n\n/**\n * 过滤税号\n * @param num\n * @returns\n */\nexport const isNumber = (num) =>\n  /^[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/.test(num);\n\n/**\n * 验证手机号\n * @param phone\n * @returns\n */\nexport const isPhone = (phone) => /^[1][0-9]{10}$/.test(phone);\n\n/**\n * 验证邮箱\n * @param email\n * @returns\n */\nexport const isEmail = (email) =>\n  /^([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+\\.[a-zA-Z]{2,3}$/.test(\n    email\n  );\n\n/**\n * 验证是否存在特殊符号或者表情\n * @param value\n * @param tips\n * @returns\n */\nexport const hasEmoji = function (value, tips = \"\") {\n  let char =\n    /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi;\n  if (char.test(value)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * 获取数组索引值\n * @param param0\n * @returns\n */\nexport const getIndexArr = function ({\n  id = \"\",\n  productTree = [],\n  idKey = \"id\",\n  childrenKey = \"child\",\n}) {\n  let indexArr = [];\n  let fn = (arr) =>\n    arr.some((elem, index) => {\n      if (elem[idKey] == id) {\n        indexArr.push(index);\n        return true;\n      } else if (\n        elem[childrenKey] &&\n        elem[childrenKey] instanceof Array &&\n        elem[childrenKey].length\n      ) {\n        return fn(elem[childrenKey]) && indexArr.push(index);\n      }\n      return false;\n    });\n  fn(productTree);\n  indexArr.reverse();\n  return indexArr;\n};\n","dynamism_density":0.0010718114,"dynamism_heuristic":1,"estimated_tokens":933,"ext":"ts","fun_ann_density":0.0192926045,"function_parameters":10,"function_signatures":0,"function_usages":1,"functions":8,"hexsha":"a7d2370ab8654f6a4ae33e2acb3c198102b400d1","lang":"TypeScript","loc":52,"loc_per_function":7.25,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"d09a0db2a34fc9352251cdac768d89980541695b","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"codeluosiyu/toa-tools","max_forks_repo_path":"src/utils/verification.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"d09a0db2a34fc9352251cdac768d89980541695b","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"codeluosiyu/toa-tools","max_issues_repo_path":"src/utils/verification.ts","max_line_length":241,"max_stars_count":35.0,"max_stars_repo_head_hexsha":"4a88a32b9a5a642ec402f7540941da39661bc604","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"codeluosiyu/toa-utils","max_stars_repo_path":"src/utils/verification.ts","max_stars_repo_stars_event_max_datetime":"2022-03-24T12:02:50.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-12T16:28:38.000Z","metric":0.2476512917,"predefined_density":0.2857142857,"predefined_types":8,"prop_ann_density":0.0,"property_declarations":0,"size":2057,"trivial_density":0.1428571429,"trivial_types":4,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0107181136,"variable_declarations":10},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * 过滤表情\n * @param name\n * @returns\n */\nexport const filterEmoji = (name: string): string => {\n    const str = name.replace(/[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD => {\n    const str = name.replace(/[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi, \"\");\n    return str;\n};\n/**\n * 过滤税号\n * @param num\n * @returns\n */\nexport const isNumber = (num: number): boolean => {\n    return /^([0-9]{3,4}-[0-9]{6,7})$/.test(num);\n};\n/**\n * 过滤身份证\n * @param num\n * @returns\n * => /^[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/.test(num);\n/**\n * 验证手机号\n * @param phone\n * @returns\n */\nexport const isPhone = (phone: string): boolean => {\n    return /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(phone);\n};\n/**\n * 验证身份证\n * @param num\n * => /^[1][0-9]{10}$/.test(phone);\n/**\n * 验证邮箱\n * @param email\n * @returns\n */\nexport const isEmail = (email: string): boolean => {\n    return /^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4}): )?([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})?$)|(^[a-zA-Z0- => /^([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+\\.[a-zA-Z]{2,3}$/.test(email);\n/**\n * 验证是否存在特殊符号或者表情\n * @param value\n * @param tips\n * @returns\n */\nexport const hasEmoji = function (value: string, tips = \"\") {\n    const str = value.replace(/[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F], tips: \"\").replace(\", tips\", \"\");\n    if (str === \"\") {\n        return true;\n    } else {\n        return false;\n    }\n};\n/**\n * 过滤字符\n * @param value\n * @param tips\n * = \"\"): => /^[a-zA-Z0-9\\u4e00-\\u9fa5]{0,}$/.test(value);\n */\nexport const isChar = (value: string, tips = \"\"): boolean => { {\n    let char = /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi;\n    if (char.test(value)) {\n        return true;\n    }\n    return false;\n};\n/**\n * 获取数组索引值\n * @param param0\n * @returns\n */\nexport const getIndexArr = function ({ id = \"\", productTree = [], idKey = \"id\", childrenKey = \"child\", }: IndexParam): number[] => {\n    let indexArr = [];\n    let fn = (arr: any): boolean => {\n        return arr instanceof Array && arr.length? true : false;\n    };\n    fn(productTree);\n    indexArr = indexArr.reverse();\n    return indexArr;\n};\n/**\n * 获取数组索引值 => arr.some((elem: any, index: number) => {\n *     return elem[idKey] == id;\n * })\n * @param param0\n * @returns\n */\nexport const getIndexArrById = function ({ id = \"\", productTree, index: = 0, idKey = \"id\", childrenKey = \"child\", }: IndexParam): number[] => {\n    let indexArr = [];\n    let fn = (arr: any): boolean => {\n        return arr instanceof Array && ar): false;\n    };\n    fn(productTree);\n    indexArr = indexArr.reverse();\n    return indexArr;\n};\n/**\n * 获取数组索引值 => arr.some((elem: any, index: number) => { => {\n        if (elem[idKey] == id) {\n            indexArr.push(index);\n            return true;\n        }\n        else if (elem[childrenKey] &&\n            elem[childrenKey] instanceof Array &&\n            elem[childrenKey].length) {\n            return fn(elem[childrenKey]) && indexArr.push(index);\n        }\n        return false;\n    });\n    fn(productTree);\n    indexArr.reverse();\n    return indexArr;\n};\n","score":153,"fallbacked":false,"num_type_errors":26},{"code":"/**\n * 过滤表情\n * @param name\n * @returns\n */\nexport const filterEmoji = (name: string) => {\n    return name.replace(/[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD8): [0-9]{1,6}\\b]/g, \"\");\n};\n/**\n * 将表情字符替换为unicode\n * @param name\n * @returns\n */\nexport const replaceEmoji = (name: string) => {\n    const str = name.replace(/[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi, \"\");\n    return str;\n};\n/**\n * 过滤税号\n * @param num\n * @returns\n */\nexport const isNumber = (num: string): boolean => {\n    return typeof num == 'number' && num.toString().length == 11;\n};\n/**\n * 生成随机UUID\n * @returns\n */\nexport const generateUUID = () => {\n    return 'xxxxxxx => /^[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/.test(num);\n/**\n * 验证手机号\n * @param phone\n * @returns\n */\nexport const isPhone = (phone: string): boolean => {\n    return /^((13[0-9])|(14[579])|(15[0-3,5-9])|(17[0-6,7])|(18[0 => /^[1][0-9]{10}$/.test(phone);\n/**\n * 验证邮箱\n * @param email\n * @returns\n */\nexport const isEmail = (email: string): boolean => {\n    return /^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4})+)$/ => /^([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+\\.[a-zA-Z]{2,3}$/.test(email);\n/**\n * 验证是否存在特殊符号或者表情\n * @param value\n * @param tips\n * @returns\n */\nexport const hasEmoji = function (value: string, tips = \"\") {\n    let char = /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\u, tips: 0-9]{1,6}\\b/g;\n    if (char.test(value)) {\n        return true;\n    }\n    return false;\n};\n/**\n * 邮箱校验\n * @param email = \"\"): string {\n * @returns\n */\nexport const emailValidator = (email: string = \"\"): boolean => {\n    if (!email || email.length < 3) {\n        return false;\n    }\n    const reg = /^([a {\n    let char = /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi;\n    if (char.test(value)) {\n        return true;\n    }\n    return false;\n};\n/**\n * 获取数组索引值\n * @param param0\n * @returns\n */\nexport const getIndexArr = function ({ id = \"\", productTree = [], idKey = \"id\", childrenKey = \"child\", }: { id: string, productTree: Array<any>, idKey: string, childrenKey: string }): number[] {\n    if (!productTree ||!productTree.length) {\n        return [];\n    }\n    if (!id ||): string {\n        return [];\n    }\n    let indexArr = [];\n    let fn = (arr) => arr.some((elem, index) => {\n        if (elem[idKey] == id) {\n            indexArr.push(inde {\n    let indexArr = [];\n    let fn = (arr: any) => arr.some((elem, index) => {\n        if (elem[idKey] == id) {\n            indexArr.push(index);\n            return true;\n        }\n        else if (elem[childrenKey] &&): Array<any> {\n            return fn(elem[childrenKey]) && indexArr.push(index);\n        }\n        return false;\n    });\n    fn(productTree);\n    return indexArr.length;\n};\n});\n    fn => arr.some((elem: any, index: number) => {\n        if (elem[idKey] == id) {\n            indexArr.push(index);\n            return true;\n        }\n        else if (elem[childrenKey] && elem[childrenKey] instanceo, index: number) {\n            return fn(elem[childrenKey]) && indexArr.push(index);\n        }\n        return false;\n    });\n    return indexArr;\n};\n/**\n * 获取数组索引值\n * @param param0): { id: string, productTree: Array<any>, idKey: string, childrenKey: string }): number[] {\n    if (!productTree ||!productTree.length) {\n        return [];\n    }\n    if (!id ||) => {\n        if (elem[idKey] == id) {\n            indexArr.push(index);\n            return true;\n        }\n        else if (elem[childrenKey] &&\n            elem[childrenKey] instanceof Array &&\n            elem[childrenKey].length) {\n            return fn(elem[childrenKey]) && indexArr.push(index);\n        }\n        return false;\n    });\n    fn(productTree);\n    indexArr.reverse();\n    return indexArr;\n};\n","score":276,"fallbacked":false,"num_type_errors":45},{"code":"/**\n * 过滤表情\n * @param name\n * @returns\n */\nexport const filterEmoji = (name: string): string => {\n    const str = name.replace(/[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD => {\n    const str = name.replace(/[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi, \"\");\n    return str;\n};\n/**\n * 过滤税号\n * @param num\n * @returns\n */\nexport const isNumber = (num: string): boolean => {\n    return /^0+$/.test(num);\n};\n/**\n * 过滤字符串中只包含字母、数字、下划线\n * @param name\n * @returns\n */\nexport const filterSpecialChar => /^[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/.test(num);\n/**\n * 验证手机号\n * @param phone\n * @returns\n */\nexport const isPhone = (phone: string): boolean => {\n    return /^1[3|4|5|8][0-9]{9}$/.test(phone);\n};\n/**\n * 验证身份证\n * @param idCard\n * @returns\n */\nexpor => /^[1][0-9]{10}$/.test(phone);\n/**\n * 验证邮箱\n * @param email\n * @returns\n */\nexport const isEmail = (email: string): boolean => /^([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+\\.[a-zA-Z]{2,3}$/.test(email);\n/**\n * 验证是否存在特殊符号或者表情\n * @param value\n * @param tips\n * @returns\n */\nexport const hasEmoji = function (value: string, tips = \"\") {\n    let char = /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\u, tips: 0-9\\u2007\\u2022\\u2025\\u2026\\u2028\\u2029\\u202A\\u20 = \"\"): true;\n    if (char.test(value)) {\n        return true;\n    }\n    return false;\n};\n/**\n * 判断是否为身份证\n * @param idCard\n * @returns\n */\nexport const isI {\n    let char = /[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF][\\u200D|\\uFE0F]|[\\uD83C|\\uD83D|\\uD83E][\\uDC00-\\uDFFF]|[0-9|*|#]\\uFE0F\\u20E3|[0-9|#]\\u20E3|[\\u203C-\\u3299]\\uFE0F\\u200D|[\\u203C-\\u3299]\\uFE0F|[\\u2122-\\u2B55]|\\u303D|[\\A9|\\AE]\\u3030|\\uA9|\\uAE|\\u3030/gi;\n    if (char.test(value)) {\n        return true;\n    }\n    return false;\n};\n/**\n * 获取数组索引值\n * @param param0\n * @returns\n */\nexport const getIndexArr = function ({ id = \"\", productTree = [], idKey = \"id\", childrenKey = \"child\", }: { id: number | string, productTree: Array<Array<any>>, idKey: string, childrenKey: string }) {\n    let indexArr = [];\n    let fn = (arr) => arr.some((elem, index): boolean => {\n        if (elem[idKey] == id) {\n            indexArr.push(index);\n            return true;\n        }\n        else if (elem[childrenKey] &&\n            elem[childrenKey] instanceof Array &&\n            ele {\n    let indexArr = [];\n    let fn = (arr: Array<any>): boolean => arr.some((elem, index) => {\n        if (elem[idKey] == id) {\n            indexArr.push(index);\n            return true;\n        }\n        else if (elem[childre): boolean {\n            let indexArr = [];\n            let fn = (arr: Array<any>): boolean => arr.some((elem, index) => {\n                if (elem[idKey] == id) {\n                    indexArr.push => arr.some((elem: any): boolean => fn(elem[childrenKey]));\n                }\n            });\n            fn(elem[childrenKey]);\n            indexArr.reverse();\n            indexArr.push(index);\n            return true;\n        }\n        return false;\n    });, index: number | string;\n    let indexArr = [];\n    let fn = (arr: Array<any>): boolean => arr.some((elem, index) => {\n        if (elem[idKey] == id) {\n            indexArr): boolean;\n            return true;\n        }\n        else if (elem[childrenKey] &&\n            elem[childrenKey] instanceof Array &&\n            elem[childrenKey].length) {\n            let indexArr = [];\n            let fn = (arr: Arra => {\n        if (elem[idKey] == id) {\n            indexArr.push(index);\n            return true;\n        }\n        else if (elem[childrenKey] &&\n            elem[childrenKey] instanceof Array &&\n            elem[childrenKey].length) {\n            return fn(elem[childrenKey]) && indexArr.push(index);\n        }\n        return false;\n    });\n    fn(productTree);\n    indexArr.reverse();\n    return indexArr;\n};\n","score":265,"fallbacked":false,"num_type_errors":66}]}
{"dataset_elem":{"alphanum_fraction":0.5031006519,"avg_line_length":32.7552083333,"content":"\n\ninterface Config {\n    rc: any\n    redirect?: string\n    rootFile?: string\n    /** 过滤文件 */\n    filter?: (file: any) => boolean\n    /** 定义组件返回 */\n    component: (file: any) => any\n}\n/**\n * https://github.com/MrHzq/vue-router-auto\n * rc：require.context 传入的文件\n * redirect：需要将根路由(/)重定向到的路由\n * rootFile：页面级别的.vue存放的文件名称\n * filter：过滤文件\n * component：定义组件返回\n */\nexport function createRouters(config: Config) {\n    // 所生成的所有路由数组\n    const Routers: any = []\n    const defaultConfig: Config = {\n        rc: null,\n        redirect: '',\n        rootFile: 'pages',\n        filter: () => true,\n        component: () => ({})\n    }\n    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign(\n        {},\n        defaultConfig,\n        config\n    )\n    if (rc === null) return Routers\n\n    // allRouters[object]：存储所有路由的变量：先将所有的路由生成，然后放在该变量里面\n    const allRouters: any = {\n        len1: []\n    }\n    // 通过循环RC(传入的文件)\n    const routerFileAndLen = rc\n        .keys()\n        .filter(filter)\n        .map((fileName: any) => {\n            // 因为得到的filename格式是: './baseButton.vue', 所以这里我们去掉头和尾，只保留真正的文件名\n            const realFileName = fileName\n                .replace(/^\\.\\//, '')\n                .replace(/\\.\\w+$/, '')\n            return {\n                file: fileName,\n                fileName: realFileName,\n                // routerName(路由名称)：将 / 转为 - 并去掉 _\n                routerName: realFileName.replace(/\\//g, '-').replace(/_/g, '').replace(/-index/g, ''),\n                // routerComponent(路由异步component的文件路径)：将 ./baseButton.vue 从 . 之后截取\n                routerComponent: fileName.substr(1),\n                // fileLen(文件的层级深度)：通过 / 的数量来判断当前文件的深度\n                fileLen: fileName.match(/\\//g).length\n            }\n        })\n        .sort((i: any, j: any) => i.fileLen - j.fileLen) // 通过文件深度 升序排序\n\n    // 传入文件中最大深度\n    let maxLen = 0\n    routerFileAndLen.map((r: any) => {\n        const name = r.routerName\n        // 生成一块路由对象，包含：name、fileName(用于后续处理真正path的依据)、path、needDelectName(用于后续处理，判断是否删除name的依据)、component\n        const obj = {\n            name,\n            exact: true,\n            fileName: r.fileName,\n            // path：只是以name命名的path，还不是真正的路由path\n            path: '/' + (name === 'index' ? '' : name),\n            // needDelectName: name === 'index',\n            needDelectName: false,\n            component: component(rc(r.file))//() => import(`~/${rootFile}${r.routerComponent}`)\n        }\n        maxLen = r.fileLen\n        // allRouters的key：以 'len'加当前的文件深度 作为key\n        const key = 'len' + maxLen\n        if (Array.isArray(allRouters[key])) allRouters[key].push(obj)\n        else allRouters[key] = [obj]\n    })\n\n    // 将根目录层的路由放入Routers中\n    // @ts-ignore\n    Routers.push(...allRouters.len1)\n\n    // 截取名称方法：从开始到最后一个'-'之间的字符串\n    const substrName = (name: any) => name.substr(0, name.lastIndexOf('-'))\n\n    /**\n     * 正式生成路由：1、将相应的路由放在对应的路由下，形成子路由；2、生成同级路由\n     * index：当前文件深度，为maxlen的倒序循环\n     * nofindnum：未找到路由的次数\n     * newcurr：当前新的深度下的路由数据\n     */\n    const ceateRouter = (index: any, nofindnum = 0, newcurr = null) => {\n        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据\n        const curr = newcurr || allRouters['len' + index]\n        // 当前深度上一层的路由数据\n        const pre = allRouters['len' + (index - 1)]\n        // 若 没有上一层的数据了\n        if (!pre) {\n            // 则表明是属于顶层的路由\n            curr.map((c: any) => {\n                let path = '/' + c.fileName.replace('/index', '')\n                // if (path.match('_')) path = path.replace('/_', '/:')\n                // 将真正的路由path赋值给当前路由\n                c.path = path\n                // 将当前路由放到Routers里面\n                Routers.push(c)\n            })\n            return\n        }\n\n        // 在上一层中 未找到的 当前深度路由数据\n        let noFind: any = []\n\n        // 循环当前深度路由数据\n        curr?.map((c: any) => {\n            // 在 上一层深度 的路由数据里面查找\n            const fobj = pre.find((p: any) => {\n                // 生成 当前深度 当前项 路由的name\n                let name = substrName(c.name)\n                // 循环nofindnum，当nofindnum>0，则表示已经出现：在上一层中未找到对应的父路由，则需要将 当前深度 当前项 路由的name 再次生成\n                for (let i = 0; i < nofindnum; i++) {\n                    name = substrName(name)\n                }\n\n                return name === p.name\n            })\n            // 如果 找到了 对应的 父路由数据(fobj)\n            if (fobj) {\n                // 生成 当前路由的path：1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；\n\n                let path = c.fileName\n                    .replace(fobj.fileName, '')\n                    .substr(1)\n                    .replace('_', ':')\n                if (path.match('/') && !path.match('/:')) {\n                    path = path.replace('/index', '')\n                }\n                if (path === undefined) {\n                    throw new Error(\n                        `找到了对应的父路由，但是生成子路由的path为【undefined】了`\n                    )\n                }\n\n                // 将真正的路由path赋值给当前路由\n                c.path = path\n\n                // 若：当前路由为 index\n                if (path === 'index') {\n                    // 1、转为 '' path，''：表明是默认子路由，那父路由就不能存在name属性\n                    c.path = ''\n                    // 2、将父路由的needDelectName标记为true，表明需要删除它的name\n                    fobj.needDelectName = fobj.needDelectName || true\n                }\n                // 将当前路由放到父路由的children里面\n                if (Array.isArray(fobj.children)) fobj.children.push(c)\n                else fobj.children = [c]\n            } else noFind.push(c) // 表明未找到父路由，则先将当前路由的数据放入noFind中存储起来\n        })\n\n        // 若存在：未找到的路由数据，则再次向上一个层级寻找\n        if (noFind.length) ceateRouter(index - 1, ++nofindnum, noFind)\n    }\n    // 倒序循环 最大深度，然后调用生成路由方法\n    for (let i = maxLen; i > 1; i--) ceateRouter(i)\n\n    // 路由生成完毕了，应该删除 有默认子路由的父路由的name属性\n    const deleteNameFun = (arr: any) => {\n        arr.map((r: any) => {\n            // 删除多余的fileName属性\n            delete r.fileName\n            // 判断是否需要删除name属性\n            if (r.needDelectName) delete r.name\n            // 判断完毕了，则要删除needDelectName属性\n            delete r.needDelectName\n            // 若 存在子路由 则继续调用deleteNameFun，删除name\n            if (Array.isArray(r.children)) deleteNameFun(r.children)\n        })\n    }\n    // 调用deleteNameFun，先删除Routers的一级路由的name\n    deleteNameFun(Routers)\n\n    // 若存在重定向的路由，则加入重定向\n    if (redirect) Routers.unshift({ path: '/', redirect })\n    // 返回正儿八经的的路由数据\n    return Routers\n}","content_without_annotations":"\n\ninterface Config {\n    rc\n    redirect?\n    rootFile?\n    /** 过滤文件 */\n    filter?\n    /** 定义组件返回 */\n    component\n}\n/**\n * https://github.com/MrHzq/vue-router-auto\n * rc：require.context 传入的文件\n * redirect：需要将根路由(/)重定向到的路由\n * rootFile：页面级别的.vue存放的文件名称\n * filter：过滤文件\n * component：定义组件返回\n */\nexport function createRouters(config) {\n    // 所生成的所有路由数组\n    const Routers = []\n    const defaultConfig = {\n        rc: null,\n        redirect: '',\n        rootFile: 'pages',\n        filter: () => true,\n        component: () => ({})\n    }\n    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign(\n        {},\n        defaultConfig,\n        config\n    )\n    if (rc === null) return Routers\n\n    // allRouters[object]：存储所有路由的变量：先将所有的路由生成，然后放在该变量里面\n    const allRouters = {\n        len1: []\n    }\n    // 通过循环RC(传入的文件)\n    const routerFileAndLen = rc\n        .keys()\n        .filter(filter)\n        .map((fileName) => {\n            // 因为得到的filename格式是: './baseButton.vue', 所以这里我们去掉头和尾，只保留真正的文件名\n            const realFileName = fileName\n                .replace(/^\\.\\//, '')\n                .replace(/\\.\\w+$/, '')\n            return {\n                file: fileName,\n                fileName: realFileName,\n                // routerName(路由名称)：将 / 转为 - 并去掉 _\n                routerName: realFileName.replace(/\\//g, '-').replace(/_/g, '').replace(/-index/g, ''),\n                // routerComponent(路由异步component的文件路径)：将 ./baseButton.vue 从 . 之后截取\n                routerComponent: fileName.substr(1),\n                // fileLen(文件的层级深度)：通过 / 的数量来判断当前文件的深度\n                fileLen: fileName.match(/\\//g).length\n            }\n        })\n        .sort((i, j) => i.fileLen - j.fileLen) // 通过文件深度 升序排序\n\n    // 传入文件中最大深度\n    let maxLen = 0\n    routerFileAndLen.map((r) => {\n        const name = r.routerName\n        // 生成一块路由对象，包含：name、fileName(用于后续处理真正path的依据)、path、needDelectName(用于后续处理，判断是否删除name的依据)、component\n        const obj = {\n            name,\n            exact: true,\n            fileName: r.fileName,\n            // path：只是以name命名的path，还不是真正的路由path\n            path: '/' + (name === 'index' ? '' : name),\n            // needDelectName: name === 'index',\n            needDelectName: false,\n            component: component(rc(r.file))//() => import(`~/${rootFile}${r.routerComponent}`)\n        }\n        maxLen = r.fileLen\n        // allRouters的key：以 'len'加当前的文件深度 作为key\n        const key = 'len' + maxLen\n        if (Array.isArray(allRouters[key])) allRouters[key].push(obj)\n        else allRouters[key] = [obj]\n    })\n\n    // 将根目录层的路由放入Routers中\n    // @ts-ignore\n    Routers.push(...allRouters.len1)\n\n    // 截取名称方法：从开始到最后一个'-'之间的字符串\n    const substrName = (name) => name.substr(0, name.lastIndexOf('-'))\n\n    /**\n     * 正式生成路由：1、将相应的路由放在对应的路由下，形成子路由；2、生成同级路由\n     * index：当前文件深度，为maxlen的倒序循环\n     * nofindnum：未找到路由的次数\n     * newcurr：当前新的深度下的路由数据\n     */\n    const ceateRouter = (index, nofindnum = 0, newcurr = null) => {\n        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据\n        const curr = newcurr || allRouters['len' + index]\n        // 当前深度上一层的路由数据\n        const pre = allRouters['len' + (index - 1)]\n        // 若 没有上一层的数据了\n        if (!pre) {\n            // 则表明是属于顶层的路由\n            curr.map((c) => {\n                let path = '/' + c.fileName.replace('/index', '')\n                // if (path.match('_')) path = path.replace('/_', '/:')\n                // 将真正的路由path赋值给当前路由\n                c.path = path\n                // 将当前路由放到Routers里面\n                Routers.push(c)\n            })\n            return\n        }\n\n        // 在上一层中 未找到的 当前深度路由数据\n        let noFind = []\n\n        // 循环当前深度路由数据\n        curr?.map((c) => {\n            // 在 上一层深度 的路由数据里面查找\n            const fobj = pre.find((p) => {\n                // 生成 当前深度 当前项 路由的name\n                let name = substrName(c.name)\n                // 循环nofindnum，当nofindnum>0，则表示已经出现：在上一层中未找到对应的父路由，则需要将 当前深度 当前项 路由的name 再次生成\n                for (let i = 0; i < nofindnum; i++) {\n                    name = substrName(name)\n                }\n\n                return name === p.name\n            })\n            // 如果 找到了 对应的 父路由数据(fobj)\n            if (fobj) {\n                // 生成 当前路由的path：1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；\n\n                let path = c.fileName\n                    .replace(fobj.fileName, '')\n                    .substr(1)\n                    .replace('_', ':')\n                if (path.match('/') && !path.match('/:')) {\n                    path = path.replace('/index', '')\n                }\n                if (path === undefined) {\n                    throw new Error(\n                        `找到了对应的父路由，但是生成子路由的path为【undefined】了`\n                    )\n                }\n\n                // 将真正的路由path赋值给当前路由\n                c.path = path\n\n                // 若：当前路由为 index\n                if (path === 'index') {\n                    // 1、转为 '' path，''：表明是默认子路由，那父路由就不能存在name属性\n                    c.path = ''\n                    // 2、将父路由的needDelectName标记为true，表明需要删除它的name\n                    fobj.needDelectName = fobj.needDelectName || true\n                }\n                // 将当前路由放到父路由的children里面\n                if (Array.isArray(fobj.children)) fobj.children.push(c)\n                else fobj.children = [c]\n            } else noFind.push(c) // 表明未找到父路由，则先将当前路由的数据放入noFind中存储起来\n        })\n\n        // 若存在：未找到的路由数据，则再次向上一个层级寻找\n        if (noFind.length) ceateRouter(index - 1, ++nofindnum, noFind)\n    }\n    // 倒序循环 最大深度，然后调用生成路由方法\n    for (let i = maxLen; i > 1; i--) ceateRouter(i)\n\n    // 路由生成完毕了，应该删除 有默认子路由的父路由的name属性\n    const deleteNameFun = (arr) => {\n        arr.map((r) => {\n            // 删除多余的fileName属性\n            delete r.fileName\n            // 判断是否需要删除name属性\n            if (r.needDelectName) delete r.name\n            // 判断完毕了，则要删除needDelectName属性\n            delete r.needDelectName\n            // 若 存在子路由 则继续调用deleteNameFun，删除name\n            if (Array.isArray(r.children)) deleteNameFun(r.children)\n        })\n    }\n    // 调用deleteNameFun，先删除Routers的一级路由的name\n    deleteNameFun(Routers)\n\n    // 若存在重定向的路由，则加入重定向\n    if (redirect) Routers.unshift({ path: '/', redirect })\n    // 返回正儿八经的的路由数据\n    return Routers\n}","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":2007,"ext":"ts","fun_ann_density":0.0134529148,"function_parameters":14,"function_signatures":0,"function_usages":3,"functions":13,"hexsha":"52d6fc301866fccc3a2004222d9a88498840f05e","lang":"TypeScript","loc":116,"loc_per_function":17.0769230769,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"e0542a2ce5fd8c1693864db0db5edf71dad2919b","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"leeichang/UID_Test","max_forks_repo_path":"UID_Test/ClientApp/src/client/createRouters.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"e0542a2ce5fd8c1693864db0db5edf71dad2919b","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"leeichang/UID_Test","max_issues_repo_path":"UID_Test/ClientApp/src/client/createRouters.ts","max_line_length":105,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"e0542a2ce5fd8c1693864db0db5edf71dad2919b","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"leeichang/UID_Test","max_stars_repo_path":"UID_Test/ClientApp/src/client/createRouters.ts","max_stars_repo_stars_event_max_datetime":"2022-03-22T14:02:13.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-22T14:02:13.000Z","metric":0.2332717214,"predefined_density":0.0555555556,"predefined_types":3,"prop_ann_density":0.0024912805,"property_declarations":5,"size":6289,"trivial_density":0.3518518519,"trivial_types":19,"type_definitions":1,"typedef_density":0.0004982561,"var_ann_density":0.0109616343,"variable_declarations":22},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"interface Config {\n    rc: string;\n    redirect?: string;\n    redirect?: string | boolean | ((to: any) => any);\n    autoRedirect?: boolean;\n    autoRedirect?: boolean | string | ((to: any) => any);\n    autoRedirect?: boolean | ((to: any) => any);;\n    rootFile?: string;\n    filter?: (file: string, fileName: string) => boolean;\n    filter?: (file: string, fileName: string) => boolean;\n    filter?: (file: string, fileName: string) => boolean;\n    filter?;\n    /** 过滤文件 */\n    filter?: (file: string, fileName: string) => boolean;\n    /** 过滤文件 */\n    filter?: (file: string, fileName: string) => boolean;\n    /** 过滤文件 */\n    filter?: (file: string, fileName: strin;\n    /** 定义组件返回 */\n    component: (file: string, fileName: string) => string;\n    /** 是否开启子路由 */\n    subRoute?: boolean;\n    /** 只读模式：true 表示只读模式 */\n    readonly?: boolean;\n    /** 是否启用路由缓存 *;\n}\n/**\n * https://github.com/MrHzq/vue-router-auto\n * rc：require.context 传入的文件\n * redirect：需要将根路由(/)重定向到的路由\n * rootFile：页面级别的.vue存放的文件名称\n * filter：过滤文件\n * component：定义组件返回\n */\nexport function createRouters(config: Config): Router[] {\n    const { redirect, rootFile, filter, component, subRoute, readonly } = config;\n    const { base, mode, notFound } = resolveConfig(config);\n    // allRouters[object]：存): 所有路由（Router）的变量：先将所有的路由生成，然后放在该变量里面\n     let allRouters = {}\n     let pageRouter = null\n     // 对于根路由（/），我们将其保存，所有路 {\n    // 所生成的所有路由数组\n    const Routers = [];\n    const defaultConfig = {\n        rc: null,\n        redirect: \"\",\n        rootFile: \"pages\",\n        filter: (): any => true,\n        component: () => ({})\n    };\n    const { rc, redirect, rootFile, filter, component } = (<any>Object).assign({}, defaultConfig, config);\n    if (rc === null)\n        return Routers => true,\n        component: (): any => ({})\n    // 根据传入的路由，生成对应的路由对象\n    const router = new VueRouter({\n        base,\n        mode,\n        notFound,\n        linkActiveClass: \"router-link-active\",\n        scrollBehavior: () => ({ => ({})\n    };\n    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign({}, defaultConfig, config);\n    if (rc === null)\n        return Routers;\n    // allRouters[object]：存储所有路由的变量：先将所有的路由生成，然后放在该变量里面\n    const allRouters = {\n        len1: []\n    };\n    // 通过循环RC(传入的文件)\n    const routerFileAndLen = rc\n        .keys()\n        .filter(filter)\n        .map((fileName: string) => {\n            // 通过路由的文件名获得路由文件（含.vue）\n            const routerFileName = fileName.replace(/\\.\\w+$/, \"\");\n            if (routerFileName.indexOf(\".\") > -1) {\n                routerFileName = route): any => ({})\n            }\n            const routerFile = rc(fileName);\n            // 匹配路由规则\n            const routerMatch = routerFile.match(new RegExp(`^/pages/${routerFileName}`))\n            if (routerMatch) {\n                / => {\n        // 因为得到的filename格式是: './baseButton.vue', 所以这里我们去掉头和尾，只保留真正的文件名\n        const realFileName = fileName\n            .replace(/^\\.\\//, \"\")\n            .replace(/\\.\\w+$/, \"\");\n        return {\n            file: fileName,\n            fileName: realFileName,\n            // routerName(路由名称)：将 / 转为 - 并去掉 _\n            routerName: realFileName.replace(/\\//g, \"-\").replace(/_/g, \"\").replace(/-index/g, \"\"),\n            // routerComponent(路由异步component的文件路径)：将 ./baseButton.vue 从 . 之后截取\n            routerComponent: fileName.substr(1),\n            // fileLen(文件的层级深度)：通过 / 的数量来判断当前文件的深度\n            fileLen: fileName.match(/\\//g).length\n        };\n    })\n        .sort((i: any, j: any) => i.fileLen - j.fileLen)\n    });\n    // 通过循环路由规则\n    routerFileAndLen.forEach((r) => {\n        // 根据路由规则匹配到所有路由\n        const routerMatc, j: any = r.routerName;\n        if (!allRouters[j]) {\n            allRouters[j] = []\n        }\n        // 匹配路由规则\n        const routerMatch = routerFile.match(new RegExp(`^/page): (${routerMatc})/?$`))\n        // 匹配成功才添加到所有路由\n        if (routerMatch) {\n            // 匹配成功就返回\n            allRouters[j].push({\n                path: routerMatc.replac => i.fileLen - j.fileLen); // 通过文件深度 升序排序\n    // 传入文件中最大深度\n    let maxLen = 0;\n    routerFileAndLen.map((r: any) => {\n        if (r.fileLen > maxLen) {\n            maxLen = r.fileLen;\n        }\n    })\n    // 最长的路由规则\n    const maxLenRouterName = Object.keys(allRouter): string => Object.keys(allRouter).find(key => allRouter[key].length === maxLen);\n    if (maxLenRouterName) {\n        const maxLenRouter = allRouter[maxLenRouterName];\n        maxLenRoute => {\n        const name = r.routerName;\n        // 生成一块路由对象，包含：name、fileName(用于后续处理真正path的依据)、path、needDelectName(用于后续处理，判断是否删除name的依据)、component\n        const obj = {\n            name,\n            exact: true,\n            fileName: r.fileName,\n            // path：只是以name命名的path，还不是真正的路由path\n            path: \"/\" + (name === \"index\" ? \"\" : name),\n            // needDelectName: name === 'index',\n            needDelectName: false,\n            component: component(rc(r.file)) //() => import(`~/${rootFile}${r.routerComponent}`)\n        };\n        maxLen = r.fileLen;\n        // allRouters的key：以 'len'加当前的文件深度 作为key\n        const key = \"len\" + maxLen;\n        if (Array.isArray(allRouters[key]))\n            allRouters[key].push(obj);\n        else\n            allRouters[key] = [obj];\n    });\n    // 将根目录层的路由放入Routers中\n    // @ts-ignore\n    Routers.push(...allRouters.len1);\n    // 截取名称方法：从开始到最后一个'-'之间的字符串\n    const substrName = (name: string) => name.substr(0, name.lastIndexOf(\"-\"));\n    // 生成默认路由\n    let newRouter = {};\n    // 将根目录层的路由放入Routers中\n    // @ts-ignore\n    newRouter = {): any };\n    // 递归获取当前目录下所有路由\n    const generateRouter = (currentRouter: any, currentRouterName: string, index = 0, maxLen = 0) => {\n        // 递归查找\n        // => name.substr(0, name.lastIndexOf(\"-\"));\n    /**\n     * 正式生成路由：1、将相应的路由放在对应的路由下，形成子路由；2、生成同级路由\n     * index：当前文件深度，为maxlen的倒序循环\n     * nofindnum：未找到路由的次数\n     * newcurr：当前新的深度下的路由数据\n     */\n    const ceateRouter = (index: number, nofindnum = 0, newcurr = null) => {\n        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据\n        const curr = newcurr || al, nofindnum: number = 0;\n        if (index < 0) return;\n        // 遍历当前目录下所有路由\n        for (let i = 0; i < curr.length; i++) {\n            // 当前深度下的路由数 = 0, newcurr: 当前深度下的路由数据\n            if (index === 0 &&!newcurr) {\n                newRouter[currentRouterName] = curr;\n            }\n            // 当前深度下的路由数 = 0, newcurr: 当前深 = null): 当前深度下的路由数据\n            if (index === 0 && newcurr) {\n                newRouter[currentRouterName] = curr.slice(0, index);\n            }\n            // 当前深度下的路由数 = 0, ne => {\n        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据\n        const curr = newcurr || allRouters[\"len\" + index];\n        // 当前深度上一层的路由数据\n        const pre = allRouters[\"len\" + (index - 1)];\n        // 若 没有上一层的数据了\n        if (!pre) {\n            // 则表明是属于顶层的路由\n            curr.map((c: { fileName: string; path: string; }) => {\n                let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n                if (path.match('_')) path = path.replace('/_', '/:');\n                // 将真正): 路由添加到Router\n                Router.push(c);\n                // 如果是顶层路由，则递归生成\n                if (c.fileName === \"/index\") {\n                    generateRouter(Router, currentRouterName, index - 1, maxLe => {\n                let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n                // if (path.match('_')) path = path.replace('/_', '/:')\n                // 将真正的路由path赋值给当前路由\n                c.path = path;\n                // 将当前路由放到Routers里面\n                Routers.push(c);\n            });\n            return;\n        }\n        // 在上一层中 未找到的 当前深度路由数据\n        let noFind = [];\n        // 循环当前深度路由数据\n        curr?.map((c: { fileName: string; path: string; }) => {\n            let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n            if (path.match('_')) path = path.replace('/_', '/:');\n            // 将真正): 路由添加到Router\n            Router.push(c);\n            // 当前深度上一层的路由数据\n            const pre = allRouters[\"len\" + (index - 1)];\n            // 若 上一层的路由数 => {\n            // 在 上一层深度 的路由数据里面查找\n            const fobj = pre.find((p: { path: string; }) => {\n                return p.path === path;\n            });\n            // 如果 找到了 对应的 父路由数据(fobj)\n            if (fobj) {\n                // 生成 当前路由的pat): 1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；\n                let path = \"/\" + fobj.path.replace(\"/index\", \"\");\n                if (path.match(' => {\n                // 生成 当前深度 当前项 路由的name\n                let name = substrName(c.name);\n                // 循环nofindnum，当nofindnum>0，则表示已经出现：在上一层中未找到对应的父路由，则需要将 当前深度 当前项 路由的name 再次生成\n                for (let i = 0; i < nofindnum; i++) {\n                    name = substrName(name);\n                }\n                return name === p.name;\n            });\n            // 如果 找到了 对应的 父路由数据(fobj)\n            if (fobj) {\n                // 生成 当前路由的path：1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；\n                let path = c.fileName\n                    .replace(fobj.fileName, \"\")\n                    .substr(1)\n                    .replace(\"_\", \":\");\n                if (path.match(\"/\") && !path.match(\"/:\")) {\n                    path = path.replace(\"/index\", \"\");\n                }\n                if (path === undefined) {\n                    throw new Error(`找到了对应的父路由，但是生成子路由的path为【undefined】了`);\n                }\n                // 将真正的路由path赋值给当前路由\n                c.path = path;\n                // 若：当前路由为 index\n                if (path === \"index\") {\n                    // 1、转为 '' path，''：表明是默认子路由，那父路由就不能存在name属性\n                    c.path = \"\";\n                    // 2、将父路由的needDelectName标记为true，表明需要删除它的name\n                    fobj.needDelectName = fobj.needDelectName || true;\n                }\n                // 将当前路由放到父路由的children里面\n                if (Array.isArray(fobj.children))\n                    fobj.children.push(c);\n                else\n                    fobj.children = [c];\n            }\n            else\n                noFind.push(c); // 表明未找到父路由，则先将当前路由的数据放入noFind中存储起来\n        });\n        // 若存在：未找到的路由数据，则再次向上一个层级寻找\n        if (noFind.length)\n            ceateRouter(index - 1, ++nofindnum, noFind);\n    };\n    // 倒序循环 最大深度，然后调用生成路由方法\n    for (let i = maxLen; i > 1; i--)\n        ceateRouter(i);\n    // 路由生成完毕了，应该删除 有默认子路由的父路由的name属性\n    const deleteNameFun = (arr: any) => {\n        arr.map((r) => {\n            if (Array.isArray(r.children)) {\n                deleteNameFun(r.children);\n                if (r.needDelectName && r.name) {): => {\n                    r.path = r.name;\n                    delete r.name;\n                };\n            }\n        });\n    };\n    deleteNameFun(Routers);\n    // 3、将路由对象转为路由器对象\n    const router => {\n        arr.map((r: Router) => {\n            const res = {\n                path: r.path,\n                name: r.name,\n                component: r.component,\n                meta: r.meta,\n            };\n            if (r.children) {\n                res): => {\n                    res.children = r.children.filter((v) => {\n                        if (v.needDelectName) {\n                            v.path = v.name;\n                            v.name = \"\";\n                            return true;\n                        } => {\n            // 删除多余的fileName属性\n            delete r.fileName;\n            // 判断是否需要删除name属性\n            if (r.needDelectName)\n                delete r.name;\n            // 判断完毕了，则要删除needDelectName属性\n            delete r.needDelectName;\n            // 若 存在子路由 则继续调用deleteNameFun，删除name\n            if (Array.isArray(r.children))\n                deleteNameFun(r.children);\n        });\n    };\n    // 调用deleteNameFun，先删除Routers的一级路由的name\n    deleteNameFun(Routers);\n    // 若存在重定向的路由，则加入重定向\n    if (redirect)\n        Routers.unshift({ path: \"/\", redirect });\n    // 返回正儿八经的的路由数据\n    return Routers;\n}\n","score":258,"fallbacked":false,"num_type_errors":136},{"code":"interface Config {\n    rc: require.Context<string>;\n    redirect?: string;\n    rootFile?: string;\n    filter?: (fileName: string) => boolean;\n    component?: () => {};\n}\nexport interface Redirect {\n    from?: string;\n    to?: string;\n}\nexport interface Route {;\n    rootFile?: string;\n    file?: string;\n    fileName?: string;\n    routerName?: string;\n    routerComponent?: string;\n    fileLen?: number;\n    redirect?: Redirect;\n}\n/**\n * https://github.com/MrHz;\n    /** 过滤文件 */\n    filter?: (fileName: string) => boolean;\n    /** 进入路由钩子 */\n    onEnter?: (to: any, from: any) => void;\n    /** 离开路由钩子 */\n    onLeave?: (to;\n    /** 定义组件返回 */\n    component: () => {}; */\n    component?: () => {};\n    /** 路由组件 */\n    componentPath?: string;\n}\n/**\n * https://github.com/MrHzq/vue-router-auto\n * rc：require;\n}\n/**\n * https://github.com/MrHzq/vue-router-auto\n * rc：require.context 传入的文件\n * redirect：需要将根路由(/)重定向到的路由\n * rootFile：页面级别的.vue存放的文件名称\n * filter：过滤文件\n * component：定义组件返回\n */\nexport function createRouters(config: Config): Route[] {\n    const { redirect, rootFile, filter, component, componentPath } = config;\n    // 所生成的所有路由数组\n    const Routers = [];\n    const defaultConfig = {\n        rc: null,\n        redirect: \"\"): \"\",\n        rootFile: \"pages\",\n        filter: () => true,\n        component: () => ({})\n    };\n    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign({}, defaultConfig, config); {\n    // 所生成的所有路由数组\n    const Routers = [];\n    const defaultConfig = {\n        rc: null,\n        redirect: \"\",\n        rootFile: \"pages\",\n        filter: (): boolean => true,\n        component: () => ({})\n    };\n    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign({}, defaultConfig, config);\n    if (rc === null)\n        return Routers => true,\n        component: (): {};\n    // allRouters[object]：存储所有路由的变量：先将所有的路由生成，然后放在该变量里面\n    const allRouters = {\n        len1: []\n    };\n    // 通过循环RC => ({})\n    };\n    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign({}, defaultConfig, config);\n    if (rc === null)\n        return Routers;\n    // allRouters[object]：存储所有路由的变量：先将所有的路由生成，然后放在该变量里面\n    const allRouters = {\n        len1: []\n    };\n    // 通过循环RC(传入的文件)\n    const routerFileAndLen = rc\n        .keys()\n        .filter(filter)\n        .map((fileName: string) => {\n             return {\n                file: fileName,\n                fileName: fileName.replace(/^\\.\\//, \"\"),\n                // routerName(路由名称)：将 / 转为 - 并去掉 _\n                routerName: fileName.replace(/\\/): fileName.replace(/^\\.\\//, \"\").replace(/\\.vue$/, \"\").replace(/\\./g, \"/\"),\n                // routerComponent(路由异步component的文件路径)：将./baseButton.vue 从. 之后截取\n                routerCompoen => {\n        // 因为得到的filename格式是: './baseButton.vue', 所以这里我们去掉头和尾，只保留真正的文件名\n        const realFileName = fileName\n            .replace(/^\\.\\//, \"\")\n            .replace(/\\.\\w+$/, \"\");\n        return {\n            file: fileName,\n            fileName: realFileName,\n            // routerName(路由名称)：将 / 转为 - 并去掉 _\n            routerName: realFileName.replace(/\\//g, \"-\").replace(/_/g, \"\").replace(/-index/g, \"\"),\n            // routerComponent(路由异步component的文件路径)：将 ./baseButton.vue 从 . 之后截取\n            routerComponent: fileName.substr(1),\n            // fileLen(文件的层级深度)：通过 / 的数量来判断当前文件的深度\n            fileLen: fileName.match(/\\//g).length\n        };\n    })\n        .sort((i: { fileLen: number; file: string }, j: { fileLen: number; file: string }) => i.fileLen - j.fileLen); // 通过文件深度 升序排序\n    // 传入文件中最大, j: { fileLen: number; file: string }\n     allRouters.len1 = routerFileAndLen.sort((i: { fileLen: number; file: string }, j: { fileLen: number; file: string }) =): any => { // 通过文件深度 升序排序\n        const max = Math.max(...routerFileAndLen.map((r) => r.fileLen));\n        return max - j.fileLen;\n    });\n    // 通过循 => i.fileLen - j.fileLen); // 通过文件深度 升序排序\n    // 传入文件中最大深度\n    let maxLen = 0;\n    routerFileAndLen.map((r: { fileLen: number; file: string }) => {\n        if (r.fileLen > maxLen) {\n            maxLen = r.fileLen;\n        }\n    })\n    // 如果文件总层级大于传入的maxLen): 根据传入的maxLen进行循环，获取最大的层级，将其与当前循环的层级值比较，如果其值相等，则设置当前层级为最大层级。\n    for (let i = 0 => {\n        const name = r.routerName;\n        // 生成一块路由对象，包含：name、fileName(用于后续处理真正path的依据)、path、needDelectName(用于后续处理，判断是否删除name的依据)、component\n        const obj = {\n            name,\n            exact: true,\n            fileName: r.fileName,\n            // path：只是以name命名的path，还不是真正的路由path\n            path: \"/\" + (name === \"index\" ? \"\" : name),\n            // needDelectName: name === 'index',\n            needDelectName: false,\n            component: component(rc(r.file)) //() => import(`~/${rootFile}${r.routerComponent}`)\n        };\n        maxLen = r.fileLen;\n        // allRouters的key：以 'len'加当前的文件深度 作为key\n        const key = \"len\" + maxLen;\n        if (Array.isArray(allRouters[key]))\n            allRouters[key].push(obj);\n        else\n            allRouters[key] = [obj];\n    });\n    // 将根目录层的路由放入Routers中\n    // @ts-ignore\n    Routers.push(...allRouters.len1);\n    // 截取名称方法：从开始到最后一个'-'之间的字符串\n    const substrName = (name: string) => name.substr(0, name.lastIndexOf(\"-\"));\n    // 递归获取所有子路由\n    allRouters.len1.forEach((r) => {\n        if (r.needDelectName) {\n            //): 当前路由名称为index，则将路由放入Router中\n            if (substrName(r.name) === \"index\") {\n                // 这是根目录\n                const obj = {\n                    name: \"index\",\n                    exact: true => name.substr(0, name.lastIndexOf(\"-\"));\n    /**\n     * 正式生成路由：1、将相应的路由放在对应的路由下，形成子路由；2、生成同级路由\n     * index：当前文件深度，为maxlen的倒序循环\n     * nofindnum：未找到路由的次数\n     * newcurr：当前新的深度下的路由数据\n     */\n    const ceateRouter = (index: number, nofindnum = 0, newcurr = null) => {\n        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据\n        const curr = newcurr || al, nofindnum: = 0;\n        // 未找到路由的次数\n        let nofind = 0;\n        let name = index + \"-\" + r.fileName.replace(\"/index\", \"\");\n        // 递归调用：遍历所有子节点\n        r = 0, newcurr: null, allRouters[key];\n        // 存在同级路由\n        if (r && r.length) {\n            for (let i = 0; i < r.length; i++) {\n                if (r[i] = null): {\n                    nofindnum++;\n                    continue;\n                }\n                if (r[i].name === \"index\") {\n                    newcurr = r[i].children;\n                    continue;\n                }\n                name += \"-\" + r[i].fileNam => {\n        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据\n        const curr = newcurr || allRouters[\"len\" + index];\n        // 当前深度上一层的路由数据\n        const pre = allRouters[\"len\" + (index - 1)];\n        // 若 没有上一层的数据了\n        if (!pre) {\n            // 则表明是属于顶层的路由\n            curr.map((c: any) => {\n                let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n                // if (path.match('_')) path = path.replace('/_', '/:');\n                // 将真正的路由path赋值给当前路): path = path.replace('/_/', '/')\n                // 将真正的路由path赋值给当前路由\n                c.path = path;\n                // 将当前路由放到Routers里面\n                Routers.push(c);\n            }) => {\n                let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n                // if (path.match('_')) path = path.replace('/_', '/:')\n                // 将真正的路由path赋值给当前路由\n                c.path = path;\n                // 将当前路由放到Routers里面\n                Routers.push(c);\n            });\n            return;\n        }\n        // 在上一层中 未找到的 当前深度路由数据\n        let noFind = [];\n        // 循环当前深度路由数据\n        curr?.map((c: any) => {\n            let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n            // if (path.match('_')) path = path.replace('/_', '/:');\n            // 将真正的路由path赋值给当前): path = path.replace('/_/', '/')\n            // 将真正的路由path赋值给当前路由\n            c.path = path;\n            // 将当前路由放到Routers里面\n            Routers.push(c);\n        } => {\n            // 在 上一层深度 的路由数据里面查找\n            const fobj = pre.find((p: any) => {\n                // 生成 当前深度 当前项 路由的name\n                let name = substrName(c.name);\n                // 循环nofindnum，当nofindnum>0，则表示已经出现：): in 上一层深度的路由数据里面未找到对应的父路由，则需要将 当前深度 当前项 路由的name 再次生成\n                for (let i = 0; i < nofindnum => {\n                // 生成 当前深度 当前项 路由的name\n                let name = substrName(c.name);\n                // 循环nofindnum，当nofindnum>0，则表示已经出现：在上一层中未找到对应的父路由，则需要将 当前深度 当前项 路由的name 再次生成\n                for (let i = 0; i < nofindnum; i++) {\n                    name = substrName(name);\n                }\n                return name === p.name;\n            });\n            // 如果 找到了 对应的 父路由数据(fobj)\n            if (fobj) {\n                // 生成 当前路由的path：1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；\n                let path = c.fileName\n                    .replace(fobj.fileName, \"\")\n                    .substr(1)\n                    .replace(\"_\", \":\");\n                if (path.match(\"/\") && !path.match(\"/:\")) {\n                    path = path.replace(\"/index\", \"\");\n                }\n                if (path === undefined) {\n                    throw new Error(`找到了对应的父路由，但是生成子路由的path为【undefined】了`);\n                }\n                // 将真正的路由path赋值给当前路由\n                c.path = path;\n                // 若：当前路由为 index\n                if (path === \"index\") {\n                    // 1、转为 '' path，''：表明是默认子路由，那父路由就不能存在name属性\n                    c.path = \"\";\n                    // 2、将父路由的needDelectName标记为true，表明需要删除它的name\n                    fobj.needDelectName = fobj.needDelectName || true;\n                }\n                // 将当前路由放到父路由的children里面\n                if (Array.isArray(fobj.children))\n                    fobj.children.push(c);\n                else\n                    fobj.children = [c];\n            }\n            else\n                noFind.push(c); // 表明未找到父路由，则先将当前路由的数据放入noFind中存储起来\n        });\n        // 若存在：未找到的路由数据，则再次向上一个层级寻找\n        if (noFind.length)\n            ceateRouter(index - 1, ++nofindnum, noFind);\n    };\n    // 倒序循环 最大深度，然后调用生成路由方法\n    for (let i = maxLen; i > 1; i--)\n        ceateRouter(i);\n    // 路由生成完毕了，应该删除 有默认子路由的父路由的name属性\n    const deleteNameFun = (arr: any) => {\n        // 遍历所有路由数据\n        arr.forEach((r) => {\n            // 删除多余的fileName属性\n            delete r.fileName;\n            // 判断是否需要删除name属性\n            if (r.needDelec): {\n                // 删除多余的name属性\n                delete r.name;\n                // 若存在子路由 则继续调用deleteNameFun，删除name\n                if (Array.isArray(r.children))\n                    deleteNameFun( => {\n        arr.map((r: any) => {\n                    // 删除多余的fileName属性\n                    delete r.fileName;\n                    // 判断是否需要删除name属性\n                    if (r.needDelectName)\n                        delete r.name;\n                    // 若存在子路): 递归调用deleteNameFun，删除name\n                        if (Array.isArray(r.children))\n                            deleteNameFun(r.children);\n                });\n            }\n        });\n    };\n    // 调用deleteNameFun，先删除Routers的一 => {\n            // 删除多余的fileName属性\n            delete r.fileName;\n            // 判断是否需要删除name属性\n            if (r.needDelectName)\n                delete r.name;\n            // 判断完毕了，则要删除needDelectName属性\n            delete r.needDelectName;\n            // 若 存在子路由 则继续调用deleteNameFun，删除name\n            if (Array.isArray(r.children))\n                deleteNameFun(r.children);\n        });\n    };\n    // 调用deleteNameFun，先删除Routers的一级路由的name\n    deleteNameFun(Routers);\n    // 若存在重定向的路由，则加入重定向\n    if (redirect)\n        Routers.unshift({ path: \"/\", redirect });\n    // 返回正儿八经的的路由数据\n    return Routers;\n}\n","score":326,"fallbacked":false,"num_type_errors":144},{"code":"interface Config {\n    rc: require.Context<any>;\n    redirect?;\n    rootFile?;\n    filter?;\n    /** 过滤文件 */\n    filter?: (file: string, fileLen: number, fileRootPath: string) => boolean;\n    /** 定义组;\n    redirect?: 过滤文件 */\n    filter?: (file: string, fileLen: number, fileRootPath: string) => boolean;\n    /** 定义组;\n    redirect?: 过滤文件 */\n    filter?: (file: string, fileLen: number, fil;\n    rootFile?: string) => boolean;\n    /** 定义组;\n    redirect?: 过滤文件 */\n    filter?: (file: string, fileLen: number, fileRootPath: string) => boolean;\n    /** 定义组;\n    redirect?: 过滤文件 *;\n    /** 过滤文件 */\n    filter?: (file: string, fileLen: number, fileRootPath: string) => boolean;\n    /** 定义组;\n    redirect?: 过滤文件 */\n    filter?: (file: string, fileLen: number, fileRootPath: string) => boolea;\n    /** 定义组件返回 */\n    component: () => any;\n    /** 过滤文件 */\n    filter?: (file: string, fileLen: number, fileRootPath: string) => boolean;\n}\nexport interface RouteConfig extends Config {\n    /** 路由组件 */\n    componen;\n}\n/**\n * https://github.com/MrHzq/vue-router-auto\n * rc：require.context 传入的文件\n * redirect：需要将根路由(/)重定向到的路由\n * rootFile：页面级别的.vue存放的文件名称\n * filter：过滤文件\n * component：定义组件返回\n */\nexport function createRouters(config: RouteConfig): Route[] {\n    const { redirect, rootFile, filter, filter: filterFunction, component } = config;\n    const res: Route[] = [];\n    let len1 = 0;\n    // 遍历路由文件\n    fo): boolean {\n        const routerFileAndLen = rc\n           .keys()\n           .filter(filter)\n           .map((fileName) => {\n        // 因为得到的filename格式是: './baseButton.vue', 所以这里我们 {\n    // 所生成的所有路由数组\n    const Routers = [];\n    const defaultConfig = {\n        rc: null,\n        redirect: \"\",\n        rootFile: \"pages\",\n        filter: (): boolean => true,\n        filter: () => true,\n        component: () => ({})\n    };\n    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign({}, defaultConfig, config);\n    if (rc == => true,\n        component: (): any => ({}),\n        redirect: \"\",\n        rootFile: \"pages\"\n    } as any) {\n        // 非空路由\n        if (rc == undefined) {\n            return {\n                fileName,\n                fileLen: 0,\n                route => ({})\n    };\n    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign({}, defaultConfig, config);\n    if (rc === null)\n        return Routers;\n    // allRouters[object]：存储所有路由的变量：先将所有的路由生成，然后放在该变量里面\n    const allRouters = {\n        len1: []\n    };\n    // 通过循环RC(传入的文件)\n    const routerFileAndLen = rc\n        .keys()\n        .filter(filter)\n        .map((fileName: string) => {\n            const config = (\n                rc(fileName) as any\n            ).default || {};\n            return {\n                file: fileName,\n                fileLen: config.length,\n                // routerName(路由名称)：将 / 转): 转换为 - 并去掉 _\n                routerName: realFileName.replace(/\\//g, \"-\").replace(/_/g, \"\").replace(/-index/g, \"\"),\n                // routerComponent(路由异步component的文件路径)：将. => {\n        // 因为得到的filename格式是: './baseButton.vue', 所以这里我们去掉头和尾，只保留真正的文件名\n        const realFileName = fileName\n            .replace(/^\\.\\//, \"\")\n            .replace(/\\.\\w+$/, \"\");\n        return {\n            file: fileName,\n            fileName: realFileName,\n            // routerName(路由名称)：将 / 转为 - 并去掉 _\n            routerName: realFileName.replace(/\\//g, \"-\").replace(/_/g, \"\").replace(/-index/g, \"\"),\n            // routerComponent(路由异步component的文件路径)：将 ./baseButton.vue 从 . 之后截取\n            routerComponent: fileName.substr(1),\n            // fileLen(文件的层级深度)：通过 / 的数量来判断当前文件的深度\n            fileLen: fileName.match(/\\//g).length\n        };\n    })\n        .sort((i: Router, j: Router) => j.fileLen - i.fileLen);\n    routerFileAndLen.map((r) => {\n        // 获取当前路由文件名的完整路径\n        const fileName = r.file;\n        cons, j: Router = {\n            name: r.routerName,\n            exact: true,\n            fileName: r.fileName,\n            // path：只是以name命名的path，还不是真正的路由path\n            path: \"/\" + (): string => {\n                return \"/\" + r.fileName;\n            },\n            component: () => import(\"views\" + r.routerComponent)\n        };\n        // 最终将路由对象添加到路由列表中\n        routerList.push(j) => i.fileLen - j.fileLen); // 通过文件深度 升序排序\n    // 传入文件中最大深度\n    let maxLen = 0;\n    routerFileAndLen.map((r: Router) => {\n        if (r.fileLen > maxLen) {\n            maxLen = r.fileLen;\n        }\n    });\n    // 从文件中获取路由对象\n    routerFileAndLen.map((r: Router) =): boolean => {\n        if (r.fileLen <= maxLen) {\n            // 将路由对象添加到路由列表中\n            routerList.push(r) => r.fileLen - maxLen;\n        } else {\n            console.lo => {\n        const name = r.routerName;\n        // 生成一块路由对象，包含：name、fileName(用于后续处理真正path的依据)、path、needDelectName(用于后续处理，判断是否删除name的依据)、component\n        const obj = {\n            name,\n            exact: true,\n            fileName: r.fileName,\n            // path：只是以name命名的path，还不是真正的路由path\n            path: \"/\" + (name === \"index\" ? \"\" : name),\n            // needDelectName: name === 'index',\n            needDelectName: false,\n            component: component(rc(r.file)) //() => import(`~/${rootFile}${r.routerComponent}`)\n        };\n        maxLen = r.fileLen;\n        // allRouters的key：以 'len'加当前的文件深度 作为key\n        const key = \"len\" + maxLen;\n        if (Array.isArray(allRouters[key]))\n            allRouters[key].push(obj);\n        else\n            allRouters[key] = [obj];\n    });\n    // 将根目录层的路由放入Routers中\n    // @ts-ignore\n    Routers.push(...allRouters.len1);\n    // 截取名称方法：从开始到最后一个'-'之间的字符串\n    const substrName = (name: string) => {\n        const substr = name.substring(0, name.length - 2);\n        return substr;\n    };\n    // 删除子路由名\n    const delName = (router: Router) => {\n        router): Router => {\n            if (router.needDelectName) {\n                const len = router.name.length - 2;\n                if (router.name.indexOf(\"-\") === len) {\n                    const subName = router.name.subst => name.substr(0, name.lastIndexOf(\"-\"));\n    /**\n     * 正式生成路由：1、将相应的路由放在对应的路由下，形成子路由；2、生成同级路由\n     * index：当前文件深度，为maxlen的倒序循环\n     * nofindnum：未找到路由的次数\n     * newcurr：当前新的深度下的路由数据\n     */\n    const ceateRouter = (index: number, nofindnum = 0, newcurr = null) => {\n        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据\n        const curr = newcurr || al, nofindnum: number = 0;\n        // 当前深度下的路由数据\n        al.map((c) => {\n            if (index === c.path.length) {\n                const subName = c.fileName.replace(\"/index\", \"\");\n                i = 0, newcurr: any = {\n                    path: path,\n                    name: subName,\n                    needDelectName: false,\n                    component: component(c.file)\n                };\n                // 递归\n                c.children && (newcurr = ceateRouter = null): c.children.map((c) => {\n                    c.path = path + \"/\" + c.fileName.replace(\"/index\", \"\");\n                    c.name = subName + i;\n                    i++;\n                    nofindnum++;\n                    // => {\n        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据\n        const curr = newcurr || allRouters[\"len\" + index];\n        // 当前深度上一层的路由数据\n        const pre = allRouters[\"len\" + (index - 1)];\n        // 若 没有上一层的数据了\n        if (!pre) {\n            // 则表明是属于顶层的路由\n            curr.map((c: Router) => {\n                let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n                // if (path.match('_')) path = path.replace('/_', '/:');\n                // 将真正的路由path赋值给当前路): 当前路由\n                c.path = path;\n                // 将当前路由放到Routers里面\n                Routers.push(c);\n            });\n            return;\n        }\n        // 在上一层中 未找到的 当前深度路 => {\n                let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n                // if (path.match('_')) path = path.replace('/_', '/:')\n                // 将真正的路由path赋值给当前路由\n                c.path = path;\n                // 将当前路由放到Routers里面\n                Routers.push(c);\n            });\n            return;\n        }\n        // 在上一层中 未找到的 当前深度路由数据\n        let noFind = [];\n        // 循环当前深度路由数据\n        curr?.map((c: Router) => {\n            let path = \"/\" + c.fileName.replace(\"/index\", \"\");\n            // if (path.match('_')) path = path.replace('/_', '/:');\n            // 将真正的路由path赋值给当前路): 当前路由\n            c.path = path;\n            // 将当前路由放到Routers里面\n            noFind.push(c);\n        });\n        // 循环上一层深度路由数据\n        pre?.map((p: Router => {\n            // 在 上一层深度 的路由数据里面查找\n            const fobj = pre.find((p: Router) => {\n                // 生成 当前深度 当前项 路由的name\n                let name = substrName(p.name);\n                // 循环nofindnum，当nofindnum>0，则表示已经出现：): 当前路由\n                if (name === \" \") return false;\n                // 生成 当前路由的path：1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；\n                let pat => {\n                // 生成 当前深度 当前项 路由的name\n                let name = substrName(c.name);\n                // 循环nofindnum，当nofindnum>0，则表示已经出现：在上一层中未找到对应的父路由，则需要将 当前深度 当前项 路由的name 再次生成\n                for (let i = 0; i < nofindnum; i++) {\n                    name = substrName(name);\n                }\n                return name === p.name;\n            });\n            // 如果 找到了 对应的 父路由数据(fobj)\n            if (fobj) {\n                // 生成 当前路由的path：1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；\n                let path = c.fileName\n                    .replace(fobj.fileName, \"\")\n                    .substr(1)\n                    .replace(\"_\", \":\");\n                if (path.match(\"/\") && !path.match(\"/:\")) {\n                    path = path.replace(\"/index\", \"\");\n                }\n                if (path === undefined) {\n                    throw new Error(`找到了对应的父路由，但是生成子路由的path为【undefined】了`);\n                }\n                // 将真正的路由path赋值给当前路由\n                c.path = path;\n                // 若：当前路由为 index\n                if (path === \"index\") {\n                    // 1、转为 '' path，''：表明是默认子路由，那父路由就不能存在name属性\n                    c.path = \"\";\n                    // 2、将父路由的needDelectName标记为true，表明需要删除它的name\n                    fobj.needDelectName = fobj.needDelectName || true;\n                }\n                // 将当前路由放到父路由的children里面\n                if (Array.isArray(fobj.children))\n                    fobj.children.push(c);\n                else\n                    fobj.children = [c];\n            }\n            else\n                noFind.push(c); // 表明未找到父路由，则先将当前路由的数据放入noFind中存储起来\n        });\n        // 若存在：未找到的路由数据，则再次向上一个层级寻找\n        if (noFind.length)\n            ceateRouter(index - 1, ++nofindnum, noFind);\n    };\n    // 倒序循环 最大深度，然后调用生成路由方法\n    for (let i = maxLen; i > 1; i--)\n        ceateRouter(i);\n    // 路由生成完毕了，应该删除 有默认子路由的父路由的name属性\n    const deleteNameFun = (arr: Router[]) => {\n        arr.map((r) => {\n            // 判断是否需要删除name属性\n            if (r.needDelectName)\n                delete r.name;\n            // 判断完毕了，则要删除needD): 需要删除的路由\n            if (Array.isArray(r.children))\n                deleteNameFun(r.children);\n        });\n    };\n    // 倒序循环 最大深度，然后调用生成路由方法\n    for (let i => {\n        arr.map((r: Router) => {\n            // 判断是否需要删除name属性\n            if (r.needDelectName)\n                delete r.name;\n            // 判断完毕了，则要删除needD): 需要删除的路由\n            if (Arra): 需要删除的路由\n            if (Array.isArray(r.children))\n                deleteNameFun(r.children);\n        });\n    };\n    // 调用deleteNameFun，先删除Routers的一级路由的name\n    deleteNameFun => {\n            // 删除多余的fileName属性\n            delete r.fileName;\n            // 判断是否需要删除name属性\n            if (r.needDelectName)\n                delete r.name;\n            // 判断完毕了，则要删除needDelectName属性\n            delete r.needDelectName;\n            // 若 存在子路由 则继续调用deleteNameFun，删除name\n            if (Array.isArray(r.children))\n                deleteNameFun(r.children);\n        });\n    };\n    // 调用deleteNameFun，先删除Routers的一级路由的name\n    deleteNameFun(Routers);\n    // 若存在重定向的路由，则加入重定向\n    if (redirect)\n        Routers.unshift({ path: \"/\", redirect });\n    // 返回正儿八经的的路由数据\n    return Routers;\n}\n","score":228,"fallbacked":false,"num_type_errors":168}]}
{"dataset_elem":{"alphanum_fraction":0.5579141671,"avg_line_length":34.9516129032,"content":"class DateUtils {\n  static monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n  static toDayMonthFormat(date: Date) {\n    const day = date.getDate();\n    const monthIndex = date.getMonth();\n    const monthName = DateUtils.monthNames[monthIndex];\n    return `${day}-${monthName}`;\n  }\n\n  static toShortFormat(date: Date) {\n    const day = date.getDate();\n    const monthIndex = date.getMonth();\n    const monthName = DateUtils.monthNames[monthIndex];\n    const year = date.getFullYear();\n\n    return `${day} ${monthName} ${year}`;\n  }\n\n  static timeSince(time: Date) {\n    const time_formats = [\n      [60, 'seconds', 1], // 60\n      [120, '1 minute ago', '1 minute from now'], // 60*2\n      [3600, 'minutes', 60], // 60*60, 60\n      [7200, '1 hour ago', '1 hour from now'], // 60*60*2\n      [86400, 'hours', 3600], // 60*60*24, 60*60\n      [172800, 'Yesterday', 'Tomorrow'], // 60*60*24*2\n      [604800, 'days', 86400], // 60*60*24*7, 60*60*24\n      [1209600, 'Last week', 'Next week'], // 60*60*24*7*4*2\n      [2419200, 'weeks', 604800], // 60*60*24*7*4, 60*60*24*7\n      [4838400, 'Last month', 'Next month'], // 60*60*24*7*4*2\n      [29030400, 'months', 2419200], // 60*60*24*7*4*12, 60*60*24*7*4\n      [58060800, 'Last year', 'Next year'], // 60*60*24*7*4*12*2\n      [2903040000, 'years', 29030400], // 60*60*24*7*4*12*100, 60*60*24*7*4*12\n      [5806080000, 'Last century', 'Next century'], // 60*60*24*7*4*12*100*2\n      [58060800000, 'centuries', 2903040000], // 60*60*24*7*4*12*100*20, 60*60*24*7*4*12*100\n    ];\n    let seconds = (+new Date().valueOf() - time.valueOf()) / 1000,\n      token = 'ago',\n      list_choice = 1;\n\n    if (seconds === 0) {\n      return 'Just now';\n    }\n    if (seconds < 0) {\n      seconds = Math.abs(seconds);\n      token = 'from now';\n      list_choice = 2;\n    }\n    let i = 0,\n      format;\n    while ((format = time_formats[i++]))\n      if (seconds < format[0]) {\n        if (typeof format[2] == 'string') return format[list_choice];\n        else return Math.floor(seconds / format[2]) + ' ' + format[1] + ' ' + token;\n      }\n    return time;\n  }\n}\n\nexport default DateUtils;\n","content_without_annotations":"class DateUtils {\n  static monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n  static toDayMonthFormat(date) {\n    const day = date.getDate();\n    const monthIndex = date.getMonth();\n    const monthName = DateUtils.monthNames[monthIndex];\n    return `${day}-${monthName}`;\n  }\n\n  static toShortFormat(date) {\n    const day = date.getDate();\n    const monthIndex = date.getMonth();\n    const monthName = DateUtils.monthNames[monthIndex];\n    const year = date.getFullYear();\n\n    return `${day} ${monthName} ${year}`;\n  }\n\n  static timeSince(time) {\n    const time_formats = [\n      [60, 'seconds', 1], // 60\n      [120, '1 minute ago', '1 minute from now'], // 60*2\n      [3600, 'minutes', 60], // 60*60, 60\n      [7200, '1 hour ago', '1 hour from now'], // 60*60*2\n      [86400, 'hours', 3600], // 60*60*24, 60*60\n      [172800, 'Yesterday', 'Tomorrow'], // 60*60*24*2\n      [604800, 'days', 86400], // 60*60*24*7, 60*60*24\n      [1209600, 'Last week', 'Next week'], // 60*60*24*7*4*2\n      [2419200, 'weeks', 604800], // 60*60*24*7*4, 60*60*24*7\n      [4838400, 'Last month', 'Next month'], // 60*60*24*7*4*2\n      [29030400, 'months', 2419200], // 60*60*24*7*4*12, 60*60*24*7*4\n      [58060800, 'Last year', 'Next year'], // 60*60*24*7*4*12*2\n      [2903040000, 'years', 29030400], // 60*60*24*7*4*12*100, 60*60*24*7*4*12\n      [5806080000, 'Last century', 'Next century'], // 60*60*24*7*4*12*100*2\n      [58060800000, 'centuries', 2903040000], // 60*60*24*7*4*12*100*20, 60*60*24*7*4*12*100\n    ];\n    let seconds = (+new Date().valueOf() - time.valueOf()) / 1000,\n      token = 'ago',\n      list_choice = 1;\n\n    if (seconds === 0) {\n      return 'Just now';\n    }\n    if (seconds < 0) {\n      seconds = Math.abs(seconds);\n      token = 'from now';\n      list_choice = 2;\n    }\n    let i = 0,\n      format;\n    while ((format = time_formats[i++]))\n      if (seconds < format[0]) {\n        if (typeof format[2] == 'string') return format[list_choice];\n        else return Math.floor(seconds / format[2]) + ' ' + format[1] + ' ' + token;\n      }\n    return time;\n  }\n}\n\nexport default DateUtils;\n","dynamism_density":0.0010548523,"dynamism_heuristic":1,"estimated_tokens":948,"ext":"ts","fun_ann_density":0.0063291139,"function_parameters":3,"function_signatures":0,"function_usages":0,"functions":3,"hexsha":"4ef875146bf91d02a43b946ba072a27eeddf80b2","lang":"TypeScript","loc":55,"loc_per_function":15.0,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-01-31T15:36:34.000Z","max_forks_repo_forks_event_min_datetime":"2022-01-31T15:36:34.000Z","max_forks_repo_head_hexsha":"0f7a8b4d41f8f031e56a14647440e9230bd9f3af","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"D2Phoenix/ton-swap","max_forks_repo_path":"src/utils/dateUtils.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"0f7a8b4d41f8f031e56a14647440e9230bd9f3af","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"D2Phoenix/ton-swap","max_issues_repo_path":"src/utils/dateUtils.ts","max_line_length":107,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"0f7a8b4d41f8f031e56a14647440e9230bd9f3af","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"D2Phoenix/ton-swap","max_stars_repo_path":"src/utils/dateUtils.ts","max_stars_repo_stars_event_max_datetime":"2022-01-31T11:03:50.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-31T11:03:50.000Z","metric":0.2312160858,"predefined_density":0.0,"predefined_types":0,"prop_ann_density":0.0010548523,"property_declarations":1,"size":2167,"trivial_density":0.0,"trivial_types":0,"type_definitions":1,"typedef_density":0.0010548523,"var_ann_density":0.0137130802,"variable_declarations":13},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"class DateUtils {\n    static monthNames: string[] = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    static toDayMonthFormat(date: Date) {\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        const day = date.getDate();\n        return `${monthName}-${day}`;\n    }\n    static toDayMonthFormatFul): string {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        const year = date.getFullYear();\n        return `${day} ${monthName} $ {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        return `${day}-${monthName}`;\n    }\n    static toShortFormat(date: Date) {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        const year = date.getFullYear();\n        return `${monthName}-${day}-${yea): string {\n        return `${monthName}-${day}`;\n    }\n    static toShortFormat2(date: Date) {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthName {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        const year = date.getFullYear();\n        return `${day} ${monthName} ${year}`;\n    }\n    static timeSince(time: Date): string {\n        return moment(new Date(time)).fromNow();\n    }\n    static getWeekdayNames() {\n        return [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"]): string[];\n    }\n}\n\nexport function isDateBefore(a: Date, b: Date) {\n    return a.getTime() < b.getTime();\n}\n\nexport class BaseAction {\n    constructor(public controller: {\n        const time_formats = [\n            [60, \"seconds\", 1],\n            [120, \"1 minute ago\", \"1 minute from now\"],\n            [3600, \"minutes\", 60],\n            [7200, \"1 hour ago\", \"1 hour from now\"],\n            [86400, \"hours\", 3600],\n            [172800, \"Yesterday\", \"Tomorrow\"],\n            [604800, \"days\", 86400],\n            [1209600, \"Last week\", \"Next week\"],\n            [2419200, \"weeks\", 604800],\n            [4838400, \"Last month\", \"Next month\"],\n            [29030400, \"months\", 2419200],\n            [58060800, \"Last year\", \"Next year\"],\n            [2903040000, \"years\", 29030400],\n            [5806080000, \"Last century\", \"Next century\"],\n            [58060800000, \"centuries\", 2903040000],\n        ];\n        let seconds = (+new Date().valueOf() - time.valueOf()) / 1000, token = \"ago\", list_choice = 1;\n        if (seconds === 0) {\n            return \"Just now\";\n        }\n        if (seconds < 0) {\n            seconds = Math.abs(seconds);\n            token = \"from now\";\n            list_choice = 2;\n        }\n        let i = 0, format;\n        while ((format = time_formats[i++]))\n            if (seconds < format[0]) {\n                if (typeof format[2] == \"string\")\n                    return format[list_choice];\n                else\n                    return Math.floor(seconds / format[2]) + \" \" + format[1] + \" \" + token;\n            }\n        return time;\n    }\n}\nexport default DateUtils;\n","score":422,"fallbacked":false,"num_type_errors":81},{"code":"class DateUtils {\n    static monthNames: string[];\n\n    static monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    static toDayMonthFormat(date: Date) {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        return `${day}-${monthName}`;\n    }\n    static toShortFormat(dat): string {\n        const day = dat.getDate();\n        const monthIndex = dat.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        return `${day}-${monthName}`;\n    }\n    static toDayMonthFormat(dat {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        return `${day}-${monthName}`;\n    }\n    static toShortFormat(date: Date) {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        return `${day}-${monthName}`;\n    }\n    static toShortFormat(dat): string {\n        const day = dat.getDate();\n        const monthIndex = dat.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        return `${day}-${monthName}`;\n    }\n    static toShortFormat(date {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        const year = date.getFullYear();\n        return `${day} ${monthName} ${year}`;\n    }\n    static timeSince(time: Date) {\n        const now = new Date();\n        const diff = now - time;\n\n        if (diff < 0) {\n            throw new Error(\"The given date is in the past\");\n        }\n\n        let seconds = Math.floor): number {\n            return Math.abs(diff) / 1000;\n        }\n\n        let periods = [\"s\", \"m\", \"h\", \"d\", \"M\", \"y\"];\n\n        let index = 0;\n\n        le {\n        const time_formats = [\n            [60, \"seconds\", 1],\n            [120, \"1 minute ago\", \"1 minute from now\"],\n            [3600, \"minutes\", 60],\n            [7200, \"1 hour ago\", \"1 hour from now\"],\n            [86400, \"hours\", 3600],\n            [172800, \"Yesterday\", \"Tomorrow\"],\n            [604800, \"days\", 86400],\n            [1209600, \"Last week\", \"Next week\"],\n            [2419200, \"weeks\", 604800],\n            [4838400, \"Last month\", \"Next month\"],\n            [29030400, \"months\", 2419200],\n            [58060800, \"Last year\", \"Next year\"],\n            [2903040000, \"years\", 29030400],\n            [5806080000, \"Last century\", \"Next century\"],\n            [58060800000, \"centuries\", 2903040000],\n        ];\n        let seconds = (+new Date().valueOf() - time.valueOf()) / 1000, token = \"ago\", list_choice = 1;\n        if (seconds === 0) {\n            return \"Just now\";\n        }\n        if (seconds < 0) {\n            seconds = Math.abs(seconds);\n            token = \"from now\";\n            list_choice = 2;\n        }\n        let i = 0, format;\n        while ((format = time_formats[i++]))\n            if (seconds < format[0]) {\n                if (typeof format[2] == \"string\")\n                    return format[list_choice];\n                else\n                    return Math.floor(seconds / format[2]) + \" \" + format[1] + \" \" + token;\n            }\n        return time;\n    }\n}\nexport default DateUtils;\n","score":441,"fallbacked":false,"num_type_errors":93},{"code":"class DateUtils {\n    static monthNames: string[] = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    static toDayMonthFormat(date: Date) {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        return `${day} ${monthName}`;\n    }\n    static toDayMonthForma): string {\n        return DateUtils.toDayMonthFormat(new Date());\n    }\n    static toDayMonthFormat(date: Date, format: string = \"d.m.Y\") {\n        return DateUtils.toDayMonthFormat(date {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        return `${day}-${monthName}`;\n    }\n    static toShortFormat(date: Date): string {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        const year = date.getFullYear();\n        return `${day}-${monthName}-$): ${year}`;\n    }\n    static toShortFormat(date: Date, format = \"d.m.Y-$\"): string {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName {\n        const day = date.getDate();\n        const monthIndex = date.getMonth();\n        const monthName = DateUtils.monthNames[monthIndex];\n        const year = date.getFullYear();\n        return `${day} ${monthName} ${year}`;\n    }\n    static timeSince(time: Date): string {\n        const now = new Date();\n        const diff = now.getTime() - time.getTime();\n        const days = Math.floor(diff / (1000 * 60 * 60 *): number);\n        const hours = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60)): number);\n        const minutes = Math.floor((diff % {\n        const time_formats = [\n            [60, \"seconds\", 1],\n            [120, \"1 minute ago\", \"1 minute from now\"],\n            [3600, \"minutes\", 60],\n            [7200, \"1 hour ago\", \"1 hour from now\"],\n            [86400, \"hours\", 3600],\n            [172800, \"Yesterday\", \"Tomorrow\"],\n            [604800, \"days\", 86400],\n            [1209600, \"Last week\", \"Next week\"],\n            [2419200, \"weeks\", 604800],\n            [4838400, \"Last month\", \"Next month\"],\n            [29030400, \"months\", 2419200],\n            [58060800, \"Last year\", \"Next year\"],\n            [2903040000, \"years\", 29030400],\n            [5806080000, \"Last century\", \"Next century\"],\n            [58060800000, \"centuries\", 2903040000],\n        ];\n        let seconds = (+new Date().valueOf() - time.valueOf()) / 1000, token = \"ago\", list_choice = 1;\n        if (seconds === 0) {\n            return \"Just now\";\n        }\n        if (seconds < 0) {\n            seconds = Math.abs(seconds);\n            token = \"from now\";\n            list_choice = 2;\n        }\n        let i = 0, format;\n        while ((format = time_formats[i++]))\n            if (seconds < format[0]) {\n                if (typeof format[2] == \"string\")\n                    return format[list_choice];\n                else\n                    return Math.floor(seconds / format[2]) + \" \" + format[1] + \" \" + token;\n            }\n        return time;\n    }\n}\nexport default DateUtils;\n","score":385,"fallbacked":false,"num_type_errors":112}]}
{"dataset_elem":{"alphanum_fraction":0.4588300527,"avg_line_length":33.3981481481,"content":"type Vec3 = [number, number, number] | Float32Array | Float64Array;\n\n/**\n * Find the two closest points on two 3D lines.\n * Return true if two lines are parallel.\n *\n * @param out1 Output - The closest point on line 1.\n * @param out2 Output - The closest point on line 2.\n * @param p1x X of a point on line 1.\n * @param p1y Y of a point on line 1.\n * @param p1z Z of a point on line 1.\n * @param n1x X of the unit vector of the direction of line 1.\n * @param n1y Y of the unit vector of the direction of line 1.\n * @param n1z Z of the unit vector of the direction of line 1.\n * @param p2x X of a point on line 2.\n * @param p2y Y of a point on line 2.\n * @param p2z Z of a point on line 2.\n * @param n2x X of the unit vector of the direction of line 2.\n * @param n2y Y of the unit vector of the direction of line 2.\n * @param n2z Z of the unit vector of the direction of line 2.\n */\nexport default function closestPointsBetweenTwoLines(\n    out1: Vec3 | null, out2: Vec3 | null,\n    p1x: number, p1y: number, p1z: number,\n    n1x: number, n1y: number, n1z: number,\n    p2x: number, p2y: number, p2z: number,\n    n2x: number, n2y: number, n2z: number\n): boolean {\n    let d = n1x ** 2 * n2y ** 2\n        + n1x ** 2 * n2z ** 2\n        - 2 * n1x * n1y * n2x * n2y\n        - 2 * n1x * n1z * n2x * n2z\n        + n1y ** 2 * n2x ** 2\n        + n1y ** 2 * n2z ** 2\n        - 2 * n1y * n1z * n2y * n2z\n        + n1z ** 2 * n2x ** 2\n        + n1z ** 2 * n2y ** 2;\n    let parallel = false;\n    let t1 = (\n        n1x * n2x * n2y * p1y\n        - n1x * n2x * n2y * p2y\n        + n1x * n2x * n2z * p1z\n        - n1x * n2x * n2z * p2z\n        - n1x * n2y ** 2 * p1x\n        + n1x * n2y ** 2 * p2x\n        - n1x * n2z ** 2 * p1x\n        + n1x * n2z ** 2 * p2x\n        - n1y * n2x ** 2 * p1y\n        + n1y * n2x ** 2 * p2y\n        + n1y * n2x * n2y * p1x\n        - n1y * n2x * n2y * p2x\n        + n1y * n2y * n2z * p1z\n        - n1y * n2y * n2z * p2z\n        - n1y * n2z ** 2 * p1y\n        + n1y * n2z ** 2 * p2y\n        - n1z * n2x ** 2 * p1z\n        + n1z * n2x ** 2 * p2z\n        + n1z * n2x * n2z * p1x\n        - n1z * n2x * n2z * p2x\n        - n1z * n2y ** 2 * p1z\n        + n1z * n2y ** 2 * p2z\n        + n1z * n2y * n2z * p1y\n        - n1z * n2y * n2z * p2y) / d;\n    if (!isFinite(t1)) {\n        parallel = true;\n        t1 = 0;\n    }\n    let o1x = p1x + n1x * t1;\n    let o1y = p1y + n1y * t1;\n    let o1z = p1z + n1z * t1;\n    if (out1) {\n        out1[0] = o1x;\n        out1[1] = o1y;\n        out1[2] = o1z;\n    }\n    if (out2) {\n        let t3 = (\n            -n1x * n2y * p1z\n            + n1x * n2y * p2z\n            + n1x * n2z * p1y\n            - n1x * n2z * p2y\n            + n1y * n2x * p1z\n            - n1y * n2x * p2z\n            - n1y * n2z * p1x\n            + n1y * n2z * p2x\n            - n1z * n2x * p1y\n            + n1z * n2x * p2y\n            + n1z * n2y * p1x\n            - n1z * n2y * p2x) / d;\n        if (isFinite(t3)) {\n            let n3x = n1y * n2z - n1z * n2y;\n            let n3y = -n1x * n2z + n1z * n2x;\n            let n3z = n1x * n2y - n1y * n2x;\n            out2[0] = o1x + n3x * t3;\n            out2[1] = o1y + n3y * t3;\n            out2[2] = o1z + n3z * t3;\n        } else {\n            parallel = true;\n            let n3x = n1y * (p1z - p2z) - n1z * (p1y - p2y);\n            let n3y = -n1x * (p1z - p2z) + n1z * (p1x - p2x);\n            let n3z = n1x * (p1y - p2y) - n1y * (p1x - p2x);\n            out2[0] = o1x + n1y * n3z - n1z * n3y;\n            out2[1] = o1y + -n1x * n3z + n1z * n3x;\n            out2[2] = o1z + n1x * n3y - n1y * n3x;\n        }\n    }\n    return parallel;\n}","content_without_annotations":"type Vec3 = [number, number, number] | Float32Array | Float64Array;\n\n/**\n * Find the two closest points on two 3D lines.\n * Return true if two lines are parallel.\n *\n * @param out1 Output - The closest point on line 1.\n * @param out2 Output - The closest point on line 2.\n * @param p1x X of a point on line 1.\n * @param p1y Y of a point on line 1.\n * @param p1z Z of a point on line 1.\n * @param n1x X of the unit vector of the direction of line 1.\n * @param n1y Y of the unit vector of the direction of line 1.\n * @param n1z Z of the unit vector of the direction of line 1.\n * @param p2x X of a point on line 2.\n * @param p2y Y of a point on line 2.\n * @param p2z Z of a point on line 2.\n * @param n2x X of the unit vector of the direction of line 2.\n * @param n2y Y of the unit vector of the direction of line 2.\n * @param n2z Z of the unit vector of the direction of line 2.\n */\nexport default function closestPointsBetweenTwoLines(\n    out1, out2,\n    p1x, p1y, p1z,\n    n1x, n1y, n1z,\n    p2x, p2y, p2z,\n    n2x, n2y, n2z\n) {\n    let d = n1x ** 2 * n2y ** 2\n        + n1x ** 2 * n2z ** 2\n        - 2 * n1x * n1y * n2x * n2y\n        - 2 * n1x * n1z * n2x * n2z\n        + n1y ** 2 * n2x ** 2\n        + n1y ** 2 * n2z ** 2\n        - 2 * n1y * n1z * n2y * n2z\n        + n1z ** 2 * n2x ** 2\n        + n1z ** 2 * n2y ** 2;\n    let parallel = false;\n    let t1 = (\n        n1x * n2x * n2y * p1y\n        - n1x * n2x * n2y * p2y\n        + n1x * n2x * n2z * p1z\n        - n1x * n2x * n2z * p2z\n        - n1x * n2y ** 2 * p1x\n        + n1x * n2y ** 2 * p2x\n        - n1x * n2z ** 2 * p1x\n        + n1x * n2z ** 2 * p2x\n        - n1y * n2x ** 2 * p1y\n        + n1y * n2x ** 2 * p2y\n        + n1y * n2x * n2y * p1x\n        - n1y * n2x * n2y * p2x\n        + n1y * n2y * n2z * p1z\n        - n1y * n2y * n2z * p2z\n        - n1y * n2z ** 2 * p1y\n        + n1y * n2z ** 2 * p2y\n        - n1z * n2x ** 2 * p1z\n        + n1z * n2x ** 2 * p2z\n        + n1z * n2x * n2z * p1x\n        - n1z * n2x * n2z * p2x\n        - n1z * n2y ** 2 * p1z\n        + n1z * n2y ** 2 * p2z\n        + n1z * n2y * n2z * p1y\n        - n1z * n2y * n2z * p2y) / d;\n    if (!isFinite(t1)) {\n        parallel = true;\n        t1 = 0;\n    }\n    let o1x = p1x + n1x * t1;\n    let o1y = p1y + n1y * t1;\n    let o1z = p1z + n1z * t1;\n    if (out1) {\n        out1[0] = o1x;\n        out1[1] = o1y;\n        out1[2] = o1z;\n    }\n    if (out2) {\n        let t3 = (\n            -n1x * n2y * p1z\n            + n1x * n2y * p2z\n            + n1x * n2z * p1y\n            - n1x * n2z * p2y\n            + n1y * n2x * p1z\n            - n1y * n2x * p2z\n            - n1y * n2z * p1x\n            + n1y * n2z * p2x\n            - n1z * n2x * p1y\n            + n1z * n2x * p2y\n            + n1z * n2y * p1x\n            - n1z * n2y * p2x) / d;\n        if (isFinite(t3)) {\n            let n3x = n1y * n2z - n1z * n2y;\n            let n3y = -n1x * n2z + n1z * n2x;\n            let n3z = n1x * n2y - n1y * n2x;\n            out2[0] = o1x + n3x * t3;\n            out2[1] = o1y + n3y * t3;\n            out2[2] = o1z + n3z * t3;\n        } else {\n            parallel = true;\n            let n3x = n1y * (p1z - p2z) - n1z * (p1y - p2y);\n            let n3y = -n1x * (p1z - p2z) + n1z * (p1x - p2x);\n            let n3z = n1x * (p1y - p2y) - n1y * (p1x - p2x);\n            out2[0] = o1x + n1y * n3z - n1z * n3y;\n            out2[1] = o1y + -n1x * n3z + n1z * n3x;\n            out2[2] = o1z + n1x * n3y - n1y * n3x;\n        }\n    }\n    return parallel;\n}","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":1591,"ext":"ts","fun_ann_density":0.0094280327,"function_parameters":14,"function_signatures":0,"function_usages":0,"functions":1,"hexsha":"b31a5e2a1789d50d26c605d881b979a28beb80a4","lang":"TypeScript","loc":88,"loc_per_function":79.0,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"0407eb2574defb61fc24175fd20b06e0f716bff8","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"x6ud/closest-points-between-two-lines","max_forks_repo_path":"src/index.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"0407eb2574defb61fc24175fd20b06e0f716bff8","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"x6ud/closest-points-between-two-lines","max_issues_repo_path":"src/index.ts","max_line_length":67,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"0407eb2574defb61fc24175fd20b06e0f716bff8","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"x6ud/closest-points-between-two-lines","max_stars_repo_path":"src/index.ts","max_stars_repo_stars_event_max_datetime":"2022-01-09T06:29:47.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-09T06:29:47.000Z","metric":0.2193988987,"predefined_density":0.5714285714,"predefined_types":16,"prop_ann_density":0.0,"property_declarations":0,"size":3607,"trivial_density":0.0,"trivial_types":0,"type_definitions":1,"typedef_density":0.0006285355,"var_ann_density":0.0081709617,"variable_declarations":13},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"type Vec3 = [number, number, number] | Float32Array | Float64Array;\n/**\n * Find the two closest points on two 3D lines.\n * Return true if two lines are parallel.\n *\n * @param out1 Output - The closest point on line 1.\n * @param out2 Output - The closest point on line 2.\n * @param p1x X of a point on line 1.\n * @param p1y Y of a point on line 1.\n * @param p1z Z of a point on line 1.\n * @param n1x X of the unit vector of the direction of line 1.\n * @param n1y Y of the unit vector of the direction of line 1.\n * @param n1z Z of the unit vector of the direction of line 1.\n * @param p2x X of a point on line 2.\n * @param p2y Y of a point on line 2.\n * @param p2z Z of a point on line 2.\n * @param n2x X of the unit vector of the direction of line 2.\n * @param n2y Y of the unit vector of the direction of line 2.\n * @param n2z Z of the unit vector of the direction of line 2.\n */\nexport default function closestPointsBetweenTwoLines(out1: Vec3, out2: Vec3, p1x: number, p1y: number, p1z: number, n1x: number, n1y: number, n1z: number, p2x: numbe, out2: Vec3, n2x: number, n2y: number, n2z: number): boolean {\n    const t1 = (n1x * n2x * n2y * p1y\n        - n1x, p1x: p1x - n1x * n1x * n1y * p1y\n        + n1x * n1y * n2x * n2y\n        - n1x * n1y * n2y, p1y: p1y - n1x * n1y * n2x * n2y\n        + n1x * n1y * n2x * n2y\n        - n1x * n1z * n2x, p1z: p1z - n1x * n1y * n2x * n2z\n        + n1y * n1z * n2x * n2y\n        - n1y * n1z * n2y, n1x: n1x - n2x * n1y * n2z\n        + n1y * n1z * n2x * n2y\n        - n1y * n1z * n2y, n1z, n1y: n1y - n2x * n1y * n2z\n        + n1y * n1z * n2x * n2y\n        - n1y * n1z * n2y, n1z, n1z: n1z - n2x * n1y * n2z\n        + n1y * n1z * n2x * n2y\n        - n1y * n1z * n2y, n1x, p2x: p2x - n1x * n2x * p2y\n        + n1x * p2x * n2x\n        - n1y * p2y * n2y\n        - n1z * p2, p2y: p2y - n1x * n1y * p2z\n         + n1y * n1z * n2x\n         - n1y * n1z * n2y\n         + n1z * n1, p2z: p2z - n1x * n1y * n2z\n         + n1z * n1, n1z: n1z - n2x * n1y * n2z\n         + n1z *, n2x: n2x - n1x * n2y * n2z\n         + n2y * n2z * n2x\n         - n2y * n2z * n2y\n         + n2y * n2, n2y: n2y - n1x * n2y * p2x\n         + n1y * n2y * n2x\n         - n1y * n2y * n2z\n         + n1y * n2, n2z: n2z - n1x * n2y * p2x\n         + n1y * n2z * n2x\n         - n1y * n2z * n2y\n         + n1y * n2): boolean {\n    const d = n1x ** 2 * n2y ** 2\n        + n1x ** 2 * n2z ** 2\n        - 2 * n1x * n1y * n2 {\n    let d = n1x ** 2 * n2y ** 2\n        + n1x ** 2 * n2z ** 2\n        - 2 * n1x * n1y * n2x * n2y\n        - 2 * n1x * n1z * n2x * n2z\n        + n1y ** 2 * n2x ** 2\n        + n1y ** 2 * n2z ** 2\n        - 2 * n1y * n1z * n2y * n2z\n        + n1z ** 2 * n2x ** 2\n        + n1z ** 2 * n2y ** 2;\n    let parallel = false;\n    let t1 = (n1x * n2x * n2y * p1y\n        - n1x * n2x * n2y * p2y\n        + n1x * n2x * n2z * p1z\n        - n1x * n2x * n2z * p2z\n        - n1x * n2y ** 2 * p1x\n        + n1x * n2y ** 2 * p2x\n        - n1x * n2z ** 2 * p1x\n        + n1x * n2z ** 2 * p2x\n        - n1y * n2x ** 2 * p1y\n        + n1y * n2x ** 2 * p2y\n        + n1y * n2x * n2y * p1x\n        - n1y * n2x * n2y * p2x\n        + n1y * n2y * n2z * p1z\n        - n1y * n2y * n2z * p2z\n        - n1y * n2z ** 2 * p1y\n        + n1y * n2z ** 2 * p2y\n        - n1z * n2x ** 2 * p1z\n        + n1z * n2x ** 2 * p2z\n        + n1z * n2x * n2z * p1x\n        - n1z * n2x * n2z * p2x\n        - n1z * n2y ** 2 * p1z\n        + n1z * n2y ** 2 * p2z\n        + n1z * n2y * n2z * p1y\n        - n1z * n2y * n2z * p2y) / d;\n    if (!isFinite(t1)) {\n        parallel = true;\n        t1 = 0;\n    }\n    let o1x = p1x + n1x * t1;\n    let o1y = p1y + n1y * t1;\n    let o1z = p1z + n1z * t1;\n    if (out1) {\n        out1[0] = o1x;\n        out1[1] = o1y;\n        out1[2] = o1z;\n    }\n    if (out2) {\n        let t3 = (-n1x * n2y * p1z\n            + n1x * n2y * p2z\n            + n1x * n2z * p1y\n            - n1x * n2z * p2y\n            + n1y * n2x * p1z\n            - n1y * n2x * p2z\n            - n1y * n2z * p1x\n            + n1y * n2z * p2x\n            - n1z * n2x * p1y\n            + n1z * n2x * p2y\n            + n1z * n2y * p1x\n            - n1z * n2y * p2x) / d;\n        if (isFinite(t3)) {\n            let n3x = n1y * n2z - n1z * n2y;\n            let n3y = -n1x * n2z + n1z * n2x;\n            let n3z = n1x * n2y - n1y * n2x;\n            out2[0] = o1x + n3x * t3;\n            out2[1] = o1y + n3y * t3;\n            out2[2] = o1z + n3z * t3;\n        }\n        else {\n            parallel = true;\n            let n3x = n1y * (p1z - p2z) - n1z * (p1y - p2y);\n            let n3y = -n1x * (p1z - p2z) + n1z * (p1x - p2x);\n            let n3z = n1x * (p1y - p2y) - n1y * (p1x - p2x);\n            out2[0] = o1x + n1y * n3z - n1z * n3y;\n            out2[1] = o1y + -n1x * n3z + n1z * n3x;\n            out2[2] = o1z + n1x * n3y - n1y * n3x;\n        }\n    }\n    return parallel;\n}\n","score":174,"fallbacked":false,"num_type_errors":76},{"code":"type Vec3 = [number, number, number] | Float32Array | Float64Array;\n/**\n * Find the two closest points on two 3D lines.\n * Return true if two lines are parallel.\n *\n * @param out1 Output - The closest point on line 1.\n * @param out2 Output - The closest point on line 2.\n * @param p1x X of a point on line 1.\n * @param p1y Y of a point on line 1.\n * @param p1z Z of a point on line 1.\n * @param n1x X of the unit vector of the direction of line 1.\n * @param n1y Y of the unit vector of the direction of line 1.\n * @param n1z Z of the unit vector of the direction of line 1.\n * @param p2x X of a point on line 2.\n * @param p2y Y of a point on line 2.\n * @param p2z Z of a point on line 2.\n * @param n2x X of the unit vector of the direction of line 2.\n * @param n2y Y of the unit vector of the direction of line 2.\n * @param n2z Z of the unit vector of the direction of line 2.\n */\nexport default function closestPointsBetweenTwoLines(out1: Vec3, out2: Vec3, p1x: number, p1y: number, p1z: number, n1x: number, n1y: number, n1z: number, p2x: numbe, out2: Vec3, n2x: number, n2y: number, n2z: number): boolean {\n    let dotP1ToLine1 = dot(n1x, n1y, n1z, p1x, p1x: number, p1y: number, p1z: number, n1x: number, n1y: number, n1z: number, p2x: number, n2x: number, n2y: number, p1y: number, p1z: number, p2y: number, p2z: number): number;\n    let dotP1ToLine2 = dot(n2x, n2y, n2z, p1x,, p1z: number, n2x: number, n2y: number, n2z: number): number;\n    if (dotP1ToLine1 < 0.0) {\n        dotP1ToLine1 = -dotP, n1x: number, n1y: number, n1z: number;\n        dotP1ToLine2 = -dotP, n2x: number, n2y: number, n2z: number;\n    }\n    if (do, n1y: number, n2y: number, n1z: number, n2z: number, p1z: number, p1y: number): number {\n        out1.set(p1x, p1y, p, n1z: number);\n    }\n    if (dotP1ToLine2 < 0.0) {\n        dotP1ToLine2 = -dotP, n1x: number, n1y: number, n1z: number, p2x: number, p2y: number, p2z: number;\n        dotP1ToLine1 = -dotP, n1x: number, n1y: number, n1z: number;\n    }\n    if (do, p2y: number, p2z: number, n2y: number, n2z: number): boolean {\n        out2.set(p2x, p2y, p2z, n2z: number);\n    }\n    retur, p2z: number = dotP1ToLine1 >= 0.0\n      ? dotP1ToLine1\n        : dotP1ToLine2 >= 0.0\n      ? dotP1ToLine2\n        : 0.0;, n2x: number, n2y: number, n2z: number, p2x: number, p2y: number, p2z: number;\n    return retur >= 0.0;\n}\n\n/**\n * Find, n2y: n2x: n1y: 0, n2z: 1, p2x: 0, p2y: 1, p2z: 0\n * @param out1: the closest point on lin, n2z: 0, n2y: 1, p2x: 0, p2y: 1, p2z: 0\n * @param n1x: the direction vector x\n * @param n1y: th): 0, 1\n * @param n1z: the direction vector z\n * @param p1x: the first point x\n * @param p1y: the first point y\n * @param p1z: the firs {\n    let d = n1x ** 2 * n2y ** 2\n        + n1x ** 2 * n2z ** 2\n        - 2 * n1x * n1y * n2x * n2y\n        - 2 * n1x * n1z * n2x * n2z\n        + n1y ** 2 * n2x ** 2\n        + n1y ** 2 * n2z ** 2\n        - 2 * n1y * n1z * n2y * n2z\n        + n1z ** 2 * n2x ** 2\n        + n1z ** 2 * n2y ** 2;\n    let parallel = false;\n    let t1 = (n1x * n2x * n2y * p1y\n        - n1x * n2x * n2y * p2y\n        + n1x * n2x * n2z * p1z\n        - n1x * n2x * n2z * p2z\n        - n1x * n2y ** 2 * p1x\n        + n1x * n2y ** 2 * p2x\n        - n1x * n2z ** 2 * p1x\n        + n1x * n2z ** 2 * p2x\n        - n1y * n2x ** 2 * p1y\n        + n1y * n2x ** 2 * p2y\n        + n1y * n2x * n2y * p1x\n        - n1y * n2x * n2y * p2x\n        + n1y * n2y * n2z * p1z\n        - n1y * n2y * n2z * p2z\n        - n1y * n2z ** 2 * p1y\n        + n1y * n2z ** 2 * p2y\n        - n1z * n2x ** 2 * p1z\n        + n1z * n2x ** 2 * p2z\n        + n1z * n2x * n2z * p1x\n        - n1z * n2x * n2z * p2x\n        - n1z * n2y ** 2 * p1z\n        + n1z * n2y ** 2 * p2z\n        + n1z * n2y * n2z * p1y\n        - n1z * n2y * n2z * p2y) / d;\n    if (!isFinite(t1)) {\n        parallel = true;\n        t1 = 0;\n    }\n    let o1x = p1x + n1x * t1;\n    let o1y = p1y + n1y * t1;\n    let o1z = p1z + n1z * t1;\n    if (out1) {\n        out1[0] = o1x;\n        out1[1] = o1y;\n        out1[2] = o1z;\n    }\n    if (out2) {\n        let t3 = (-n1x * n2y * p1z\n            + n1x * n2y * p2z\n            + n1x * n2z * p1y\n            - n1x * n2z * p2y\n            + n1y * n2x * p1z\n            - n1y * n2x * p2z\n            - n1y * n2z * p1x\n            + n1y * n2z * p2x\n            - n1z * n2x * p1y\n            + n1z * n2x * p2y\n            + n1z * n2y * p1x\n            - n1z * n2y * p2x) / d;\n        if (isFinite(t3)) {\n            let n3x = n1y * n2z - n1z * n2y;\n            let n3y = -n1x * n2z + n1z * n2x;\n            let n3z = n1x * n2y - n1y * n2x;\n            out2[0] = o1x + n3x * t3;\n            out2[1] = o1y + n3y * t3;\n            out2[2] = o1z + n3z * t3;\n        }\n        else {\n            parallel = true;\n            let n3x = n1y * (p1z - p2z) - n1z * (p1y - p2y);\n            let n3y = -n1x * (p1z - p2z) + n1z * (p1x - p2x);\n            let n3z = n1x * (p1y - p2y) - n1y * (p1x - p2x);\n            out2[0] = o1x + n1y * n3z - n1z * n3y;\n            out2[1] = o1y + -n1x * n3z + n1z * n3x;\n            out2[2] = o1z + n1x * n3y - n1y * n3x;\n        }\n    }\n    return parallel;\n}\n","score":59,"fallbacked":false,"num_type_errors":133},{"code":"type Vec3 = [number, number, number] | Float32Array | Float64Array;\n/**\n * Find the two closest points on two 3D lines.\n * Return true if two lines are parallel.\n *\n * @param out1 Output - The closest point on line 1.\n * @param out2 Output - The closest point on line 2.\n * @param p1x X of a point on line 1.\n * @param p1y Y of a point on line 1.\n * @param p1z Z of a point on line 1.\n * @param n1x X of the unit vector of the direction of line 1.\n * @param n1y Y of the unit vector of the direction of line 1.\n * @param n1z Z of the unit vector of the direction of line 1.\n * @param p2x X of a point on line 2.\n * @param p2y Y of a point on line 2.\n * @param p2z Z of a point on line 2.\n * @param n2x X of the unit vector of the direction of line 2.\n * @param n2y Y of the unit vector of the direction of line 2.\n * @param n2z Z of the unit vector of the direction of line 2.\n */\nexport default function closestPointsBetweenTwoLines(out1: Vec3, out2: Vec3, p1x: number, p1y: number, p1z: number, n1x: number, n1y: number, n1z: number, p2x: numbe, out2: Vec3, n2x: number, n2y: number, n2z: number): boolean {\n    // Special case if either line is parallel.\n    if (n1x === 0 && n1y === 0 &, p1x: = 0 && p1y === 0 && p1z === 0) {\n        return false;\n    }\n    const closestPointOnLine1 = closestPointOnLine(p1x, p1y, p1z, p1y: p1z, n1x: n1y: n1z, p2x: p2y: p2z, n2x: n2y: n2z, out1: out1, out2: ou, p1z: p2y: p2z: number): Vec3 {\n        if (n2x === 0 && n2y === 0 && n2z === 0) {\n            return out1;\n        }\n\n        const t =, n1x: number, n1y: number, n1z: number, n2x: number, n2y: number, n2z: number;\n        const t1 = closestPointOnLine1(out1, p1x, n1y: p1z, n1z: n1y);\n        const t2 = closestPointOnLine1(out2, p2x, n2y: p2z, n2z: n2y);\n\n        if (, n1z: number, n2z: number, n1y: number) {\n            const t = t1 - t2;\n            if (t < 0) {\n                return out2;\n            }\n            if (t > 1), p2x: number, p2y: number, p2z: number;\n            }\n        } else if (, n2z: number, n2y: number) {\n            const t = t2 - t1;\n            if (t, p2y: number, p2z: number;\n            }\n        } else {\n            if (p1y === p2y) {\n                const t = t1 - t2;\n                if (t < 0) {\n                    return out2, p2z: p2y: number;\n                }\n                if (t > 1) {\n                    return out1, p1z: p1y: number;\n                }\n                }\n            }\n        }\n\n        const t = t1 - t2, n2x: number, n2y: number, n2z: number;\n        const t1 = closestPointOnLine1(out1, p1x: p1y: number, p1y: n1y: number, n, n2y: p2y: number, n2z: p2y: number);\n        const t2 = closestPointOnLine1(out2, p2x: p2y: number, p2y: n2y: number, n2z: p2y: number);\n\n        if (, n1z: number, n2z: number, n1y: number) {\n            const t = t1 - t2;\n            if (t < 0) {\n                retur): Vec3;\n                return out2;\n            }\n            if (t > 1) {\n                retur): Vec3;\n                return out1;\n            }\n            }\n        else if (, n2z: number, n2y {\n    let d = n1x ** 2 * n2y ** 2\n        + n1x ** 2 * n2z ** 2\n        - 2 * n1x * n1y * n2x * n2y\n        - 2 * n1x * n1z * n2x * n2z\n        + n1y ** 2 * n2x ** 2\n        + n1y ** 2 * n2z ** 2\n        - 2 * n1y * n1z * n2y * n2z\n        + n1z ** 2 * n2x ** 2\n        + n1z ** 2 * n2y ** 2;\n    let parallel = false;\n    let t1 = (n1x * n2x * n2y * p1y\n        - n1x * n2x * n2y * p2y\n        + n1x * n2x * n2z * p1z\n        - n1x * n2x * n2z * p2z\n        - n1x * n2y ** 2 * p1x\n        + n1x * n2y ** 2 * p2x\n        - n1x * n2z ** 2 * p1x\n        + n1x * n2z ** 2 * p2x\n        - n1y * n2x ** 2 * p1y\n        + n1y * n2x ** 2 * p2y\n        + n1y * n2x * n2y * p1x\n        - n1y * n2x * n2y * p2x\n        + n1y * n2y * n2z * p1z\n        - n1y * n2y * n2z * p2z\n        - n1y * n2z ** 2 * p1y\n        + n1y * n2z ** 2 * p2y\n        - n1z * n2x ** 2 * p1z\n        + n1z * n2x ** 2 * p2z\n        + n1z * n2x * n2z * p1x\n        - n1z * n2x * n2z * p2x\n        - n1z * n2y ** 2 * p1z\n        + n1z * n2y ** 2 * p2z\n        + n1z * n2y * n2z * p1y\n        - n1z * n2y * n2z * p2y) / d;\n    if (!isFinite(t1)) {\n        parallel = true;\n        t1 = 0;\n    }\n    let o1x = p1x + n1x * t1;\n    let o1y = p1y + n1y * t1;\n    let o1z = p1z + n1z * t1;\n    if (out1) {\n        out1[0] = o1x;\n        out1[1] = o1y;\n        out1[2] = o1z;\n    }\n    if (out2) {\n        let t3 = (-n1x * n2y * p1z\n            + n1x * n2y * p2z\n            + n1x * n2z * p1y\n            - n1x * n2z * p2y\n            + n1y * n2x * p1z\n            - n1y * n2x * p2z\n            - n1y * n2z * p1x\n            + n1y * n2z * p2x\n            - n1z * n2x * p1y\n            + n1z * n2x * p2y\n            + n1z * n2y * p1x\n            - n1z * n2y * p2x) / d;\n        if (isFinite(t3)) {\n            let n3x = n1y * n2z - n1z * n2y;\n            let n3y = -n1x * n2z + n1z * n2x;\n            let n3z = n1x * n2y - n1y * n2x;\n            out2[0] = o1x + n3x * t3;\n            out2[1] = o1y + n3y * t3;\n            out2[2] = o1z + n3z * t3;\n        }\n        else {\n            parallel = true;\n            let n3x = n1y * (p1z - p2z) - n1z * (p1y - p2y);\n            let n3y = -n1x * (p1z - p2z) + n1z * (p1x - p2x);\n            let n3z = n1x * (p1y - p2y) - n1y * (p1x - p2x);\n            out2[0] = o1x + n1y * n3z - n1z * n3y;\n            out2[1] = o1y + -n1x * n3z + n1z * n3x;\n            out2[2] = o1z + n1x * n3y - n1y * n3x;\n        }\n    }\n    return parallel;\n}\n","score":200,"fallbacked":false,"num_type_errors":304}]}
{"dataset_elem":{"alphanum_fraction":0.590949955,"avg_line_length":26.0025974026,"content":"/* eslint-disable @typescript-eslint/no-empty-function, max-classes-per-file, no-param-reassign */\r\n\r\nconst alwaysFn = (C: any): any => {\r\n  // Search up the prototype chain until we hit base. The base class of Class has no name I guess.\r\n  const classHierarchy = [];\r\n  for (let curr = C; curr.name; curr = Object.getPrototypeOf(curr)) {\r\n    classHierarchy.push(curr);\r\n  }\r\n\r\n  // Get all static methods defined on any ancestor\r\n  const statics = classHierarchy\r\n    .map(klass => Object.getOwnPropertyNames(klass))\r\n    .reduce((a, b) => [...a, ...b], []) // flatten\r\n    .filter(n => typeof C[n] === 'function')\r\n    .reduce((acc: any, name) => {\r\n      acc[name] = C[name];\r\n      return acc;\r\n    }, {});\r\n\r\n  return Object.assign(\r\n    // eslint-disable-next-line func-names\r\n    function() {\r\n      return new C();\r\n    },\r\n    C,\r\n    statics\r\n  );\r\n};\r\n\r\n// Add canvas mock based on this comment: https://github.com/jsdom/jsdom/issues/1782#issuecomment-337656878\r\nfunction mockCanvas(window: any) {\r\n  window.HTMLCanvasElement.prototype.getContext = () => ({\r\n    fillRect: () => ({}),\r\n    clearRect: () => ({}),\r\n    getImageData: (_x: number, _y: number, w: number, h: number) => ({ data: new Array(w * h * 4) }),\r\n    putImageData: () => ({}),\r\n    createImageData: () => [],\r\n    setTransform: () => ({}),\r\n    drawImage: () => ({}),\r\n    save: () => ({}),\r\n    fillText: () => ({}),\r\n    restore: () => ({}),\r\n    beginPath: () => ({}),\r\n    moveTo: () => ({}),\r\n    lineTo: () => ({}),\r\n    closePath: () => ({}),\r\n    stroke: () => ({}),\r\n    translate: () => ({}),\r\n    scale: () => ({}),\r\n    rotate: () => ({}),\r\n    arc: () => ({}),\r\n    fill: () => ({}),\r\n    measureText: () => ({ width: 0 }),\r\n    transform: () => ({}),\r\n    rect: () => ({}),\r\n    clip: () => ({}),\r\n  });\r\n\r\n  window.HTMLCanvasElement.prototype.toDataURL = () => '';\r\n}\r\n\r\nfunction mockIntl(window: any) {\r\n  if (!window.Intl) {\r\n    class IntlMock {\r\n      static supportedLocalesOf() {\r\n        return [];\r\n      }\r\n\r\n      resolvedOptions() {\r\n        return {};\r\n      }\r\n    }\r\n    class IntlFormatMock extends IntlMock {\r\n      format() {\r\n        return '';\r\n      }\r\n\r\n      formatToParts() {\r\n        return [];\r\n      }\r\n    }\r\n    class IntlCollatorMock extends IntlMock {\r\n      compare() {\r\n        return 0;\r\n      }\r\n    }\r\n    class IntlPluralRulesMock extends IntlMock {\r\n      select() {\r\n        return '';\r\n      }\r\n    }\r\n\r\n    class IntlDateTimeFormatMock extends IntlFormatMock {}\r\n    class IntlNumberFormatMock extends IntlFormatMock {}\r\n    class IntlListFormatMock extends IntlFormatMock {}\r\n    class IntlRelativeTimeFormatMock extends IntlFormatMock {}\r\n    Object.defineProperty(window, 'Intl', {\r\n      value: {\r\n        Collator: alwaysFn(IntlCollatorMock),\r\n        DateTimeFormat: alwaysFn(IntlDateTimeFormatMock),\r\n        ListFormat: alwaysFn(IntlListFormatMock),\r\n        NumberFormat: alwaysFn(IntlNumberFormatMock),\r\n        PluralRules: alwaysFn(IntlPluralRulesMock),\r\n        RelativeTimeFormat: alwaysFn(IntlRelativeTimeFormatMock),\r\n      },\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockMatchMedia(window: any) {\r\n  if (!window.matchMedia) {\r\n    Object.defineProperty(window, 'matchMedia', {\r\n      value: () => ({\r\n        matches: true,\r\n        addListener: () => {},\r\n        removeListener: () => {},\r\n      }),\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockLocalStorage(window: any) {\r\n  if (!window.localStorage) {\r\n    class LocalStorageMock {\r\n      store: any;\r\n      constructor() {\r\n        this.store = {};\r\n      }\r\n\r\n      getItem(key: any): any {\r\n        return this.store[key];\r\n      }\r\n\r\n      removeItem(key: any) {\r\n        delete this.store[key];\r\n      }\r\n\r\n      setItem(key: any, value: any) {\r\n        this.store[key] = value.toString();\r\n      }\r\n\r\n      clear() {\r\n        this.store = {};\r\n      }\r\n    }\r\n    Object.defineProperty(window, 'localStorage', {\r\n      value: new LocalStorageMock(),\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockWebWorker(window: any) {\r\n  if (!window.Worker) {\r\n    class WorkerMock {\r\n      addEventListener() {}\r\n\r\n      removeEventLister() {}\r\n\r\n      postMessage() {}\r\n\r\n      terminate() {}\r\n    }\r\n    Object.defineProperty(window, 'Worker', {\r\n      value: WorkerMock,\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockCrypto(window: any) {\r\n  if (!window.crypto) {\r\n    Object.defineProperty(window, 'crypto', {\r\n      value: {\r\n        getRandomValues: (arr: any) => arr.fill(0),\r\n      },\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockMimeTypes(window: any) {\r\n  if (!window.navigator.mimeTypes) {\r\n    Object.defineProperty(window.navigator, 'mimeTypes', {\r\n      value: () => [],\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockFetch(window: any) {\r\n  // issue: https://github.com/chromaui/chromatic-cli/issues/14\r\n  Object.defineProperty(window, 'fetch', {\r\n    value: () =>\r\n      new Promise((_res, _rej) => {\r\n        // we just let this never resolve\r\n      }),\r\n    writable: true,\r\n  });\r\n}\r\n\r\nfunction mockObjectURL(window: any) {\r\n  if (!window.URL.createObjectURL) {\r\n    Object.defineProperty(window.URL, 'createObjectURL', { value: () => {}, writable: true });\r\n  }\r\n  if (!window.URL.revokeObjectURL) {\r\n    Object.defineProperty(window.URL, 'revokeObjectURL', { value: () => {}, writable: true });\r\n  }\r\n}\r\n\r\nfunction mockMutationObserver(window: any) {\r\n  if (!window.MutationObserver) {\r\n    // We have to do this in this screwy way because Angular does some monkey patching\r\n    // expects an non-es2015 class here.\r\n    // eslint-disable-next-line no-inner-declarations\r\n    // @ts-ignore\r\n    function MutationObserverMock() {}\r\n    MutationObserverMock.prototype = {\r\n      observe() {\r\n        return [];\r\n      },\r\n      takeRecords() {\r\n        return [];\r\n      },\r\n      disconnect() {},\r\n    };\r\n\r\n    Object.defineProperty(window, 'MutationObserver', {\r\n      value: MutationObserverMock,\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockSVG(window: any) {\r\n  // issue: https://github.com/chromaui/chromatic-cli/issues/27\r\n  // solution found here: https://github.com/facebook/jest/issues/5379#issuecomment-360044161\r\n  // not incuded in jsdom yet: https://github.com/jsdom/jsdom/issues/2128\r\n  const svgElements = [\r\n    'SVGAElement',\r\n    'SVGAltGlyphElement',\r\n    'SVGAngle',\r\n    'SVGAnimateColorElement',\r\n    'SVGAnimateElement',\r\n    'SVGAnimateMotionElement',\r\n    'SVGAnimateTransformElement',\r\n    'SVGAnimatedAngle',\r\n    'SVGAnimatedBoolean',\r\n    'SVGAnimatedEnumeration',\r\n    'SVGAnimatedInteger',\r\n    'SVGAnimatedLength',\r\n    'SVGAnimatedLengthList',\r\n    'SVGAnimatedNumber',\r\n    'SVGAnimatedNumberList',\r\n    'SVGAnimatedPoints',\r\n    'SVGAnimatedPreserveAspectRatio',\r\n    'SVGAnimatedRect',\r\n    'SVGAnimatedString',\r\n    'SVGAnimatedTransformList',\r\n    'SVGAnimationElement',\r\n    'SVGCircleElement',\r\n    'SVGClipPathElement',\r\n    'SVGComponentTransferFunctionElement',\r\n    'SVGCursorElement',\r\n    'SVGDefsElement',\r\n    'SVGDescElement',\r\n    'SVGDocument',\r\n    'SVGElement',\r\n    'SVGEllipseElement',\r\n    'SVGFEBlendElement',\r\n    'SVGFEColorMatrixElement',\r\n    'SVGFEComponentTransferElement',\r\n    'SVGFECompositeElement',\r\n    'SVGFEConvolveMatrixElement',\r\n    'SVGFEDiffuseLightingElement',\r\n    'SVGFEDisplacementMapElement',\r\n    'SVGFEDistantLightElement',\r\n    'SVGFEDropShadowElement',\r\n    'SVGFEFloodElement',\r\n    'SVGFEFuncAElement',\r\n    'SVGFEFuncBElement',\r\n    'SVGFEFuncGElement',\r\n    'SVGFEFuncRElement',\r\n    'SVGFEGaussianBlurElement',\r\n    'SVGFEImageElement',\r\n    'SVGFEMergeElement',\r\n    'SVGFEMergeNodeElement',\r\n    'SVGFEMorphologyElement',\r\n    'SVGFEOffsetElement',\r\n    'SVGFEPointLightElement',\r\n    'SVGFESpecularLightingElement',\r\n    'SVGFESpotLightElement',\r\n    'SVGFETileElement',\r\n    'SVGFETurbulenceElement',\r\n    'SVGFilterElement',\r\n    'SVGFilterPrimitiveStandardAttributes',\r\n    'SVGFontElement',\r\n    'SVGFontFaceElement',\r\n    'SVGFontFaceFormatElement',\r\n    'SVGFontFaceNameElement',\r\n    'SVGFontFaceSrcElement',\r\n    'SVGFontFaceUriElement',\r\n    'SVGForeignObjectElement',\r\n    'SVGGElement',\r\n    'SVGGlyphElement',\r\n    'SVGGradientElement',\r\n    'SVGGraphicsElement',\r\n    'SVGHKernElement',\r\n    'SVGImageElement',\r\n    'SVGLength',\r\n    'SVGLengthList',\r\n    'SVGLineElement',\r\n    'SVGLinearGradientElement',\r\n    'SVGMPathElement',\r\n    'SVGMaskElement',\r\n    'SVGMatrix',\r\n    'SVGMetadataElement',\r\n    'SVGMissingGlyphElement',\r\n    'SVGNumber',\r\n    'SVGNumberList',\r\n    'SVGPathElement',\r\n    'SVGPatternElement',\r\n    'SVGPoint',\r\n    'SVGPolylineElement',\r\n    'SVGPreserveAspectRatio',\r\n    'SVGRadialGradientElement',\r\n    'SVGRect',\r\n    'SVGRectElement',\r\n    'SVGSVGElement',\r\n    'SVGScriptElement',\r\n    'SVGSetElement',\r\n    'SVGStopElement',\r\n    'SVGStringList',\r\n    'SVGStylable',\r\n    'SVGStyleElement',\r\n    'SVGSwitchElement',\r\n    'SVGSymbolElement',\r\n    'SVGTRefElement',\r\n    'SVGTSpanElement',\r\n    'SVGTests',\r\n    'SVGTextContentElement',\r\n    'SVGTextElement',\r\n    'SVGTextPathElement',\r\n    'SVGTextPositioningElement',\r\n    'SVGTitleElement',\r\n    'SVGTransform',\r\n    'SVGTransformList',\r\n    'SVGTransformable',\r\n    'SVGURIReference',\r\n    'SVGUnitTypes',\r\n    'SVGUseElement',\r\n    'SVGVKernElement',\r\n    'SVGViewElement',\r\n    'SVGZoomAndPan',\r\n  ];\r\n\r\n  svgElements.forEach(e => {\r\n    if (!window[e]) {\r\n      // eslint-disable-next-line no-eval\r\n      const Value = eval(`(class ${e} extends window.HTMLElement {})`);\r\n\r\n      Object.defineProperty(window, e, {\r\n        value: Value,\r\n        writable: true,\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\nexport function addShimsToJSDOM(window: any) {\r\n  mockSVG(window);\r\n  mockMutationObserver(window);\r\n  mockObjectURL(window);\r\n  mockFetch(window);\r\n  mockMimeTypes(window);\r\n  mockCrypto(window);\r\n  mockWebWorker(window);\r\n  mockLocalStorage(window);\r\n  mockMatchMedia(window);\r\n  mockIntl(window);\r\n  mockCanvas(window);\r\n}\r\n","content_without_annotations":"/* eslint-disable @typescript-eslint/no-empty-function, max-classes-per-file, no-param-reassign */\r\n\r\nconst alwaysFn = (C) => {\r\n  // Search up the prototype chain until we hit base. The base class of Class has no name I guess.\r\n  const classHierarchy = [];\r\n  for (let curr = C; curr.name; curr = Object.getPrototypeOf(curr)) {\r\n    classHierarchy.push(curr);\r\n  }\r\n\r\n  // Get all static methods defined on any ancestor\r\n  const statics = classHierarchy\r\n    .map(klass => Object.getOwnPropertyNames(klass))\r\n    .reduce((a, b) => [...a, ...b], []) // flatten\r\n    .filter(n => typeof C[n] === 'function')\r\n    .reduce((acc, name) => {\r\n      acc[name] = C[name];\r\n      return acc;\r\n    }, {});\r\n\r\n  return Object.assign(\r\n    // eslint-disable-next-line func-names\r\n    function() {\r\n      return new C();\r\n    },\r\n    C,\r\n    statics\r\n  );\r\n};\r\n\r\n// Add canvas mock based on this comment: https://github.com/jsdom/jsdom/issues/1782#issuecomment-337656878\r\nfunction mockCanvas(window) {\r\n  window.HTMLCanvasElement.prototype.getContext = () => ({\r\n    fillRect: () => ({}),\r\n    clearRect: () => ({}),\r\n    getImageData: (_x, _y, w, h) => ({ data: new Array(w * h * 4) }),\r\n    putImageData: () => ({}),\r\n    createImageData: () => [],\r\n    setTransform: () => ({}),\r\n    drawImage: () => ({}),\r\n    save: () => ({}),\r\n    fillText: () => ({}),\r\n    restore: () => ({}),\r\n    beginPath: () => ({}),\r\n    moveTo: () => ({}),\r\n    lineTo: () => ({}),\r\n    closePath: () => ({}),\r\n    stroke: () => ({}),\r\n    translate: () => ({}),\r\n    scale: () => ({}),\r\n    rotate: () => ({}),\r\n    arc: () => ({}),\r\n    fill: () => ({}),\r\n    measureText: () => ({ width: 0 }),\r\n    transform: () => ({}),\r\n    rect: () => ({}),\r\n    clip: () => ({}),\r\n  });\r\n\r\n  window.HTMLCanvasElement.prototype.toDataURL = () => '';\r\n}\r\n\r\nfunction mockIntl(window) {\r\n  if (!window.Intl) {\r\n    class IntlMock {\r\n      static supportedLocalesOf() {\r\n        return [];\r\n      }\r\n\r\n      resolvedOptions() {\r\n        return {};\r\n      }\r\n    }\r\n    class IntlFormatMock extends IntlMock {\r\n      format() {\r\n        return '';\r\n      }\r\n\r\n      formatToParts() {\r\n        return [];\r\n      }\r\n    }\r\n    class IntlCollatorMock extends IntlMock {\r\n      compare() {\r\n        return 0;\r\n      }\r\n    }\r\n    class IntlPluralRulesMock extends IntlMock {\r\n      select() {\r\n        return '';\r\n      }\r\n    }\r\n\r\n    class IntlDateTimeFormatMock extends IntlFormatMock {}\r\n    class IntlNumberFormatMock extends IntlFormatMock {}\r\n    class IntlListFormatMock extends IntlFormatMock {}\r\n    class IntlRelativeTimeFormatMock extends IntlFormatMock {}\r\n    Object.defineProperty(window, 'Intl', {\r\n      value: {\r\n        Collator: alwaysFn(IntlCollatorMock),\r\n        DateTimeFormat: alwaysFn(IntlDateTimeFormatMock),\r\n        ListFormat: alwaysFn(IntlListFormatMock),\r\n        NumberFormat: alwaysFn(IntlNumberFormatMock),\r\n        PluralRules: alwaysFn(IntlPluralRulesMock),\r\n        RelativeTimeFormat: alwaysFn(IntlRelativeTimeFormatMock),\r\n      },\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockMatchMedia(window) {\r\n  if (!window.matchMedia) {\r\n    Object.defineProperty(window, 'matchMedia', {\r\n      value: () => ({\r\n        matches: true,\r\n        addListener: () => {},\r\n        removeListener: () => {},\r\n      }),\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockLocalStorage(window) {\r\n  if (!window.localStorage) {\r\n    class LocalStorageMock {\r\n      store;\r\n      constructor() {\r\n        this.store = {};\r\n      }\r\n\r\n      getItem(key) {\r\n        return this.store[key];\r\n      }\r\n\r\n      removeItem(key) {\r\n        delete this.store[key];\r\n      }\r\n\r\n      setItem(key, value) {\r\n        this.store[key] = value.toString();\r\n      }\r\n\r\n      clear() {\r\n        this.store = {};\r\n      }\r\n    }\r\n    Object.defineProperty(window, 'localStorage', {\r\n      value: new LocalStorageMock(),\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockWebWorker(window) {\r\n  if (!window.Worker) {\r\n    class WorkerMock {\r\n      addEventListener() {}\r\n\r\n      removeEventLister() {}\r\n\r\n      postMessage() {}\r\n\r\n      terminate() {}\r\n    }\r\n    Object.defineProperty(window, 'Worker', {\r\n      value: WorkerMock,\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockCrypto(window) {\r\n  if (!window.crypto) {\r\n    Object.defineProperty(window, 'crypto', {\r\n      value: {\r\n        getRandomValues: (arr) => arr.fill(0),\r\n      },\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockMimeTypes(window) {\r\n  if (!window.navigator.mimeTypes) {\r\n    Object.defineProperty(window.navigator, 'mimeTypes', {\r\n      value: () => [],\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockFetch(window) {\r\n  // issue: https://github.com/chromaui/chromatic-cli/issues/14\r\n  Object.defineProperty(window, 'fetch', {\r\n    value: () =>\r\n      new Promise((_res, _rej) => {\r\n        // we just let this never resolve\r\n      }),\r\n    writable: true,\r\n  });\r\n}\r\n\r\nfunction mockObjectURL(window) {\r\n  if (!window.URL.createObjectURL) {\r\n    Object.defineProperty(window.URL, 'createObjectURL', { value: () => {}, writable: true });\r\n  }\r\n  if (!window.URL.revokeObjectURL) {\r\n    Object.defineProperty(window.URL, 'revokeObjectURL', { value: () => {}, writable: true });\r\n  }\r\n}\r\n\r\nfunction mockMutationObserver(window) {\r\n  if (!window.MutationObserver) {\r\n    // We have to do this in this screwy way because Angular does some monkey patching\r\n    // expects an non-es2015 class here.\r\n    // eslint-disable-next-line no-inner-declarations\r\n    // @ts-ignore\r\n    function MutationObserverMock() {}\r\n    MutationObserverMock.prototype = {\r\n      observe() {\r\n        return [];\r\n      },\r\n      takeRecords() {\r\n        return [];\r\n      },\r\n      disconnect() {},\r\n    };\r\n\r\n    Object.defineProperty(window, 'MutationObserver', {\r\n      value: MutationObserverMock,\r\n      writable: true,\r\n    });\r\n  }\r\n}\r\n\r\nfunction mockSVG(window) {\r\n  // issue: https://github.com/chromaui/chromatic-cli/issues/27\r\n  // solution found here: https://github.com/facebook/jest/issues/5379#issuecomment-360044161\r\n  // not incuded in jsdom yet: https://github.com/jsdom/jsdom/issues/2128\r\n  const svgElements = [\r\n    'SVGAElement',\r\n    'SVGAltGlyphElement',\r\n    'SVGAngle',\r\n    'SVGAnimateColorElement',\r\n    'SVGAnimateElement',\r\n    'SVGAnimateMotionElement',\r\n    'SVGAnimateTransformElement',\r\n    'SVGAnimatedAngle',\r\n    'SVGAnimatedBoolean',\r\n    'SVGAnimatedEnumeration',\r\n    'SVGAnimatedInteger',\r\n    'SVGAnimatedLength',\r\n    'SVGAnimatedLengthList',\r\n    'SVGAnimatedNumber',\r\n    'SVGAnimatedNumberList',\r\n    'SVGAnimatedPoints',\r\n    'SVGAnimatedPreserveAspectRatio',\r\n    'SVGAnimatedRect',\r\n    'SVGAnimatedString',\r\n    'SVGAnimatedTransformList',\r\n    'SVGAnimationElement',\r\n    'SVGCircleElement',\r\n    'SVGClipPathElement',\r\n    'SVGComponentTransferFunctionElement',\r\n    'SVGCursorElement',\r\n    'SVGDefsElement',\r\n    'SVGDescElement',\r\n    'SVGDocument',\r\n    'SVGElement',\r\n    'SVGEllipseElement',\r\n    'SVGFEBlendElement',\r\n    'SVGFEColorMatrixElement',\r\n    'SVGFEComponentTransferElement',\r\n    'SVGFECompositeElement',\r\n    'SVGFEConvolveMatrixElement',\r\n    'SVGFEDiffuseLightingElement',\r\n    'SVGFEDisplacementMapElement',\r\n    'SVGFEDistantLightElement',\r\n    'SVGFEDropShadowElement',\r\n    'SVGFEFloodElement',\r\n    'SVGFEFuncAElement',\r\n    'SVGFEFuncBElement',\r\n    'SVGFEFuncGElement',\r\n    'SVGFEFuncRElement',\r\n    'SVGFEGaussianBlurElement',\r\n    'SVGFEImageElement',\r\n    'SVGFEMergeElement',\r\n    'SVGFEMergeNodeElement',\r\n    'SVGFEMorphologyElement',\r\n    'SVGFEOffsetElement',\r\n    'SVGFEPointLightElement',\r\n    'SVGFESpecularLightingElement',\r\n    'SVGFESpotLightElement',\r\n    'SVGFETileElement',\r\n    'SVGFETurbulenceElement',\r\n    'SVGFilterElement',\r\n    'SVGFilterPrimitiveStandardAttributes',\r\n    'SVGFontElement',\r\n    'SVGFontFaceElement',\r\n    'SVGFontFaceFormatElement',\r\n    'SVGFontFaceNameElement',\r\n    'SVGFontFaceSrcElement',\r\n    'SVGFontFaceUriElement',\r\n    'SVGForeignObjectElement',\r\n    'SVGGElement',\r\n    'SVGGlyphElement',\r\n    'SVGGradientElement',\r\n    'SVGGraphicsElement',\r\n    'SVGHKernElement',\r\n    'SVGImageElement',\r\n    'SVGLength',\r\n    'SVGLengthList',\r\n    'SVGLineElement',\r\n    'SVGLinearGradientElement',\r\n    'SVGMPathElement',\r\n    'SVGMaskElement',\r\n    'SVGMatrix',\r\n    'SVGMetadataElement',\r\n    'SVGMissingGlyphElement',\r\n    'SVGNumber',\r\n    'SVGNumberList',\r\n    'SVGPathElement',\r\n    'SVGPatternElement',\r\n    'SVGPoint',\r\n    'SVGPolylineElement',\r\n    'SVGPreserveAspectRatio',\r\n    'SVGRadialGradientElement',\r\n    'SVGRect',\r\n    'SVGRectElement',\r\n    'SVGSVGElement',\r\n    'SVGScriptElement',\r\n    'SVGSetElement',\r\n    'SVGStopElement',\r\n    'SVGStringList',\r\n    'SVGStylable',\r\n    'SVGStyleElement',\r\n    'SVGSwitchElement',\r\n    'SVGSymbolElement',\r\n    'SVGTRefElement',\r\n    'SVGTSpanElement',\r\n    'SVGTests',\r\n    'SVGTextContentElement',\r\n    'SVGTextElement',\r\n    'SVGTextPathElement',\r\n    'SVGTextPositioningElement',\r\n    'SVGTitleElement',\r\n    'SVGTransform',\r\n    'SVGTransformList',\r\n    'SVGTransformable',\r\n    'SVGURIReference',\r\n    'SVGUnitTypes',\r\n    'SVGUseElement',\r\n    'SVGVKernElement',\r\n    'SVGViewElement',\r\n    'SVGZoomAndPan',\r\n  ];\r\n\r\n  svgElements.forEach(e => {\r\n    if (!window[e]) {\r\n      // eslint-disable-next-line no-eval\r\n      const Value = eval(`(class ${e} extends window.HTMLElement {})`);\r\n\r\n      Object.defineProperty(window, e, {\r\n        value: Value,\r\n        writable: true,\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\nexport function addShimsToJSDOM(window) {\r\n  mockSVG(window);\r\n  mockMutationObserver(window);\r\n  mockObjectURL(window);\r\n  mockFetch(window);\r\n  mockMimeTypes(window);\r\n  mockCrypto(window);\r\n  mockWebWorker(window);\r\n  mockLocalStorage(window);\r\n  mockMatchMedia(window);\r\n  mockIntl(window);\r\n  mockCanvas(window);\r\n}\r\n","dynamism_density":0.0007722008,"dynamism_heuristic":2,"estimated_tokens":2590,"ext":"ts","fun_ann_density":0.0401544402,"function_parameters":31,"function_signatures":0,"function_usages":12,"functions":73,"hexsha":"0ac468cdf3c8d2136343160aa7b224310a7ba0b6","lang":"TypeScript","loc":340,"loc_per_function":5.4794520548,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"ba8824bf4084c7b98bc38930b151d0b664211f76","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"Red-Folder/chromatic-core","max_forks_repo_path":"src/chromatic/lib/jsdom-shims.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"ba8824bf4084c7b98bc38930b151d0b664211f76","max_issues_repo_issues_event_max_datetime":"2022-01-22T12:07:16.000Z","max_issues_repo_issues_event_min_datetime":"2022-01-22T12:07:16.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"Red-Folder/chromatic-core","max_issues_repo_path":"src/chromatic/lib/jsdom-shims.ts","max_line_length":108,"max_stars_count":null,"max_stars_repo_head_hexsha":"ba8824bf4084c7b98bc38930b151d0b664211f76","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"Red-Folder/chromatic-core","max_stars_repo_path":"src/chromatic/lib/jsdom-shims.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.2775539786,"predefined_density":0.036036036,"predefined_types":4,"prop_ann_density":0.0003861004,"property_declarations":1,"size":10011,"trivial_density":0.1981981982,"trivial_types":22,"type_definitions":10,"typedef_density":0.0038610039,"var_ann_density":0.0023166023,"variable_declarations":6},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/* eslint-disable @typescript-eslint/no-empty-function, max-classes-per-file, no-param-reassign */\nconst alwaysFn = (C: Function) => (args: any, thisArgs?: any) => (args as any).call(thisArgs);\nconst createFunctionConstructor = (C: Function) => new C();\nconst createFunctionConstructorFrom = (C: Functio): (args: any, thisArgs?: any) => (args as any).call(thisArgs);\nconst createFunctionConstructorFromConstructor = (C: Function) => (...args: any, thisArgs?: any) => (args as an => {\n    // Search up the prototype chain until we hit base. The base class of Class has no name I guess.\n    const classHierarchy = [];\n    for (let curr = C; curr.name; curr = Object.getPrototypeOf(curr)) {\n        classHierarchy.push(curr);\n    }\n    // Get all static methods defined on any ancestor\n    const statics = classHierarchy\n        .map((klass: any) => Object.getOwnPropertyNames(klass))\n       .reduce((a, b) => [...a,...b], []) // flatten\n       .filter((n) => typeof C[n] === \"function\")\n       .reduce((acc, nam): (acc, name) => {\n        acc[name] = C[name];\n        return acc;\n    }, {});\n    return Object.assign(\n    // eslint-disable-next-line func-names\n    function () {\n        return new => Object.getOwnPropertyNames(klass))\n        .reduce((a: any, b: any) => [...a, b], []) // flatten\n       .filter((n) => typeof C[n] === \"function\")\n       .reduce((acc, name) => {\n        acc[name] = C[nam, b: any];\n        return acc;\n    }, {});\n};\nconst createFunctionConstructorWithConstructor = (C: Function) => (...args: any, thisArgs?: any) => (args as any).call(thisArgs);\nconst createFunctio): (args: any, thisArgs?: any) => (args as any).call(thisArgs);\nconst createFunctioConstructor = (C: Function) => new C();\nconst createFunctionConstructorWithContext = (C: Functio => [...a, ...b], []) // flatten\n        .filter((n: string) => typeof C[n] === \"function\")\n       .reduce((acc, name) => {\n        acc[name] = C[name];\n        return acc;\n    }, {});\nconst createFunctionConstructorWithContext2 = (): (a: any, b: any) => (a as any).call(b);\nconst createFunctionConstructorWithContext3 = (): (...a: any, b: any) => (a as any).call(b);\ncons => typeof C[n] === \"function\")\n        .reduce((acc: any, name: string) => {\n        acc[name] = C[n];\n        return acc;\n    }, {});\nconst createFunctionConstructorWithContext4 = (C: Functio => [...a,...b], []) // flatte, name: string\n       .filter((n: string) => typeof C[n] === \"function\")\n      .reduce((acc: any, name: string) => {\n        acc[name] = C[name];\n        return acc;\n    }, {})): (a: any, b: any) => (a as any).call(b);\nconst createFunctionConstructorWithContext5 = (C: Function, args?: any) => (...args: any, thisArgs?: any) => => {\n        acc[name] = C[name];\n        return acc;\n    }, {});\n    return Object.assign(\n    // eslint-disable-next-line func-names\n    function (): Function {\n        const C = typeof C === \"function\"? C : (a: any, b: any) => C[n];\n        return new C();\n    }, C, {\n    constructor: createFunctionConstructorWithContext4,\n    appl {\n        return new C();\n    }, C, statics);\n};\n// Add canvas mock based on this comment: https://github.com/jsdom/jsdom/issues/1782#issuecomment-337656878\nfunction mockCanvas(window: any, canvas?: any) {\n    if (!window.HTMLCanvasElement) {\n        return;\n    }\n    const context = canvas? canvas.getContext(\"2d\") : window.document.createElement(\"canvas\").getContext(\"2d\");): window.document.createElement(\"canvas\").getContext(\"2d\");\n    const mockCanvas: HTMLCanvasElement = {\n        getContext: () => context,\n    };\n    if (!context.save) {\n        mockCanvas.save = () => context {\n    window.HTMLCanvasElement.prototype.getContext = (): any => context;\n};\n    }\n    return mockCanvas;\n}\n\nconst mockCanvas1 = mockCanvas(window);\nconst mockCanvas2 = mockCanvas(window, {\n    width: 200,\n    height => ({\n        fillRect: (): any => context,\n    }),\n});\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\nconst mockCanvas3 = mockCanvas => ({}),\n        clearRect: (): any => mockCanvas.clearRect(0, 0, 200, 200);\nconst mockCanvas4 = mockCanvas3(mockCanvas2);\n\nconst mockCanvas5 = mockCanvas3(mockCanvas => ({}),\n        getImageData: (_x: number, _y: number, _w: number, _h: number) => ({ data: new Array(200 * 200 * 4) }),\n        putImageData: () => ({}),\n        createImageData: (, _y: number, _w: number, _h: number) => ({ data: new Array(200 * 200 * 4) }),\n        putImageData: () => ({}),\n        createImageData: () => [],\n        setTransfor, w: 200, h: 200,\n);\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\nconst mockCanva, h: number, w: number, canvas: CanvasRenderingContext2D, context: CanvasRenderingContext2D, mockCanvas6 = mockCanvas3(mockCanvas2);\n\ndescribe(\"Canvas\", () => {\n\n    it(\"should create a ne): 2d\", () => {\n        expect(mockCanvas1).toBeTruthy();\n    });\n\n    it(\"should create a ne): 3d\", () => {\n        expect(mockCanvas2).toBeTruthy();\n    });\n\n    it(\"should create a n => ({ data: new Array(w * h * 4) }),\n        putImageData: (): any => ({ data: new Array(w * h * 4) }),\n        createImageData: (): any => ({ data: new Array(w * h * 4) }),\n        getContext: (): any => ({ data: new Array( => ({}),\n        createImageData: (): any => ({ data: new Array(w * h * 4) }),\n        getContext: (): any => ({ data: new Array( => ({}),\n        createImageData: (): any => ({ data: new Array(w * h * => [],\n        setTransform: (): any => ({}),\n        createImageData: (): any => ({ data: new Array(w * h * 4) }),\n        setTransform: (): any => ({ data: new Array(w * h * 4) }),\n        drawImage => ({}),\n        drawImage: (): any => ({}),\n        drawImage: (): any => ({}),\n        getImageData: (): any => ({ data: new Array(200 * 200 * 4) }),\n        putImageData: (): any => ({ data: ne => ({}),\n        save: (): any => ({}),\n        createImageData: (): any => ({ data: new Array(w * h * 4) }),\n        getContext: (): any => ({ data: new Array( => ({}),\n        createImageData: (): any => ({ data => ({}),\n        fillText: (): any => ({}),\n        getBoundingClientRect: (): any => ({ top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 }),\n        getContext: (): any => ( => ({}),\n        restore: (): any => ({}),\n        beginPath: (): any => ({}),\n        moveTo: (): any => ({}),\n        lineTo: (): any => ({}),\n        closePath: (): any => ({}),\n        stroke: (): any => ({}),\n        translate => ({}),\n        beginPath: (): any => ({}),\n        moveTo: (): any => ({}),\n        lineTo: (): any => ({}),\n        closePath: (): any => ({}),\n        stroke: (): any => ({}),\n        translate: (): any => ({}),\n        scale: () => ({}),\n        moveTo: (): any => ({}),\n        scale: () => ({}),\n        rotate: () => ({}),\n        transform: () => ({}),\n        translate: () => ({}),\n        scale: () => ({}),\n        rotate: () => ({}),\n        arc: ( => ({}),\n        lineTo: (): any => ({}),\n        closePath: () => ({}),\n        fill: () => ({}),\n        stroke: () => ({}),\n        rotate: () => ({}),\n        transform: () => ({}),\n        moveTo: () => ({}),\n        lineT => ({}),\n        closePath: (): any => ({}),\n        beginPath: () => ({}),\n        lineTo: () => ({}),\n        closePath: () => ({}),\n        fill: () => ({}),\n        stroke: () => ({}),\n        rotate: () => ({}), => ({}),\n        stroke: (): any => ({}),\n        lineTo: (): any => ({}),\n        closePath: (): any => ({}),\n        beginPath: (): any => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        moveTo: () = => ({}),\n        translate: (): any => ({}),\n        scale: () => ({}),\n        closePath: () => ({}),\n        fill: () => ({}),\n        stroke: () => ({}),\n        rotate: () => ({}),\n        transform: () => ({}),\n        moveTo => ({}),\n        scale: (): any => ({}),\n        scale: () => ({}),\n        rotate: () => ({}),\n        transform: () => ({}),\n        scale: () => ({}),\n        closePath: () => ({}),\n        fill: () => ({}),\n        stroke => ({}),\n        rotate: (): any => ({}),\n        transform: () => ({}),\n        translate: () => ({}),\n        scale: () => ({}),\n        rotate: () => ({}),\n        closePath: () => ({}),\n        beginPath: () => ({}),\n        moveT => ({}),\n        arc: (): any => ({}),\n        moveTo: () => ({}),\n        closePath: () => ({}),\n        fill: () => ({}),\n        stroke: () => ({}),\n        rotate: () => ({}),\n        transform: () => ({}),\n        moveTo => ({}),\n        fill: (): any => ({}),\n        stroke: () => ({}),\n        rotate: () => ({}),\n        transform: () => ({}),\n        moveTo => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        closePath: () = => ({}),\n        measureText: (): any => ({}),\n        beginPath: () => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        closePath: () => ({}),\n        lineTo: () => ({}), => ({ width: 0 }),\n        transform: (): any => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        closePath => ({}),\n        rect: (): any => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        closePath: () => ({}),\n        stroke: () => ({}),\n        moveTo: () => ({}),\n        moveTo: () => ({}),\n        closePat => ({}),\n        clip: (): any => ({}),\n        moveTo: () => ({}),\n        closePath: () => ({}),\n        closePath: () => ({}),\n        moveTo: () => ({}),\n        closePath: () => ({}),\n        closePath: () => ({}) => ({}),\n    });\n    window.HTMLCanvasElement.prototype.toDataURL = (): any => \"\";\n}\nfunction mockCanvas(window) {\n    if (!window.CanvasRenderingContext2D) {\n        class CanvasRenderingContext2DMock {\n            constructor() {\n                super();\n            }\n            toDataURL() {\n                retur => \"\";\n}\nfunction mockIntl(window: any) {\n    if (!window.Intl) {\n        class IntlMock {\n            constructor(options?: any) {\n                super();\n            }\n            resolvedOptions() {\n                return {};\n            }\n            format(format: string) {\n                return \"\"): any => \"\";\n            }\n        }\n        window.Intl = IntlMock;\n    }\n    window.Intl.supportedLocalesOf = (): string[] => [];\n}\nfunction mockWindow(window: any) {\n    if (!window.CanvasRenderin {\n    if (!window.Intl) {\n        class IntlMock {\n            static supportedLocalesOf(): string[] {\n                return [];\n            }\n            constructor(options?: any) {\n                super();\n            }\n            resolvedOptions() {\n                return {};\n            }\n            format(format: string) {\n                return \"\";\n            }\n            formatToParts() {\n                return [];\n            }\n            resolvedOptions(): any {\n                return {};\n            }\n        }\n        window.Intl = IntlMock;\n    }\n    window.Intl.supportedLocalesOf = (): string[] => [];\n}\nfunction mockCanvasRenderingContext2D(window: any) { {\n                return {};\n            }\n        }\n        class IntlFormatMock extends IntlMock {\n            format(): any {\n                return \"\";\n            }\n            constructor(options?: any) {\n                super(options);\n            }\n            format(): any {\n                return \"\";\n            }\n            resolvedOptions() {\n                return {};\n            }\n            compare(a: any, {\n                return \"\";\n            }\n            formatToParts(): any {\n                return [];\n            }\n        }\n        window.Intl = IntlFormatMock;\n    }\n    window.Intl.supportedLocalesOf = (): string[] => [];\n}\nfunction mockWebAnimations() {\n    if (!window.WebAnimation {\n                return [];\n            }\n        }\n        class IntlCollatorMock extends IntlMock {\n            compare(): any {\n                return 0;\n            }\n        }\n        Object.defineProperty(window, \"Intl\", 0);\n        window.Intl.supportedLocalesOf = (): string[] => [];\n    }\n    window.Intl.supportedLocalesOf = () {\n                return 0;\n            }\n        }\n        class IntlPluralRulesMock extends IntlMock {\n            select(): any {\n                return \"\";\n            }\n        }\n        class IntlNumberFormatMock extends IntlMock {\n            constructor(options?: any) {\n                super(options);\n            }\n            format(): any {\n                return \"\";\n            }\n            resolvedOptions() {\n                retur {\n                return \"\";\n            }\n        }\n        class IntlDateTimeFormatMock extends IntlFormatMock {\n        }\n        class IntlNumberFormatMock extends IntlFormatMock {\n        }\n        class IntlListFormatMock extends IntlFormatMock {\n        }\n        class IntlRelativeTimeFormatMock extends IntlFormatMock {\n        }\n        Object.defineProperty(window, \"Intl\", {\n            value: {\n                Collator: alwaysFn(IntlCollatorMock),\n                DateTimeFormat: alwaysFn(IntlDateTimeFormatMock),\n                ListFormat: alwaysFn(IntlListFormatMock),\n                NumberFormat: alwaysFn(IntlNumberFormatMock),\n                PluralRules: alwaysFn(IntlPluralRulesMock),\n                RelativeTimeFormat: alwaysFn(IntlRelativeTimeFormatMock),\n            },\n            writable: true,\n        });\n    }\n}\nfunction mockMatchMedia(window: any, mediaQuery: string) {\n    if (!window.matchMedia) {\n        Object.defineProperty(window, \"matchMedia\", {\n            value: () => ({\n                matches: false,\n                addListener: () => { },\n                remov): { removeListener: () => { }, },\n            }),\n            writable: true,\n        });\n    }\n}\nfunction mockNavigator(window) {\n    if (!window.navigator) {\n        Object.defineProperty(window, \"navigator\", { {\n    if (!window.matchMedia) {\n        Object.defineProperty(window, \"matchMedia\", {\n            value: (): any => ({\n                matches: true,\n                addListener: () => { },\n                removeListener: () => { },\n            }),\n            writable: true,\n        });\n    }\n}\n}\nfunction mockHistory(window) {\n    if ( => ({\n                matches: true,\n                addListener: (): { },\n                removeListener: () => { },\n            }),\n            writable: true,\n        });\n}\nfunction mockHistoryPushState(window) {\n    if (!window.history) {\n        Object.defineProperty(window, \"history\", => { },\n                removeListener: (): () => { },\n            });\n}\nfunction mockHistoryReplaceState(window) {\n    if (!window.history) {\n        Object.defineProperty(window, \"history\", { },\n                removeListener: () => { },\n            }); => { },\n            }),\n            writable: true,\n        });\n    }\n}\nfunction mockLocalStorage(window: any, key: string) {\n    if (!window.localStorage) {\n        class LocalStorageMock {\n            store;\n            constructor() {\n                this.store = {};\n            }\n            getItem(key) {\n                return this.store[key]): {};\n            }\n            removeItem(key) {\n                delete this.store[key];\n            }\n            setItem(key, value) {\n                this.store[key] = value.toString();\n            }\n            clear() {\n                this {\n    if (!window.localStorage) {\n        class LocalStorageMock {\n            store: any;\n            constructor() {\n                this.store = {};\n            }\n            getItem(key) {\n                return this.store[key];\n            }\n            removeItem(key) {\n                delete this.store[key];\n            }\n            setItem;\n            constructor() {\n                this.store = {};\n            }\n            getItem(key: any, value: any) {\n                return this.store[key];\n            }\n            removeItem(key) {\n                delete this.store[key];\n            }\n            setItem(key: any, value: any) {\n                this.stor): any;\n            }\n            clear() {\n                this.store = {};\n            }\n        }\n        Object.defineProperty(window, \"localStorage\", {\n            value: new LocalStorageMock(),\n            writable: true,\n        });\n    }\n} {\n                return this.store[key];\n            }\n            removeItem(key: any) {\n                delete this.store[key];\n            }\n            setItem(key: any, value: any) {\n                this.store[key] = value.toString();\n            }\n            clear() {\n                this.store = {};): any {\n            }\n        }\n        Object.defineProperty(window, \"localStorage\", {\n            value: new LocalStorageMock(),\n            writable: true,\n        });\n    }\n}\nfunction mockWebStorage(window) {\n    if (!window {\n                delete this.store[key];\n            }\n            setItem(key: any, value: any) {\n                this.store[key] = value.toString();\n            }\n            clear() {\n                this.store = {};\n            }\n        }\n        Object.defineProperty(window, \"localStorage\", {\n            value: ne, value: new LocalStorageMock(),\n            writable: true,\n        });\n    }\n}\nfunction mockWebStorageSync(window) {\n    if (!window.localStorage) {\n        class LocalStorageSyncMock {\n            constructor() {\n                this.store): any;\n            }\n            getItem(key: any) {\n                return this.store[key];\n            }\n            setItem(key: any, value: any) {\n                this.store[key] = value.toString();\n            }\n            remov {\n                this.store[key] = value.toString();\n            }\n            clear(): any {\n            }\n        }\n        Object.defineProperty(window, \"localStorage\", {\n            value: new LocalStorageSyncMock(),\n            writable: true,\n        });\n    }\n}\nfunction mockWebStorageAsync(window) {\n    if ( {\n                this.store = {};\n            }\n        }\n        Object.defineProperty(window, \"localStorage\", {\n            value: new LocalStorageMock(),\n            writable: true,\n        });\n    }\n}\nfunction mockWebWorker(window: any) {\n    if (!window.Worker) {\n        class WorkerMock {\n            addEventListener() { }\n            removeEventLister() { }\n            postMessage() { }\n            terminate() { }\n        }\n        Object.defineProperty(window): any;\n    }\n}\nfunction mockWebWorkerConstructor(window: any) {\n    if (!window.Worker) {\n        class WorkerMock {\n            addEventListener() { }\n            removeEventLister() { }\n            postMessage() {\n    if (!window.Worker) {\n        class WorkerMock {\n            addEventListener(): any;\n            removeEventLister() { }\n            postMessage() { }\n            terminate() { }\n        }\n        Object.defineProperty(window, \"Worker\", {\n            value: WorkerMock,\n            writable: true,\n        });\n    } { }\n            removeEventLister(): any;\n            terminate() { }\n        }\n        Object.defineProperty(window, \"Worker\", {\n            value: WorkerMock,\n            writable: true,\n        });\n    }\n}\nfunction mockWebWorkerSync(window) {\n    if ( { }\n            postMessage(): any {\n            terminate(): any { }\n        }\n        Object.defineProperty(window, \"Worker\", {\n            value: class WorkerSyncMock {\n                addEventListener() { }\n                removeEventLister() { }\n                postMessage() { } { }\n            terminate(): any { }\n        }\n        Object.defineProperty(window, \"Worker\", {\n            value: class WorkerSyncMock {\n                addEventListener() { }\n                removeEventLister() { }\n                postMessage() { } { }\n            terminate(): an { }\n        }\n        Object.defineProperty(window, \"Worker\", {\n            value: WorkerMock,\n            writable: true,\n        });\n    }\n}\nfunction mockCrypto(window: any) {\n    if (window.crypto) {\n        Object.defineProperty(window, \"crypto\", {\n            value: {\n               getRandomValues: (arr) => arr.fill(0),\n            },\n            writable: true,\n        });): any {\n            if (!window.crypto.subtle) {\n                window.crypto.subtle = {\n                    encrypt(data, key) {\n                        return new Promise<ArrayBuffer>;\n                    },\n                    decrypt(data, key) {\n                        return ne {\n    if (!window.crypto) {\n        Object.defineProperty(window, \"crypto\", {\n            value: {\n                getRandomValues: (arr: ArrayBuffer[]) => arr.fill(0),\n            },\n            writable: true,\n        });\n    }\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}): any {\n    if (window.fetch) {\n        Object.defineProperty(window, \"fetch\", {\n            value: () => new Promise((_res, _rej) => {\n                if (window.fetch) {\n                    if (window => arr.fill(0),\n            },\n            writable: true,\n        });\n    }\n}\nfunction mockMimeTypes(window: any) {\n    if (!window.navigator.mimeTypes) {\n        Object.defineProperty(window.navigator, \"mimeTypes\", {\n            value: [],\n            writable: true,\n        });\n    }\n}\n}\nfunction mockStorage): any {\n    if (!window.localStorage) {\n        Object.defineProperty(window, \"localStorage\", {\n            value: {\n               setItem(key, value) {\n                    if (key === \"key\") {\n                        if (!window.localStorage) {\n    if (!window.navigator.mimeTypes) {\n        Object.defineProperty(window.navigator, \"mimeTypes\", {\n            value: (): any => [],\n            writable: true,\n        });\n    }\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n} => [],\n            writable: true,\n        });\n    }\n}\nfunction mockFetch(window: any) {\n    if (!window.fetch) {\n        Object.defineProperty(window, \"fetch\", {\n            value: () => new Promise((_res, _rej) => {\n                if (window.fetch) {\n                    if (windo): any {\n                        if (window => arr.fill(0),\n            }\n            }),\n            writable: true,\n        });\n    }\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n} {\n    // issue: https://github.com/chromaui/chromatic-cli/issues/14\n    Object.defineProperty(window, \"fetch\", {\n        value: (): any => new Promise((_res, _rej) => {\n            if (window.fetch) {\n                if (window => arr.fill(0),\n            }\n            }),\n        writable: true,\n    });\n}\n}\nfunction moc => new Promise((_res: () => void, _rej: () => void) => {\n    if (moc.window) {\n        return mockFetch(moc.window);\n    } else {\n        return new Promise((_res, _rej) => {, _rej: () => {}, _res: () => {}, window: moc.window});\n    }\n});\n}\nfunction mockBlob(window: any, data: any) {\n    if (!window.Blob) {\n        Object.definePropert): any;\n    }\n}\nfunction mockResponse(window: any, res: any, status?: number) {\n    if (!window.Response) {\n        Object.defineProperty(window.Response, \"prototype\", {\n            value: { => {\n            // we just let this never resolve\n        }),\n        writable: true,\n    });\n}\nfunction mockObjectURL(window: any, url: string, callback?: () => void) {\n    if (!window.URL) {\n        Object.defineProperty(window.URL, \"createObjectURL\", { value: () => { }, writable: true });\n    }\n    if (): any {\n        return mockBlob(window, data);\n    } else {\n        return new Promise((_res, _rej) => {\n            if (callback) {\n                callback();\n            }\n            }),\n        };\n    }\n}\nfunction moc {\n    if (!window.URL.createObjectURL) {\n        Object.defineProperty(window.URL, \"createObjectURL\", { value: (): any => { }, writable: true });\n    }\n    if (!window.Blob) {\n        Object.defineProperty(window.Blob, \"prototype\", {\n            value: { => {\n            // we just let this never resolve\n        }),\n        writable => { }, writable: true });\n    }\n    if (!window.URL.revokeObjectURL) {\n        Object.defineProperty(window.URL, \"revokeObjectURL\", { value: (): any => { }, writable: true });\n    }\n    if (!window.URL.createObjectURL) {\n        Object.defineProperty(window.URL, \"createObjectURL\", { value: () => { }, writable: true });\n    }\n    if ( => { }, writable: true });\n    }\n}\nfunction mockMutationObserver(window: any, callback?: () => void) {\n    if (!window.MutationObserver) {\n        Object.defineProperty(window.MutationObserver.prototype, \"observe\", {\n            value: () => {\n                if (callback) {\n                    callback();): any { }, writable: true };\n            },\n            writable: true,\n        });\n    }\n}\nfunction mockSetInterval(window: any, callback?: () => void) {\n    if (!window.setTimeout) {\n        Object.defineProperty {\n    if (!window.MutationObserver) {\n        // We have to do this in this screwy way because Angular does some monkey patching\n        // expects an non-es2015 class here.\n        // eslint-disable-next-line no-inner-declarations\n        // @ts-ignore\n        function MutationObserverMock(): any { }\n        MutationObserverMock.prototype = {\n            observe() {\n                return [];\n            },\n            takeRecords() {\n                return [];\n            },\n            disconnect() { },\n        };\n        Object.defineProperty(window, \"MutationObserver\", { { }\n        MutationObserverMock.prototype = {\n            observe(): any { },\n            takeRecords(): any { },\n            disconnect() { },\n        };\n        Object.defineProperty(window, \"MutationObserver\", {\n            value: MutationObserverMock,\n            writable: true,\n        });\n    }\n}\n} {\n                return [];\n            },\n            takeRecords(): any { },\n            disconnect() { },\n        };\n        Object.defineProperty(window, \"MutationObserver\", {\n            value: MutationObserverMock,\n            writable: true,\n        });\n    }\n}\nfunction mockSetTimeout(window: any {\n                return [];\n            },\n            disconnect(): any { },\n        ) {\n    if (!window.setTimeout) {\n        Object.defineProperty {\n    if (!window.MutationObserver) {\n        // We have to do this in this screwy way because Angular does some monkey patching { },\n        };\n        Object.defineProperty(window, \"MutationObserver\", {\n            value: MutationObserverMock,\n            writable: true,\n        });\n    }\n}\nfunction mockSVG(window: any {\n                return [];\n            },\n            disconnect(): any { },\n        ) {\n    if (!window.SVGSVGElement) {\n        Object.defineProperty {\n    if (!window.MutationObserver) {\n        // We have to do this in this s): monkey patching { },\n        };\n        Object.defineProperty(window, \"MutationObserver\", {\n            value: MutationObserverMock,\n            writable: true,\n        });\n    }\n}\nfunction mockURL(window: any {\n                return []; {\n    // issue: https://github.com/chromaui/chromatic-cli/issues/27\n    // solution found here: https://github.com/facebook/jest/issues/5379#issuecomment-360044161\n    // not incuded in jsdom yet: https://github.com/jsdom/jsdom/issues/2128\n    const svgElements = [\n        \"SVGAElement\",\n        \"SVGAltGlyphElement\",\n        \"SVGAngle\",\n        \"SVGAnimateColorElement\",\n        \"SVGAnimateElement\",\n        \"SVGAnimateMotionElement\",\n        \"SVGAnimateTransformElement\",\n        \"SVGAnimatedAngle\",\n        \"SVGAnimatedBoolean\",\n        \"SVGAnimatedEnumeration\",\n        \"SVGAnimatedInteger\",\n        \"SVGAnimatedLength\",\n        \"SVGAnimatedLengthList\",\n        \"SVGAnimatedNumber\",\n        \"SVGAnimatedNumberList\",\n        \"SVGAnimatedPoints\",\n        \"SVGAnimatedPreserveAspectRatio\",\n        \"SVGAnimatedRect\",\n        \"SVGAnimatedString\",\n        \"SVGAnimatedTransformList\",\n        \"SVGAnimationElement\",\n        \"SVGCircleElement\",\n        \"SVGClipPathElement\",\n        \"SVGComponentTransferFunctionElement\",\n        \"SVGCursorElement\",\n        \"SVGDefsElement\",\n        \"SVGDescElement\",\n        \"SVGDocument\",\n        \"SVGElement\",\n        \"SVGEllipseElement\",\n        \"SVGFEBlendElement\",\n        \"SVGFEColorMatrixElement\",\n        \"SVGFEComponentTransferElement\",\n        \"SVGFECompositeElement\",\n        \"SVGFEConvolveMatrixElement\",\n        \"SVGFEDiffuseLightingElement\",\n        \"SVGFEDisplacementMapElement\",\n        \"SVGFEDistantLightElement\",\n        \"SVGFEDropShadowElement\",\n        \"SVGFEFloodElement\",\n        \"SVGFEFuncAElement\",\n        \"SVGFEFuncBElement\",\n        \"SVGFEFuncGElement\",\n        \"SVGFEFuncRElement\",\n        \"SVGFEGaussianBlurElement\",\n        \"SVGFEImageElement\",\n        \"SVGFEMergeElement\",\n        \"SVGFEMergeNodeElement\",\n        \"SVGFEMorphologyElement\",\n        \"SVGFEOffsetElement\",\n        \"SVGFEPointLightElement\",\n        \"SVGFESpecularLightingElement\",\n        \"SVGFESpotLightElement\",\n        \"SVGFETileElement\",\n        \"SVGFETurbulenceElement\",\n        \"SVGFilterElement\",\n        \"SVGFilterPrimitiveStandardAttributes\",\n        \"SVGFontElement\",\n        \"SVGFontFaceElement\",\n        \"SVGFontFaceFormatElement\",\n        \"SVGFontFaceNameElement\",\n        \"SVGFontFaceSrcElement\",\n        \"SVGFontFaceUriElement\",\n        \"SVGForeignObjectElement\",\n        \"SVGGElement\",\n        \"SVGGlyphElement\",\n        \"SVGGradientElement\",\n        \"SVGGraphicsElement\",\n        \"SVGHKernElement\",\n        \"SVGImageElement\",\n        \"SVGLength\",\n        \"SVGLengthList\",\n        \"SVGLineElement\",\n        \"SVGLinearGradientElement\",\n        \"SVGMPathElement\",\n        \"SVGMaskElement\",\n        \"SVGMatrix\",\n        \"SVGMetadataElement\",\n        \"SVGMissingGlyphElement\",\n        \"SVGNumber\",\n        \"SVGNumberList\",\n        \"SVGPathElement\",\n        \"SVGPatternElement\",\n        \"SVGPoint\",\n        \"SVGPolylineElement\",\n        \"SVGPreserveAspectRatio\",\n        \"SVGRadialGradientElement\",\n        \"SVGRect\",\n        \"SVGRectElement\",\n        \"SVGSVGElement\",\n        \"SVGScriptElement\",\n        \"SVGSetElement\",\n        \"SVGStopElement\",\n        \"SVGStringList\",\n        \"SVGStylable\",\n        \"SVGStyleElement\",\n        \"SVGSwitchElement\",\n        \"SVGSymbolElement\",\n        \"SVGTRefElement\",\n        \"SVGTSpanElement\",\n        \"SVGTests\",\n        \"SVGTextContentElement\",\n        \"SVGTextElement\",\n        \"SVGTextPathElement\",\n        \"SVGTextPositioningElement\",\n        \"SVGTitleElement\",\n        \"SVGTransform\",\n        \"SVGTransformList\",\n        \"SVGTransformable\",\n        \"SVGURIReference\",\n        \"SVGUnitTypes\",\n        \"SVGUseElement\",\n        \"SVGVKernElement\",\n        \"SVGViewElement\",\n        \"SVGZoomAndPan\",\n    ];\n    svgElements.forEach((e: string) => {\n        if (!window[e]) {\n            // eslint-disable-next-line no-eval\n            const Value = eval(`(class ${e} extends window.HTMLElement {})`);\n            Object.defineProperty(window, e): any;\n        }\n    });\n}\nfunction mockObjectURL(window: Window) {\n    Object.defineProperty(window, \"URL\", {\n        value: window.URL || window.webkitURL,\n        writable: true,\n    }); => {\n        if (!window[e]) {\n            // eslint-disable-next-line no-eval\n            const Value = eval(`(class ${e} extends window.HTMLElement {})`);\n            Object.defineProperty(window, e, {\n                value: Value,\n                writable: true,\n            });\n        }\n    });\n}\nexport function addShimsToJSDOM(window: Window): void {\n    if (!window.fetch) {\n        mockFetch(window);\n    }\n    if (!window.navigator.mediaDevices) {\n        mockMediaDevices(window);\n    }\n    if (!window.navigator.permissions) {\n        moc {\n    mockSVG(window);\n    mockMutationObserver(window);\n    mockObjectURL(window);\n    mockFetch(window);\n    mockMimeTypes(window);\n    mockCrypto(window);\n    mockWebWorker(window);\n    mockLocalStorage(window);\n    mockMatchMedia(window);\n    mockIntl(window);\n    mockCanvas(window);\n}\n","score":448,"fallbacked":false,"num_type_errors":776}]}
{"dataset_elem":{"alphanum_fraction":0.6676122931,"avg_line_length":26.7721518987,"content":"export class OntologyDiscipline {\n\n  constructor(\n    public id: string,\n    public label: string,\n    public delivered: string,\n    public implemented: string,\n    public maturity: string,\n    public source: string,\n    public className: string,\n    public validator: string,\n    public validated: string,\n    public uri: string,\n    public icon: string\n  ) { }\n\n  public static Create(jsonData: any): OntologyDiscipline {\n    const result: OntologyDiscipline = new OntologyDiscipline(\n      jsonData[OntologyParameterAttributes.ID],\n      jsonData[OntologyParameterAttributes.LABEL],\n      jsonData[OntologyParameterAttributes.DELIVERED],\n      jsonData[OntologyParameterAttributes.IMPLEMENTED],\n      jsonData[OntologyParameterAttributes.MATURITY],\n      jsonData[OntologyParameterAttributes.SOURCE],\n      jsonData[OntologyParameterAttributes.CLASSNAME],\n      jsonData[OntologyParameterAttributes.VALIDATOR],\n      jsonData[OntologyParameterAttributes.VALIDATED],\n      jsonData[OntologyParameterAttributes.URI],\n      jsonData[OntologyParameterAttributes.ICON]);\n\n    return result;\n  }\n\n  public static getKeyLabel(key: string): string {\n    const keyLabelDict = {\n      id: 'ID',\n      delivered: 'Delivered',\n      implemented: 'Implemented',\n      label: 'Discipline Name',\n      maturity: 'Maturity',\n      source: 'Source',\n      className: 'Discipline Class Name',\n      uri: 'Ontology URI',\n      validator: 'Validator',\n      validated: 'Validated'\n    };\n\n    if (key in keyLabelDict) {\n      return keyLabelDict[key];\n    } else {\n      return key;\n    }\n  }\n\n  public toString = (): string => {\n    const strings: string[] = [];\n    if (this.id !== null && this.id !== undefined) {\n      strings.push(`${this.id}`);\n    }\n\n    // TO BE IMPLEMENTED IF NEEDED\n    return strings.join('\\n');\n  }\n}\n\nexport enum OntologyParameterAttributes {\n  ID = 'id',\n  DELIVERED = 'delivered',\n  IMPLEMENTED = 'implemented',\n  LABEL = 'label',\n  MATURITY = 'modelType',\n  SOURCE = 'originSource',\n  CLASSNAME = 'pythonClass',\n  URI = 'uri',\n  VALIDATOR = 'validator',\n  VALIDATED = 'validated',\n  ICON = 'icon'\n}\n","content_without_annotations":"export class OntologyDiscipline {\n\n  constructor(\n    public id,\n    public label,\n    public delivered,\n    public implemented,\n    public maturity,\n    public source,\n    public className,\n    public validator,\n    public validated,\n    public uri,\n    public icon\n  ) { }\n\n  public static Create(jsonData) {\n    const result = new OntologyDiscipline(\n      jsonData[OntologyParameterAttributes.ID],\n      jsonData[OntologyParameterAttributes.LABEL],\n      jsonData[OntologyParameterAttributes.DELIVERED],\n      jsonData[OntologyParameterAttributes.IMPLEMENTED],\n      jsonData[OntologyParameterAttributes.MATURITY],\n      jsonData[OntologyParameterAttributes.SOURCE],\n      jsonData[OntologyParameterAttributes.CLASSNAME],\n      jsonData[OntologyParameterAttributes.VALIDATOR],\n      jsonData[OntologyParameterAttributes.VALIDATED],\n      jsonData[OntologyParameterAttributes.URI],\n      jsonData[OntologyParameterAttributes.ICON]);\n\n    return result;\n  }\n\n  public static getKeyLabel(key) {\n    const keyLabelDict = {\n      id: 'ID',\n      delivered: 'Delivered',\n      implemented: 'Implemented',\n      label: 'Discipline Name',\n      maturity: 'Maturity',\n      source: 'Source',\n      className: 'Discipline Class Name',\n      uri: 'Ontology URI',\n      validator: 'Validator',\n      validated: 'Validated'\n    };\n\n    if (key in keyLabelDict) {\n      return keyLabelDict[key];\n    } else {\n      return key;\n    }\n  }\n\n  public toString = () => {\n    const strings = [];\n    if (this.id !== null && this.id !== undefined) {\n      strings.push(`${this.id}`);\n    }\n\n    // TO BE IMPLEMENTED IF NEEDED\n    return strings.join('\\n');\n  }\n}\n\nexport enum OntologyParameterAttributes {\n  ID = 'id',\n  DELIVERED = 'delivered',\n  IMPLEMENTED = 'implemented',\n  LABEL = 'label',\n  MATURITY = 'modelType',\n  SOURCE = 'originSource',\n  CLASSNAME = 'pythonClass',\n  URI = 'uri',\n  VALIDATOR = 'validator',\n  VALIDATED = 'validated',\n  ICON = 'icon'\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":494,"ext":"ts","fun_ann_density":0.0344129555,"function_parameters":13,"function_signatures":0,"function_usages":0,"functions":4,"hexsha":"6c720cf9896446d51c2fbf27c0bd5b96c8e2a900","lang":"TypeScript","loc":69,"loc_per_function":8.75,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"029dc7f13850997fb756991e98c2b6d4d837de51","max_forks_repo_licenses":["MIT","Apache-2.0","BSD-3-Clause"],"max_forks_repo_name":"os-climate/sostrades-webgui","max_forks_repo_path":"src/app/models/ontology-discipline.model.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"029dc7f13850997fb756991e98c2b6d4d837de51","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT","Apache-2.0","BSD-3-Clause"],"max_issues_repo_name":"os-climate/sostrades-webgui","max_issues_repo_path":"src/app/models/ontology-discipline.model.ts","max_line_length":62,"max_stars_count":1.0,"max_stars_repo_head_hexsha":"029dc7f13850997fb756991e98c2b6d4d837de51","max_stars_repo_licenses":["MIT","Apache-2.0","BSD-3-Clause"],"max_stars_repo_name":"os-climate/sostrades-webgui","max_stars_repo_path":"src/app/models/ontology-discipline.model.ts","max_stars_repo_stars_event_max_datetime":"2022-03-16T08:25:41.000Z","max_stars_repo_stars_event_min_datetime":"2022-03-16T08:25:41.000Z","metric":0.2720118883,"predefined_density":0.7142857143,"predefined_types":15,"prop_ann_density":0.0020242915,"property_declarations":1,"size":2115,"trivial_density":0.0476190476,"trivial_types":1,"type_definitions":1,"typedef_density":0.0020242915,"var_ann_density":0.0060728745,"variable_declarations":3},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export class OntologyDiscipline {\n    constructor(public id: number, public label: string, public delivered: boolean, public implemented: boolean, public maturity: string, public source: string, public className: string, public validator: string, public validated: boolean, public uri: string, public ico, public label: string, public delivered: boolean, public implemented: boolean, public maturity: string, public source: string, public className: string, public validator: string, public validated: boolean, public uri: string, public icon: string) {, public delivered: boolean, public implemented: boolean, public maturity: string, public source: string, public className: string, public validator: string, public validated: boolean, public uri: string, public ico, public label: string, public delivered, public implemented: boolean, public maturity: string, public source: string, public className: string, public validator: string, public validated: boolean, public uri: string, public icon: string) { }\n    }\n    public static Create(jsonData), public maturity: string, public source: string, public validator: string, public validated: boolean, public ico: string, public label: string, public delivered: boolean, public implemented: boolean, public icon: string) {\n        const result = new O, public source: string, public validator: string, public validated: boolean, public ico: string, public label: string, public delivered: boolean, public implemented: boolean, public icon: string;\n        if (jsonData.hasOwnProperty(OntologyParameterAttributes.I, public className: \"string\")) {\n            result.I = jsonData[OntologyParameterAttributes.I];\n        } else {\n            result.I = \"\";\n        }\n        if (jsonData.hasOwnProperty(OntologyParameterAttributes.L, public className: \"string\")) {, public validator: \"string\";\n            result.L = jsonData[OntologyParameterAttributes.L];\n        } else {\n            result.L = \"\";\n        }\n        if (jsonData.hasOwnProperty(OntologyParameterAttributes.VALIDATED, public className: \"boolean\")) {, public validated: \"boolean\";\n            result.VALIDATED = jsonData[OntologyParameterAttributes.VALIDATED];\n        } else {\n            result.VALIDATED = false;\n        }\n        if (jsonData.hasOwnProperty(OntologyParameterAttributes.URI, public className: \"strin, public uri: \")) {, public uri: \"string\";\n            result.URI = jsonData[OntologyParameterAttributes.URI];\n        } else {\n            result.URI = \"\";\n        }\n        if (jsonData.hasOwnProperty(OntologyParameterAttributes.ICON, public classNam, public icon: \"string\")) {, public icon: \"string\";\n            result.ICON = jsonData[OntologyParameterAttributes.ICON];\n        } else {\n            result.ICON = \"\";\n        }\n        if (jsonData.hasOwnProperty(OntologyParameterAttributes.SOURCE, publi) { }\n    public static Create(jsonData: any, public className: string, public validator: string, public validated: boolean, public ico: string, public label: string, public delivered: boolean, public implemented: boolean, public icon: string) {\n        const result = new O): OntologyParameter {\n            result.ID = \"\";\n            result.LABEL = \"\";\n            result.DELIVERED = false;\n            result.IMPLEMENTED = false;\n            result.MATURITY = \"\";\n            result.I = \"\";\n            result.L = \"\" {\n        const result = new OntologyDiscipline(jsonData[OntologyParameterAttributes.ID], jsonData[OntologyParameterAttributes.LABEL], jsonData[OntologyParameterAttributes.DELIVERED], jsonData[OntologyParameterAttributes.IMPLEMENTED], jsonData[OntologyParameterAttributes.MATURITY], jsonData[OntologyParameterAttributes.SOURCE], jsonData[OntologyParameterAttributes.CLASSNAME], jsonData[OntologyParameterAttributes.VALIDATOR], jsonData[OntologyParameterAttributes.VALIDATED], jsonData[OntologyParameterAttributes.URI], jsonData[OntologyParameterAttributes.ICON]);\n        return result;\n    }\n    public static getKeyLabel(key: string) {\n        const result: string = \"\";\n        if (key in keyLabelDict) {\n            result = keyLabelDict[key];\n        }\n        else {\n            console.warn(\"Parameter key not found in keyLabelDict!\");\n            retur): string {\n                return \"\";\n            }\n        }\n        return result;\n    }\n    public static fromJSON(jsonData: any): OntologyParameter {\n        const result: OntologyParameter = new O();\n        result.ID = jsonData[OntologyParameterAttribute {\n        const keyLabelDict = {\n            id: \"ID\",\n            delivered: \"Delivered\",\n            implemented: \"Implemented\",\n            label: \"Discipline Name\",\n            maturity: \"Maturity\",\n            source: \"Source\",\n            className: \"Discipline Class Name\",\n            uri: \"Ontology URI\",\n            validator: \"Validator\",\n            validated: \"Validated\"\n        };\n        if (key in keyLabelDict) {\n            return keyLabelDict[key];\n        }\n        else {\n            return key;\n        }\n    }\n    public toString: () => {\n        const strings = [];\n        if (this.id!== null && this.id!== undefined) {\n            strings.push(`${this.id}`);\n        }\n        if (this.label!== null && this.label!== undefined = (): string {\n            return `${this.label}`;\n        }\n        // TO BE IMPLEMENTED IF NEEDED\n        return strings.join(\"\\n\");\n    };\n}\nexport enum OntologyParameterAttribute {\n    ID = \"id\",\n    DEL => {\n        const strings = [];\n        if (this.id !== null && this.id !== undefined) {\n            strings.push(`${this.id}`);\n        }\n        // TO BE IMPLEMENTED IF NEEDED\n        return strings.join(\"\\n\");\n    };\n}\nexport enum OntologyParameterAttributes {\n    ID = \"id\",\n    DELIVERED = \"delivered\",\n    IMPLEMENTED = \"implemented\",\n    LABEL = \"label\",\n    MATURITY = \"modelType\",\n    SOURCE = \"originSource\",\n    CLASSNAME = \"pythonClass\",\n    URI = \"uri\",\n    VALIDATOR = \"validator\",\n    VALIDATED = \"validated\",\n    ICON = \"icon\"\n}\n","score":122,"fallbacked":false,"num_type_errors":272},{"code":"export class OntologyDiscipline {\n    constructor(public id: string, public label: string, public delivered: boolean, public implemented: boolean, public maturity: string, public source: string, public className: string, public validator: string, public validated: boolean, public uri: string, public ico, public label: string, public icon: string, public delivered_icon: string, public implemented_icon: string, public delivered_label: string, public implemented_label: string, public maturity_label: string, public validator_label: string, public delivered: boolean, public delivered_icon_hover: string, public implemented_icon_hover: string, public delivered_icon_hover_on_hover: string, public implemented_icon_hover_on_hover: string) { }\n    publi, public implemented: public delivered: public uri: public ico: public label: public icon: public delivered_icon: public delivered_icon_hover: public implemented_icon: public implemented_icon_hover: public delivered_icon_hover_on_hove, public maturity: public validator: public validated: public uri: public icon: public icon: public delivered_icon_hover: public icon_hover: public icon_hover_on_hover: public icon_hover_on_hover: public delivered_icon, public source: public validator_label: public validator_label: public validated_label: public icon_hover: public icon_hover_on_hover: public icon_hover_on_hover: public delivered_icon_hover: public delivered_icon, public className: public validator_label: public validator_label: public delivered_label: public icon_hover_on_hover: public icon_hover_on_hover: public delivered_label: public delivered_label: public delivered_label: public delivere, public validator: public ico: public icon_hover: public icon_hover_on_hover: public icon_hover_on_hover: public delivered_icon_hover: public delivered_icon_hover_on_hover: public delivered_icon, public validated: public delivered_icon_hover_on_hover: public delivered_icon_hover: public delivered_icon_hover: public delivered_icon_hover: public delivered_icon_hover: public delivered_icon_hover: public delivered_ico, public uri: public icon_hover: public icon_hover_on_hover: public delivered_ico_hover_on_hover: public delivered_ico_hover: public delivered_ico_hover: public delivered_ico_hover: public delivered_ic, public icon: public icon: public delivered_icon, public validator_label: public validator_label, public icon_hover: public icon_hover_on_hover, public icon_hover_on_hover: public delivered_ico_hover_on) { }\n    public static Create(jsonData: IOntologyDisciplineCreate, data: string, callback?: (result: IOntologyDiscipline) => void): IOntologyDisciplineCreateResponse {\n        if (!jsonData) {\n            throw new Error('OntologyDisciplineCreate is undefined.');): IOntologyDisciplineCreateResponse;\n        }\n\n        return new OntologyDisciplineCreateResponse(jsonData[OntologyParameterAttributes.ID], jsonData[OntologyParameterAttributes.LABEL], jsonData[OntologyParameterAttributes.DELIVERED], jsonData[OntologyParameterAttribute {\n        const result = new OntologyDiscipline(jsonData[OntologyParameterAttributes.ID], jsonData[OntologyParameterAttributes.LABEL], jsonData[OntologyParameterAttributes.DELIVERED], jsonData[OntologyParameterAttributes.IMPLEMENTED], jsonData[OntologyParameterAttributes.MATURITY], jsonData[OntologyParameterAttributes.SOURCE], jsonData[OntologyParameterAttributes.CLASSNAME], jsonData[OntologyParameterAttributes.VALIDATOR], jsonData[OntologyParameterAttributes.VALIDATED], jsonData[OntologyParameterAttributes.URI], jsonData[OntologyParameterAttributes.ICON]);\n        return result;\n    }\n    public static getKeyLabel(key: string): string {\n        if (!key) {\n            throw new Error(\"key is undefined.\");\n        }\n\n        const keyLabelDict = {\n            id: \"ID\",\n            delivered: \"Delivered\",\n            implemented: \"Implemented\",\n            label): \"Discipline Name\",\n            maturity: \"Maturity\",\n            source: \"Source\",\n            className: \"Discipline Class Name\",\n            uri: \"Ontology URI\",\n            validator: \"Validator\",\n            validated: \"Validated\"\n        }; {\n        const keyLabelDict = {\n            id: \"ID\",\n            delivered: \"Delivered\",\n            implemented: \"Implemented\",\n            label: \"Discipline Name\",\n            maturity: \"Maturity\",\n            source: \"Source\",\n            className: \"Discipline Class Name\",\n            uri: \"Ontology URI\",\n            validator: \"Validator\",\n            validated: \"Validated\"\n        };\n        if (key in keyLabelDict) {\n            return keyLabelDict[key];\n        }\n        else {\n            return key;\n        }\n    }\n    public toString: () => string {\n        const strings = [];\n        strings.push(`Ontology Parameter Id: ${this.id}`);\n        strings.push(`Ontology Parameter Type: ${this.disciplineType}`);\n        if (this.deliverability === null) = (): string => \"None\";\n        else if (this.deliverability === OntologyParameterDeliverability.DIRECTLY_IMPLEMENTED) {\n            strings.push(`Ontology Parameter Deliverability: Directly Implemented`);\n        } else if (this.deliverabilit => {\n        const strings = [];\n        if (this.id !== null && this.id !== undefined) {\n            strings.push(`${this.id}`);\n        }\n        // TO BE IMPLEMENTED IF NEEDED\n        return strings.join(\"\\n\");\n    };\n}\nexport enum OntologyParameterAttributes {\n    ID = \"id\",\n    DELIVERED = \"delivered\",\n    IMPLEMENTED = \"implemented\",\n    LABEL = \"label\",\n    MATURITY = \"modelType\",\n    SOURCE = \"originSource\",\n    CLASSNAME = \"pythonClass\",\n    URI = \"uri\",\n    VALIDATOR = \"validator\",\n    VALIDATED = \"validated\",\n    ICON = \"icon\"\n}\n","score":96,"fallbacked":false,"num_type_errors":273},{"code":"export class OntologyDiscipline {\n    constructor(public id: string, public label: string, public delivered: boolean, public implemented: boolean, public maturity: string, public source: string, public className: string, public validator: string, public validated: boolean, public uri: string, public ico, public label: string, public delivered: boolean, public implemented: boolean, public maturity: string, public source: string, public className: string, public validator: string, public validated: boolean, public uri: string, public ico: string, publi, public delivered: boolean, public implemented: boolean, public maturity: string, public source: string, public className: string, public validator: string, public validated: boolean, public uri: string, public icon: string) { }\n    public static Create, public implemented: boolean, public delivered: boolean, public maturity: string, public source: string, public ico: string, public className: string, public validator: string, public validated: boolean, public uri: string, publi: string, publi, public maturity: string, public icon: string, public label: string, public delivered: boolean, public source: string, public validator: string, public ico: string, public className: string) { }\n    public static Create(jsonData) {\n        cons, public source: string, public className: string;\n        const result = new OntologyDiscipline(jsonData[OntologyParameterAttributes.ID], jsonData[OntologyParameterAttributes.LABEL], jsonData[OntologyParameterAttributes.DELIVERED], jsonData[OntologyParameterAttributes.IMPLEMENTE, public className: \"OntologyDiscipline\"], jsonData[OntologyParameterAttributes.MATURITY], jsonData[OntologyParameterAttributes.ICO], jsonData[OntologyParameterAttributes.VALIDATOR], jsonData[OntologyParameterAttributes.VALIDATED], jsonData[OntologyParameterAttributes.URI], jsonDat, public validator: jsonData[OntologyParameterAttributes.ICON], jsonData[OntologyParameterAttributes.LABEL], jsonData[OntologyParameterAttributes.ICO], jsonData[OntologyParameterAttributes.DELIVERED]);\n        return result;\n    }\n}\n\nexport class OntologyDi, public validated: boolean, public ico: string, public className: string, public validator: string, public ico: string, public maturity: string, public delivered: boolean, public uri: string, public icon: string, public label: string, public uri: string, public ico: string, public validator: string, public className: string, public validated: boolean, public validator: string, public ico: string, public label: string, public maturity: string, public icon: string, public icon: string, public validator: string, public className: string, public delivered: boolean, public validator: string, public validator: string, public validator: string, public validator: string, public validator: string, public validator: string, public validator) { }\n    public static Create(jsonData: { [key: string]: any}, jsonDat?: any): OntologyDi {\n        const result = new OntologyDi(jsonData[OntologyParameterAttributes.ID], jsonData[OntologyParameterAttributes.LABEL], jsonData[OntologyParameterAttributes.DELIVE): OntologyDi(jsonData[OntologyParameterAttributes.ID], jsonData[OntologyParameterAttributes.LABEL], jsonData[OntologyParameterAttributes.DELIVE], jsonData[OntologyParameterAttributes.ICON], jsonData[OntologyParameterAttributes.MATURITY], jsonData[OntologyParameterAttribute {\n        const result = new OntologyDiscipline(jsonData[OntologyParameterAttributes.ID], jsonData[OntologyParameterAttributes.LABEL], jsonData[OntologyParameterAttributes.DELIVERED], jsonData[OntologyParameterAttributes.IMPLEMENTED], jsonData[OntologyParameterAttributes.MATURITY], jsonData[OntologyParameterAttributes.SOURCE], jsonData[OntologyParameterAttributes.CLASSNAME], jsonData[OntologyParameterAttributes.VALIDATOR], jsonData[OntologyParameterAttributes.VALIDATED], jsonData[OntologyParameterAttributes.URI], jsonData[OntologyParameterAttributes.ICON]);\n        return result;\n    }\n    public static getKeyLabel(key: string): string {\n        const keyLabelDict = {\n            id: \"ID\",\n            delivered: \"Delivered\",\n            implemented: \"Implemented\",\n            label: \"Discipline Name\",\n            maturity: \"Maturity\",\n            source:): \"Source\",\n            className: \"Discipline Class Name\",\n            uri: \"Ontology URI\",\n            validator: \"Validator\",\n            validated: \"Validated\"\n        };\n        if (key in keyLabelDict) {\n            return keyLabelDict[ke {\n        const keyLabelDict = {\n            id: \"ID\",\n            delivered: \"Delivered\",\n            implemented: \"Implemented\",\n            label: \"Discipline Name\",\n            maturity: \"Maturity\",\n            source: \"Source\",\n            className: \"Discipline Class Name\",\n            uri: \"Ontology URI\",\n            validator: \"Validator\",\n            validated: \"Validated\"\n        };\n        if (key in keyLabelDict) {\n            return keyLabelDict[key];\n        }\n        else {\n            return key;\n        }\n    }\n    public toString: () => string {\n        const strings = [];\n        if (this.id!== null && this.id!== undefined) {\n            strings.push(`${this.id}`);\n        }\n        strings.push(`${this.label}`);\n        strings.push(`$ = (): ${this.validator}`);\n        strings.push(`@ = ${this.uri}`);\n        strings.push(`C = ${this.className}`);\n        strings.push(`M = ${this.maturity}`);\n        strings.push(`I = $ => {\n        const strings = [];\n        if (this.id !== null && this.id !== undefined) {\n            strings.push(`${this.id}`);\n        }\n        // TO BE IMPLEMENTED IF NEEDED\n        return strings.join(\"\\n\");\n    };\n}\nexport enum OntologyParameterAttributes {\n    ID = \"id\",\n    DELIVERED = \"delivered\",\n    IMPLEMENTED = \"implemented\",\n    LABEL = \"label\",\n    MATURITY = \"modelType\",\n    SOURCE = \"originSource\",\n    CLASSNAME = \"pythonClass\",\n    URI = \"uri\",\n    VALIDATOR = \"validator\",\n    VALIDATED = \"validated\",\n    ICON = \"icon\"\n}\n","score":83,"fallbacked":false,"num_type_errors":334}]}
{"dataset_elem":{"alphanum_fraction":0.6236819607,"avg_line_length":23.238410596,"content":"// TODO check these comments:\n// Assuming that polygon vertices are in clockwise order\n\ntype Vector = {\n  x: number;\n  y: number;\n};\n\ntype Edge = {\n  index: number;\n  inwardNormal: Vector;\n  outwardNormal: Vector;\n  vertex1: Vector;\n  vertex2: Vector;\n};\n\ntype OffsetEdge = {\n  vertex1: Vector;\n  vertex2: Vector;\n};\n\ntype Polygon = {\n  edges: Edge[];\n  offsetEdges?: OffsetEdge[];\n  maxX: number;\n  maxY: number;\n  minX: number;\n  minY: number;\n  vertices: Vector[];\n};\n\nconst TWO_PI = Math.PI * 2;\n\n// See http://paulbourke.net/geometry/pointlineplane/\nfunction inwardEdgeNormal(vertex1: Vector, vertex2: Vector): Vector {\n  // Assuming that polygon vertices are in clockwise order\n  const dx = vertex2.x - vertex1.x;\n  const dy = vertex2.y - vertex1.y;\n  const edgeLength = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    x: -dy / edgeLength,\n    y: dx / edgeLength,\n  };\n}\n\nfunction outwardEdgeNormal(vertex1: Vector, vertex2: Vector): Vector {\n  var n = inwardEdgeNormal(vertex1, vertex2);\n\n  return {\n    x: -n.x,\n    y: -n.y,\n  };\n}\n\nfunction createPolygon(vertices: Vector[]): Polygon {\n  const edges: Edge[] = [];\n  let minX = vertices.length > 0 ? vertices[0].x : undefined;\n  let minY = vertices.length > 0 ? vertices[0].y : undefined;\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 0; i < vertices.length; i++) {\n    const vertex1 = vertices[i];\n    const vertex2 = vertices[(i + 1) % vertices.length];\n\n    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);\n\n    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);\n\n    const edge: Edge = {\n      vertex1,\n      vertex2,\n      index: i,\n      outwardNormal,\n      inwardNormal,\n    };\n\n    edges.push(edge);\n\n    const x = vertices[i].x;\n    const y = vertices[i].y;\n    minX = Math.min(x, minX);\n    minY = Math.min(y, minY);\n    maxX = Math.max(x, maxX);\n    maxY = Math.max(y, maxY);\n  }\n\n  const polygon: Polygon = {\n    vertices,\n    edges,\n    minX,\n    minY,\n    maxX,\n    maxY,\n  };\n\n  return polygon;\n}\n\n// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => \"line a\", edgeB => \"line b\"\n\nfunction edgesIntersection(edgeA: Edge | OffsetEdge, edgeB: Edge | OffsetEdge) {\n  const den =\n    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -\n    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);\n\n  if (den == 0) {\n    return null; // lines are parallel or coincident\n  }\n\n  const ua =\n    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n      (edgeB.vertex2.y - edgeB.vertex1.y) *\n        (edgeA.vertex1.x - edgeB.vertex1.x)) /\n    den;\n\n  const ub =\n    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n      (edgeA.vertex2.y - edgeA.vertex1.y) *\n        (edgeA.vertex1.x - edgeB.vertex1.x)) /\n    den;\n\n  // Edges are not intersecting but the lines defined by them are\n  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;\n\n  return {\n    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),\n    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),\n    isIntersectionOutside,\n  };\n}\n\nfunction appendArc(\n  arcSegments: number,\n  vertices: Vector[],\n  center: Vector,\n  radius: number,\n  startVertex: Vector,\n  endVertex: Vector,\n  isPaddingBoundary: boolean\n) {\n  var startAngle = Math.atan2(\n    startVertex.y - center.y,\n    startVertex.x - center.x\n  );\n  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);\n\n  if (startAngle < 0) {\n    startAngle += TWO_PI;\n  }\n\n  if (endAngle < 0) {\n    endAngle += TWO_PI;\n  }\n\n  const angle =\n    startAngle > endAngle\n      ? startAngle - endAngle\n      : startAngle + TWO_PI - endAngle;\n  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;\n\n  vertices.push(startVertex);\n\n  for (let i = 1; i < arcSegments; ++i) {\n    const angle = startAngle + angleStep * i;\n\n    const vertex = {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius,\n    };\n\n    vertices.push(vertex);\n  }\n\n  vertices.push(endVertex);\n}\n\nfunction createOffsetEdge(edge: Edge, dx: number, dy: number): OffsetEdge {\n  return {\n    vertex1: {\n      x: edge.vertex1.x + dx,\n      y: edge.vertex1.y + dy,\n    },\n    vertex2: {\n      x: edge.vertex2.x + dx,\n      y: edge.vertex2.y + dy,\n    },\n  };\n}\n\nfunction createMarginPolygon(\n  polygon: Polygon,\n  offset: number,\n  arcSegments: number\n): Polygon {\n  const offsetEdges: OffsetEdge[] = [];\n\n  for (let i = 0; i < polygon.edges.length; i++) {\n    const edge = polygon.edges[i];\n    const dx = edge.outwardNormal.x * offset;\n    const dy = edge.outwardNormal.y * offset;\n    offsetEdges.push(createOffsetEdge(edge, dx, dy));\n  }\n\n  const vertices: Vector[] = [];\n\n  for (let i = 0; i < offsetEdges.length; i++) {\n    const thisEdge = offsetEdges[i];\n    const prevEdge =\n      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n    const vertex = edgesIntersection(prevEdge, thisEdge);\n\n    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n      vertices.push({\n        x: vertex.x,\n        y: vertex.y,\n      });\n    } else {\n      const arcCenter = polygon.edges[i].vertex1;\n\n      appendArc(\n        arcSegments,\n        vertices,\n        arcCenter,\n        offset,\n        prevEdge.vertex2,\n        thisEdge.vertex1,\n        false\n      );\n    }\n  }\n\n  const marginPolygon = createPolygon(vertices);\n\n  marginPolygon.offsetEdges = offsetEdges;\n\n  return marginPolygon;\n}\n\nfunction createPaddingPolygon(\n  polygon: Polygon,\n  offset: number,\n  arcSegments: number\n): Polygon {\n  const offsetEdges: OffsetEdge[] = [];\n\n  for (let i = 0; i < polygon.edges.length; i++) {\n    const edge = polygon.edges[i];\n    const dx = edge.inwardNormal.x * offset;\n    const dy = edge.inwardNormal.y * offset;\n    offsetEdges.push(createOffsetEdge(edge, dx, dy));\n  }\n\n  const vertices: Vector[] = [];\n\n  for (let i = 0; i < offsetEdges.length; i++) {\n    const thisEdge = offsetEdges[i];\n    const prevEdge =\n      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n    const vertex = edgesIntersection(prevEdge, thisEdge);\n    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n      vertices.push({\n        x: vertex.x,\n        y: vertex.y,\n      });\n    } else {\n      const arcCenter = polygon.edges[i].vertex1;\n\n      appendArc(\n        arcSegments,\n        vertices,\n        arcCenter,\n        offset,\n        prevEdge.vertex2,\n        thisEdge.vertex1,\n        true\n      );\n    }\n  }\n\n  const paddingPolygon = createPolygon(vertices);\n\n  paddingPolygon.offsetEdges = offsetEdges;\n\n  return paddingPolygon;\n}\n\nexport default function offsetPolygon(\n  vertices: Vector[],\n  offset: number,\n  arcSegments: number = 0\n): Vector[] {\n  const polygon = createPolygon(vertices);\n\n  if (offset > 0) {\n    return createMarginPolygon(polygon, offset, arcSegments).vertices;\n  } else {\n    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;\n  }\n}\n","content_without_annotations":"// TODO check these comments:\n// Assuming that polygon vertices are in clockwise order\n\ntype Vector = {\n  x;\n  y;\n};\n\ntype Edge = {\n  index;\n  inwardNormal;\n  outwardNormal;\n  vertex1;\n  vertex2;\n};\n\ntype OffsetEdge = {\n  vertex1;\n  vertex2;\n};\n\ntype Polygon = {\n  edges;\n  offsetEdges?;\n  maxX;\n  maxY;\n  minX;\n  minY;\n  vertices;\n};\n\nconst TWO_PI = Math.PI * 2;\n\n// See http://paulbourke.net/geometry/pointlineplane/\nfunction inwardEdgeNormal(vertex1, vertex2) {\n  // Assuming that polygon vertices are in clockwise order\n  const dx = vertex2.x - vertex1.x;\n  const dy = vertex2.y - vertex1.y;\n  const edgeLength = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    x: -dy / edgeLength,\n    y: dx / edgeLength,\n  };\n}\n\nfunction outwardEdgeNormal(vertex1, vertex2) {\n  var n = inwardEdgeNormal(vertex1, vertex2);\n\n  return {\n    x: -n.x,\n    y: -n.y,\n  };\n}\n\nfunction createPolygon(vertices) {\n  const edges = [];\n  let minX = vertices.length > 0 ? vertices[0].x : undefined;\n  let minY = vertices.length > 0 ? vertices[0].y : undefined;\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 0; i < vertices.length; i++) {\n    const vertex1 = vertices[i];\n    const vertex2 = vertices[(i + 1) % vertices.length];\n\n    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);\n\n    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);\n\n    const edge = {\n      vertex1,\n      vertex2,\n      index: i,\n      outwardNormal,\n      inwardNormal,\n    };\n\n    edges.push(edge);\n\n    const x = vertices[i].x;\n    const y = vertices[i].y;\n    minX = Math.min(x, minX);\n    minY = Math.min(y, minY);\n    maxX = Math.max(x, maxX);\n    maxY = Math.max(y, maxY);\n  }\n\n  const polygon = {\n    vertices,\n    edges,\n    minX,\n    minY,\n    maxX,\n    maxY,\n  };\n\n  return polygon;\n}\n\n// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => \"line a\", edgeB => \"line b\"\n\nfunction edgesIntersection(edgeA, edgeB) {\n  const den =\n    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -\n    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);\n\n  if (den == 0) {\n    return null; // lines are parallel or coincident\n  }\n\n  const ua =\n    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n      (edgeB.vertex2.y - edgeB.vertex1.y) *\n        (edgeA.vertex1.x - edgeB.vertex1.x)) /\n    den;\n\n  const ub =\n    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n      (edgeA.vertex2.y - edgeA.vertex1.y) *\n        (edgeA.vertex1.x - edgeB.vertex1.x)) /\n    den;\n\n  // Edges are not intersecting but the lines defined by them are\n  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;\n\n  return {\n    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),\n    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),\n    isIntersectionOutside,\n  };\n}\n\nfunction appendArc(\n  arcSegments,\n  vertices,\n  center,\n  radius,\n  startVertex,\n  endVertex,\n  isPaddingBoundary\n) {\n  var startAngle = Math.atan2(\n    startVertex.y - center.y,\n    startVertex.x - center.x\n  );\n  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);\n\n  if (startAngle < 0) {\n    startAngle += TWO_PI;\n  }\n\n  if (endAngle < 0) {\n    endAngle += TWO_PI;\n  }\n\n  const angle =\n    startAngle > endAngle\n      ? startAngle - endAngle\n      : startAngle + TWO_PI - endAngle;\n  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;\n\n  vertices.push(startVertex);\n\n  for (let i = 1; i < arcSegments; ++i) {\n    const angle = startAngle + angleStep * i;\n\n    const vertex = {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius,\n    };\n\n    vertices.push(vertex);\n  }\n\n  vertices.push(endVertex);\n}\n\nfunction createOffsetEdge(edge, dx, dy) {\n  return {\n    vertex1: {\n      x: edge.vertex1.x + dx,\n      y: edge.vertex1.y + dy,\n    },\n    vertex2: {\n      x: edge.vertex2.x + dx,\n      y: edge.vertex2.y + dy,\n    },\n  };\n}\n\nfunction createMarginPolygon(\n  polygon,\n  offset,\n  arcSegments\n) {\n  const offsetEdges = [];\n\n  for (let i = 0; i < polygon.edges.length; i++) {\n    const edge = polygon.edges[i];\n    const dx = edge.outwardNormal.x * offset;\n    const dy = edge.outwardNormal.y * offset;\n    offsetEdges.push(createOffsetEdge(edge, dx, dy));\n  }\n\n  const vertices = [];\n\n  for (let i = 0; i < offsetEdges.length; i++) {\n    const thisEdge = offsetEdges[i];\n    const prevEdge =\n      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n    const vertex = edgesIntersection(prevEdge, thisEdge);\n\n    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n      vertices.push({\n        x: vertex.x,\n        y: vertex.y,\n      });\n    } else {\n      const arcCenter = polygon.edges[i].vertex1;\n\n      appendArc(\n        arcSegments,\n        vertices,\n        arcCenter,\n        offset,\n        prevEdge.vertex2,\n        thisEdge.vertex1,\n        false\n      );\n    }\n  }\n\n  const marginPolygon = createPolygon(vertices);\n\n  marginPolygon.offsetEdges = offsetEdges;\n\n  return marginPolygon;\n}\n\nfunction createPaddingPolygon(\n  polygon,\n  offset,\n  arcSegments\n) {\n  const offsetEdges = [];\n\n  for (let i = 0; i < polygon.edges.length; i++) {\n    const edge = polygon.edges[i];\n    const dx = edge.inwardNormal.x * offset;\n    const dy = edge.inwardNormal.y * offset;\n    offsetEdges.push(createOffsetEdge(edge, dx, dy));\n  }\n\n  const vertices = [];\n\n  for (let i = 0; i < offsetEdges.length; i++) {\n    const thisEdge = offsetEdges[i];\n    const prevEdge =\n      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n    const vertex = edgesIntersection(prevEdge, thisEdge);\n    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n      vertices.push({\n        x: vertex.x,\n        y: vertex.y,\n      });\n    } else {\n      const arcCenter = polygon.edges[i].vertex1;\n\n      appendArc(\n        arcSegments,\n        vertices,\n        arcCenter,\n        offset,\n        prevEdge.vertex2,\n        thisEdge.vertex1,\n        true\n      );\n    }\n  }\n\n  const paddingPolygon = createPolygon(vertices);\n\n  paddingPolygon.offsetEdges = offsetEdges;\n\n  return paddingPolygon;\n}\n\nexport default function offsetPolygon(\n  vertices,\n  offset,\n  arcSegments = 0\n) {\n  const polygon = createPolygon(vertices);\n\n  if (offset > 0) {\n    return createMarginPolygon(polygon, offset, arcSegments).vertices;\n  } else {\n    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;\n  }\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":2159,"ext":"ts","fun_ann_density":0.0162112089,"function_parameters":26,"function_signatures":0,"function_usages":8,"functions":9,"hexsha":"2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf","lang":"TypeScript","loc":241,"loc_per_function":19.7777777778,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"4e92233e2187d0c67a03505ec077128b265a5365","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"Stanko/offset-polygon","max_forks_repo_path":"src/offset-polygon.ts","max_issues_count":1.0,"max_issues_repo_head_hexsha":"4e92233e2187d0c67a03505ec077128b265a5365","max_issues_repo_issues_event_max_datetime":"2022-01-31T20:53:40.000Z","max_issues_repo_issues_event_min_datetime":"2022-01-31T10:37:18.000Z","max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"Stanko/offset-polygon","max_issues_repo_path":"src/offset-polygon.ts","max_line_length":108,"max_stars_count":2.0,"max_stars_repo_head_hexsha":"4e92233e2187d0c67a03505ec077128b265a5365","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"Stanko/offset-polygon","max_stars_repo_path":"src/offset-polygon.ts","max_stars_repo_stars_event_max_datetime":"2022-01-31T11:00:47.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-31T10:34:57.000Z","metric":0.2960859223,"predefined_density":0.1698113208,"predefined_types":18,"prop_ann_density":0.0074108384,"property_declarations":16,"size":7018,"trivial_density":0.0,"trivial_types":0,"type_definitions":4,"typedef_density":0.0018527096,"var_ann_density":0.0254747568,"variable_declarations":55},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"// TODO check these comments:\n// Assuming that polygon vertices are in clockwise order\ntype Vector = {\n    x: number;\n    y: number;\n};\ntype Line = {\n    index: number;\n    vertex1: Vector;\n    vertex2: Vector;\n    y: number;\n};\ntype Line2 = {\n    index: number;\n    vertex1: Vector;\n    vertex2: Vector;\n    y: number;\n};\ntype Triangle = {\n    index;\n    vertex1;\n    vertex2;\n};\ntype Edge = {\n    index: number;\n    vertex1: Vector;\n    vertex2: Vector;\n    vertex3: Vector;\n};\ntype TriangleEdge = {\n    index: number;\n    vertex1: Vector;\n    vertex2: Vector;\n    vertex3: Vecto;\n    inwardNormal: Vector;\n    outwardNormal: Vector;\n    vertex1: Vector;\n    vertex2: Vector;\n    vertex3: Vector;\n};\ntype Face = {\n    edges;\n    triangles;\n};\ntype Point = {\n    x;\n    outwardNormal: Vector;\n};\ntype Point2D = {\n    x;\n    y;\n};\ntype LineSegment = {\n    vertex1;\n    vertex2: Point2D;\n};\ntype LineSegment2 = {\n    vertex1;\n    vertex1: Point2D;\n};\ntype TriangleSegment = {\n    vertex1;\n    vertex2;\n    vertex3: Point2D;\n};\ntype Polygon = {\n    edges;\n    triangles;\n};\n\n// TODO check these comment;\n    vertex2: Point2D;\n    vertex3: Point2D;\n    vertex4: Point2D;\n\nfunction pointIsInside(point: Point2D, polygon: Polygon) {\n    for (let i = 0, len = polygo;\n};\ntype OffsetEdge = {\n    vertex1: Point2D;\n    vertex2: Point2D;\n};\nfunction createSegment(start, end) {\n    return {\n        vertex1: start,\n        vertex2: end,\n    };\n}\nfunction createLineSegment(star;\n    vertex2: Point2D;\n    vertex3: Point2D) {\n    return createSegment(vertex1, vertex2);\n}\nfunction createLineSegment2(vertex1: Point2D, vertex2: Point2D) {\n    retur;\n};\ntype Polygon = {\n    edges: OffsetEdge[];\n    triangles: Triangle[];\n};\nconst EPS = 1e-10;\nconst MIN_VERTEX_DISTANCE = 0.00001;\n\nfunction getPolygonTriangle(polygon: Polygon, verte;\n    offsetEdges?: OffsetEdge[]) {\n    var len = polygon.edges.length;\n    if (len < 3) {\n        return undefined;\n    }\n\n    var polygonTriangles = new Array(len);\n    var polygonEdges = polygon.edges;;\n    maxX: number;\n    maxY: number;\n    minX: number;\n    minY: number;\n    vertices = polygon.vertices;\n    for (let i = 0; i < len; i++) {\n        polygonTriangles[i] = new Polygo;\n    maxY: number;\n    minX: number;\n    minY: number;\n    for (let j = 0; j < 3; j++) {\n        if (i === 0 || i === len - 1 || j === 0 ||;\n    minX: number;\n        minY: number;\n        var edge = polygonEdges[i];\n        var p1 = vertices[edge[0]];\n        var p2 = vertices[edge[1]];\n        maxX = Math.max(p1.x;\n    minY: number;\n        maxX = Math.max(p2.x);\n        maxY = Math.max(p1.y, p2.y);\n        minX = Math.min(p1.x, p2.x);\n        min;\n    vertices: number;\n        minY: number;\n    }\n    maxX;\n    maxY;\n    minX;\n    minY;\n    for (let i = 0; i < len; i++) {\n        polygonTriangles[i] = new Polygo;;\n};\nconst TWO_PI = Math.PI * 2;\n// See http://paulbourke.net/geometry/pointlineplane/\nfunction inwardEdgeNormal(vertex1: Point2D, vertex2: Point2D, vertex3: Point2D) {\n    const dx = vertex2.x - vertex1.x;\n    const dy = vertex2.y - vertex1.y;\n    const edg, vertex2: Point2D;\n    if (dx === 0 && dy === 0) {\n        return { x: 0, y: 0 };\n    }\n    edg = new Line(vertex1, vertex2);\n    var edge): { x: number, y: number }[];\n    edge = edg.points;\n    var n = { x: 0, y: 0 };\n    n.x = edge[1].x - edge[0].x {\n    // Assuming that polygon vertices are in clockwise order\n    const dx = vertex2.x - vertex1.x;\n    const dy = vertex2.y - vertex1.y;\n    const edgeLength = Math.sqrt(dx * dx + dy * dy);\n    return {\n        x: -dy / edgeLength,\n        y: dx / edgeLength,\n    };\n}\nfunction outwardEdgeNormal(vertex1: Point2D, vertex2: Point2D, vertex3: Point2D) {\n    const dx = vertex3.x - vertex1.x;\n    const dy = vertex3.y - vertex1.y;\n    const e, vertex2: Point2D;\n    if (dx === 0 && dy === 0) {\n        return { x: 0, y: 0 };\n    }\n    e = new Line(vertex1, vertex3);\n    var edge:): { x: number, y: number }[];\n    edge = e.points;\n    var n = { x: 0, y: 0 };\n    n.x = edge[1].x - edge[0].x; {\n    var n = inwardEdgeNormal(vertex1, vertex2);\n    return {\n        x: -n.x,\n        y: -n.y,\n    };\n}\nfunction createPolygon(vertices: Point2D[], holes?: Point2D[]) {\n    const verticesLen = vertices.length;\n    const holesLen = holes? holes.length : 0;\n    const polygon: Polygon = {\n        vertices: verticesLe): { x: number, y: number }[] => {\n        const polygons = [];\n        const polygon: Polygon;\n        if (verticesLen < 3) {\n            polygon = {\n                vertices: vertices,\n            };\n        } else {\n            i {\n    const edges = [];\n    let minX = vertices.length > 0 ? vertices[0].x : undefined;\n    let minY = vertices.length > 0 ? vertices[0].y : undefined;\n    let maxX = minX;\n    let maxY = minY;\n    for (let i = 0; i < vertices.length; i++) {\n        const vertex1 = vertices[i];\n        const vertex2 = vertices[(i + 1) % vertices.length];\n        const outwardNormal = outwardEdgeNormal(vertex1, vertex2);\n        const inwardNormal = inwardEdgeNormal(vertex1, vertex2);\n        const edge = {\n            vertex1,\n            vertex2,\n            index: i,\n            outwardNormal,\n            inwardNormal,\n        };\n        edges.push(edge);\n        const x = vertices[i].x;\n        const y = vertices[i].y;\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n    }\n    const polygon = {\n        vertices,\n        edges,\n        minX,\n        minY,\n        maxX,\n        maxY,\n    };\n    return polygon;\n}\n// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => \"line a\", edgeB => \"line b\"\nfunction edgesIntersection(edgeA: LineSegment, edgeB: LineSegment): LineSegment | null {\n    const pointA = edgeA.vertex1;\n    const pointB = edgeB.vertex1;\n    const pointC = edgeB.vertex2;\n    const poin, edgeB: LineSegment;\n    let poin0: Point;\n    let poin1: Point;\n    if (pointA.x == pointB.x) {\n        if (pointA.y == pointC.y) {\n            return nul): Point | null; // lines are coincident\n        } else if (pointA.y > pointC.y) {\n            poin0 = pointB;\n            poin1 = pointC;\n            edgeB = new LineSegment(poin {\n    const den = (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -\n        (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);\n    if (den == 0) {\n        return null; // lines are parallel or coincident\n    }\n    const ua = ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n        (edgeB.vertex2.y - edgeB.vertex1.y) *\n            (edgeA.vertex1.x - edgeB.vertex1.x)) /\n        den;\n    const ub = ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n        (edgeA.vertex2.y - edgeA.vertex1.y) *\n            (edgeA.vertex1.x - edgeB.vertex1.x)) /\n        den;\n    // Edges are not intersecting but the lines defined by them are\n    const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;\n    return {\n        x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),\n        y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),\n        isIntersectionOutside,\n    };\n}\nfunction appendArc(arcSegments: ArcSegment[], angle, startRadius, endRadius, center, radius, startVertex, endVertex) {\n    const arcAngle = angle + startAngle;\n    const arcStartPoint = {\n        x: center.x + radius * Math, vertices: [startVertex],\n    };\n    const arcEndPoint = {\n        x: center.x + radius * Math * Math.cos(arcAngle), vertices: [endVertex],\n    };\n    if (arcStartPoint.x == arcEndPoint, center: {\n        return arcSegments;\n    }\n    const arcSegment = {\n        segmentType: SegmentType.Arc,\n        arcStartPoint,\n        arcEndPoint,\n        startAngle: arcStartPoint.y > center.y && arcStartPoint, radius: startRadius, angle: startAngle, endAngle: arcAngle,\n    };\n    return [...arcSegments, arcSegment];\n}\nfunction removeArc(arcSegments: ArcSegment[], arcSegment: ArcSegment) {\n    const index = ar, startVertex: ArcVertex, endVertex: ArcVertex;\n    for (let i = 0; i < ar.length; i++) {\n        if (arcSegment === ar[i]) {\n            if (i === 0) {\n                startVerte, endVertex: ArcVertex;\n            } else {\n                startVerte = ar[i - 1];\n                endVertex = ar[i];\n            }\n            break;\n        }\n    }\n    if (startVerte === undefined) {\n        return arcSegment, isPaddingBoundary: true;\n    }\n    const arcStartPoint = startVerte;\n    const arcEndPoint = endVerte;\n    if (arcStartPoint.x === arcEndPoint.x) {\n        return arcSegments;\n    }\n    const arcRadius): ArcSegment = {\n        segmentType: SegmentType.Arc,\n        arcStartPoint,\n        arcEndPoint,\n        startAngle: arcStartPoint.y > center.y && arcStartPoint, radius: startRadius, angle: startAngle {\n    var startAngle = Math.atan2(startVertex.y - center.y, startVertex.x - center.x);\n    var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);\n    if (startAngle < 0) {\n        startAngle += TWO_PI;\n    }\n    if (endAngle < 0) {\n        endAngle += TWO_PI;\n    }\n    const angle = startAngle > endAngle\n        ? startAngle - endAngle\n        : startAngle + TWO_PI - endAngle;\n    const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;\n    vertices.push(startVertex);\n    for (let i = 1; i < arcSegments; ++i) {\n        const angle = startAngle + angleStep * i;\n        const vertex = {\n            x: center.x + Math.cos(angle) * radius,\n            y: center.y + Math.sin(angle) * radius,\n        };\n        vertices.push(vertex);\n    }\n    vertices.push(endVertex);\n}\nfunction createOffsetEdge(edge: Edge, vertices: ArcVertex[]) {\n    vertices.push(edge.vertex1);\n    vertices.push(edge.vertex2);\n}\nfunction createCircle(circle: Circle, vertices: ArcVertex[]) {\n    const center = circl, dx: number, dy: number;\n    if (circle.x === center.x) {\n        if (circle.y < center.y) {\n            dy = circle.y - center.y;\n        } else {\n            dy = -circl, dy: circle.y - center.y;\n        }\n    } else {\n        if (circle.y < center.y) {\n            dx = -circle.x - center.x;\n        } else {\n            dx = circle.x - cente): { dx: number, dy: number };\n        }\n    }\n    vertices.push(circle.vertex1);\n    vertices.push(circle.vertex2);\n    vertices.push(circle.vertex1.clone().add(circle.verte {\n    return {\n        vertex1: {\n            x: edge.vertex1.x + dx,\n            y: edge.vertex1.y + dy,\n        },\n        vertex2: {\n            x: edge.vertex2.x + dx,\n            y: edge.vertex2.y + dy,\n        },\n    };\n}\nfunction createMarginPolygon(polygon: Edge[], vertices: ArcVertex[]) {\n    const center = polygon.vertex1.clone().add(polygon.vertex2).multiplyScalar(0.5), dx: number, dy: number;\n    if (center.x === polygon, offset: number) {\n        if (center.y < polygon.vertex1.y) {\n            dy = polygon.vertex1.y - center.y;\n        } else {\n            dy = -polygon.vertex1.y - center., arcSegments: number;\n        }\n    } else {\n        if (center.y < polygon.vertex1.y) {\n            dx = polygon.vertex1.x - center.x;\n        } else {\n            dx = -polygon.vertex1): { dx: number, dy: number };\n        }\n    }\n    vertices.push(polygon.vertex1.clone().add(polygon.vertex2));\n    vertices.push(polygon.vertex2.clone().add(polygon.vertex {\n    const offsetEdges = [];\n    for (let i = 0; i < polygon.edges.length; i++) {\n        const edge = polygon.edges[i];\n        const dx = edge.outwardNormal.x * offset;\n        const dy = edge.outwardNormal.y * offset;\n        offsetEdges.push(createOffsetEdge(edge, dx, dy));\n    }\n    const vertices = [];\n    for (let i = 0; i < offsetEdges.length; i++) {\n        const thisEdge = offsetEdges[i];\n        const prevEdge = offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n        const vertex = edgesIntersection(prevEdge, thisEdge);\n        if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n            vertices.push({\n                x: vertex.x,\n                y: vertex.y,\n            });\n        }\n        else {\n            const arcCenter = polygon.edges[i].vertex1;\n            appendArc(arcSegments, vertices, arcCenter, offset, prevEdge.vertex2, thisEdge.vertex1, false);\n        }\n    }\n    const marginPolygon = createPolygon(vertices);\n    marginPolygon.offsetEdges = offsetEdges;\n    return marginPolygon;\n}\nfunction createPaddingPolygon(polygon: Polygon, offset: number, center: Vector, arcSegments?: number) {\n    const offsetEdges = [];\n    for (let i = 0; i < polygon.edges.length; i++) {\n        const edge = polygon.edges, offset: number = offset;\n        const dx = edge.outwardNormal.x * offset;\n        const dy = edge.outwardNormal.y * offset;\n        offsetEdges.push(createOffsetEdge(edge, dx, dy));, arcSegments: number = arcSegments;\n    }\n    const vertices = [];\n    for (let i = 0; i < offsetEdges.length; i++) {\n        const thisEdge = offsetEdges[i];\n        const prevEdge = offsetEdges[(): number];\n        const vertex = edgesIntersection(prevEdge, thisEdge);\n        if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n            vertices.push({\n                x: vertex.x,\n                y: verte {\n    const offsetEdges = [];\n    for (let i = 0; i < polygon.edges.length; i++) {\n        const edge = polygon.edges[i];\n        const dx = edge.inwardNormal.x * offset;\n        const dy = edge.inwardNormal.y * offset;\n        offsetEdges.push(createOffsetEdge(edge, dx, dy));\n    }\n    const vertices = [];\n    for (let i = 0; i < offsetEdges.length; i++) {\n        const thisEdge = offsetEdges[i];\n        const prevEdge = offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n        const vertex = edgesIntersection(prevEdge, thisEdge);\n        if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n            vertices.push({\n                x: vertex.x,\n                y: vertex.y,\n            });\n        }\n        else {\n            const arcCenter = polygon.edges[i].vertex1;\n            appendArc(arcSegments, vertices, arcCenter, offset, prevEdge.vertex2, thisEdge.vertex1, true);\n        }\n    }\n    const paddingPolygon = createPolygon(vertices);\n    paddingPolygon.offsetEdges = offsetEdges;\n    return paddingPolygon;\n}\nexport default function offsetPolygon(vertices: Polygon, offset: number, offset: number, arcSegments = 0) {\n    const polygon = createPolygon(vertices);\n    if (offset > 0) {\n        return createMarginPolygon(polygon, offset, arcSegments);\n    }\n    else {\n        return createPaddingPolygo, arcSegments: arcSegments };\n}\nexport function offsetPolygon(vertices: Polygon, offset: number, arcSegments = 0): Polygon[] {\n    const polygon = createPolygon(vertices);\n    if (offset > 0) {\n        return createMarginPolygon(polygon, offset, arcSegments).vertices;\n    }\n    else {\n        return createPaddingPolygon(polygon, -offset, arcSegments).vertices;\n    }\n}\n","score":389,"fallbacked":false,"num_type_errors":283},{"code":"// TODO check these comments:\n// Assuming that polygon vertices are in clockwise order\ntype Vector = {\n    x: number;\n    y: number;\n};\n// Assuming that polygon vertices are in clockwise order\ntype Polygon = {\n    vertices;\n    edges;\n};\nconst TWO_PI = Math.PI * 2;\n// See htt;\n    y: number;\n}\ntype Vertex = {\n    x: number;\n    y: number;\n};\ntype Spline = {\n    edges: Edge[];\n};\n\n// TODO:\n// - support for holes\n// - suppor;\n};\ntype Edge = {\n    index: number;\n    point1;\n    point2;\n    normal;\n};\ntype Polygon = {\n    vertices;\n    edges;\n};\n\n// TODO:\n// - support for holes\n// - suppor;\n};;\n    inwardNormal: Vector;\n    outwardNormal: Vector;\n    vertex1: Vertex;\n    vertex2: Vertex;\n};\ntype OffsetEdge = {\n    vertex1;\n    vertex2;\n};\ntype Polygon = {\n    edges;\n    offsetEdge;\n    outwardNormal: Vector;\n    inwardNormal: Vector;\n};\n\n/**\n * Class for polygons\n * @param vertices\n * @param holes\n */\nclass Polygon3D extends Polygon {\n    constructor(vertices, holes: Polygon;\n    vertex1: Vertex;\n    vertex2: Vertex;\n};\n\ntype Vector = {\n    x: number;\n    y: number;\n};\n// Assuming that polygon vertices are in clockwise order\ntype Polygon = {\n    vertices;\n    edges;\n    vertex2: Vertex;\n    offsetEdge;\n};\n\n// TODO:\n// - support for holes\n// - suppor;\n};\n\ntype Polygon = {\n    vertices;\n    edges;\n    vertex2: Vertex;\n};;\n};\ntype OffsetEdge = {\n    vertex1: Vertex;\n    vertex2: Vertex;\n};\n\n// TODO:\n// - support for holes\n// - suppor;\n};\n\ntype Polygon = {\n    vertices;\n    edges;\n};\n\n// TODO:;\n    vertex2: Vertex;\n\n// TODO:\n// - support for holes\n// - suppor;\n};\n\ntype Polygon = {\n    vertices;\n    edges;\n};\n\n// TODO:\n// - support for holes\n/;\n};\ntype Polygon = {\n    edges: Edge[];\n};\n\ntype Polygon = {\n    vertices: Polygon[];\n};\n\n// TODO:\n// - support for holes\n// - suppor;\n};\n\ntype Polygon = {\n    vertices: Polygon[];\n    hol;\n    offsetEdges?: OffsetEdge[];\n};\n\ntype Polygon = {\n    vertices: Polygon[];\n    holes: Polygon[];\n};\n\n// TODO:\n// - support for holes\n// - suppor;\n};\n\ntype Polygon =;\n    maxX: number;\n    maxY: number;\n    minX: number;\n    minY: number;\n    vertices: Vector[];\n};\n\n// Assuming that polygon vertices are in clockwise order\ntype Polygon = {\n    vertices;\n    edges;\n    vertex;\n    maxY: number;\n    maxX: number;\n    minX: number;\n    minY: number;\n};\n\ntype Polygon = {\n    vertices;\n    edges;\n    vertex;\n    maxY: number;\n    maxX: number;\n    minX: number;;\n    minX: number;\n    minY: number;\n};\n\ntype Polygon = {\n    vertices;\n    edges;\n    vertex;\n    maxY: number;\n    maxX: number;\n    minX: number;\n    minY: number;\n};\n\ntype Polygo;\n    minY: number;\n    maxY: number;\n    maxX: number;\n    minX: number;\n};\n\n// Assuming that polygon vertices are in clockwise order\ntype Polygon = {\n    vertices;\n    edges;\n    vertex;\n    maxY: number;\n    vertices: Vector[];\n    minX: number;\n    maxX: number;\n    minY: number;\n};\n\ntype Polygon = {\n    vertices: Polygon[];\n    holes: Polygon[];\n};\n\ntype Polygon = {\n    vertices: Polygon[];;\n};\nconst TWO_PI = Math.PI * 2;\n// See http://paulbourke.net/geometry/pointlineplane/\nfunction inwardEdgeNormal(vertex1: Vector, vertex2: Vector) {\n    // Assuming that polygon vertices are in clockwise order\n    const dx = vertex2.x - vertex1.x;\n    const dy = vertex2.y - vertex1.y;\n    const edg, vertex2: Vector;\n    if (dx === 0 || dy === 0) {\n        edg = vertex1;\n    } else {\n        edg = {\n            x: vertex1.x + dx,\n            y: vertex1.y): { x: vertex1.x, y: vertex1.y };\n    }\n    return outwardEdgeNormal(vertex1, edg);\n}\nfunction inwardEdgeNormal(vertex1: Vector, vertex2: Vector) {\n    // Assuming that polygon vertices are in clockwise order\n    const dx = vertex2.x - vertex1.x;\n    const dy = vertex2.y - vertex1.y;\n    const edgeLength = Math.sqrt(dx * dx + dy * dy);\n    return {\n        x: -dy / edgeLength,\n        y: dx / edgeLength,\n    };\n}\nfunction outwardEdgeNormal(vertex1: Vector, vertex2: Vector) {\n    // Assuming that polygon vertices are in clockwise order\n    const dx = vertex2.x - vertex1.x;\n    const dy = vertex2.y - vertex1.y;\n    return, vertex2: { x: vertex2.x, y: vertex2.y };\n}\nfunction inwardEdgeNormal(vertex1: Vector, vertex2: Vector) {\n    // Assuming that polygon vertices are in clockwise order\n    const dx): Vector {\n        // Assuming that polygon vertices are in clockwise order\n        const dx = vertex2.x - vertex1.x;\n        const dy = vertex2.y - vertex1.y;\n        return {\n            x: -dy {\n    var n = inwardEdgeNormal(vertex1, vertex2);\n    return {\n        x: -n.x,\n        y: -n.y,\n    };\n}\nfunction createPolygon(vertices: PolygonVertex[]): Polygon {\n    const edges: PolygonEdge[] = [];\n    let minX = vertices.length > 0? vertices[0].x : undefined;\n    let minY = vertices.length > 0? vertices[0].): undefined;\n    let maxX = minX;\n    let maxY = minY;\n    for (let i = 0; i < vertices.length; i++) {\n        const vertex1 = vertices[i];\n        const vertex2 = vertices[(i {\n    const edges = [];\n    let minX = vertices.length > 0 ? vertices[0].x : undefined;\n    let minY = vertices.length > 0 ? vertices[0].y : undefined;\n    let maxX = minX;\n    let maxY = minY;\n    for (let i = 0; i < vertices.length; i++) {\n        const vertex1 = vertices[i];\n        const vertex2 = vertices[(i + 1) % vertices.length];\n        const outwardNormal = outwardEdgeNormal(vertex1, vertex2);\n        const inwardNormal = inwardEdgeNormal(vertex1, vertex2);\n        const edge = {\n            vertex1,\n            vertex2,\n            index: i,\n            outwardNormal,\n            inwardNormal,\n        };\n        edges.push(edge);\n        const x = vertices[i].x;\n        const y = vertices[i].y;\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n    }\n    const polygon = {\n        vertices,\n        edges,\n        minX,\n        minY,\n        maxX,\n        maxY,\n    };\n    return polygon;\n}\n// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => \"line a\", edgeB => \"line b\"\nfunction edgesIntersection(edgeA: PolygonEdge, edgeB: PolygonEdge): PolygonEdge | null {\n    if (edgeA.vertex1.x == edgeB.vertex1.x && edgeA.vertex1.y == edgeB.vertex1.y), edgeB: {\n        if (edgeA.vertex2.x == edgeB.vertex2.x && edgeA.vertex2.y == edgeB.vertex2.y), edgeA: {\n            return null; // lines are parallel or coi): return null\n        }\n    } else if (edgeA.vertex1.x == edgeB.vertex2.x && edgeA.vertex1.y == edgeB.vertex2.y), edgeA: {\n        if (edge {\n    const den = (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -\n        (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);\n    if (den == 0) {\n        return null; // lines are parallel or coincident\n    }\n    const ua = ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n        (edgeB.vertex2.y - edgeB.vertex1.y) *\n            (edgeA.vertex1.x - edgeB.vertex1.x)) /\n        den;\n    const ub = ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n        (edgeA.vertex2.y - edgeA.vertex1.y) *\n            (edgeA.vertex1.x - edgeB.vertex1.x)) /\n        den;\n    // Edges are not intersecting but the lines defined by them are\n    const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;\n    return {\n        x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),\n        y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),\n        isIntersectionOutside,\n    };\n}\nfunction appendArc(arcSegments: ArcSegment[], arc: PolygonArc, pointA: Vector2, pointB: Vector2, isPaddingBoundary: boolean) {\n    const arcSegment = {\n        pointA,\n        pointB,\n        angle: isPaddingBoundary\n          ? ge, vertices: [pointA, pointB]\n           : arc.angle,\n        radius: arc.radius,\n        angleStart: arc.angleStart,\n        angleEnd: arc.angleEnd,\n        vertices: isPaddingBoundary\n          ? [pointA, center: pointB]\n           : [pointA, pointB, pointA],\n    };\n    arcSegments.push(arcSegment);\n    const angle = arcSegment.angleStart + arcSegment.angle;\n    const vertex = arcSegment.vertices, radius: arcSegmentRadius = arcSegment.radius;\n    const isIntersectionOutside = arcSegment.isIntersectionOutside;\n    if (isPaddingBoundary) {\n        arcSegmentRadius *= -1;\n    }\n    arcSegment.angle = angle;\n    ar, startVertex: ArcSegment, endVertex: ArcSegment = {\n        pointA: arcSegment.vertices[0],\n        pointB: arcSegment.vertices[2],\n        angle: arcSegment.angle,\n        radius: arcSegmentRadius,\n        angleStar, endVertex: { pointA, pointB },\n    };\n    const nextAngle = isPaddingBoundary? -arcSegment.angleStart : arcSegment.angleStart;\n    const nextPoint = isPaddingBoundary\n        ? edgeAtoB(pointA, poin, isPaddingBoundary: true)\n         : edgeAtoB(pointA, pointB, isPaddingBoundary: true);\n    const nextArc = new PolygonArc(nextPoint, nextAngle);\n    if (isPaddingBoundary) {\n        nextArc.radius *): number;\n    }\n    arcSegments.push(nextArc);\n    return appendArc(arcSegments, nextArc, nextPoint, center, isPaddingBoundary);\n}\nfunction edgeAtoB(a: Vector2, b: Vecto {\n    var startAngle = Math.atan2(startVertex.y - center.y, startVertex.x - center.x);\n    var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);\n    if (startAngle < 0) {\n        startAngle += TWO_PI;\n    }\n    if (endAngle < 0) {\n        endAngle += TWO_PI;\n    }\n    const angle = startAngle > endAngle\n        ? startAngle - endAngle\n        : startAngle + TWO_PI - endAngle;\n    const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;\n    vertices.push(startVertex);\n    for (let i = 1; i < arcSegments; ++i) {\n        const angle = startAngle + angleStep * i;\n        const vertex = {\n            x: center.x + Math.cos(angle) * radius,\n            y: center.y + Math.sin(angle) * radius,\n        };\n        vertices.push(vertex);\n    }\n    vertices.push(endVertex);\n}\nfunction createOffsetEdge(edge: PolygonEdge, dx: number, dy: number) {\n    const nextEdge = {\n        vertex1: { x: edge.vertex1.x + dx, y: edge.vertex1.y + dy },\n        vertex2:, dx: 0,\n        vertex3:, dx: 0,\n        vertex4: edge.vertex4,\n    };\n    if (offsetEdges.length > 0) {\n        const prevEdge = offsetEdges[offsetEdges.length - 1], dy: 0;\n        const prevDx: number = prevEdge.vertex2.x - prevEdge.vertex1.x;\n        const prevDy: number = prevEdge.vertex2.y - prevEdge.vertex1.y;\n        cons): number {\n            const prevAngle = Math.atan2(prevEdge.vertex2.y - prevEdge.vertex1.y, prevEdge.vertex2.x - prevEdge.vertex1.x);\n            if (prevAngle {\n    return {\n        vertex1: {\n            x: edge.vertex1.x + dx,\n            y: edge.vertex1.y + dy,\n        },\n        vertex2: {\n            x: edge.vertex2.x + dx,\n            y: edge.vertex2.y + dy,\n        },\n    };\n}\nfunction createMarginPolygon(polygon: Polygon, margin: number) {\n    const polygons: Polygon[] = [];\n    if (polygon.edges.length > 1) {\n        polygons.push(polygon);\n    } else {\n        polygons.push(polygon.clone().reverse()), offset: 0;\n    }\n    const center = polygon.edges[0].vertex1;\n    const radius = polygon.edges[0].vertex1.distanceTo(polygon.edges[polygon.edges.length - 1].vertex1);\n    cons, arcSegments: ArcSegment[] = [];\n    const angle1: number = Math.atan2(center.y - polygon.edges[0].vertex1.y, center.x - polygon.edges[0].vertex1.x);\n    const angl): ArcSegment[] {\n        const angle2: number = Math.atan2(center.y - polygon.edges[polygon.edges.length - 1].vertex1.y, center.x - polygon.edges[polygon.edges {\n    const offsetEdges = [];\n    for (let i = 0; i < polygon.edges.length; i++) {\n        const edge = polygon.edges[i];\n        const dx = edge.outwardNormal.x * offset;\n        const dy = edge.outwardNormal.y * offset;\n        offsetEdges.push(createOffsetEdge(edge, dx, dy));\n    }\n    const vertices = [];\n    for (let i = 0; i < offsetEdges.length; i++) {\n        const thisEdge = offsetEdges[i];\n        const prevEdge = offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n        const vertex = edgesIntersection(prevEdge, thisEdge);\n        if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n            vertices.push({\n                x: vertex.x,\n                y: vertex.y,\n            });\n        }\n        else {\n            const arcCenter = polygon.edges[i].vertex1;\n            appendArc(arcSegments, vertices, arcCenter, offset, prevEdge.vertex2, thisEdge.vertex1, false);\n        }\n    }\n    const marginPolygon = createPolygon(vertices);\n    marginPolygon.offsetEdges = offsetEdges;\n    return marginPolygon;\n}\nfunction createPaddingPolygon(polygon: Polygon, offset: number, arcSegments: ArcSegment[]): Polygon {\n    const center = polygon.edges[0].vertex1;\n    const radius = polygon.edges[0].vertex1.distanceTo(polygon.edges[polygon.edge, offset: polygon.edges[0].vertex1.distanceTo(polygon.edges[polygon.edges.length - 1].vertex1, 1) as Point]);\n    const centerRadius = radius * 1.05;\n    const angle, arcSegments: ArcSegment[];\n    if (offset > 0) {\n        angle = Math.PI * 2 / arcSegments;\n        arcSegments = [new ArcSegment(center, centerRadius, angle)];\n    }\n    else {\n        angle =): number;\n        arcSegments = [new ArcSegment(center, centerRadius, angle - Math.PI * 2)];\n    }\n    const vertices = [];\n    for (let i = 0; i < arcSegments.length; i++ {\n    const offsetEdges = [];\n    for (let i = 0; i < polygon.edges.length; i++) {\n        const edge = polygon.edges[i];\n        const dx = edge.inwardNormal.x * offset;\n        const dy = edge.inwardNormal.y * offset;\n        offsetEdges.push(createOffsetEdge(edge, dx, dy));\n    }\n    const vertices = [];\n    for (let i = 0; i < offsetEdges.length; i++) {\n        const thisEdge = offsetEdges[i];\n        const prevEdge = offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n        const vertex = edgesIntersection(prevEdge, thisEdge);\n        if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n            vertices.push({\n                x: vertex.x,\n                y: vertex.y,\n            });\n        }\n        else {\n            const arcCenter = polygon.edges[i].vertex1;\n            appendArc(arcSegments, vertices, arcCenter, offset, prevEdge.vertex2, thisEdge.vertex1, true);\n        }\n    }\n    const paddingPolygon = createPolygon(vertices);\n    paddingPolygon.offsetEdges = offsetEdges;\n    return paddingPolygon;\n}\nexport default function offsetPolygon(vertices: PolygonVertex[], offset = 0, offset: number, arcSegments: ArcSegment[]) {\n    if (offset > 0) {\n        return createMarginPolygon(vertices, offset, arcSegments).vertices;\n    }\n    else {\n        return createPaddingPolygon(vertices, -offset, arcSegments).vertices; = 0): PolygonVertex[] {\n    if (offset <= 0) {\n        return vertices;\n    }\n    const arcSegments: ArcSegment[] = [];\n    const center = { x: 0, y: 0 };\n    let centerRadius = {\n    const polygon = createPolygon(vertices);\n    if (offset > 0) {\n        return createMarginPolygon(polygon, offset, arcSegments).vertices;\n    }\n    else {\n        return createPaddingPolygon(polygon, -offset, arcSegments).vertices;\n    }\n}\n","score":329,"fallbacked":false,"num_type_errors":321},{"code":"// TODO check these comments:\n// Assuming that polygon vertices are in clockwise order\ntype Vector = {\n    x: number;\n    y: number;\n};\ntype Line = {\n    index;\n    inwardNormal;\n    outwardNormal;\n    vertex1;\n    vertex2;\n};\ntype OffsetLine = {\n    vertex1;\n    vertex;\n    y: number;\n    vertex2: Vector;\n};\ntype OffsetLineWithDistance = {\n    vertex1;\n    vertex2;\n    distanceToVertex;\n};\ntype OffsetEdge = {\n    vertex1;\n    vertex2;\n};;\n};\ntype Edge = {\n    index: number;\n    inwardNormal;\n    outwardNormal;\n    vertex1;\n    vertex2;\n};\ntype OffsetEdge = {\n    vertex1;\n    vertex2;\n};\ntype Polygon = {\n    edges;\n    offsetEdges;\n    inwardNormal: Vector;\n    outwardNormal: Vector;\n    vertex1;\n    vertex2;\n    offsetEdges?;\n};\nconst edgePool = [];\nfunction createEdge(index, inwardNormal, outwardNormal, vertex1, vertex;\n    outwardNormal: Vector, vertex2: Vector) {\n    const edge = edgePool[index] || createEdgePool();\n    edge.index = index;\n    edge.inwardNormal = inwardNormal;\n    edge.outwardNormal = outwardNorma;\n    vertex1: = vertices[vertex1];\n    vertex2 = vertices[vertex2];\n    edge.vertex1 = vertex1;\n    edge.vertex2 = vertex2;\n    return edge;\n};\nfunction createEdgePool() {\n    return {;\n    vertex2: vertices[0];\n    inwardNormal: Vector;\n    outwardNormal: Vector;\n    vertex1: number;\n    index: number;\n};\nfunction computeNormals(edges) {\n    for (let edgeIndex = 0, edg;\n};\ntype OffsetEdge = {\n    vertex1: Vector;\n    vertex2: Vector;\n    distanceToVertex: number;\n};\n// Polygon offset\nfunction computePolygonOffset(polygon: Polygon, offset: number, offsetNormal: Vector) {\n    polygon.offsetEdges = polygon.offse;\n    vertex2: Vector;\n    vertex1: Vector;\n    for (let edgeIndex = 0, edge;\n        edge = polygon.edges[edgeIndex]; edgeIndex++) {\n        const vertex1 = edge.vertex1;\n        const vertex2 = edg;\n};\ntype Polygon = {\n    edges: Edge[];\n    offsetEdges: OffsetEdge[];\n    inwardNormal: Vector;\n    outwardNormal: Vector;\n    vertex1: Vector;\n    vertex2: Vector;\n    offsetEdges?;\n};\n}\ntype Polygon = {;\n    offsetEdges?: OffsetEdge[];\n    inwardNormal?: Vector;\n    outwardNormal?: Vector;\n    vertices: Vector[];\n};\nfunction computeOffset(polygon: Polygon, offset: number, offsetNormal: Vector) {\n    if (offset ===;\n    maxX: number;\n    maxY: number;\n    minX: number;\n    minY: number;\n    vertices: Vector[];\n    const edgeIndex = polygon.offsetEdges[offset];\n    edgeIndex;\n    edge: Polygon.Edge;\n    if (edgeInde;\n    maxY: number;\n    minX: number;\n    minY: number;\n    vertices: Vector[];\n    const edge = polygon.edges[edgeIndex];\n    edge;\n    vertex1: Vector;\n    vertex2: Vector;\n    offsetEdges: OffsetEdge[];\n    minX: number;\n    minY: number;\n    vertices: Vector[];\n    const vertex1 = edge.vertex1;\n    const vertex2 = edge.vertex2;\n    if (vertex1.distanceTo(vertex2) < 0) {\n        retur;\n    minY: number;\n        maxX: number;\n        minY: number;\n        maxX: number;\n        minY: number;\n        vertices: Vector[];\n        const edgeIndex = polygon.offsetEdges[offset + 1];\n        edgeIndex;\n        edge: Polygo;\n    vertices: Vector[];\n    const edge = polygon.edges[edgeIndex];\n    edge;\n    vertex1: Vector;\n    vertex2: Vector;\n    offsetEdges: OffsetEdge[];\n    minX: number;\n    minY: number;\n    vertices: Vector[];\n};\nconst TWO_PI = Math.PI * 2;\n// See http://paulbourke.net/geometry/pointlineplane/\nfunction inwardEdgeNormal(vertex1: Vector, vertex2: Vector) {\n    // Assuming that polygon vertices are in clockwise order\n    const dx = vertex2.x - vertex1.x;\n    const dy = vertex2.y - vertex1.y;\n    const edg, vertex2: Vector;\n    let d = -vertex1.dot(vertex2);\n    if (d >= 0) {\n        return;\n    }\n    edg = new Polygon.Edge(vertex1, vertex2);\n    edg.length): number;\n    const angle = Math.acos(d);\n    if (angle < 0) {\n        angle += TWO_PI;\n    }\n    return angle;\n}\nfunction inwardPointNormal(point, polygon) {\n    cons {\n    // Assuming that polygon vertices are in clockwise order\n    const dx = vertex2.x - vertex1.x;\n    const dy = vertex2.y - vertex1.y;\n    const edgeLength = Math.sqrt(dx * dx + dy * dy);\n    return {\n        x: -dy / edgeLength,\n        y: dx / edgeLength,\n    };\n}\nfunction outwardEdgeNormal(vertex1: Vector, vertex2: Vector) {\n    const point = { x: vertex1.x - vertex2.x, y: vertex1.y - vertex2.y };\n    return inwardPointNormal(point, polygon);, vertex2: Vector;\n}\nfunction outwardPointNormal(point, polygon) {\n    // Assuming that polygon vertices are in clockwise order\n    const dx = point.x - vertex1.x;\n    const dy = point.y - vertex): {\n        x: -point.y / point.x,\n        y: point.x / point.y,\n    };\n}\nfunction rotateAroundPoint(point: Vector, angle: number, center: Vector) {\n    const poin {\n    var n = inwardEdgeNormal(vertex1, vertex2);\n    return {\n        x: -n.x,\n        y: -n.y,\n    };\n}\nfunction createPolygon(vertices: Vector[], holes: Polygon[]) {\n    const polygon = new Polygon(vertices);\n    if (holes.length === 0) {\n        return polygon;\n    }\n    const holesPolygons: Polygon[] = [];\n    for (le): Polygon {\n        const holesVertices: Vector[] = [];\n        for (let i = 0; i < holes.length; i++) {\n            const hole = holes[i];\n            const holeVertices = hole.vertices.ma {\n    const edges = [];\n    let minX = vertices.length > 0 ? vertices[0].x : undefined;\n    let minY = vertices.length > 0 ? vertices[0].y : undefined;\n    let maxX = minX;\n    let maxY = minY;\n    for (let i = 0; i < vertices.length; i++) {\n        const vertex1 = vertices[i];\n        const vertex2 = vertices[(i + 1) % vertices.length];\n        const outwardNormal = outwardEdgeNormal(vertex1, vertex2);\n        const inwardNormal = inwardEdgeNormal(vertex1, vertex2);\n        const edge = {\n            vertex1,\n            vertex2,\n            index: i,\n            outwardNormal,\n            inwardNormal,\n        };\n        edges.push(edge);\n        const x = vertices[i].x;\n        const y = vertices[i].y;\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n    }\n    const polygon = {\n        vertices,\n        edges,\n        minX,\n        minY,\n        maxX,\n        maxY,\n    };\n    return polygon;\n}\n// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => \"line a\", edgeB => \"line b\"\nfunction edgesIntersection(edgeA: Edge, edgeB: Edge) {\n    const lineA = new Line(edgeA.vertex1, edgeA.vertex2);\n    const lineB = new Line(edgeB.vertex1, edgeB.vertex2);\n    i, edgeB: Edge;\n    for (edgeB of lineB.edges) {\n        if (lineA.intersectsLine(edgeB)) {\n            return edgeB;\n        }\n    }\n    return null;\n}\n\nfunction inwardEdgeNormal): Vector {\n    const x = edgeB.vertex2.x - edgeB.vertex1.x;\n    const y = edgeB.vertex2.y - edgeB.vertex1.y;\n    return { x: -y {\n    const den = (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -\n        (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);\n    if (den == 0) {\n        return null; // lines are parallel or coincident\n    }\n    const ua = ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n        (edgeB.vertex2.y - edgeB.vertex1.y) *\n            (edgeA.vertex1.x - edgeB.vertex1.x)) /\n        den;\n    const ub = ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -\n        (edgeA.vertex2.y - edgeA.vertex1.y) *\n            (edgeA.vertex1.x - edgeB.vertex1.x)) /\n        den;\n    // Edges are not intersecting but the lines defined by them are\n    const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;\n    return {\n        x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),\n        y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),\n        isIntersectionOutside,\n    };\n}\nfunction appendArc(arcSegments: ArcSegment[], points: Point[], center: Point, radius: number, startVertex: Point, endVertex: Point, isPaddingBoundary: boolean) {\n    if (points.length === 0) {\n        return arcSegments;, vertices: []\n    }\n    var pointsLength = points.length;\n    var arcLength = Math.PI * 2 * radius;\n    if (arcLength > Math.PI) {\n        arcLength = Math.PI;\n    }\n    var thet, center: Point;\n    var edgeA = new Line(points[pointsLength - 1], points[0]);\n    var edgeB = new Line(points[pointsLength - 2], points[pointsLength - 1]);\n    var centerPoin, radius: number;\n    var arcSegments = [];\n    centerPoin = center;\n    for (var i = 1; i < pointsLength - 1; i++) {\n        center = centerPoin.add(points[i].subtract, startVertex: startVertex);\n        centerPoin = centerPoin.add(points[i].subtract, endVertex: endVertex);\n        var angle = Math.atan2(endVertex.y - startVertex.y, endVertex.x, endVertex: endVertex);\n        thet = Math.PI - angle;\n        if (thet < 0) {\n            thet += Math.PI * 2;\n        }\n        radius = Math.sqrt(center.subtract(centerPoi, isPaddingBoundary: isPaddingBoundary).magnitudeSquared);\n        if (Math.abs(thet) > Math.PI * 2) {\n            radius = 0;\n        }\n        var arcSegment = new ArcSegment(arcLength, thet, cente): ArcSegment;\n        arcSegment.center = center;\n        arcSegment.radius = radius;\n        arcSegments.push(arcSegment);\n    }\n    return arcSegments, centerPoin\n}\nfunction appendArcWithPadding(arcSegments {\n    var startAngle = Math.atan2(startVertex.y - center.y, startVertex.x - center.x);\n    var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);\n    if (startAngle < 0) {\n        startAngle += TWO_PI;\n    }\n    if (endAngle < 0) {\n        endAngle += TWO_PI;\n    }\n    const angle = startAngle > endAngle\n        ? startAngle - endAngle\n        : startAngle + TWO_PI - endAngle;\n    const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;\n    vertices.push(startVertex);\n    for (let i = 1; i < arcSegments; ++i) {\n        const angle = startAngle + angleStep * i;\n        const vertex = {\n            x: center.x + Math.cos(angle) * radius,\n            y: center.y + Math.sin(angle) * radius,\n        };\n        vertices.push(vertex);\n    }\n    vertices.push(endVertex);\n}\nfunction createOffsetEdge(edge: Edge, polygon: Polygon): void {\n    const offsetEdge = new Edge(edge.outwardNormal, edge.vertex1, edge.vertex2);\n    if (edge.outwardNormal.magnitudeSquared < 1e-5, dx: number, dy: number) {\n        offsetEdge.vertex1 = { x: edge.vertex1.x + dx, y: edge.vertex1.y + dy };\n        offsetEdge.vertex2 = { x: edge.verte, dy: -edge.vertex1.dy };\n    }\n    polygon.edges.push(offsetEdge);\n}\nfunction createEdge(edge: Edge, polygon: Polygon): void {\n    vertices.push(edge.vertex1);\n    vertices): void {\n        polygon.edges.push(edge);\n    }\n}\nfunction createTriangle(edge: Edge, polygon: Polygon) {\n    const triangle = new Polygon();\n    triangle.edges.push(edge);\n    if (edge {\n    return {\n        vertex1: {\n            x: edge.vertex1.x + dx,\n            y: edge.vertex1.y + dy,\n        },\n        vertex2: {\n            x: edge.vertex2.x + dx,\n            y: edge.vertex2.y + dy,\n        },\n    };\n}\nfunction createMarginPolygon(polygon: Polygon, margin: number, offset: number, arcSegments: number) {\n    const marginPolygon = new Polygon();\n    const marginEdge = new Edge(new Vector2(0, 0), polygon.edges[0].vertex1, offset: offset);\n    const marginEdge2 = new Edge(new Vector2(0, 0), polygon.edges[polygon.edges.length - 1].vertex1, offset: offset);\n    marginPolygon.edges.push(marginEdg, arcSegments: arcSegments);\n    const center = new Vector2(offsetEdge.vertex1.x, offsetEdge.vertex1.y);\n    const radius = edgeLength(offsetEdge.vertex1, offsetEdge2.vertex1);\n    const angl): number {\n        return Math.acos(center.x / radius);\n    }\n    const theta = Math.acos(center.y / radius);\n    const center2 = new Vector2(offsetEdge2.vertex1.x, offsetEdg {\n    const offsetEdges = [];\n    for (let i = 0; i < polygon.edges.length; i++) {\n        const edge = polygon.edges[i];\n        const dx = edge.outwardNormal.x * offset;\n        const dy = edge.outwardNormal.y * offset;\n        offsetEdges.push(createOffsetEdge(edge, dx, dy));\n    }\n    const vertices = [];\n    for (let i = 0; i < offsetEdges.length; i++) {\n        const thisEdge = offsetEdges[i];\n        const prevEdge = offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n        const vertex = edgesIntersection(prevEdge, thisEdge);\n        if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n            vertices.push({\n                x: vertex.x,\n                y: vertex.y,\n            });\n        }\n        else {\n            const arcCenter = polygon.edges[i].vertex1;\n            appendArc(arcSegments, vertices, arcCenter, offset, prevEdge.vertex2, thisEdge.vertex1, false);\n        }\n    }\n    const marginPolygon = createPolygon(vertices);\n    marginPolygon.offsetEdges = offsetEdges;\n    return marginPolygon;\n}\nfunction createPaddingPolygon(polygon: IPolygon, offset: number, arcSegments: number) {\n    const vertices = [];\n    for (let i = 0; i < polygon.edges.length; i++) {\n        const edge = polygon.edges[i];\n        cons, offset: number = edgeLength(edge.vertex1, edge.vertex2);\n        const dx = offset;\n        const dy = edgeLength(edge.vertex2, edge.vertex1);\n        vertices.push({\n            x: edge.vertex, arcSegments: arcSegments, dx, dy,\n        });\n    }\n    const marginPolygon = createPolygon(vertices);\n    marginPolygon.offsetEdges = offsetEdges;\n    return marginPolygon;\n}\nfunction createPolygon(vertices: IPolygonVertex[])): IPolygon {\n    const polygon = new Polygon();\n    polygon.edges = vertices.map((v, i) => new PolygonEdge(v, vertices[(i + 1) % vertices.length]));\n    return polygon;\n} {\n    const offsetEdges = [];\n    for (let i = 0; i < polygon.edges.length; i++) {\n        const edge = polygon.edges[i];\n        const dx = edge.inwardNormal.x * offset;\n        const dy = edge.inwardNormal.y * offset;\n        offsetEdges.push(createOffsetEdge(edge, dx, dy));\n    }\n    const vertices = [];\n    for (let i = 0; i < offsetEdges.length; i++) {\n        const thisEdge = offsetEdges[i];\n        const prevEdge = offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];\n        const vertex = edgesIntersection(prevEdge, thisEdge);\n        if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {\n            vertices.push({\n                x: vertex.x,\n                y: vertex.y,\n            });\n        }\n        else {\n            const arcCenter = polygon.edges[i].vertex1;\n            appendArc(arcSegments, vertices, arcCenter, offset, prevEdge.vertex2, thisEdge.vertex1, true);\n        }\n    }\n    const paddingPolygon = createPolygon(vertices);\n    paddingPolygon.offsetEdges = offsetEdges;\n    return paddingPolygon;\n}\nexport default function offsetPolygon(vertices: IPolygonVertex[], offset: number, arcSegments = 0) {\n    const polygon = createPolygon(vertices);\n    if (offset > 0) {\n        return createMarginPolygon(polygon, offset, arcSegments).edges;\n    }\n    else {\n        return creat, arcSegments: arcSegments, vertices: polygon.vertices, offset: -offset;\n    }\n}\nexport function offsetPolygon(vertices: IPolygonVertex[], offset: number, arcSegments = 0): IPolygonVertex[] {\n    const polygon = createPolygon(vertices);\n    if (offset > 0) {\n        return createMarginPolygon(polygon, offset, arcSegments).vertices;\n    }\n    else {\n        return createPaddingPolygon(polygon, -offset, arcSegments).vertices;\n    }\n}\n","score":392,"fallbacked":false,"num_type_errors":347}]}
{"dataset_elem":{"alphanum_fraction":0.5887204044,"avg_line_length":32.6869565217,"content":"/**\n * The MIT License (MIT)\n *\n * Igor Zinken 2016-2022 - https://www.igorski.nl\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * order of note names within a single octave\n */\nexport const OCTAVE_SCALE: Array<string> = [ \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" ];\n\n/**\n * @param {string} aNote - musical note to return ( A, B, C, D, E, F, G with\n *               possible enharmonic notes ( 'b' meaning 'flat', '#' meaning 'sharp' )\n *               NOTE: flats are CASE sensitive ( to prevent seeing the note 'B' instead of 'b' )\n * @param {number} aOctave - the octave to return ( accepted range 0 - 9 )\n * @return {number} containing exact frequency in Hz for requested note\n */\nexport const getFrequency = ( aNote: string, aOctave: number ): number => {\n    let freq;\n    let enharmonic = 0;\n\n    // detect flat enharmonic\n    let i = aNote.indexOf( \"b\" );\n    if ( i > -1 ) {\n        aNote = aNote.substr( i - 1, 1 );\n        enharmonic = -1;\n    }\n\n    // detect sharp enharmonic\n    i = aNote.indexOf( \"#\" );\n    if ( i > -1 ) {\n        aNote = aNote.substr( i - 1, 1 );\n        enharmonic = 1;\n    }\n\n    freq = getOctaveIndex( aNote, enharmonic );\n\n    if ( aOctave === 4 ) {\n        return freq;\n    }\n    else {\n        // translate the pitches to the requested octave\n        const d = aOctave - 4;\n        let j = Math.abs( d );\n\n        for ( i = 0; i < j; ++i ) {\n            if ( d > 0 ) {\n                freq *= 2;\n            }\n            else {\n                freq *= 0.5;\n            }\n        }\n        return freq;\n    }\n};\n\n/* internal methods */\n\n/**\n * pitch table for all notes from C to B at octave 4\n * which is used for calculating all pitches at other octaves\n */\nconst OCTAVE: Array<number> = [\n    261.626, 277.183, 293.665, 311.127, 329.628, 349.228, 369.994, 391.995, 415.305, 440, 466.164, 493.883\n];\n\n/**\n * retrieves the index in the octave array for a given note\n * modifier enharmonic returns the previous ( for a 'flat' note )\n * or next ( for a 'sharp' note ) index\n *\n * @param {string} aNote ( A, B, C, D, E, F, G )\n * @param {number=} aEnharmonic optional, defaults to 0 ( 0, -1 for flat, 1 for sharp )\n * @return {number}\n */\nfunction getOctaveIndex( aNote: string, aEnharmonic?: number ): number {\n    if ( typeof aEnharmonic !== \"number\" ) {\n        aEnharmonic = 0;\n    }\n\n    for ( let i = 0, j = OCTAVE.length; i < j; ++i ) {\n        if ( OCTAVE_SCALE[ i ] === aNote ) {\n            let k = i + aEnharmonic;\n\n            if ( k > j ) {\n                return OCTAVE[ 0 ];\n            }\n            if ( k < 0 ) {\n                return OCTAVE[ OCTAVE.length - 1 ];\n            }\n            return OCTAVE[ k ];\n        }\n    }\n    return NaN;\n}\n","content_without_annotations":"/**\n * The MIT License (MIT)\n *\n * Igor Zinken 2016-2022 - https://www.igorski.nl\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * order of note names within a single octave\n */\nexport const OCTAVE_SCALE = [ \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\" ];\n\n/**\n * @param {string} aNote - musical note to return ( A, B, C, D, E, F, G with\n *               possible enharmonic notes ( 'b' meaning 'flat', '#' meaning 'sharp' )\n *               NOTE: flats are CASE sensitive ( to prevent seeing the note 'B' instead of 'b' )\n * @param {number} aOctave - the octave to return ( accepted range 0 - 9 )\n * @return {number} containing exact frequency in Hz for requested note\n */\nexport const getFrequency = ( aNote, aOctave ) => {\n    let freq;\n    let enharmonic = 0;\n\n    // detect flat enharmonic\n    let i = aNote.indexOf( \"b\" );\n    if ( i > -1 ) {\n        aNote = aNote.substr( i - 1, 1 );\n        enharmonic = -1;\n    }\n\n    // detect sharp enharmonic\n    i = aNote.indexOf( \"#\" );\n    if ( i > -1 ) {\n        aNote = aNote.substr( i - 1, 1 );\n        enharmonic = 1;\n    }\n\n    freq = getOctaveIndex( aNote, enharmonic );\n\n    if ( aOctave === 4 ) {\n        return freq;\n    }\n    else {\n        // translate the pitches to the requested octave\n        const d = aOctave - 4;\n        let j = Math.abs( d );\n\n        for ( i = 0; i < j; ++i ) {\n            if ( d > 0 ) {\n                freq *= 2;\n            }\n            else {\n                freq *= 0.5;\n            }\n        }\n        return freq;\n    }\n};\n\n/* internal methods */\n\n/**\n * pitch table for all notes from C to B at octave 4\n * which is used for calculating all pitches at other octaves\n */\nconst OCTAVE = [\n    261.626, 277.183, 293.665, 311.127, 329.628, 349.228, 369.994, 391.995, 415.305, 440, 466.164, 493.883\n];\n\n/**\n * retrieves the index in the octave array for a given note\n * modifier enharmonic returns the previous ( for a 'flat' note )\n * or next ( for a 'sharp' note ) index\n *\n * @param {string} aNote ( A, B, C, D, E, F, G )\n * @param {number=} aEnharmonic optional, defaults to 0 ( 0, -1 for flat, 1 for sharp )\n * @return {number}\n */\nfunction getOctaveIndex( aNote, aEnharmonic? ) {\n    if ( typeof aEnharmonic !== \"number\" ) {\n        aEnharmonic = 0;\n    }\n\n    for ( let i = 0, j = OCTAVE.length; i < j; ++i ) {\n        if ( OCTAVE_SCALE[ i ] === aNote ) {\n            let k = i + aEnharmonic;\n\n            if ( k > j ) {\n                return OCTAVE[ 0 ];\n            }\n            if ( k < 0 ) {\n                return OCTAVE[ OCTAVE.length - 1 ];\n            }\n            return OCTAVE[ k ];\n        }\n    }\n    return NaN;\n}\n","dynamism_density":0.0008643042,"dynamism_heuristic":1,"estimated_tokens":1157,"ext":"ts","fun_ann_density":0.0051858254,"function_parameters":4,"function_signatures":0,"function_usages":1,"functions":2,"hexsha":"574a90b8366d07f821fdec6eb1f5c102e754c994","lang":"TypeScript","loc":53,"loc_per_function":22.5,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"b1265ab84a18e893d71bf537a534dc730d090f21","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"igorski/molecular-music-generator-web","max_forks_repo_path":"src/utils/PitchUtil.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"b1265ab84a18e893d71bf537a534dc730d090f21","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"igorski/molecular-music-generator-web","max_issues_repo_path":"src/utils/PitchUtil.ts","max_line_length":111,"max_stars_count":5.0,"max_stars_repo_head_hexsha":"b1265ab84a18e893d71bf537a534dc730d090f21","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"igorski/molecular-music-generator-web","max_stars_repo_path":"src/utils/PitchUtil.ts","max_stars_repo_stars_event_max_datetime":"2022-03-03T23:17:28.000Z","max_stars_repo_stars_event_min_datetime":"2022-02-02T01:45:08.000Z","metric":0.2128090911,"predefined_density":0.4705882353,"predefined_types":8,"prop_ann_density":0.0,"property_declarations":0,"size":3759,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0095073466,"variable_declarations":11},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * The MIT License (MIT)\n *\n * Igor Zinken 2016-2022 - https://www.igorski.nl\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/**\n * order of note names within a single octave\n */\nexport const OCTAVE_SCALE = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n/**\n * @param {string} aNote - musical note to return ( A, B, C, D, E, F, G with\n *               possible enharmonic notes ( 'b' meaning 'flat', '#' meaning 'sharp' )\n *               NOTE: flats are CASE sensitive ( to prevent seeing the note 'B' instead of 'b' )\n * @param {number} aOctave - the octave to return ( accepted range 0 - 9 )\n * @return {number} containing exact frequency in Hz for requested note\n */\nexport const getFrequency = (aNote: string, aOctave: number) => {\n    let notes = OCTAVE_SCALE.map((note, index) => ({ note, frequency: index }));\n    let notesIndex = notes.findIndex(x => x.note ===, aOctave: aOctave);\n    if (notesIndex > -1) {\n        return notes[notesIndex].frequency;\n    }\n    else {\n        throw new Error(\"Invalid octave specified: \" + aOctave);\n    }\n};\n/*): number {\n    let notes = OCTAVE_SCALE.map((note, index) => ({ note, frequency: index }));\n    let notesIndex = notes.findIndex(x => x.note ===, aOctave: aOctave) => {\n    let freq;\n    let enharmonic = 0;\n    // detect flat enharmonic\n    let i = aNote.indexOf(\"b\");\n    if (i > -1) {\n        aNote = aNote.substr(i - 1, 1);\n        enharmonic = -1;\n    }\n    // detect sharp enharmonic\n    i = aNote.indexOf(\"#\");\n    if (i > -1) {\n        aNote = aNote.substr(i - 1, 1);\n        enharmonic = 1;\n    }\n    freq = getOctaveIndex(aNote, enharmonic);\n    if (aOctave === 4) {\n        return freq;\n    }\n    else {\n        // translate the pitches to the requested octave\n        const d = aOctave - 4;\n        let j = Math.abs(d);\n        for (i = 0; i < j; ++i) {\n            if (d > 0) {\n                freq *= 2;\n            }\n            else {\n                freq *= 0.5;\n            }\n        }\n        return freq;\n    }\n};\n/* internal methods */\n/**\n * pitch table for all notes from C to B at octave 4\n * which is used for calculating all pitches at other octaves\n */\nconst OCTAVE = [\n    261.626, 277.183, 293.665, 311.127, 329.628, 349.228, 369.994, 391.995, 415.305, 440, 466.164, 493.883\n];\n/**\n * retrieves the index in the octave array for a given note\n * modifier enharmonic returns the previous ( for a 'flat' note )\n * or next ( for a 'sharp' note ) index\n *\n * @param {string} aNote ( A, B, C, D, E, F, G )\n * @param {number=} aEnharmonic optional, defaults to 0 ( 0, -1 for flat, 1 for sharp )\n * @return {number}\n */\nfunction getOctaveIndex(aNote: string, aEnharmonic?: number) {\n    return notesIndex(aNote, aEnharmonic);\n}\n\n/**\n * translate a note string ( A, B, C, D, E, F, G ) t, aEnharmonic?: number\n * into its index in the octave array\n *\n * @param {string} aNote ( A, B, C, D, E, F, G )\n * @param {number=} aEnharmonic optional): defaults to 0 ( 0, -1 for flat, 1 for sharp )\n * @return {number}\n */\nfunction notesIndex(aNote: string, aEnharmonic?: number) {\n    if (typeof aEnharmonic !== \"number\") {\n        aEnharmonic = 0;\n    }\n    for (let i = 0, j = OCTAVE.length; i < j; ++i) {\n        if (OCTAVE_SCALE[i] === aNote) {\n            let k = i + aEnharmonic;\n            if (k > j) {\n                return OCTAVE[0];\n            }\n            if (k < 0) {\n                return OCTAVE[OCTAVE.length - 1];\n            }\n            return OCTAVE[k];\n        }\n    }\n    return NaN;\n}\n","score":342,"fallbacked":false,"num_type_errors":3},{"code":"/**\n * The MIT License (MIT)\n *\n * Igor Zinken 2016-2022 - https://www.igorski.nl\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/**\n * order of note names within a single octave\n */\nexport const OCTAVE_SCALE = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n/**\n * @param {string} aNote - musical note to return ( A, B, C, D, E, F, G with\n *               possible enharmonic notes ( 'b' meaning 'flat', '#' meaning 'sharp' )\n *               NOTE: flats are CASE sensitive ( to prevent seeing the note 'B' instead of 'b' )\n * @param {number} aOctave - the octave to return ( accepted range 0 - 9 )\n * @return {number} containing exact frequency in Hz for requested note\n */\nexport const getFrequency = (aNote: string, aOctave: number) => {\n    // if no octave is specified, return 440Hz\n    if (aOctave === undefined) {\n        aOctave = 4;\n    }\n    // check for a, aOctave: [0-9]\n    if (!aNote ||![0, 1, 2, 3, 4, 5, 6, 7, 8, 9].includes(aOctave)) {): number {\n        throw new TypeError(\"Invalid octave number provided\");\n    }\n    // check for A: [0-9]\n    if (aNote === \"A\") {\n        aNote = \"C\";\n    }\n    // check for => {\n    let freq;\n    let enharmonic = 0;\n    // detect flat enharmonic\n    let i = aNote.indexOf(\"b\");\n    if (i > -1) {\n        aNote = aNote.substr(i - 1, 1);\n        enharmonic = -1;\n    }\n    // detect sharp enharmonic\n    i = aNote.indexOf(\"#\");\n    if (i > -1) {\n        aNote = aNote.substr(i - 1, 1);\n        enharmonic = 1;\n    }\n    freq = getOctaveIndex(aNote, enharmonic);\n    if (aOctave === 4) {\n        return freq;\n    }\n    else {\n        // translate the pitches to the requested octave\n        const d = aOctave - 4;\n        let j = Math.abs(d);\n        for (i = 0; i < j; ++i) {\n            if (d > 0) {\n                freq *= 2;\n            }\n            else {\n                freq *= 0.5;\n            }\n        }\n        return freq;\n    }\n};\n/* internal methods */\n/**\n * pitch table for all notes from C to B at octave 4\n * which is used for calculating all pitches at other octaves\n */\nconst OCTAVE = [\n    261.626, 277.183, 293.665, 311.127, 329.628, 349.228, 369.994, 391.995, 415.305, 440, 466.164, 493.883\n];\n/**\n * retrieves the index in the octave array for a given note\n * modifier enharmonic returns the previous ( for a 'flat' note )\n * or next ( for a 'sharp' note ) index\n *\n * @param {string} aNote ( A, B, C, D, E, F, G )\n * @param {number=} aEnharmonic optional, defaults to 0 ( 0, -1 for flat, 1 for sharp )\n * @return {number}\n */\nfunction getOctaveIndex(aNote: string, aEnharmonic?: number) {\n    if (aEnharmonic === undefined) {\n        aEnharmonic = 0;\n    }\n    const index = OCTAVE.findIndex((o: number) => {\n        i, aEnharmonic?: number;\n        return OCTAVE_SCALE[i] === aNote && OCTAVE_SCALE[i + aEnharmonic] === aNote;\n    });\n    return index;\n}\n\n/**\n * gets the pitch fro): -261.626 261.626 277.183 293.665 311.127 329.628 {\n    if (typeof aEnharmonic !== \"number\") {\n        aEnharmonic = 0;\n    }\n    for (let i = 0, j = OCTAVE.length; i < j; ++i) {\n        if (OCTAVE_SCALE[i] === aNote) {\n            let k = i + aEnharmonic;\n            if (k > j) {\n                return OCTAVE[0];\n            }\n            if (k < 0) {\n                return OCTAVE[OCTAVE.length - 1];\n            }\n            return OCTAVE[k];\n        }\n    }\n    return NaN;\n}\n","score":344,"fallbacked":false,"num_type_errors":11},{"code":"/**\n * The MIT License (MIT)\n *\n * Igor Zinken 2016-2022 - https://www.igorski.nl\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/**\n * order of note names within a single octave\n */\nexport const OCTAVE_SCALE = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n/**\n * @param {string} aNote - musical note to return ( A, B, C, D, E, F, G with\n *               possible enharmonic notes ( 'b' meaning 'flat', '#' meaning 'sharp' )\n *               NOTE: flats are CASE sensitive ( to prevent seeing the note 'B' instead of 'b' )\n * @param {number} aOctave - the octave to return ( accepted range 0 - 9 )\n * @return {number} containing exact frequency in Hz for requested note\n */\nexport const getFrequency = (aNote: string, aOctave: number): number => {\n    let freq;\n    let enharmonic = 0;\n    // detect flat enharmonic\n    let i = aNote.indexOf(\"b\");\n    if (i > -1, aOctave: number = 0) {\n        aNote = aNote.substr(i - 1, 1);\n        enharmonic = -1;\n    }\n    // detect sharp enharmonic\n    i = aNote.indexOf(\"#\");): number = 0) {\n        aNote = aNote.substr(i + 1, 1);\n        enharmonic = 1;\n    }\n    // translate the pitches to the requested octave\n    freq = getOctav => {\n    let freq;\n    let enharmonic = 0;\n    // detect flat enharmonic\n    let i = aNote.indexOf(\"b\");\n    if (i > -1) {\n        aNote = aNote.substr(i - 1, 1);\n        enharmonic = -1;\n    }\n    // detect sharp enharmonic\n    i = aNote.indexOf(\"#\");\n    if (i > -1) {\n        aNote = aNote.substr(i - 1, 1);\n        enharmonic = 1;\n    }\n    freq = getOctaveIndex(aNote, enharmonic);\n    if (aOctave === 4) {\n        return freq;\n    }\n    else {\n        // translate the pitches to the requested octave\n        const d = aOctave - 4;\n        let j = Math.abs(d);\n        for (i = 0; i < j; ++i) {\n            if (d > 0) {\n                freq *= 2;\n            }\n            else {\n                freq *= 0.5;\n            }\n        }\n        return freq;\n    }\n};\n/* internal methods */\n/**\n * pitch table for all notes from C to B at octave 4\n * which is used for calculating all pitches at other octaves\n */\nconst OCTAVE = [\n    261.626, 277.183, 293.665, 311.127, 329.628, 349.228, 369.994, 391.995, 415.305, 440, 466.164, 493.883\n];\n/**\n * retrieves the index in the octave array for a given note\n * modifier enharmonic returns the previous ( for a 'flat' note )\n * or next ( for a 'sharp' note ) index\n *\n * @param {string} aNote ( A, B, C, D, E, F, G )\n * @param {number=} aEnharmonic optional, defaults to 0 ( 0, -1 for flat, 1 for sharp )\n * @return {number}\n */\nfunction getOctaveIndex(aNote: string, aEnharmonic?: number) {\n    if (typeof aEnharmonic!== \"number\") {\n        aEnharmonic = 0;\n    }\n    let i = OCTAVE.indexOf(aNote);\n    if, aEnharmonic?: 1\n    0) {\n        return i;\n    }\n    else {\n        const x = (i + aEnharmonic) % (OCTAVE.length - 1);\n        return OCTAVE[x];\n    }\n}\n/*): [number] */\n/**\n * retrieves the index in the octave array for a given note\n * modifier enharmonic returns the previous ( for a 'flat' note )\n * or next ( for a'sharp' note ) inde {\n    if (typeof aEnharmonic !== \"number\") {\n        aEnharmonic = 0;\n    }\n    for (let i = 0, j = OCTAVE.length; i < j; ++i) {\n        if (OCTAVE_SCALE[i] === aNote) {\n            let k = i + aEnharmonic;\n            if (k > j) {\n                return OCTAVE[0];\n            }\n            if (k < 0) {\n                return OCTAVE[OCTAVE.length - 1];\n            }\n            return OCTAVE[k];\n        }\n    }\n    return NaN;\n}\n","score":375,"fallbacked":false,"num_type_errors":21}]}
{"dataset_elem":{"alphanum_fraction":0.6819772528,"avg_line_length":32.6571428571,"content":"export function normalizeRadians(angle) {\n  return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));\n}\n\nexport function computeRotation(point1, point2) {\n  const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);\n  return normalizeRadians(radians);\n}\n\nexport const buildTranslationMatrix = (x, y) => [[1, 0, x], [0, 1, y], [0, 0, 1]];\n\nexport function dot(v1, v2) {\n  let product = 0;\n  for (let i = 0; i < v1.length; i++) {\n    product += v1[i] * v2[i];\n  }\n  return product;\n}\n\nexport function getColumnFrom2DArr(arr, columnIndex) {\n  const column: Array<number> = [];\n  for (let i = 0; i < arr.length; i++) {\n    column.push(arr[i][columnIndex]);\n  }\n  return column;\n}\n\nexport function multiplyTransformMatrices(mat1, mat2) {\n  const product: Array<number[]> = [];\n  const size = mat1.length;\n  for (let row = 0; row < size; row++) {\n    product.push([]);\n    for (let col = 0; col < size; col++) {\n      product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));\n    }\n  }\n  return product;\n}\n\nexport function buildRotationMatrix(rotation, center) {\n  const cosA = Math.cos(rotation);\n  const sinA = Math.sin(rotation);\n  const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];\n  const translationMatrix = buildTranslationMatrix(center[0], center[1]);\n  const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);\n  const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);\n  return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);\n}\n\nexport function invertTransformMatrix(matrix) {\n  const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];\n  const translationComponent = [matrix[0][2], matrix[1][2]];\n  const invertedTranslation = [\n    -dot(rotationComponent[0], translationComponent),\n    -dot(rotationComponent[1], translationComponent),\n  ];\n  return [\n    rotationComponent[0].concat(invertedTranslation[0]),\n    rotationComponent[1].concat(invertedTranslation[1]),\n    [0, 0, 1],\n  ];\n}\n\nexport function rotatePoint(homogeneousCoordinate, rotationMatrix) {\n  return [\n    dot(homogeneousCoordinate, rotationMatrix[0]),\n    dot(homogeneousCoordinate, rotationMatrix[1]),\n  ];\n}\n","content_without_annotations":"export function normalizeRadians(angle) {\n  return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));\n}\n\nexport function computeRotation(point1, point2) {\n  const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);\n  return normalizeRadians(radians);\n}\n\nexport const buildTranslationMatrix = (x, y) => [[1, 0, x], [0, 1, y], [0, 0, 1]];\n\nexport function dot(v1, v2) {\n  let product = 0;\n  for (let i = 0; i < v1.length; i++) {\n    product += v1[i] * v2[i];\n  }\n  return product;\n}\n\nexport function getColumnFrom2DArr(arr, columnIndex) {\n  const column = [];\n  for (let i = 0; i < arr.length; i++) {\n    column.push(arr[i][columnIndex]);\n  }\n  return column;\n}\n\nexport function multiplyTransformMatrices(mat1, mat2) {\n  const product = [];\n  const size = mat1.length;\n  for (let row = 0; row < size; row++) {\n    product.push([]);\n    for (let col = 0; col < size; col++) {\n      product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));\n    }\n  }\n  return product;\n}\n\nexport function buildRotationMatrix(rotation, center) {\n  const cosA = Math.cos(rotation);\n  const sinA = Math.sin(rotation);\n  const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];\n  const translationMatrix = buildTranslationMatrix(center[0], center[1]);\n  const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);\n  const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);\n  return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);\n}\n\nexport function invertTransformMatrix(matrix) {\n  const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];\n  const translationComponent = [matrix[0][2], matrix[1][2]];\n  const invertedTranslation = [\n    -dot(rotationComponent[0], translationComponent),\n    -dot(rotationComponent[1], translationComponent),\n  ];\n  return [\n    rotationComponent[0].concat(invertedTranslation[0]),\n    rotationComponent[1].concat(invertedTranslation[1]),\n    [0, 0, 1],\n  ];\n}\n\nexport function rotatePoint(homogeneousCoordinate, rotationMatrix) {\n  return [\n    dot(homogeneousCoordinate, rotationMatrix[0]),\n    dot(homogeneousCoordinate, rotationMatrix[1]),\n  ];\n}\n","dynamism_density":0.0,"dynamism_heuristic":0,"estimated_tokens":689,"ext":"ts","fun_ann_density":0.0362844702,"function_parameters":16,"function_signatures":0,"function_usages":5,"functions":9,"hexsha":"c8c0eb3cd54ad278f0d858d396c8e71c98b9926b","lang":"TypeScript","loc":61,"loc_per_function":5.0,"max_forks_count":1.0,"max_forks_repo_forks_event_max_datetime":"2022-01-05T23:18:23.000Z","max_forks_repo_forks_event_min_datetime":"2022-01-05T23:18:23.000Z","max_forks_repo_head_hexsha":"ac44363382a10a753f3e99dfb18fd75ff6eafbec","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"BTTHuyen/Human_library","max_forks_repo_path":"src/handpose/util.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"ac44363382a10a753f3e99dfb18fd75ff6eafbec","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"BTTHuyen/Human_library","max_issues_repo_path":"src/handpose/util.ts","max_line_length":96,"max_stars_count":null,"max_stars_repo_head_hexsha":"ac44363382a10a753f3e99dfb18fd75ff6eafbec","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"BTTHuyen/Human_library","max_stars_repo_path":"src/handpose/util.ts","max_stars_repo_stars_event_max_datetime":null,"max_stars_repo_stars_event_min_datetime":null,"metric":0.3462763355,"predefined_density":0.0454545455,"predefined_types":2,"prop_ann_density":0.0,"property_declarations":0,"size":2286,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0275761974,"variable_declarations":19},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"export function normalizeRadians(angle: number) {\n    return angle - Math.floor(angle / Math.PI) * Math.PI;\n}\nexport function normalizeDegrees(angle: number) {\n    return angle - 2 * Math.floor((angle +): number) * 360;\n}\nexport function isZero(val: number) {\n    return val === 0;\n}\nexport function isPositive(val: number) {\n    return val > 0; {\n    return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));\n}\nexport function computeRotation(point1: [number, number], point2: [number, number]) {\n    const angle = computeAngleBetweenVectors(point1, point2);\n    return normalizeRadians(angle);\n}\nexport function computeAngleBetweenVectors(point1:, point2: [number, number]) {\n    const x1 = point1[0];\n    const y1 = point1[1];\n    const x2 = point2[0];\n    const y2 = point2[1];\n    const dx): number = x2 - x1;\n    const dy = y2 - y1;\n    return Math.atan2(dy, dx);\n}\nexport function computeAngle(point1: [number, number], point2: [numbe {\n    const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);\n    return normalizeRadians(radians);\n}\nexport const buildTranslationMatrix = (x: number, y: number) => [[1, 0, x], [0, 1, y], [0, 0, 1]];\nexport function transformPoint(matrix: [number, number, number, number], poin, y: number, x: number) {\n    return [matrix[0][0] * poin[0] + matrix[0][1] * poin[1] + matrix[0][2], matrix[1][0] *): [number, number] | undefined;\n}\nexport function getDistance(v1: [number, number], v2: [number, number]) {\n    return Math.sqrt(dot(v1, v1) + dot => [[1, 0, x], [0, 1, y], [0, 0, 1]];\nexport function dot(v1: [number, number], v2: [number, number]) {\n    return v1[0] * v2[0] + v1[1] * v2[1];\n}\nexport function cross(v1:, v2: [number, number]) {\n    return v1[0] * v2[1] - v1[1] * v2[0];\n}\nexport function normalizeRadians(radians: number) {\n    if (radians <): return radians;\n    else return radians - Math.PI * 2;\n}\nexport function normalizeAngle(angle: number) {\n    if (angle <): return angle;\n    else return angle - Math.PI * 2; {\n    let product = 0;\n    for (let i = 0; i < v1.length; i++) {\n        product += v1[i] * v2[i];\n    }\n    return product;\n}\nexport function getColumnFrom2DArr(arr: [number], columnIndex: number) {\n    const column = [];\n    for (let i = 0; i < arr.length; i++) {\n        column.push(arr[i][columnIndex]);\n    }\n    return column;, columnIndex: number;\n}\nexport function getRowFrom2DArr(arr: [number], rowIndex: number) {\n    const row = [];\n    for (let i = 0; i < arr.length; i++) {\n        row.pus): [number, number] | undefined {\n        row.push(arr[rowIndex][i]);\n    }\n    return row;\n}\nexport function buildTranslationMatrix(x: number, y: number) {\n    const m = [ {\n    const column = [];\n    for (let i = 0; i < arr.length; i++) {\n        column.push(arr[i][columnIndex]);\n    }\n    return column;\n}\nexport function multiplyTransformMatrices(mat1: [number, number], mat2: [number, number]) {\n    const product = [];\n    const size = mat1.length;\n    for (let row = 0; row < size; row++) {\n        product.push([]);, mat2: [number, number] | undefined {\n            product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, 0)));\n        }\n    }\n    return product;\n}\nexport function buildTranslationMatri): [number, number] {\n    return [\n        x,\n        y\n    ];\n}\nexport function getCenter(points: [number, number]) {\n    const [centerX, centerY] = points.map(p => p * {\n    const product = [];\n    const size = mat1.length;\n    for (let row = 0; row < size; row++) {\n        product.push([]);\n        for (let col = 0; col < size; col++) {\n            product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));\n        }\n    }\n    return product;\n}\nexport function buildRotationMatrix(rotation: number) {\n    const rotationMatrix = [\n        [Math.cos(rotation), -Math.sin(rotation), 0],\n        [Math.sin(rotation), Math.cos(rotation), 0],\n        [0,, center: [x, y]]\n    ];\n    return rotationMatrix;\n}\nexport function getTransformedPoints(points: [number, number], rotation: number, center: [number, number]) {\n    const transformedPoints = points.map(poin): [number, number] | undefined {\n        transformedPoints: [number, number] | undefined;\n        const size = mat1.length;\n        for (let row = 0; row < size; row++) {\n            transformedPoints.pus {\n    const cosA = Math.cos(rotation);\n    const sinA = Math.sin(rotation);\n    const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];\n    const translationMatrix = buildTranslationMatrix(center[0], center[1]);\n    const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);\n    const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);\n    return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);\n}\nexport function invertTransformMatrix(matrix: [number, number][]) {\n    const size = matrix.length;\n    const invertedMatrix = [\n        [0, 0],\n        [0, 0],\n        [0, 0],\n    ];\n    for (let row): [number, number][] {\n        for (let col = 0; col < size; col++) {\n            invertedMatrix[col].push(matrix[row][col]);\n        }\n    }\n    return invertedMatrix;\n}\nexpor {\n    const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];\n    const translationComponent = [matrix[0][2], matrix[1][2]];\n    const invertedTranslation = [\n        -dot(rotationComponent[0], translationComponent),\n        -dot(rotationComponent[1], translationComponent),\n    ];\n    return [\n        rotationComponent[0].concat(invertedTranslation[0]),\n        rotationComponent[1].concat(invertedTranslation[1]),\n        [0, 0, 1],\n    ];\n}\nexport function rotatePoint(homogeneousCoordinate: [number, number], rotationMatrix: [number, number][]) {\n    return [\n        homogeneousCoordinate[0] * rotationMatrix[0][0] + homogeneousCoordinate[1] * rotationMatrix[0][1],\n        ho, rotationMatrix: [\n            [rotationMatrix[0][0] * homogeneousCoordinate[0] + rotationMatrix[0][1] * homogeneousCoordinate[1], rotationMatrix[0][0] * homogeneousCoordinate[1] - rotationMatrix): [number, number]\n        ],\n    ];\n}\nexport function rotatePointWithTranslation(homogeneousCoordinate: [number, number], rotationMatrix: [number, number][], center: [number, number]): [number, number] {\n    return [\n        dot(homogeneousCoordinate, rotationMatrix[0]),\n        dot(homogeneousCoordinate, rotationMatrix[1]),\n    ];\n}\n","score":209,"fallbacked":false,"num_type_errors":160},{"code":"export function normalizeRadians(angle: number) {\n    return angle % (2 * Math.PI);\n}\nexport function clamp(min: number, max: number, value: number) {\n    return Math.min(Math.max(value, min), max)): number;\n}\nexport function createEmptyObject() {\n    return Object.create(null);\n}\nexport function isNil(value: any) {\n    return value === null || value === undefined;\n}\nexport function isNumeri {\n    return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));\n}\nexport function computeRotation(point1: [number, number], point2: [number, number]) {\n    const radians = angleToRadians(point1, point2);\n    const rotation = Math.floor(Math.abs(radians) / (2 * Math.PI), point2: [number, number]) % 360;\n    return rotation;\n}\nexport function angleToRadians(point1: [number, number], point2: [number, number]) {\n    const radians = Math.atan2): number {\n    const radians = (point2[0] - point1[0]) * (point2[1] - point1[1]) + point1[0] * point2[0] + point2[1] {\n    const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);\n    return normalizeRadians(radians);\n}\nexport const buildTranslationMatrix = (x: number, y: number, z: number, rotation: number) => [\n    [Math.cos(rotation), -Math.sin(rotation), 0, x],\n    [Math.sin(rotation), Math.cos(rotation), y: y, 0],\n    [0, 0, z, 1],\n];\nexport function buildRotationMatrix(x: number, y: number, z: number, rotation: number) {\n    const rotationMatrix = buildTranslatio): [[number, number, number], [number, number, number], [number, number, number], [number, number, number]] {\n    const translationMatrix = buildTranslationMatrix(x, y, z, rotation);\n    const rotationMatri => [[1, 0, x], [0, 1, y], [0, 0, 1]];\nexport function dot(v1: [number, number, number], v2: [number, number, number]) {\n    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2], v2: [number, number, number];\n}\nexport function normalizeRadians(radians) {\n    return radians - Math.floor(radians / (2 * Math.PI));\n}\nexport function addVectors(v1: [number, numbe): [number, number] {\n    let x = 0;\n    let y = 0;\n    let z = 0;\n    for (let i = 0; i < 3; i++) {\n        x += v1 {\n    let product = 0;\n    for (let i = 0; i < v1.length; i++) {\n        product += v1[i] * v2[i];\n    }\n    return product;\n}\nexport function getColumnFrom2DArr(arr: [number, number], column: number) {\n    const column = [];\n    for (let i = 0; i < 3; i++) {\n        column.push(arr[i][column]);\n    }\n    return column;, columnIndex: number {\n        const a = column[0];\n        const b = column[1];\n        const c = column[2];\n        const s = Math.sqrt(a * a + b * b + c * c);\n        return [): [number, number] {\n            const c = Math.cos(radians);\n            const s = Math.sin(radians);\n            return [c * a + s * b, c * b - s * a, c * c + {\n    const column = [];\n    for (let i = 0; i < arr.length; i++) {\n        column.push(arr[i][columnIndex]);\n    }\n    return column;\n}\nexport function multiplyTransformMatrices(mat1: [[number, number, number], [number, number, number], [number, number, number]], mat2: [[number, number, number], [number, number, number], [number, number, number]], mat3: [[numbe, mat2: [number, number, number], [number, number, number], [number, number, number]]], mat4: [[numbe, [mat3: 0, [0, 0, 0, 1]]], mat): [number, number] {\n    const res = mat4;\n    const x = res[0][0] * mat1[0][0] + res[0][1] * mat1[1][0] + res[ {\n    const product = [];\n    const size = mat1.length;\n    for (let row = 0; row < size; row++) {\n        product.push([]);\n        for (let col = 0; col < size; col++) {\n            product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));\n        }\n    }\n    return product;\n}\nexport function buildRotationMatrix(rotation: number): [[number, number, number], [number, number, number], [number, number, number]] {\n    const rotationMatrix = [[Math.cos(rotation), -Math.sin(rotation), 0], [Math.si, center: [0, 0, 1]], [0, 0, 1]];\n    return rotationMatrix;\n}\nexport function buildTranslationMatrix(x: number, y: number): [[number, number, number], [number): [number, number, number], [number]: [number, number]] {\n    const xMatrix = [[1, 0, x], [0, 1, 0], [0, 0, 1]];\n    const {\n    const cosA = Math.cos(rotation);\n    const sinA = Math.sin(rotation);\n    const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];\n    const translationMatrix = buildTranslationMatrix(center[0], center[1]);\n    const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);\n    const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);\n    return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);\n}\nexport function invertTransformMatrix(matrix: [[number, [number, number]]], angle: number): [[number, [number, number]]], mat3: [[number, [number, number]]], mat: [[number, [number, number]]], [number, number]] {\n    if): [number, [number, number]] {\n        const determinant = determinant2DArr(matrix);\n        if (determinant === 0) {\n            throw new Error(\"Rotation matrix cannot be inverted!\");\n        }\n        const matrixInverse {\n    const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];\n    const translationComponent = [matrix[0][2], matrix[1][2]];\n    const invertedTranslation = [\n        -dot(rotationComponent[0], translationComponent),\n        -dot(rotationComponent[1], translationComponent),\n    ];\n    return [\n        rotationComponent[0].concat(invertedTranslation[0]),\n        rotationComponent[1].concat(invertedTranslation[1]),\n        [0, 0, 1],\n    ];\n}\nexport function rotatePoint(homogeneousCoordinate: [number, number], rotation: number): [number, number] {\n    const rotationMatrix = buildRotationMatrix(rotation);\n    const homogeneousCoordinateTransformed = applyTransformMatrix(homogeneousCoordinate, rotationMatrix);\n    return homogeneousCoordinateTransforme, rotationMatrix: [mat3, mat];\n}\nexport function applyTransformMatrix(homogeneousCoordinate: [number, number], rotationMatrix: [mat3, mat]): [number, number] {\n    const translationMatrix = buildTranslationMatrix(homogeneou): [mat3, mat];\n    const homogeneousCoordinateTransformed = multiplyMatrices(rotationMatrix, translationMatrix, homogeneousCoordinate);\n    return homogeneousCoordinateTransformed;\n}\nexport function applyTransformationMatrix(homogeneousCoordinate: [number, numbe {\n    return [\n        dot(homogeneousCoordinate, rotationMatrix[0]),\n        dot(homogeneousCoordinate, rotationMatrix[1]),\n    ];\n}\n","score":143,"fallbacked":false,"num_type_errors":187},{"code":"export function normalizeRadians(angle: number) {\n    angle = angle % (Math.PI * 2);\n    if (angle < 0) {\n        angle = angle + Math.PI * 2;\n    }\n    return angle;\n}\nexport function isUni): boolean {\n    return Math.abs(angle - Math.PI) < 1e-6;\n}\nexport function isUnitaryAngle(angle: number) {\n    return Math.abs(angle - Math.PI * {\n    return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));\n}\nexport function computeRotation(point1: number[], point2: number[]) {\n    const radians = computeRadiansBetweenPoints(point1, point2);\n    return normalizeRadians(radians);\n}\nexport function computeRadiansBetweenPoints(point1: number[], point2: number[], point2: number[], point2: number[]) {\n    const [x1, y1, z1] = point1;\n    const [x2, y2, z2] = point2;\n    return Math.atan2(y2): {\n        [x2 - x1, y2 - y1, z2 - z1];\n    };\n}\nexport function computeRotationMatrix(point1: number[], point2: number[], point2: number[]) {\n    cons {\n    const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);\n    return normalizeRadians(radians);\n}\nexport const buildTranslationMatrix = (x: number, y: number, z: number) => [[1, 0, x], [0, 1, y], [0, 0, z]];\nexport function buildRotationMatrix(rotation, center) {\n    const co, y: number, z: number;\n    if (rotation === 'XYZ') {\n        [x, y, z] = center;\n        co = [1, 0, 0, 0, 0, 0, 1): any;\n    } else {\n        const [x, y, z] = center;\n        co = [-x, -y, -z, x * x + y * y + z * z, x * x - y * y => [[1, 0, x], [0, 1, y], [0, 0, 1]];\nexport function dot(v1: number[], v2: number[]) {\n    let prod = 0;\n    for (let i = 0; i < v1.length; i++) {\n        prod += v1[i] * v2[i];, v2: any;\n    }\n    return prod;\n}\nexport function buildTransformMatrix(rotation, center) {\n    const co, y: number, z: number;\n    if (rotation === 'XYZ') {\n        [x, y,): any;\n        co = [1, 0, 0, 0, 0, 0, 1]: any;\n    } else {\n        [x, y, z]: any;\n        co = [-x, - {\n    let product = 0;\n    for (let i = 0; i < v1.length; i++) {\n        product += v1[i] * v2[i];\n    }\n    return product;\n}\nexport function getColumnFrom2DArr(arr: any, columnIndex: number) {\n    const column = [];\n    for (let i = 0; i < arr.length; i++) {\n        column.push(arr[i][columnIndex]);\n    }\n    return column;\n}, columnIndex: number) {\n    const column = getColumnFrom2DArr(arr, columnIndex);\n    return column;\n}, center: [number[], number[]] {\n    const [x, y] = center;\n    return [\n    [1,): any,\n    [0, 1]: any,\n    [0, 0, 1]: any,\n    [0, x]: any,\n    [0, y]: any,\n    [0, 0, z]: any] {\n    const column = [];\n    for (let i = 0; i < arr.length; i++) {\n        column.push(arr[i][columnIndex]);\n    }\n    return column;\n}\nexport function multiplyTransformMatrices(mat1: any, mat2: any): any {\n    let result = [];\n    const size = mat1.length;\n    for (let row = 0; row < size; row++) {\n        result.push([]);\n        for (let col, mat2: any {\n            const val = mat1[row][col];\n            const mat2val = mat2[row][col];\n            result[row].push(val * mat2val);\n        }\n    }\n    return result;\n}): any {\n    let result: any = [];\n    const size = mat1.length;\n    for (let row = 0; row < size; row++) {\n        result.push([]);\n        for (let col = 0; col {\n    const product = [];\n    const size = mat1.length;\n    for (let row = 0; row < size; row++) {\n        product.push([]);\n        for (let col = 0; col < size; col++) {\n            product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));\n        }\n    }\n    return product;\n}\nexport function buildRotationMatrix(rotation: number, center: [number, number]) {\n    const cosA = Math.cos(rotation);\n    const sinA = Math.sin(rotation);\n    return [\n    [cosA, sinA, 0],\n    [-sin, center: center],\n    [0, 0, 1] {\n    const centerColumn = getColumnFrom2DArr(center, 0);\n    const centerRow = getColumnFrom2DArr(center, 1);\n    const rotationMatrix): any {\n    const columnMatrix = [[centerColumn[0], centerColumn[1], centerColumn[2]], [centerRow[0], centerRow[1], centerRow[2]], [centerColumn[0], centerRow[0] {\n    const cosA = Math.cos(rotation);\n    const sinA = Math.sin(rotation);\n    const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];\n    const translationMatrix = buildTranslationMatrix(center[0], center[1]);\n    const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);\n    const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);\n    return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);\n}\nexport function invertTransformMatrix(matrix: [number, number, number]) {\n    const determinant = matrix[0][0] * matrix[1][1] * matrix[2][2] - matrix[0][1] * matrix[1][2] * matrix): number;\n    return [\n    [matrix[0][0] / determinant, matrix[1][0] / determinant, matrix[2][0] / determinant],\n    [matrix[0][1] / determinant, matri {\n    const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];\n    const translationComponent = [matrix[0][2], matrix[1][2]];\n    const invertedTranslation = [\n        -dot(rotationComponent[0], translationComponent),\n        -dot(rotationComponent[1], translationComponent),\n    ];\n    return [\n        rotationComponent[0].concat(invertedTranslation[0]),\n        rotationComponent[1].concat(invertedTranslation[1]),\n        [0, 0, 1],\n    ];\n}\nexport function rotatePoint(homogeneousCoordinate: [number, number], rotationMatrix: [number, number, number]) {\n    const x = homogeneousCoordinate[0];\n    const y = homogeneousCoordinate[1];\n    const z = homogeneousCoordinate[2];\n    return [, rotationMatrix: [number, number, number], x, y, z];\n}\nexport function multiplyTransformMatrices(matrixA: [number, number, number], matrixB: [number, number, number]) {\n    return [\n        [matrix): [number, number, number],\n        [matrix]: [number, number, number],\n    ];\n}\nexport function transformCoordinate(homogeneousCoordinate: [number, number], rotationMatrix: [number, number, number]): [number {\n    return [\n        dot(homogeneousCoordinate, rotationMatrix[0]),\n        dot(homogeneousCoordinate, rotationMatrix[1]),\n    ];\n}\n","score":261,"fallbacked":false,"num_type_errors":332}]}
{"dataset_elem":{"alphanum_fraction":0.5791800643,"avg_line_length":23.9230769231,"content":"/**\n * 动态规划\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap(height: number[]): number {\n  const len = height.length\n  if (!len) return 0\n\n  // 记录从左到右扫描的最大值数组\n  const leftMax: number[] = new Array(len).fill(0)\n  for (let i = 0; i < len; i++)\n    leftMax[i] = i === 0 ? height[i] : Math.max(leftMax[i - 1], height[i])\n\n  // 记录从右到左扫描的最大值数组\n  const rightMax = new Array(len).fill(0)\n  for (let i = len - 1; i >= 0; i--) {\n    rightMax[i]\n      = i === len - 1 ? height[i] : Math.max(rightMax[i + 1], height[i])\n  }\n\n  let ans = 0\n  // leftMax和rightMax重叠的区域减掉height[i]就是对应区域的接水量\n  for (let i = 0; i < len; i++)\n    ans += Math.min(leftMax[i], rightMax[i]) - height[i]\n\n  return ans\n}\n\n/**\n * 单调栈\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap2(height: number[]): number {\n  let ans = 0\n  const stack: number[] = []\n  for (let i = 0; i < height.length; i++) {\n    while (\n      stack.length\n      && /* 栈有值 */ height[i]\n        > height[stack[stack.length - 1]] /* 当前高度比上一个高度高的话 */\n    ) {\n      // 获取栈顶，并弹出\n      const top = stack.pop() as number\n\n      // 确保栈还有值\n      if (!stack.length) break\n\n      // 获取左边坐标\n      const left = stack[stack.length - 1] as number\n      // 计算出宽高\n      const w = i - left - 1\n      const h = Math.min(height[left], height[i]) - height[top]\n      ans += w * h\n    }\n\n    // 入栈\n    stack.push(i)\n  }\n\n  return ans\n}\n\n/**\n * 双指针\n * @desc 时间复杂度 O(N)  空间复杂度 O(1)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap3(height: number[]): number {\n  let ans = 0\n\n  let left = 0\n  let right: number = height.length - 1\n  let leftMaxHeight = 0\n  let rightMaxHeight = 0\n\n  while (left < right) {\n    // 更新左右最大高度\n    leftMaxHeight = Math.max(leftMaxHeight, height[left])\n    rightMaxHeight = Math.max(rightMaxHeight, height[right])\n\n    if (height[left] < height[right]) {\n      // 当height[left] < height[right] 在动态规划中必有leftMax[left] < rightMax[left]\n      // 因此在动态规划中，此时的高度为 Math.min(leftMax[left], rightMax[left]) - height[left]\n      // 即 leftMaxHeight - height[left]\n      ans += leftMaxHeight - height[left]\n      left++\n    }\n    else {\n      // 同理，当height[left] >= height[right] 在动态规划中必有leftMax[right] >= rightMax[right]\n      // 因此在动态规划中，此时的高度为 Math.min(leftMax[right], rightMax[right]) - height[right]\n      // 即 rightMaxHeight - height[right]\n      ans += rightMaxHeight - height[right]\n      right--\n    }\n  }\n\n  return ans\n}\n","content_without_annotations":"/**\n * 动态规划\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap(height) {\n  const len = height.length\n  if (!len) return 0\n\n  // 记录从左到右扫描的最大值数组\n  const leftMax = new Array(len).fill(0)\n  for (let i = 0; i < len; i++)\n    leftMax[i] = i === 0 ? height[i] : Math.max(leftMax[i - 1], height[i])\n\n  // 记录从右到左扫描的最大值数组\n  const rightMax = new Array(len).fill(0)\n  for (let i = len - 1; i >= 0; i--) {\n    rightMax[i]\n      = i === len - 1 ? height[i] : Math.max(rightMax[i + 1], height[i])\n  }\n\n  let ans = 0\n  // leftMax和rightMax重叠的区域减掉height[i]就是对应区域的接水量\n  for (let i = 0; i < len; i++)\n    ans += Math.min(leftMax[i], rightMax[i]) - height[i]\n\n  return ans\n}\n\n/**\n * 单调栈\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap2(height) {\n  let ans = 0\n  const stack = []\n  for (let i = 0; i < height.length; i++) {\n    while (\n      stack.length\n      && /* 栈有值 */ height[i]\n        > height[stack[stack.length - 1]] /* 当前高度比上一个高度高的话 */\n    ) {\n      // 获取栈顶，并弹出\n      const top = stack.pop() as number\n\n      // 确保栈还有值\n      if (!stack.length) break\n\n      // 获取左边坐标\n      const left = stack[stack.length - 1] as number\n      // 计算出宽高\n      const w = i - left - 1\n      const h = Math.min(height[left], height[i]) - height[top]\n      ans += w * h\n    }\n\n    // 入栈\n    stack.push(i)\n  }\n\n  return ans\n}\n\n/**\n * 双指针\n * @desc 时间复杂度 O(N)  空间复杂度 O(1)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap3(height) {\n  let ans = 0\n\n  let left = 0\n  let right = height.length - 1\n  let leftMaxHeight = 0\n  let rightMaxHeight = 0\n\n  while (left < right) {\n    // 更新左右最大高度\n    leftMaxHeight = Math.max(leftMaxHeight, height[left])\n    rightMaxHeight = Math.max(rightMaxHeight, height[right])\n\n    if (height[left] < height[right]) {\n      // 当height[left] < height[right] 在动态规划中必有leftMax[left] < rightMax[left]\n      // 因此在动态规划中，此时的高度为 Math.min(leftMax[left], rightMax[left]) - height[left]\n      // 即 leftMaxHeight - height[left]\n      ans += leftMaxHeight - height[left]\n      left++\n    }\n    else {\n      // 同理，当height[left] >= height[right] 在动态规划中必有leftMax[right] >= rightMax[right]\n      // 因此在动态规划中，此时的高度为 Math.min(leftMax[right], rightMax[right]) - height[right]\n      // 即 rightMaxHeight - height[right]\n      ans += rightMaxHeight - height[right]\n      right--\n    }\n  }\n\n  return ans\n}\n","dynamism_density":0.0021231423,"dynamism_heuristic":2,"estimated_tokens":942,"ext":"ts","fun_ann_density":0.0063694268,"function_parameters":3,"function_signatures":0,"function_usages":0,"functions":3,"hexsha":"9411bc35f0916e880babde2f1f971f7c4f02165d","lang":"TypeScript","loc":56,"loc_per_function":16.6666666667,"max_forks_count":null,"max_forks_repo_forks_event_max_datetime":null,"max_forks_repo_forks_event_min_datetime":null,"max_forks_repo_head_hexsha":"50e61ce16d1c419ccefc075ae9ead721cdd1cdbb","max_forks_repo_licenses":["MIT"],"max_forks_repo_name":"OUDUIDUI/leet-code","max_forks_repo_path":"problemset/trapping-rain-water/index.ts","max_issues_count":null,"max_issues_repo_head_hexsha":"50e61ce16d1c419ccefc075ae9ead721cdd1cdbb","max_issues_repo_issues_event_max_datetime":null,"max_issues_repo_issues_event_min_datetime":null,"max_issues_repo_licenses":["MIT"],"max_issues_repo_name":"OUDUIDUI/leet-code","max_issues_repo_path":"problemset/trapping-rain-water/index.ts","max_line_length":84,"max_stars_count":6.0,"max_stars_repo_head_hexsha":"50e61ce16d1c419ccefc075ae9ead721cdd1cdbb","max_stars_repo_licenses":["MIT"],"max_stars_repo_name":"OUDUIDUI/leet-code","max_stars_repo_path":"problemset/trapping-rain-water/index.ts","max_stars_repo_stars_event_max_datetime":"2022-01-17T05:45:39.000Z","max_stars_repo_stars_event_min_datetime":"2022-01-17T03:19:56.000Z","metric":0.2499917776,"predefined_density":0.44,"predefined_types":11,"prop_ann_density":0.0,"property_declarations":0,"size":2488,"trivial_density":0.0,"trivial_types":0,"type_definitions":0,"typedef_density":0.0,"var_ann_density":0.0201698514,"variable_declarations":19},"failed_message":null,"eval_spec":{"model":"santacoder","strategy":"simple","local_model_socket":"/tmp/santa0.sock,/tmp/santa1.sock,/tmp/santa2.sock,/tmp/santa3.sock,/tmp/santa4.sock,/tmp/santa5.sock,/tmp/santa6.sock,/tmp/santa7.sock","remote_model_key":null,"language":"ts","results_path":"results/santacoder_baseline_noparser_normal_ts-eval-subset.json","dataset_path":"data/ts-eval-subset.jsonl","num_comps":3,"retries":1,"fallback":false,"stop_at":400,"enable_defgen":false,"enable_usages":false,"enable_stubbing":false,"depth_limit":null,"max_type_quality":1000,"temperature":0.75,"types":["FuncDecl","FuncExpr","ClassProp","ClassMethod","TypeDecl"]},"stats":null,"completions":[{"code":"/**\n * 动态规划\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap(height: number[]) {\n    const len = height.length;\n    if (!len)\n        return 0;\n    // 记录从左到右扫描的最大值数组\n    const leftMax = new Array(len).fill(0)): any;\n    // 记录从右到左扫描的最大值数组\n    const rightMax = new Array(len).fill(0);\n    for (let i = 0; i < len; i++) {\n        // {\n    const len = height.length;\n    if (!len)\n        return 0;\n    // 记录从左到右扫描的最大值数组\n    const leftMax = new Array(len).fill(0);\n    for (let i = 0; i < len; i++)\n        leftMax[i] = i === 0 ? height[i] : Math.max(leftMax[i - 1], height[i]);\n    // 记录从右到左扫描的最大值数组\n    const rightMax = new Array(len).fill(0);\n    for (let i = len - 1; i >= 0; i--) {\n        rightMax[i]\n            = i === len - 1 ? height[i] : Math.max(rightMax[i + 1], height[i]);\n    }\n    let ans = 0;\n    // leftMax和rightMax重叠的区域减掉height[i]就是对应区域的接水量\n    for (let i = 0; i < len; i++)\n        ans += Math.min(leftMax[i], rightMax[i]) - height[i];\n    return ans;\n}\n/**\n * 单调栈\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap2(height: number[]) {\n    const len = height.length;\n    if (!len)\n        return 0;\n    // 记录单调栈的最大值数组\n    const stack = [];\n    // 记录单调栈的最小值数组\n    cons): any {\n        if (!len)\n            return 0;\n        let ans = 0;\n        for (let i = 0; i < len; i++) {\n            const len = height.length;\n            // 记录单调 {\n    let ans = 0;\n    const stack = [];\n    for (let i = 0; i < height.length; i++) {\n        while (stack.length\n            && /* 栈有值 */ height[i]\n                > height[stack[stack.length - 1]] /* 当前高度比上一个高度高的话 */) {\n            // 获取栈顶，并弹出\n            const top = stack.pop() as number;\n            // 确保栈还有值\n            if (!stack.length)\n                break;\n            // 获取左边坐标\n            const left = stack[stack.length - 1] as number;\n            // 计算出宽高\n            const w = i - left - 1;\n            const h = Math.min(height[left], height[i]) - height[top];\n            ans += w * h;\n        }\n        // 入栈\n        stack.push(i);\n    }\n    return ans;\n}\n/**\n * 双指针\n * @desc 时间复杂度 O(N)  空间复杂度 O(1)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap3(height: number[]) {\n    let ans = 0;\n    let left = 0;\n    let right = height.length - 1;\n    let leftMaxHeight = 0;\n    let rightMaxHeight = 0;\n    while (lef): any {\n        if (height[left] < leftMaxHeight) {\n            // 左栈中左栈顶元素小于左栈的最大值，也就是左栈顶元素出栈\n            leftMaxHeight = height[left]; {\n    let ans = 0;\n    let left = 0;\n    let right = height.length - 1;\n    let leftMaxHeight = 0;\n    let rightMaxHeight = 0;\n    while (left < right) {\n        // 更新左右最大高度\n        leftMaxHeight = Math.max(leftMaxHeight, height[left]);\n        rightMaxHeight = Math.max(rightMaxHeight, height[right]);\n        if (height[left] < height[right]) {\n            // 当height[left] < height[right] 在动态规划中必有leftMax[left] < rightMax[left]\n            // 因此在动态规划中，此时的高度为 Math.min(leftMax[left], rightMax[left]) - height[left]\n            // 即 leftMaxHeight - height[left]\n            ans += leftMaxHeight - height[left];\n            left++;\n        }\n        else {\n            // 同理，当height[left] >= height[right] 在动态规划中必有leftMax[right] >= rightMax[right]\n            // 因此在动态规划中，此时的高度为 Math.min(leftMax[right], rightMax[right]) - height[right]\n            // 即 rightMaxHeight - height[right]\n            ans += rightMaxHeight - height[right];\n            right--;\n        }\n    }\n    return ans;\n}\n","score":419,"fallbacked":false,"num_type_errors":10},{"code":"/**\n * 动态规划\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap(height: number[]): number {\n    const len = height.length;\n    if (!len)\n        return 0;\n    // 记录从左到右扫描的最大值数组\n    const leftMax = new Array(len).fill): number[];\n    for (let i = 0; i < len; i++)\n        leftMax[i] = i === 0? height[i] : Math.max(leftMax[i - 1], height[ {\n    const len = height.length;\n    if (!len)\n        return 0;\n    // 记录从左到右扫描的最大值数组\n    const leftMax = new Array(len).fill(0);\n    for (let i = 0; i < len; i++)\n        leftMax[i] = i === 0 ? height[i] : Math.max(leftMax[i - 1], height[i]);\n    // 记录从右到左扫描的最大值数组\n    const rightMax = new Array(len).fill(0);\n    for (let i = len - 1; i >= 0; i--) {\n        rightMax[i]\n            = i === len - 1 ? height[i] : Math.max(rightMax[i + 1], height[i]);\n    }\n    let ans = 0;\n    // leftMax和rightMax重叠的区域减掉height[i]就是对应区域的接水量\n    for (let i = 0; i < len; i++)\n        ans += Math.min(leftMax[i], rightMax[i]) - height[i];\n    return ans;\n}\n/**\n * 单调栈\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap2(height: number[]): number {\n    let ans = 0;\n    const stack = [];\n    let currMax = 0;\n    for (let i = 0; i < height.length; i++) {\n        const top = stack.lengt): number;\n        // 确保栈还有值\n        if (!stack.length)\n            break;\n        // 入栈\n        stack.push(i);\n        if (height[i] > currMax)\n            currMax = height {\n    let ans = 0;\n    const stack = [];\n    for (let i = 0; i < height.length; i++) {\n        while (stack.length\n            && /* 栈有值 */ height[i]\n                > height[stack[stack.length - 1]] /* 当前高度比上一个高度高的话 */) {\n            // 获取栈顶，并弹出\n            const top = stack.pop() as number;\n            // 确保栈还有值\n            if (!stack.length)\n                break;\n            // 获取左边坐标\n            const left = stack[stack.length - 1] as number;\n            // 计算出宽高\n            const w = i - left - 1;\n            const h = Math.min(height[left], height[i]) - height[top];\n            ans += w * h;\n        }\n        // 入栈\n        stack.push(i);\n    }\n    return ans;\n}\n/**\n * 双指针\n * @desc 时间复杂度 O(N)  空间复杂度 O(1)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap3(height: number[]): number {\n    const len = height.length;\n    let leftMax = 0;\n    let rightMax = 0;\n    for (let i = 0; i < len; i++) {\n        leftMax = Mat): number;\n        rightMax = Mat);\n        if (height[i] > leftMax)\n            leftMax = height[i];\n        if (height[i] > rightMax)\n            rightMax = height[i];\n    }\n    / {\n    let ans = 0;\n    let left = 0;\n    let right = height.length - 1;\n    let leftMaxHeight = 0;\n    let rightMaxHeight = 0;\n    while (left < right) {\n        // 更新左右最大高度\n        leftMaxHeight = Math.max(leftMaxHeight, height[left]);\n        rightMaxHeight = Math.max(rightMaxHeight, height[right]);\n        if (height[left] < height[right]) {\n            // 当height[left] < height[right] 在动态规划中必有leftMax[left] < rightMax[left]\n            // 因此在动态规划中，此时的高度为 Math.min(leftMax[left], rightMax[left]) - height[left]\n            // 即 leftMaxHeight - height[left]\n            ans += leftMaxHeight - height[left];\n            left++;\n        }\n        else {\n            // 同理，当height[left] >= height[right] 在动态规划中必有leftMax[right] >= rightMax[right]\n            // 因此在动态规划中，此时的高度为 Math.min(leftMax[right], rightMax[right]) - height[right]\n            // 即 rightMaxHeight - height[right]\n            ans += rightMaxHeight - height[right];\n            right--;\n        }\n    }\n    return ans;\n}\n","score":390,"fallbacked":false,"num_type_errors":39},{"code":"/**\n * 动态规划\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap(height: number[]): number {\n    if (!height ||!height.length)\n        return 0;\n    let ans = 0;\n    // 记录当前左边扫描的最大值\n    let leftMax = 0;\n    /): number | undefined;\n    for (let i = 1; i < height.length; i++) {\n        // 第i个高度最大\n        const h = Math.max(height[i - 1], height[i]); {\n    const len = height.length;\n    if (!len)\n        return 0;\n    // 记录从左到右扫描的最大值数组\n    const leftMax = new Array(len).fill(0);\n    for (let i = 0; i < len; i++)\n        leftMax[i] = i === 0 ? height[i] : Math.max(leftMax[i - 1], height[i]);\n    // 记录从右到左扫描的最大值数组\n    const rightMax = new Array(len).fill(0);\n    for (let i = len - 1; i >= 0; i--) {\n        rightMax[i]\n            = i === len - 1 ? height[i] : Math.max(rightMax[i + 1], height[i]);\n    }\n    let ans = 0;\n    // leftMax和rightMax重叠的区域减掉height[i]就是对应区域的接水量\n    for (let i = 0; i < len; i++)\n        ans += Math.min(leftMax[i], rightMax[i]) - height[i];\n    return ans;\n}\n/**\n * 单调栈\n * @desc 时间复杂度 O(N)  空间复杂度 O(N)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap2(height: number[]): number {\n    if (!height ||!height.length)\n        return 0;\n    let ans = 0;\n    let stack = [];\n    let leftMax = 0;\n    for (let i = 0;): number | undefined {\n        while (stack.length) {\n            const top = stack[stack.length - 1];\n            const left = stack[stack.length - 1] - 1;\n            const right = stack[stack {\n    let ans = 0;\n    const stack = [];\n    for (let i = 0; i < height.length; i++) {\n        while (stack.length\n            && /* 栈有值 */ height[i]\n                > height[stack[stack.length - 1]] /* 当前高度比上一个高度高的话 */) {\n            // 获取栈顶，并弹出\n            const top = stack.pop() as number;\n            // 确保栈还有值\n            if (!stack.length)\n                break;\n            // 获取左边坐标\n            const left = stack[stack.length - 1] as number;\n            // 计算出宽高\n            const w = i - left - 1;\n            const h = Math.min(height[left], height[i]) - height[top];\n            ans += w * h;\n        }\n        // 入栈\n        stack.push(i);\n    }\n    return ans;\n}\n/**\n * 双指针\n * @desc 时间复杂度 O(N)  空间复杂度 O(1)\n * @param height {number[]}\n * @return {number}\n */\nexport function trap3(height: number[]): number {\n    if (!height ||!height.length)\n        return 0;\n    let ans = 0;\n    let leftMax = 0;\n    let rightMax = 0;\n    let left = 0): number | undefined {\n        if (!height.length) {\n            return 0;\n        }\n        for (let i = 1; i < height.length; i++) {\n            leftMax = Math.max(leftMax, height {\n    let ans = 0;\n    let left = 0;\n    let right = height.length - 1;\n    let leftMaxHeight = 0;\n    let rightMaxHeight = 0;\n    while (left < right) {\n        // 更新左右最大高度\n        leftMaxHeight = Math.max(leftMaxHeight, height[left]);\n        rightMaxHeight = Math.max(rightMaxHeight, height[right]);\n        if (height[left] < height[right]) {\n            // 当height[left] < height[right] 在动态规划中必有leftMax[left] < rightMax[left]\n            // 因此在动态规划中，此时的高度为 Math.min(leftMax[left], rightMax[left]) - height[left]\n            // 即 leftMaxHeight - height[left]\n            ans += leftMaxHeight - height[left];\n            left++;\n        }\n        else {\n            // 同理，当height[left] >= height[right] 在动态规划中必有leftMax[right] >= rightMax[right]\n            // 因此在动态规划中，此时的高度为 Math.min(leftMax[right], rightMax[right]) - height[right]\n            // 即 rightMaxHeight - height[right]\n            ans += rightMaxHeight - height[right];\n            right--;\n        }\n    }\n    return ans;\n}\n","score":378,"fallbacked":false,"num_type_errors":57}]}
